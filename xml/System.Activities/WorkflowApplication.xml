<Type Name="WorkflowApplication" FullName="System.Activities.WorkflowApplication">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a306551266053970f49f8a237037d8cb9dfdf4c8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69343659" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowApplication : System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowApplication extends System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowApplication&#xA;Inherits WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowApplication sealed : System::Activities::Hosting::WorkflowInstance" />
  <TypeSignature Language="F#" Value="type WorkflowApplication = class&#xA;    inherit WorkflowInstance" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.Hosting.WorkflowInstance</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет ведущее приложение для одиночного экземпляра рабочего процесса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Activities.WorkflowApplication> предоставляет ведущее приложение для одиночного экземпляра рабочего процесса. Он служит прокси-классом для фактического экземпляра рабочего процесса, который управляется средой выполнения рабочего процесса. Пользователи <xref:System.Activities.WorkflowApplication> могут выполнять в среде выполнения рабочего процесса различные действия с экземпляром рабочего процесса, вызывая соответствующие методы в объекте <xref:System.Activities.WorkflowApplication>. Если запрошенное действие оказывается недопустимым, создается исключение.  
  
 С помощью <xref:System.Activities.WorkflowApplication> можно выполнять следующие задачи.  
  
1.  Создавать новый экземпляр рабочего процесса или загружать экземпляр рабочего процесса из хранилища экземпляров.  
  
2.  Задавать расширения для использования действиями в пределах экземпляра рабочего процесса.  
  
3.  Управлять выполнением экземпляра рабочего процесса.  
  
4.  Возобновлять закладку, созданную действием в пределах экземпляра рабочего процесса.  
  
5.  Сохранять или выгружать экземпляр рабочего процесса.  
  
6.  Получать уведомления о событиях жизненного цикла экземпляра рабочего процесса.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр класса <see cref="T:System.Activities.WorkflowApplication" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication workflowDefinition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Определение рабочего процесса.</param>
        <summary>Создает новый экземпляр класса <see cref="T:System.Activities.WorkflowApplication" /> с указанным определением рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Экземпляр создается с использованием определения рабочего процесса, состоящего из одного `DiceRoll` действия. <xref:System.Activities.WorkflowApplication> Действие `DiceRoll` имеет два выходных аргумента, представляющих результаты броска игральных костей. При завершении рабочего процесса выходные данные извлекаются обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A> и на консоль выдается следующее.  
  
```Output  
Workflow aae3fb48-7229-4737-b969-d63e131b96b3 Completed.   
The two dice are 1 and 5.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Определение рабочего процесса.</param>
        <param name="definitionIdentity">Удостоверение определения.</param>
        <summary>Создает новый экземпляр класса <see cref="T:System.Activities.WorkflowApplication" /> с указанным определением рабочего процесса и удостоверением определения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Определение рабочего процесса.</param>
        <param name="inputs">Значения для аргументов, определенных в корневом действии определения рабочего процесса, привязанные к именам аргументов.</param>
        <summary>Создает новый экземпляр класса <see cref="T:System.Activities.WorkflowApplication" />, использующий указанное определение рабочего процесса и указанные значения аргументов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Экземпляр создается с использованием определения рабочего процесса, состоящего из одного `Divide` действия, которое принимает два входных аргумента, и словаря входных аргументов, содержащих два передаваемых значения, с ключом по имени аргумента. <xref:System.Activities.WorkflowApplication> Нужные события жизненного цикла рабочего процесса обрабатываются, и рабочий процесс запускается вызовом метода <xref:System.Activities.WorkflowApplication.Run%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Completed  
500 / 36 = 13 Remainder 32  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object), definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Определение рабочего процесса.</param>
        <param name="inputs">Удостоверение определения.</param>
        <param name="definitionIdentity">Значения для аргументов, определенных в корневом действии определения рабочего процесса, привязанные к именам аргументов.</param>
        <summary>Создает новый экземпляр класса <see cref="T:System.Activities.WorkflowApplication" />, использующий указанное определение рабочего процесса, указанные значения аргументов и удостоверение определения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Уведомляет среду выполнения рабочего процесса о том, что работа этого экземпляра рабочего процесса будет прервана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если прерывается рабочий процесс, размещенный в <xref:System.Activities.WorkflowApplication>, то вызывается обработчик <xref:System.Activities.WorkflowApplication.Aborted%2A>, а обработчик <xref:System.Activities.WorkflowApplication.Completed%2A> не вызывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="workflowApplication.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уведомляет среду выполнения рабочего процесса о том, что работа этого экземпляра рабочего процесса будет прервана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если прерывается рабочий процесс, размещенный в <xref:System.Activities.WorkflowApplication>, то вызывается обработчик <xref:System.Activities.WorkflowApplication.Aborted%2A>, а обработчик <xref:System.Activities.WorkflowApplication.Completed%2A> не вызывается.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Abort%2A>. В случае прерывания рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Idle.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The workflow has been aborted.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="override this.Abort : string -&gt; unit" Usage="workflowApplication.Abort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Причина запроса на прерывание.</param>
        <summary>Уведомляет среду выполнения рабочего процесса о необходимом прерывании этого экземпляра рабочего процесса по указанной причине.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если прерывается рабочий процесс, размещенный в <xref:System.Activities.WorkflowApplication>, то вызывается обработчик <xref:System.Activities.WorkflowApplication.Aborted%2A>, а обработчик <xref:System.Activities.WorkflowApplication.Completed%2A> не вызывается.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Abort%2A>. В случае прерывания рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Idle.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The reason for aborting the workflow.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Aborted" />
      <MemberSignature Language="VB.NET" Value="Public Property Aborted As Action(Of WorkflowApplicationAbortedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ Aborted { Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Aborted : Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Aborted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает действие <see cref="T:System.Action`1" />, которое вызывается, когда прерывается экземпляр рабочего процесса.</summary>
        <value>Действие, которое вызывается, когда прерывается экземпляр рабочего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если прерывается рабочий процесс, размещенный в <xref:System.Activities.WorkflowApplication>, то вызывается обработчик <xref:System.Activities.WorkflowApplication.Aborted%2A>, а обработчик <xref:System.Activities.WorkflowApplication.Completed%2A> не вызывается.  
  
   
  
## Examples  
 В следующем примере кода проверяются аргументы <xref:System.Activities.WorkflowApplicationAbortedEventArgs>, переданные в обработчик <xref:System.Activities.WorkflowApplication.Aborted%2A> экземпляра <xref:System.Activities.WorkflowApplication>, и выводятся сведения о причинах прерывания рабочего процесса.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#5](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInitialInstanceValues">
      <MemberSignature Language="C#" Value="public void AddInitialInstanceValues (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,object&gt; writeOnlyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInitialInstanceValues(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, object&gt; writeOnlyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.AddInitialInstanceValues(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInitialInstanceValues (writeOnlyValues As IDictionary(Of XName, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInitialInstanceValues(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Object ^&gt; ^ writeOnlyValues);" />
      <MemberSignature Language="F#" Value="member this.AddInitialInstanceValues : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, obj&gt; -&gt; unit" Usage="workflowApplication.AddInitialInstanceValues writeOnlyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writeOnlyValues" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="writeOnlyValues">Значения метаданных, которые включаются в первое сохранение.</param>
        <summary>Задает значения метаданных экземпляра, которые включаются в первое сохранение нового экземпляра.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отменяет выполнение рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый при завершении операции отмены.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Отменяет экземпляр рабочего процесса в асинхронном режиме с указанным <see cref="T:System.AsyncCallback" /> и предоставляемым пользователем состоянием.</summary>
        <returns>Ссылка на асинхронную операцию отмены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция отмены, вызовите метод <xref:System.Activities.WorkflowApplication.EndCancel%2A>. Метод <xref:System.Activities.WorkflowApplication.EndCancel%2A> можно вызвать как изнутри, так и извне метода `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndCancel%2A> вызывается до завершения операции отмены, то он блокируется до завершения операции отмены. По умолчанию операция отмены должна завершаться за 30 секунд. В противном случае в методе <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndCancel%2A>.  
  
 Этот метод отменяет рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция отмены должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый при завершении операции отмены.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Отменяет экземпляр рабочего процесса в асинхронном режиме с использованием указанного интервала времени ожидания, объекта <see cref="T:System.AsyncCallback" /> и предоставляемого пользователем состояния.</summary>
        <returns>Ссылка на асинхронную операцию отмены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция отмены, вызовите метод <xref:System.Activities.WorkflowApplication.EndCancel%2A>. Метод <xref:System.Activities.WorkflowApplication.EndCancel%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndCancel%2A> вызывается до завершения операции отмены, то он блокируется до завершения операции отмены. Если операция отмены не завершается в течение интервала, указанного в параметре `timeOut`, то в методе <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndCancel%2A>.  
  
 Этот метод отменяет рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно создает владельца экземпляра по умолчанию с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="definitionIdentity">Удостоверение определения.</param>
        <param name="identityFilter">Фильтр удостоверения.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Создает владельца экземпляра по умолчанию в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, идентификатором определения, фильтром идентификатора, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="definitionIdentity">Удостоверение определения.</param>
        <param name="identityFilter">Фильтр удостоверения.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Создает владельца экземпляра по умолчанию в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, идентификатором определения, фильтром идентификатора, интервалом истечения времени ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginDeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно делегирует владельца экземпляра по умолчанию с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Удаляет владельца экземпляра по умолчанию в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Удаляет владельца экземпляра по умолчанию в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, интервалом времени ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно Извлекает владельца экземпляра с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Идентификатор экземпляра.</param>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Извлекает владельца экземпляра в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанными идентификатором, хранилищем экземпляров, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Идентификатор экземпляра.</param>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Извлекает владельца экземпляра в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанными идентификатором, хранилищем экземпляров, сроком ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно Извлекает владельца готового к запуску экземпляра с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Извлекает владельца готового к запуску экземпляра в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Извлекает владельца готового к запуску экземпляра в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" /> с указанным хранилищем экземпляров, интервалом времени ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает рабочий процесс в асинхронном режиме из хранилища экземпляров с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Асинхронно загружает рабочий процесс из хранилища экземпляров с помощью шаблона асинхронного проекта <see cref="T:System.IAsyncResult" /> с указанным экземпляром, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Глобально уникальный 128-разрядный идентификатор экземпляра рабочего процесса.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Загружает рабочий процесс в асинхронном режиме из хранилища экземпляров, используя указанный идентификатор экземпляра, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Состояние асинхронной операции.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="updateMap">Сопоставление обновления.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Асинхронно загружает рабочий процесс из хранилища экземпляров с помощью шаблона асинхронного проекта <see cref="T:System.IAsyncResult" /> с указанным экземпляром, сопоставлением обновления, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Асинхронно загружает рабочий процесс из хранилища экземпляров с помощью шаблона асинхронного проекта <see cref="T:System.IAsyncResult" /> с указанным экземпляром, интервалом времени ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Глобально уникальный 128-разрядный идентификатор экземпляра рабочего процесса.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Загружает рабочий процесс в асинхронном режиме из хранилища экземпляров, используя указанный идентификатор экземпляра, интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Состояние асинхронной операции.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="updateMap">Сопоставление обновления.</param>
        <param name="timeout">Интервал, в течение которого операция начала загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый, когда операция начала загрузки была выполнена успешно.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Асинхронно загружает рабочий процесс из хранилища экземпляров с помощью шаблона асинхронного проекта <see cref="T:System.IAsyncResult" /> с указанным экземпляром, сопоставлением обновления, интервалом времени ожидания, обратным вызовом и состоянием.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует асинхронный процесс загрузки запускаемого экземпляра рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый при завершении этой операции.</param>
        <param name="state">Необязательный относящийся к приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает операцию для загрузки выполняемого экземпляра рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 Чтобы определить, была ли операция загрузки выполнена успешно, вызовите метод <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>. Метод <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> можно вызвать как изнутри, так и извне метода `callback`. Если <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. По умолчанию операция возобновления должна быть завершена в течение 30 секунд, в противном случае будет сформировано исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>.  
  
 Этот метод загружает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция загрузки должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый при завершении этой операции.</param>
        <param name="state">Необязательный относящийся к приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает операцию для загрузки выполняемого экземпляра рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" /> с использованием указанного интервала времени ожидания.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 Чтобы определить, была ли операция загрузки выполнена успешно, вызовите метод <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>. Метод <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> можно вызвать как изнутри, так и извне метода `callback`. Если <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. Если операция загрузки не завершается в течение указанного интервала времени ожидания, то в методе <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A>.  
  
 Этот метод загружает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPersist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет экземпляр рабочего процесса в асинхронном режиме в хранилище экземпляров с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый при завершении операции сохранения.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Сохраняет экземпляр рабочего процесса в хранилище экземпляров в асинхронном режиме, используя указанный метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию сохранения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция сохранения, вызовите метод <xref:System.Activities.WorkflowApplication.EndPersist%2A>. Метод <xref:System.Activities.WorkflowApplication.EndPersist%2A> можно вызвать как изнутри, так и извне метода, ссылка на который приведена в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndPersist%2A> вызывается до завершения операции сохранения, то он будет заблокирован до завершения операции сохранения. Если операция сохранения не завершается в течение 30 секунд, то в методе <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndPersist%2A>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 Этот метод сохраняет рабочий процесс асинхронно, с помощью асинхронного шаблона <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция сохранения должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый при завершении операции сохранения.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Сохраняет экземпляр рабочего процесса в хранилище экземпляров в асинхронном режиме, используя указанный интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию сохранения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция сохранения, вызовите метод <xref:System.Activities.WorkflowApplication.EndPersist%2A>. Метод <xref:System.Activities.WorkflowApplication.EndPersist%2A> можно вызвать как изнутри, так и извне метода, ссылка на который приведена в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndPersist%2A> вызывается до завершения операции сохранения, то он будет заблокирован до завершения операции сохранения. Если операция сохранения не завершается в течение указанного интервала времени ожидания, то в методе <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndPersist%2A>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 Этот метод сохраняет экземпляр рабочего процесса в асинхронном режиме в соответствии с асинхронным шаблоном разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает асинхронную операцию продолжения чтения с закладки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Возобновляемая закладка.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="callback">Метод, вызываемый при завершении операции возобновления.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает операцию для возобновления закладки, используя указанное значение, метод обратного вызова и состояние.</summary>
        <returns>Ссылка на асинхронную операцию возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, была ли операция возобновлена успешно, вызовите <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>. Метод <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> можно вызвать как изнутри, так и извне метода `callback`. Если <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. По умолчанию операция возобновления должна быть завершена в течение 30 секунд, в противном случае будет сформировано исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>.  
  
 Этот метод возобновляет чтение с закладки в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Имя закладки, с которой будет продолжено чтение.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="callback">Метод, который вызывается после завершения асинхронной операции.</param>
        <param name="state">Состояние выполнения рабочего процесса, сохраненное вызывающим потоком перед началом асинхронной операции.</param>
        <summary>Запускает асинхронную операцию для возобновления закладки с указанным именем, используя указанное значение, метод обратного вызова и состояние. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Возобновляемая закладка.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="timeout">Период времени, в течение которого операция возобновления должна быть завершена, прежде чем операция отменяется и создается исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый при завершении операции возобновления.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает операцию для возобновления закладки, используя указанное значение, интервал времени ожидания, метод обратного вызова и состояние.</summary>
        <returns>Ссылка на асинхронную операцию возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, была ли операция возобновлена успешно, вызовите <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>. Метод <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> можно вызвать как изнутри, так и извне метода `callback`. Если <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. Если операция возобновления не завершается в течение указанного интервала времени ожидания, то из <xref:System.TimeoutException> формируется исключение <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>.  
  
 Этот метод возобновляет чтение с закладки в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Имя закладки, с которой будет продолжено чтение.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="timeout">Временной интервал, в течение которого чтение с закладки должно быть возобновлено.</param>
        <param name="callback">Метод, который вызывается после завершения асинхронной операции.</param>
        <param name="state">Состояние выполнения рабочего процесса, сохраненное вызывающим потоком перед началом асинхронной операции.</param>
        <summary>Запускает асинхронную операцию для возобновления закладки с указанным именем, используя указанное значение, интервал времени ожидания, метод обратного вызова и состояние. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginRun">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает или возобновляет экземпляр рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый при завершении операции возобновления.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает или возобновляет экземпляр рабочего процесса в асинхронном режиме, используя указанный метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию запуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция запуска, вызовите метод <xref:System.Activities.WorkflowApplication.EndRun%2A>. Метод <xref:System.Activities.WorkflowApplication.EndRun%2A> можно вызвать как изнутри, так и извне метода, ссылка на который приведена в параметре `callback`. Если <xref:System.Activities.WorkflowApplication.EndRun%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. По умолчанию операция возобновления должна быть завершена в течение 30 секунд, или создается исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndRun%2A>.  
  
 Этот метод запускает или возобновляет рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция возобновления должна быть завершена, прежде чем операция отменяется и создается исключение <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый при завершении операции возобновления.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Запускает или возобновляет экземпляр рабочего процесса в асинхронном режиме, используя указанный интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию запуска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция запуска, вызовите метод <xref:System.Activities.WorkflowApplication.EndRun%2A>. Метод <xref:System.Activities.WorkflowApplication.EndRun%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если <xref:System.Activities.WorkflowApplication.EndRun%2A> вызывается до завершения операции возобновления, это приведет к блокировке до завершения операции возобновления. Если операция возобновления не завершается в течение указанного интервала времени ожидания, то из <xref:System.TimeoutException> формируется исключение <xref:System.Activities.WorkflowApplication.EndRun%2A>.  
  
 Этот метод запускает или возобновляет рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTerminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Прерывает экземпляр рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения экземпляра рабочего процесса.</param>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Завершает экземпляр рабочего процесса в асинхронном режиме, используя указанное исключение, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на текущую операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. Метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> можно вызвать как изнутри, так и извне метода, ссылка на который приведена в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>. По умолчанию операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> должна быть завершена в течение 30 секунд, в противном случае будет вызвано исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Этот метод завершает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Завершает экземпляр рабочего процесса в асинхронном режиме, используя указанное сообщение об ошибке, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на текущую операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. Метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>. По умолчанию операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> должна быть завершена в течение 30 секунд, в противном случае будет вызвано исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Этот метод завершает экземпляр рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Завершает экземпляр рабочего процесса в асинхронном режиме, используя указанное исключение, интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на текущую операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. Метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> можно вызвать как изнутри, так и извне метода `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>. Если операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> не завершается в течение указанного интервала времени ожидания, то создается исключение <xref:System.TimeoutException>. Это исключение и все другие исключения, создаваемые в процессе <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, вызываются из метода <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Этот метод завершает рабочий процесс в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Завершает экземпляр рабочего процесса в асинхронном режиме, используя указанное сообщение об ошибке, интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A>. Метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndTerminate%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>. Если операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> не завершается в течение указанного интервала времени ожидания, то из <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndTerminate%2A>.  
  
 Этот метод завершает экземпляр рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginUnload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет и удаляет экземпляр рабочего процесса в асинхронном режиме с помощью асинхронного шаблона проектирования <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Сохраняет и освобождает экземпляр рабочего процесса в асинхронном режиме, используя указанный метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginUnload%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndUnload%2A>. Метод <xref:System.Activities.WorkflowApplication.EndUnload%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndUnload%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginUnload%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginUnload%2A>. По умолчанию операция <xref:System.Activities.WorkflowApplication.BeginUnload%2A> должна быть завершена в течение 30 секунд, в противном случае будет вызвано исключение <xref:System.TimeoutException> из <xref:System.Activities.WorkflowApplication.EndUnload%2A>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 Этот метод сохраняет и освобождает экземпляр рабочего процесса в асинхронном режиме, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" /> должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">Метод, вызываемый после завершения операции <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</param>
        <param name="state">Относящийся к необязательному приложению объект, содержащий сведения об асинхронной операции.</param>
        <summary>Сохраняет и освобождает экземпляр рабочего процесса в асинхронном режиме, используя указанный интервал времени ожидания, метод обратного вызова и предоставляемое пользователем состояние.</summary>
        <returns>Ссылка на асинхронную операцию <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, успешно ли выполнена операция <xref:System.Activities.WorkflowApplication.BeginUnload%2A>, вызовите метод <xref:System.Activities.WorkflowApplication.EndUnload%2A>. Метод <xref:System.Activities.WorkflowApplication.EndUnload%2A> можно вызывать как в пределах, так и вне пределов метода, указанного в параметре `callback`. Если метод <xref:System.Activities.WorkflowApplication.EndUnload%2A> вызывается до завершения операции <xref:System.Activities.WorkflowApplication.BeginUnload%2A>, то он блокируется до завершения операции <xref:System.Activities.WorkflowApplication.BeginUnload%2A>. Если операция <xref:System.Activities.WorkflowApplication.BeginUnload%2A> не завершается в течение указанного интервала времени ожидания, то из <xref:System.TimeoutException> вызывается исключение <xref:System.Activities.WorkflowApplication.EndUnload%2A>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 Этот метод сохраняет и выгружает экземпляр рабочего процесса в асинхронном режиме, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отменяет экземпляр рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует отмену экземпляра рабочего процесса. Чтобы получить уведомление о выполнении отмены, воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 По умолчанию операция отмены должна быть завершена в течение 30 секунд, в противном случае будет сформировано исключение <xref:System.TimeoutException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="workflowApplication.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет экземпляр рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует отмену экземпляра рабочего процесса. Чтобы получить уведомление о выполнении отмены, используйте обработчик <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 По умолчанию операция отмены должна быть завершена в течение 30 секунд, в противном случае будет сформировано исключение <xref:System.TimeoutException>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Cancel%2A>. После отмены рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Cancel : TimeSpan -&gt; unit" Usage="workflowApplication.Cancel timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция отмены должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Отменяет экземпляр рабочего процесса, используя указанный интервал времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует отмену экземпляра рабочего процесса. Чтобы получить уведомление о выполнении отмены, используйте обработчик <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Cancel%2A>. После отмены рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Property Completed As Action(Of WorkflowApplicationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ Completed { Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Completed : Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Completed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает действие <see cref="T:System.Action`1" />, которое вызывается, когда завершается экземпляр рабочего процесса.</summary>
        <value>Действие, вызываемое при завершении экземпляра рабочего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода проверяются аргументы <xref:System.Activities.WorkflowApplicationCompletedEventArgs>, переданные в обработчик <xref:System.Activities.WorkflowApplication.Completed%2A> экземпляра <xref:System.Activities.WorkflowApplication>, и выводятся сведения о завершении рабочего процесса.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#4](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает владелец экземпляра по умолчанию для рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="definitionIdentity">Удостоверение определения рабочего процесса.</param>
        <param name="identityFilter">Фильтр удостоверения.</param>
        <summary>Создает владелец экземпляра по умолчанию для рабочего процесса, используя указанное хранилище экземпляров, идентификатор определения, фильтр идентификатора.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="definitionIdentity">Удостоверение определения рабочего процесса.</param>
        <param name="identityFilter">Фильтр удостоверения.</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Создает владелец экземпляра по умолчанию для рабочего процесса, используя указанное хранилище экземпляров, идентификатор определения, фильтр идентификатора и интервал истечения времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет владелец экземпляра по умолчанию для рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <summary>Удаляет владелец экземпляра по умолчанию для рабочего процесса с указанным хранилищем экземпляров.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Удаляет владелец экземпляра по умолчанию для рабочего процесса с указанным хранилищем экземпляров и интервалом времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public void EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndCancel (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndCancel : IAsyncResult -&gt; unit" Usage="workflowApplication.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция отмены.</param>
        <summary>Ожидает завершения отложенной асинхронной операции отмены.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет, была ли операция <xref:System.Activities.WorkflowApplication.BeginCancel%2A> успешной. Если вызывается до завершения операции отмены, то блокирует работу до завершения операции отмены.  
  
 Этот метод завершает асинхронную операцию отмены, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndCreateDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCreateDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCreateDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCreateDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndCreateDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Асинхронный результат.</param>
        <summary>Ожидает завершения создания владельца экземпляра по умолчанию.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndDeleteDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndDeleteDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndDeleteDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndDeleteDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndDeleteDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Асинхронный результат.</param>
        <summary>Ожидает завершения удаления владельца экземпляра по умолчанию.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Асинхронный результат.</param>
        <summary>Ожидает завершения извлечения экземпляра.</summary>
        <returns>Результат операции.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetRunnableInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetRunnableInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetRunnableInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetRunnableInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetRunnableInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetRunnableInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Асинхронный результат.</param>
        <summary>Ожидает завершения асинхронной операции получения выполняемого экземпляра.</summary>
        <returns>Результат операции.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoad">
      <MemberSignature Language="C#" Value="public void EndLoad (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoad(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoad(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoad (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoad(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoad : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoad result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция загрузки.</param>
        <summary>Ожидает завершения отложенной асинхронной операции загрузки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод вызывается до завершения операции загрузки, то он блокирует работу до завершения операции загрузки.  
  
 Этот метод завершает асинхронную операцию загрузки, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void EndLoadRunnableInstance (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadRunnableInstance(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoadRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadRunnableInstance (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadRunnableInstance(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoadRunnableInstance : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoadRunnableInstance result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на асинхронную операцию загрузки.</param>
        <summary>Ожидает завершения асинхронной операции загрузки выполняемого экземпляра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет, была ли операция <xref:System.Activities.WorkflowApplication.BeginLoadRunnableInstance%2A> успешной. При вызове до завершения операции загрузки метод блокируется до завершения операции.  
  
 Этот метод загружает рабочие процессы в асинхронном режиме, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndPersist">
      <MemberSignature Language="C#" Value="public void EndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.EndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция сохранения.</param>
        <summary>Ожидает завершения отложенной асинхронной операции сохранения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет, была ли операция <xref:System.Activities.WorkflowApplication.BeginPersist%2A> успешной. Если вызывается до завершения операции сохранения, то блокирует работу до завершения операции сохранения.  
  
 Этот метод завершает асинхронную операцию сохранения, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult EndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult EndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult EndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.EndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ссылка на асинхронную операцию возобновления чтения с закладки.</param>
        <summary>Ожидает завершения операции возобновления закладки.</summary>
        <returns>Одно из значений перечисления, которое указывает результаты операции возобновления закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет, была ли операция <xref:System.Activities.WorkflowApplication.BeginResumeBookmark%2A> успешной. При вызове до завершения операции загрузки метод блокируется до завершения операции.  
  
 Этот метод возобновляет чтение с закладки в асинхронном режиме с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRun">
      <MemberSignature Language="C#" Value="public void EndRun (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndRun(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndRun(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndRun (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndRun(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndRun : IAsyncResult -&gt; unit" Usage="workflowApplication.EndRun result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция запуска.</param>
        <summary>Ожидает завершения отложенной асинхронной операции выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет, была ли операция <xref:System.Activities.WorkflowApplication.BeginRun%2A> успешной. Если вызывается до завершения операции возобновления, то происходит блокировка до завершения операции возобновления.  
  
 Этот метод завершает асинхронную операцию выполнения, следуя асинхронному шаблону разработки <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTerminate">
      <MemberSignature Language="C#" Value="public void EndTerminate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndTerminate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndTerminate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndTerminate (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndTerminate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndTerminate : IAsyncResult -&gt; unit" Usage="workflowApplication.EndTerminate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция завершения.</param>
        <summary>Ожидает выполнения отложенной асинхронной операции завершения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать, чтобы определить, была ли успешной операция <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>. Если вызывается до выполнения операции завершения, то блокирует работу до выполнения операции.  
  
 Этот метод завершает асинхронную операцию <xref:System.Activities.WorkflowApplication.BeginTerminate%2A> с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUnload">
      <MemberSignature Language="C#" Value="public void EndUnload (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUnload(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndUnload(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUnload (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUnload(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndUnload : IAsyncResult -&gt; unit" Usage="workflowApplication.EndUnload result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Асинхронная операция выгрузки.</param>
        <summary>Ожидает завершения отложенной асинхронной операции выгрузки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать, чтобы определить, была ли успешной операция <xref:System.Activities.WorkflowApplication.BeginUnload%2A>. Если вызывается до завершения операции выгрузки, то блокирует работу до завершения операции.  
  
 Этот метод завершает асинхронную операцию <xref:System.Activities.WorkflowApplication.BeginUnload%2A> с помощью асинхронного шаблона проектирования <xref:System.IAsyncResult>. Дополнительные сведения см. в разделе [Общие сведения о асинхронном программировании](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowApplication.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию расширений для текущего экземпляра рабочего процесса.</summary>
        <value>Коллекция объектов.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBookmarks">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию закладок для экземпляра рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks () As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks();" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию закладок для экземпляра рабочего процесса.</summary>
        <returns>Доступная только для чтения коллекция закладок для экземпляра рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эта операция не завершается в течение 30 секунд, то вызывается исключение <xref:System.TimeoutException>.  
  
   
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и, когда создается <xref:System.Activities.Bookmark>, а рабочий процесс переходит в состояние бездействия, вызывается метод <xref:System.Activities.WorkflowApplication.GetBookmarks%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks (timeout As TimeSpan) As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : TimeSpan -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Интервал, в течение которого этот метод должен завершить работу до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Возвращает коллекцию закладок для экземпляра рабочего процесса, используя указанный интервал времени ожидания.</summary>
        <returns>Доступная только для чтения коллекция закладок для экземпляра рабочего процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и, когда создается <xref:System.Activities.Bookmark>, а рабочий процесс переходит в состояние бездействия, вызывается метод <xref:System.Activities.WorkflowApplication.GetBookmarks%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает Экземпляр рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Идентификатор экземпляра.</param>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <summary>Извлекает экземпляр рабочего процесса, используя указанный идентификатор экземпляра и хранилище экземпляров.</summary>
        <returns>Извлеченный экземпляр.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceId">Идентификатор экземпляра.</param>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Извлекает экземпляр рабочего процесса, используя указанный идентификатор экземпляра, хранилище экземпляров и срок ожидания.</summary>
        <returns>Ссылка на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает готовый к запуску экземпляр рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса</param>
        <summary>Извлекает готовый к запуску экземпляр рабочего процесса с указанным хранилищем экземпляров.</summary>
        <returns>Запускаемый экземпляр.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Извлекает готовый к запуску экземпляр рабочего процесса с указанным хранилищем экземпляров и интервалом времени ожидания.</summary>
        <returns>Запускаемый экземпляр.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public override Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Id" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Activities.WorkflowApplication.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает 128-разрядный идентификатор GUID для текущего экземпляра приложения рабочего процесса.</summary>
        <value>128-разрядный идентификатор GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается экземпляр <xref:System.Activities.WorkflowApplication> и на консоль выдается значение <xref:System.Activities.WorkflowApplication.Id%2A>.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Property Idle As Action(Of WorkflowApplicationIdleEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ Idle { Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Idle : Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Idle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает действие <see cref="T:System.Action`1" />, которое вызывается, когда текущий экземпляр рабочего процесса становится бездействующим.</summary>
        <value>Действие, которое выполняется, когда экземпляр рабочего процесса становится бездействующим.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода проверяются аргументы <xref:System.Activities.WorkflowApplicationIdleEventArgs>, переданные в обработчик <xref:System.Activities.WorkflowApplication.Idle%2A> экземпляра <xref:System.Activities.WorkflowApplication>. В этом примере рабочий процесс, переходящий в состояние бездействия, содержит одну закладку <xref:System.Activities.Bookmark> с именем `EnterGuess`, которая принадлежит действию с именем `ReadInt`. Этот пример кода основан на [следующем: Запустите рабочий процесс](~/docs/framework/windows-workflow-foundation/how-to-run-a-workflow.md), который входит в состав учебника [ &#91;по начало работы .NET Framework&#93;4,5](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md). Если на данном этапе изменить обработчик <xref:System.Activities.WorkflowApplication.Idle%2A> и включить код из этого примера, то будут выведены следующие данные.  
  
```Output  
BookmarkName: EnterGuess - OwnerDisplayName: ReadInt  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceStore">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceStore InstanceStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceStore InstanceStore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.InstanceStore" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceStore As InstanceStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceStore ^ InstanceStore { System::Runtime::DurableInstancing::InstanceStore ^ get(); void set(System::Runtime::DurableInstancing::InstanceStore ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceStore : System.Runtime.DurableInstancing.InstanceStore with get, set" Usage="System.Activities.WorkflowApplication.InstanceStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, который предоставляет доступ к сохраненному состоянию текущего экземпляра приложения рабочего процесса.</summary>
        <value>Хранилище экземпляров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается экземпляр WorkflowApplication, а затем настраивается <xref:System.Activities.WorkflowApplication.InstanceStore%2A> с помощью <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Этот пример кода является частью [того, как: Создайте и запустите длительный рабочий процесс](~/docs/framework/windows-workflow-foundation/how-to-create-and-run-a-long-running-workflow.md), который входит в состав учебника [ &#91;по начало работы .NET Framework&#93;4,5](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md).  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает экземпляр рабочего процесса из хранилища экземпляров.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance -&gt; unit" Usage="workflowApplication.Load instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <summary>Загружает экземпляр рабочего процесса из хранилища экземпляров с указанным экземпляром.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid -&gt; unit" Usage="workflowApplication.Load instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">Глобально уникальный 128-разрядный идентификатор экземпляра рабочего процесса.</param>
        <summary>Загружает указанный экземпляр рабочего процесса в память из хранилища экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается метод <xref:System.Activities.WorkflowApplication.Load%2A> для загрузки сохраненного экземпляра рабочего процесса из <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Этот пример представлен в примере `LoadAndCompleteInstance` из метода [сохранения приложения рабочего процесса](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; unit" Usage="workflowApplication.Load (instance, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="updateMap">Сопоставление обновления.</param>
        <summary>Загружает экземпляр рабочего процесса из хранилища экземпляров с указанным экземпляром и сопоставлением обновления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Загружает экземпляр рабочего процесса из хранилища экземпляров с указанным экземпляром и интервалом времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instanceId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Глобально уникальный 128-разрядный идентификатор экземпляра рабочего процесса.</param>
        <param name="timeout">Интервал, в течение которого операция загрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Загружает указанный экземпляр рабочего процесса в память из хранилища экземпляров, используя указанный интервал времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается метод <xref:System.Activities.WorkflowApplication.Load%2A> для загрузки сохраненного экземпляра рабочего процесса из <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore>. Этот пример представлен в примере `LoadAndCompleteInstance` из метода [сохранения приложения рабочего процесса](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, updateMap, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр.</param>
        <param name="updateMap">Сопоставление обновления.</param>
        <param name="timeout">Период времени, в течение которого операция начала загрузки должна быть завершена, прежде чем она будет отменена.</param>
        <summary>Загружает экземпляр рабочего процесса из хранилища экземпляров с указанным экземпляром, сопоставлением обновления и интервалом времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает экземпляр запускаемого рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance();" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : unit -&gt; unit" Usage="workflowApplication.LoadRunnableInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Загружает экземпляр запускаемого рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 По умолчанию операция загрузки должна завершаться за 30 секунд. В противном случае вызывается исключение <xref:System.TimeoutException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : TimeSpan -&gt; unit" Usage="workflowApplication.LoadRunnableInstance timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция загрузки должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Загружает выполняемый экземпляр рабочего процесса из <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />, используя указанный интервал времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускаемый экземпляр является экземпляром, для которого истекло время таймера или блокировки экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginAssociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginAssociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginAssociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginAssociateKeys (keys As ICollection(Of InstanceKey), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginAssociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginAssociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginAssociateKeys (keys, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginPersist">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">To be added.</param>
        <param name="value">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisassociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnDisassociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnDisassociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnDisassociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnDisassociateKeys (keys As ICollection(Of InstanceKey))" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnDisassociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="override this.OnDisassociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; -&gt; unit" Usage="workflowApplication.OnDisassociateKeys keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnEndAssociateKeys (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndAssociateKeys(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndAssociateKeys(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndAssociateKeys (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndAssociateKeys(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndAssociateKeys : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndAssociateKeys result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndPersist">
      <MemberSignature Language="C#" Value="protected internal override void OnEndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override System.Activities.BookmarkResumptionResult OnEndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance valuetype System.Activities.BookmarkResumptionResult OnEndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnEndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Activities::BookmarkResumptionResult OnEndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.OnEndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyPaused">
      <MemberSignature Language="C#" Value="protected override void OnNotifyPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyPaused" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnNotifyPaused ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyPaused();" />
      <MemberSignature Language="F#" Value="override this.OnNotifyPaused : unit -&gt; unit" Usage="workflowApplication.OnNotifyPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyUnhandledException">
      <MemberSignature Language="C#" Value="protected override void OnNotifyUnhandledException (Exception exception, System.Activities.Activity exceptionSource, string exceptionSourceInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyUnhandledException(class System.Exception exception, class System.Activities.Activity exceptionSource, string exceptionSourceInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyUnhandledException(System.Exception,System.Activities.Activity,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyUnhandledException(Exception ^ exception, System::Activities::Activity ^ exceptionSource, System::String ^ exceptionSourceInstanceId);" />
      <MemberSignature Language="F#" Value="override this.OnNotifyUnhandledException : Exception * System.Activities.Activity * string -&gt; unit" Usage="workflowApplication.OnNotifyUnhandledException (exception, exceptionSource, exceptionSourceInstanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="exceptionSource" Type="System.Activities.Activity" />
        <Parameter Name="exceptionSourceInstanceId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exception">To be added.</param>
        <param name="exceptionSource">To be added.</param>
        <param name="exceptionSourceInstanceId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRequestAbort">
      <MemberSignature Language="C#" Value="protected internal override void OnRequestAbort (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRequestAbort(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnRequestAbort(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRequestAbort (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRequestAbort(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="override this.OnRequestAbort : Exception -&gt; unit" Usage="workflowApplication.OnRequestAbort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnhandledException">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt; OnUnhandledException { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, valuetype System.Activities.UnhandledExceptionAction&gt; OnUnhandledException" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Property OnUnhandledException As Func(Of WorkflowApplicationUnhandledExceptionEventArgs, UnhandledExceptionAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ OnUnhandledException { Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OnUnhandledException : Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, System.Activities.UnhandledExceptionAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает функцию <see cref="T:System.Func`2" />, которая вызывается, когда в текущем экземпляре рабочего процесса обнаруживается необработанное исключение.</summary>
        <value>Делегат, который вызывается, когда в экземпляре рабочего процесса обнаруживается необработанное исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 И <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A>, и <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> определяют поведение среды выполнения, когда исключение не обработано рабочим процессом. Однако при этом для <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> предусмотрен параметр, который позволяет оставить приостановленный рабочий процесс в хранилище сохраняемости, а у <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> такого параметра нет. Причина этого заключается в том, что происходящее с приостановленным рабочим процессом зависит от узла, а <xref:System.Activities.WorkflowApplication> — не зависит. Чтобы реализовать эту возможность с помощью <xref:System.Activities.WorkflowApplication>, создайте пользовательский <xref:System.Activities.Persistence.PersistenceParticipant> с этим поведением.  
  
   
  
## Examples  
 В следующем примере кода вызывается рабочий процесс, в котором создается исключение. Исключение не обрабатывается рабочим процессом, и вызывается обработчик <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A>. Чтобы получить сведения об исключении, проверяются аргументы <xref:System.Activities.WorkflowApplicationUnhandledExceptionEventArgs>, и рабочий процесс завершается.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет экземпляр рабочего процесса в хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist();" />
      <MemberSignature Language="F#" Value="member this.Persist : unit -&gt; unit" Usage="workflowApplication.Persist " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет экземпляр рабочего процесса в хранилище экземпляров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция сохранения не завершается в течение 30 секунд, то вызывается исключение <xref:System.TimeoutException>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Activities.WorkflowApplication.Persist%2A> для сохранения экземпляра рабочего процесса перед запуском рабочего процесса. Этот пример является частью `StartAndUnloadInstance` метода в примере [сохранения приложения рабочего процесса](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Persist : TimeSpan -&gt; unit" Usage="workflowApplication.Persist timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период времени, в течение которого операция сохранения должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Сохраняет экземпляр рабочего процесса в хранилище экземпляров с использованием указанного интервала времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Activities.WorkflowApplication.Persist%2A> для сохранения экземпляра рабочего процесса перед запуском рабочего процесса. Этот пример представлен в примере `StartAndUnloadInstance` из метода [сохранения приложения рабочего процесса](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) .  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistableIdle">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt; PersistableIdle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationIdleEventArgs, valuetype System.Activities.PersistableIdleAction&gt; PersistableIdle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberSignature Language="VB.NET" Value="Public Property PersistableIdle As Func(Of WorkflowApplicationIdleEventArgs, PersistableIdleAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ PersistableIdle { Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PersistableIdle : Func&lt;System.Activities.WorkflowApplicationIdleEventArgs, System.Activities.PersistableIdleAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат, который вызывается, когда текущий экземпляр рабочего процесса является бездействующим и может быть сохранен.</summary>
        <value>Делегат, который вызывается, когда текущий экземпляр рабочего процесса находится в состоянии бездействия и может быть сохранен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда рабочий процесс приходит в состояние бездействия и может быть сохранен, вызываются методы <xref:System.Activities.WorkflowApplication.Idle%2A> и <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> в указанном порядке. Обработчик <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> возвращает одно из значений перечисления <xref:System.Activities.PersistableIdleAction>: <xref:System.Activities.PersistableIdleAction.None>, <xref:System.Activities.PersistableIdleAction.Persist> или <xref:System.Activities.PersistableIdleAction.Unload>.  
  
   
  
## Examples  
 В следующем примере показан обработчик <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> и даются указания среде выполнения сохранить и разгрузить поток.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#26](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает операцию продолжения чтения с закладки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Возобновляемая закладка.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <summary>Запускает операцию для возобновления указанной закладки, используя указанное значение. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
   
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и после создания <xref:System.Activities.Bookmark> и перехода рабочего процесса в состояние бездействия запрашивается действие пользователя и возобновляется закладка.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#24](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Имя закладки, с которой будет продолжено чтение.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <summary>Запускает операцию для возобновления закладки с указанным именем, используя указанное значение. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
   
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и после создания <xref:System.Activities.Bookmark> и перехода рабочего процесса в состояние бездействия запрашивается действие пользователя и возобновляется закладка.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmark">Возобновляемая закладка.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="timeout">Временной интервал, в течение которого чтение с закладки должно быть возобновлено.</param>
        <summary>Запускает операцию для возобновления указанной закладки, используя указанное значение и интервал времени ожидания. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
   
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и после создания <xref:System.Activities.Bookmark> и перехода рабочего процесса в состояние бездействия запрашивается действие пользователя и возобновляется закладка.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#25](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Имя закладки, с которой будет продолжено чтение.</param>
        <param name="value">Объект, передаваемый в качестве параметра методу, вызываемому при возобновлении чтения с закладки.</param>
        <param name="timeout">Временной интервал, в течение которого чтение с закладки должно быть возобновлено.</param>
        <summary>Запускает операцию для возобновления закладки с указанным именем, используя указанное значение и интервал времени ожидания. Закладка, с которой будет продолжено чтение, ранее создавалась действием в экземпляре рабочего процесса.</summary>
        <returns>Результат операции возобновления чтения с закладки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат по закладке показывает, была ли операция возобновления успешной, либо она завершилась с ошибками.  
  
   
  
## Examples  
 В следующем примере создается рабочий процесс, который использует действие `ReadLine`, создающее <xref:System.Activities.Bookmark>. Рабочий процесс запускается, и после создания <xref:System.Activities.Bookmark> и перехода рабочего процесса в состояние бездействия запрашивается действие пользователя и возобновляется закладка.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает или возобновляет выполнение экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается для инициализации выполнения вновь созданного экземпляра рабочего процесса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; unit" Usage="workflowApplication.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает или возобновляет выполнение экземпляра рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается для инициализации выполнения вновь созданного экземпляра рабочего процесса.  
  
 Если операция выполнения не завершается в течение 30 секунд, то вызывается исключение <xref:System.TimeoutException>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Run : TimeSpan -&gt; unit" Usage="workflowApplication.Run timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Этот метод вызывается для инициализации выполнения вновь созданного экземпляра рабочего процесса.  
  
Интервал, в течение которого операция выполнения должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Начинает или возобновляет выполнение экземпляра рабочего процесса с использованием указанного интервала времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что в отличие от <xref:System.Activities.WorkflowInvoker.Invoke%2A> этот метод завершается по истечении времени ожидания только в том случае, если рабочий процесс не запустился за указанное время, а не при необходимости завершения, когда истекло указанное время. Причина этого заключается в том, что метод <xref:System.Activities.WorkflowInvoker.Invoke%2A> выполняется синхронно (блокируя основной поток), тогда как метод <xref:System.Activities.WorkflowApplication.Run%2A> выполняется асинхронно, блокируя основной поток только на то время, которое требуется для запуска рабочего процесса.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsInstanceKeys">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsInstanceKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsInstanceKeys" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsInstanceKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsInstanceKeys { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsInstanceKeys : bool" Usage="System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Terminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает экземпляр рабочего процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <summary>Завершает экземпляр рабочего процесса, используя указанное исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 По умолчанию операция <xref:System.Activities.WorkflowApplication.Terminate%2A> должна быть завершена в течение 30 секунд. В противном случае будет сформировано исключение <xref:System.TimeoutException>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Terminate%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#16](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <summary>Завершает экземпляр рабочего процесса, используя указанное сообщение об ошибке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
 По умолчанию операция <xref:System.Activities.WorkflowApplication.Terminate%2A> должна быть завершена в течение 30 секунд. В противном случае будет сформировано исключение <xref:System.TimeoutException>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Terminate%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#18](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция <see cref="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" /> должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Завершает экземпляр рабочего процесса, используя указанное исключение и интервал времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Terminate%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#17](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Причина завершения работы экземпляра рабочего процесса.</param>
        <param name="timeout">Период времени, в течение которого операция <see cref="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" /> должна быть завершена, прежде чем она будет отменена с формированием исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Завершает экземпляр рабочего процесса, используя указанное сообщение об ошибке и интервал времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод планирует завершение экземпляра рабочего процесса. Чтобы получить уведомление о завершении прерывания воспользуйтесь обработчиком <xref:System.Activities.WorkflowApplication.Completed%2A>.  
  
   
  
## Examples  
 В следующем примере рабочий процесс размещается с помощью <xref:System.Activities.WorkflowApplication>. Создается экземпляр <xref:System.Activities.WorkflowApplication> с использованием указанного определения рабочего процесса, обрабатываются нужные события жизненного цикла рабочего процесса и вызывается рабочий процесс методом <xref:System.Activities.WorkflowApplication.Run%2A>. После запуска рабочего процесса вызывается метод <xref:System.Activities.WorkflowApplication.Terminate%2A>. После завершения рабочего процесса на консоль выводятся следующие данные.  
  
```Output  
Starting the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#19](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет и выгружает экземпляр рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию операция выгрузки должна быть завершена в течение 30 секунд, в противном случае будет вызвано исключение <xref:System.TimeoutException>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowApplication.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет и выгружает экземпляр рабочего процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию операция выгрузки должна быть завершена в течение 30 секунд, в противном случае будет вызвано исключение <xref:System.TimeoutException>.  
  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Следующий пример кода является частью примера [действия NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) . В этом примере рабочий процесс бездействует, а ведущее приложение ожидает ввода данных пользователем. Если пользователь выберет выгрузку процесса, вызывается метод <xref:System.Activities.WorkflowApplication.Unload%2A>. В случае успешного выполнения этого метода рабочий процесс сохраняется и выгружается из памяти.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Unload : TimeSpan -&gt; unit" Usage="workflowApplication.Unload timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Интервал, в течение которого операция выгрузки должна завершиться до отмены операции и создания исключения <see cref="T:System.TimeoutException" />.</param>
        <summary>Сохраняет и выгружает экземпляр рабочего процесса с использованием указанного интервала времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В экземпляре рабочего процесса, ранее загруженного из сохраняемости, для загрузки процесса используется тот же <xref:System.Runtime.DurableInstancing.InstanceStore>, что и для загрузки рабочего процесса. Если рабочий процесс создан и еще не сохранен, то <xref:System.Activities.WorkflowApplication.InstanceStore%2A> должен быть настроен перед вызовом этого метода, в противном случае во время его вызова возникнет исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Следующий пример кода является частью примера [действия NoPersistScope](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) . В этом примере рабочий процесс бездействует, а ведущее приложение ожидает ввода данных пользователем. Если пользователь выберет выгрузку процесса, вызывается метод <xref:System.Activities.WorkflowApplication.Unload%2A>. В случае успешного выполнения этого метода рабочий процесс сохраняется и выгружается из памяти.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; Unloaded { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationEventArgs&gt; Unloaded" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Property Unloaded As Action(Of WorkflowApplicationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ Unloaded { Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Unloaded : Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Unloaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает действие <see cref="T:System.Action`1" />, которое вызывается, когда выгружается текущий рабочий процесс.</summary>
        <value>Действие, которое вызывается, когда выгружается экземпляр рабочего процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода проверяются аргументы <xref:System.Activities.WorkflowApplicationEventArgs>, переданные в обработчик <xref:System.Activities.WorkflowApplication.Unloaded%2A> экземпляра <xref:System.Activities.WorkflowApplication>, и выводится <xref:System.Activities.WorkflowApplicationEventArgs.InstanceId%2A> для выгруженного рабочего процесса.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#3](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
