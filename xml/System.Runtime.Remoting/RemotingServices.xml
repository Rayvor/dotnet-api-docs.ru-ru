<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ab0ab2dd346b1b257cb338da76789e5122a361e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69060433" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Обеспечивает несколько методов для использования и публикации удаленных объектов и прокси. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не являетесь поставщиком услуг, которые используют такие проблемы, как активация, управление жизненным циклом или транзакции, вам не нужно различать ссылки на прокси-серверы и ссылки на объекты. Инфраструктура удаленного взаимодействия использует прозрачные прокси-серверы, которые дают впечатление, что удаленные объекты находятся в пространстве клиента. Прокси-серверы достигают этого путем переадресации вызовов, сделанных на них, на реальные объекты в удаленных расположениях.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает прокси для хорошо известного объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">Тип <see cref="T:System.Type" /> хорошо известного объекта, к которому нужно подключиться.</param>
        <param name="url">URL-адрес класса сервера.</param>
        <summary>Создает прокси для хорошо известного объекта, если заданы <see cref="T:System.Type" /> и URL-адрес.</summary>
        <returns>Прокси на удаленный объект, который указывает на конечную точка, обслуживаемую указанным хорошо известным объектом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный прокси-объект указывает на конечную точку, обслуживаемую указанным хорошо известным объектом. Сообщения не отправляются по сети, пока на прокси-сервере не будет вызван метод.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> метод для создания прокси-сервера для хорошо известного объекта.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Непосредственный вызывающий оператор не имеет разрешения для конфигурации типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">Тип <see cref="T:System.Type" /> хорошо известного объекта, к которому нужно подключиться.</param>
        <param name="url">URL-адрес хорошо известного объекта.</param>
        <param name="data">Данные указанного канала. Может иметь значение <see langword="null" />.</param>
        <summary>Создает прокси для хорошо известного объекта, если заданы <see cref="T:System.Type" />, URL-адрес и данные указанного канала.</summary>
        <returns>Прокси указывают на конечную точка, обслуживаемую указанным хорошо известным объектом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный прокси-объект указывает на конечную точку, обслуживаемую указанным хорошо известным объектом. Сообщения не отправляются по сети, пока на прокси-сервере не будет вызван метод.  
  
 Объект используется для передачи сведений в канал и передается <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> в метод. `data`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Непосредственный вызывающий оператор не имеет разрешения для конфигурации типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Объекты, отключаемые от своих каналов.</param>
        <summary>Прекращает получение дальнейших сообщений по зарегистрированным каналам удаленного доступа.</summary>
        <returns><see langword="true" />, если объект отключается от зарегистрированного канала удаленного доступа успешно; иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> метод для отключения объекта от каналов удаленного взаимодействия.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="obj" /> является прокси.</exception>
        <exception cref="T:System.Security.SecurityException">Непосредственный вызывающий оператор не имеет разрешения для конфигурации типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">Удаленные объекты, методы которых необходимо вызвать.</param>
        <param name="reqMsg">Сообщение вызова метода на указанный метод удаленного объекта.</param>
        <summary>Подключается к указанному удаленному объекту и выполняет на нем предоставленный <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" />.</summary>
        <returns>Ответ удаленного метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий метод используется в специальных случаях сервером для пересылки указанного вызова метода другому, возможно, удаленному объекту. Этот метод может быть вызван только в том случае, если вызывающий объект находится в соответствующем контексте.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> метод для пересылки вызовов методов удаленным объектам.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Метод был вызван из контекста, отличного от заданного контекста объекта.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Прокси удаленного объекта, запросившего приемники связанного с ним делегата.</param>
        <summary>Возвращает цепь приемников делегата, которые должны использоваться при пересылке сообщений на удаленный объект, представленный указанным прокси.</summary>
        <returns>Цепь приемников делегата, связанных с указанным прокси.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приемники делегатов — это приемники, отправляемые вместе с <xref:System.Runtime.Remoting.ObjRef> объектом, который используется при возврате сообщений в этот объект. Текущий метод возвращает Приемники делегата, которые используются во время обмена данными между прокси объекта и самим объектом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, для которого необходимо получить время жизни службы.</param>
        <summary>Возвращает объект службы времени жизни, который контролирует политику времени жизни указанного объекта.</summary>
        <returns>Объект, контролирующий время жизни <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для службы времени существования по умолчанию возвращаемый объект будет объектом типа <xref:System.Runtime.Remoting.Lifetime.ILease>. Если параметр имеет значение `null`, метод возвращает `null`значение. `obj`  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> метод для получения аренды времени существования для указанного объекта.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 Чтобы скомпилировать и запустить этот пример, необходимо скомпилировать и запустить сервер тимерсервер. exe и скомпилировать общую библиотеку тимерсервице. dll.  
  
 Источник для тимерсервер. exe выглядит следующим образом:  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Источник для тимерсервице. dll выглядит следующим образом:  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Сообщение метода, из которого извлекается база метода.</param>
        <summary>Возвращает базу метода из данного <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</summary>
        <returns>База метода, извлеченная из параметра <paramref name="msg" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>определяет базовый метод из свойств, и <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> <xref:System.Runtime.Remoting.Messaging.IMethodMessage> класса и используется классами, реализующими интерфейс.<xref:System.Runtime.Remoting.Messaging.IMethodMessage> Потребители классов должны ссылаться на <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> свойство. <xref:System.Runtime.Remoting.Messaging.IMethodMessage>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Или непосредственный вызывающий не имеет разрешения инфраструктуры, или ни один из вызывающих, находящихся на вершине стека вызовов, не имеет разрешения на извлечение сведений о типе членов, не являющихся открытыми.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сериализации.</param>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />, в котором упорядочивается объект.</param>
        <param name="context">Новые источник и приемник сериализации.</param>
        <summary>Сериализует указанный упаковываемый и передаваемый по ссылке объект, в предоставленный <see cref="T:System.Runtime.Serialization.SerializationInfo" /> .</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> или параметра <paramref name="info" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.MarshalByRefObject" /> для которого запрашивается URI.</param>
        <summary>Извлекает URI для указанного объекта.</summary>
        <returns>URI указанного объекта, если существует, или <see langword="null" />, если объект не был упакован и передан.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">Прокси, подключенный к объекту, для которого создается <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Возвращает <see cref="T:System.Runtime.Remoting.ObjRef" />, который представляет удаленный объект из указанного прокси.</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjRef" />, представляющий удаленный объект, к которому подключен указанный прокси или <see langword="null" />, если объект или прокси не были упакованы и переданы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой. Во время распаковки <xref:System.Runtime.Remoting.ObjRef> анализируется для извлечения сведений о методах удаленного объекта, а также при создании прозрачного прокси-сервера <xref:System.Runtime.Remoting.Proxies.RealProxy> и объектов.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалирование, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с удаленным приложением, где <xref:System.Runtime.Remoting.ObjRef> Объект расположен.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить <xref:System.Runtime.Remoting.ObjRef> экземпляр для указанного объекта.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Прозрачный прокси.</param>
        <summary>Возвращает настоящий прокси, поддерживающий указанный прозрачный прокси.</summary>
        <returns>Настоящий прокси, поддерживающий указанный прозрачный прокси.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиент, использующий объект через любые границы удаленного взаимодействия, на самом деле использует прозрачный прокси для объекта. Прозрачный прокси-сервер дает впечатление, что фактический объект находится в пространстве клиента. Это достигается путем переадресации вызовов, сделанных на нем, на реальный объект, использующий инфраструктуру удаленного взаимодействия.  
  
 Прозрачный прокси-сервер поддерживается экземпляром управляемого класса среды выполнения типа <xref:System.Runtime.Remoting.Proxies.RealProxy>. Компонент <xref:System.Runtime.Remoting.Proxies.RealProxy> реализует часть функций, необходимых для пересылки операций от прозрачного прокси-сервера.  
  
 Прокси-объект наследует связанную семантику управляемых объектов, таких как сборка мусора, поддержку членов и методов и может быть расширена для формирования новых классов. Прокси выступает в качестве объекта того же класса, что и удаленный объект (прозрачный прокси), а также является управляемым объектом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">URI объекта, тип <see cref="T:System.Type" /> которого запрошен.</param>
        <summary>Возвращает тип <see cref="T:System.Type" /> объекта с указанным URI.</summary>
        <returns>Тип <see cref="T:System.Type" /> объекта с указанным URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку удаленное взаимодействие определяет конечные точки с <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> помощью URI, метод очень полезен в подключаемых компонентах инфраструктуры удаленного взаимодействия (например, приемников каналов, динамических приемников и приемников контекста), использующих <xref:System.Runtime.Remoting.Messaging.IMessage> объекты, так как текущий метод вернет связанный объект типа из универсального кода ресурса (URI).  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Или непосредственный вызывающий не имеет разрешения инфраструктуры, или ни один из вызывающих, находящихся на вершине стека вызовов, не имеет разрешения на извлечение сведений о типе членов, не являющихся открытыми.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для получения сведений о типе членов, не являющихся открытыми. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />, для которого запрашивается идентификатор сессии.</param>
        <summary>Извлекает идентификатор сессии для сообщения.</summary>
        <returns>Строка идентификатора сессии, однозначно определяющая текущую сессию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Один и тот же идентификатор сеанса может возвращаться для объектов в том же приложении, но этот метод никогда не возвращает один и тот же идентификатор сеанса для двух объектов в разных удаленных приложениях.  
  
 Дополнительные сведения об идентификации сеансов и идентификаторов сеансов см. в статье ASP.Net [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить строку идентификатора сеанса для текущего сеанса.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Сообщение, содержащее вызов метода в вопросе.</param>
        <summary>Возвращает логическое значение, указывающее, перезагружен ли метод в данном сообщении.</summary>
        <returns><see langword="true" />, если метод, вызываемый в <paramref name="msg" />, перезагружен; иначе — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Объект для проверки.</param>
        <summary>Возвращает логическое значение, указывающее, находится ли объект, указанный данным прозрачным прокси, в домене приложения, отличном от объекта, который вызвал текущий метод.</summary>
        <returns><see langword="true" />, если объект не принадлежит текущему домену приложения; иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о доменах приложений см. в разделе [домены приложений](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Домены приложений</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">Объект для проверки.</param>
        <summary>Возвращает логическое значение, указывающее находится ли объект, представленный данным прозрачным прокси, в контексте, отличном от объекта, который вызвал текущий метод.</summary>
        <returns><see langword="true" />, если объект не принадлежит текущему контексту; иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Контекст — это упорядоченная последовательность свойств, определяющая среду для объектов, которые находятся внутри нее. Контексты создаются в процессе активации для объектов, для которых настроено требование определенных автоматических служб, таких как синхронизация, транзакции, JIT-активация, безопасность и т. д. Внутри контекста возможно существование многих объектов.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">Метод в вопросе.</param>
        <summary>Возвращает логическое значение, указывающее, ожидает ли клиент, вызывающий указанный в данном сообщении метод, окончание обработки метода сервером, до того как продолжить обработку.</summary>
        <returns><see langword="true" />, если метод односторонний; иначе — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове одностороннего метода клиент не ждет завершения обработки сообщения сервером. Клиентский метод возвращается в приложение без знания того, будет ли сервер успешно обрабатывать сообщение. Методы помечаются одним из способов с <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>помощью.  
  
 Односторонние методы не могут иметь возвращаемое значение или параметры out.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У непосредственно вызывающего объекта отсутствует разрешение инфраструктуры.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для работы с кодом инфраструктуры. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">Проверяемая ссылка на объект.</param>
        <summary>Возвращает логическое значение, указывающее, является ли данный объект прозрачным прокси или настоящим объектом.</summary>
        <returns>Логическое значение, указывающее, является ли объект, указанный в параметре <paramref name="proxy" />, прозрачным прокси или настоящим объектом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиент, использующий объект через любой тип границы удаленного взаимодействия, на самом деле использует прозрачный прокси для объекта. Прозрачный прокси-сервер дает впечатление, что фактический объект находится в пространстве клиента. Это достигается путем переадресации вызовов, сделанных на нем, на реальный объект, использующий инфраструктуру удаленного взаимодействия.  
  
 Прозрачный прокси-сервер сам управляется экземпляром управляемого класса среды выполнения типа <xref:System.Runtime.Remoting.Proxies.RealProxy>. Компонент <xref:System.Runtime.Remoting.Proxies.RealProxy> реализует часть функций, необходимых для пересылки операций от прозрачного прокси-сервера. Прокси-объект наследует связанную семантику управляемых объектов, таких как сборка мусора, поддержку членов и методов и может быть расширена для формирования новых классов. Поэтому прокси-сервер имеет две особенности; с одной стороны, она должна работать как объект того же класса, что и удаленный объект (прозрачный прокси), а на другом — сам управляемый объект.  
  
 Прокси-объект может использоваться без учета удаленных подразделений <xref:System.AppDomain>в. Приложениям не нужно различать ссылки прокси-сервера и ссылки на объекты. Однако поставщики услуг, работающие с такими проблемами, как активация, управление жизненным циклом и транзакции, должны выполнять такие различия.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> метода для определения того, является ли объект прокси-сервером или реальным объектом. Полный пример кода см. в примере для <xref:System.Runtime.Remoting.Messaging.AsyncResult> класса.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">Определенная внутри константа, определяющая этап удаленного обмена.</param>
        <summary>Регистрирует этап удаленного обмена во внешнем отладчике.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символ предварительной обработки применяется к методу с <xref:System.Diagnostics.ConditionalAttribute> помощью атрибута. `"REMOTING_PERF"`  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Переводит данный <see cref="T:System.MarshalByRefObject" /> в экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" />, который может упорядочиваться для передачи между доменами приложения и по сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">Преобразуемый объект.</param>
        <summary>Принимает <see cref="T:System.MarshalByRefObject" />, регистрирует его инфраструктурой удаленного взаимодействия и переводит в экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" />.</summary>
        <returns>Экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" />, представляющий объект, указанный в параметре <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалинг, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с подразделением удаленного взаимодействия. <xref:System.Runtime.Remoting.ObjRef> место расположения объекта.  
  
 Во время маршалирования используется контекст из текущего потока, а не контекст, который был активным при создании объекта. Если универсальный код ресурса (URI) не был <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> явно задан методом, он автоматически создается инфраструктурой удостоверений удаленного взаимодействия.  
  
 Невозможно связать URI с прокси по одной из двух причин: либо URI был создан на стороне сервера для объекта, который он представляет, либо объект хорошо известен, в этом случае URI известен. По этой причине, если `Obj` параметр является прокси-сервером, будет выдано исключение. Для настраиваемых прокси это ограничение неограниченно, так как прозрачный прокси обрабатывается как объект сервера.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Параметр <paramref name="Obj" /> является прокси объектом.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Домены приложений</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">Преобразуемый объект.</param>
        <param name="URI">Указанный URI, с которым инициализируется новый <see cref="T:System.Runtime.Remoting.ObjRef" />. Может иметь значение <see langword="null" />.</param>
        <summary>Преобразует данный <see cref="T:System.MarshalByRefObject" /> в экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" /> с указанным URI.</summary>
        <returns>Экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" />, представляющий объект, указанный в параметре <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалинг, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с подразделением удаленного взаимодействия. <xref:System.Runtime.Remoting.ObjRef> место расположения объекта.  
  
 Во время маршалирования используется контекст из текущего потока, а не контекст, который был активным при создании объекта.  
  
 Невозможно связать URI с прокси по одной из двух причин: либо URI был создан на стороне сервера для объекта, который он представляет, либо объект хорошо известен, в этом случае URI известен. По этой причине, если `Obj` параметр является прокси-сервером, будет выдано исключение. Для настраиваемых прокси это ограничение неограниченно, так как прозрачный прокси обрабатывается как объект сервера.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать текущий <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> метод для маршалирования указанного объекта.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> является прокси объектом и параметр <paramref name="URI" /> не равен <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Домены приложений</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">Объект, преобразуемый в <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <param name="ObjURI">URI, с которым упакован и передан объект, указанный в параметре <paramref name="Obj" />. Может иметь значение <see langword="null" />.</param>
        <param name="RequestedType"><see cref="T:System.Type" />, в качестве которого маршалируется <paramref name="Obj" />. Может иметь значение <see langword="null" />.</param>
        <summary>Получает <see cref="T:System.MarshalByRefObject" /> и переводит его в экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" /> с указанным URI, и предоставленным <see cref="T:System.Type" />.</summary>
        <returns>Экземпляр класса <see cref="T:System.Runtime.Remoting.ObjRef" />, представляющий объект, указанный в параметре <paramref name="Obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалинг, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с подразделением удаленного взаимодействия. <xref:System.Runtime.Remoting.ObjRef> место расположения объекта.  
  
 Указанный <xref:System.Type> объект используется инфраструктурой удаленного взаимодействия для ограничения области предоставляемой иерархии типов. Например, если объект A является производным от объекта B, который является производным от объекта C и <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> вызывается, то клиент может привести прокси-сервер между C и B, но не с.  
  
 Во время маршалирования используется контекст из текущего потока, а не контекст, который был активным при создании объекта.  
  
 Невозможно связать URI с прокси по одной из двух причин: либо URI был создан на стороне сервера для объекта, который он представляет, либо объект хорошо известен, в этом случае URI известен. По этой причине, если `Obj` параметр является прокси-сервером, будет выдано исключение. Для настраиваемых прокси это ограничение неограниченно, так как прозрачный прокси обрабатывается как объект сервера.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> является прокси удаленного объекта, и параметр <paramref name="ObjUri" /> не равен <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">Домены приложений</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, для которого задается URI.</param>
        <param name="uri">URI, которое приписывается заданному объекту.</param>
        <summary>Задает URI для дальнейшего вызова в метод <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Универсальный код ресурса (URI), заданный текущим методом, используется при упаковке данного объекта.  
  
 После маршалирования URI указанного объекта задается в строке `uri` параметра, добавленного <xref:System.Guid> в текущий <xref:System.AppDomain>объект.  
  
 Если текущее приложение прослушивает HTTP-порт, то строка, `uri` указанная в параметре, `uri` и <xref:System.Guid> строка, добавляемая к текущему <xref:System.AppDomain> маршруту к указанному объекту. Например, если приложение прослушивает HTTP-порт 9000, то оба они `http://localhost:9000/objectUri`и `http://localhost:9000/<appdomainguid>/objectUri` направляются в объект, указанный в `obj` параметре.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать URI, который будет использоваться <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> методом при упаковке указанного объекта.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="obj" /> не является локальным объектом, уже был упакован и передан или на него вызван текущий метод.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует данный <see cref="T:System.Runtime.Remoting.ObjRef" /> в прокси-объект.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" />, который представляет удаленный объект, для которого создается прокси.</param>
        <summary>Получает <see cref="T:System.Runtime.Remoting.ObjRef" /> и создает из него прокси-объект.</summary>
        <returns>Прокси к объекту, который представлен данным <see cref="T:System.Runtime.Remoting.ObjRef" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой. Во время распаковки <xref:System.Runtime.Remoting.ObjRef> анализируется для извлечения сведений о методах удаленного объекта, а также при создании прозрачного прокси-сервера <xref:System.Runtime.Remoting.Proxies.RealProxy> и объектов. Содержимое проанализированных <xref:System.Runtime.Remoting.ObjRef> данных добавляется к прозрачному прокси-серверу до того, как прозрачный прокси-сервер будет зарегистрирован в среде CLR.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалинг, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с подразделением удаленного взаимодействия. <xref:System.Runtime.Remoting.ObjRef> место расположения объекта.  
  
   
  
## Examples  
 В следующем примере кода показано, как распаковать объект.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Экземпляр <see cref="T:System.Runtime.Remoting.ObjRef" />, указанный в параметре <paramref name="objectRef" />, создан с ошибкой.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef"><see cref="T:System.Runtime.Remoting.ObjRef" />, который представляет удаленный объект, для которого создается прокси.</param>
        <param name="fRefine"><see langword="true" />, чтобы уточнить прокси для типа сервера; иначе — <see langword="false" />.</param>
        <summary>Получает <see cref="T:System.Runtime.Remoting.ObjRef" /> и создает из него прокси-объект, подгоняя его к типу сервера.</summary>
        <returns>Прокси к объекту, который представлен данным <see cref="T:System.Runtime.Remoting.ObjRef" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> Является сериализуемым представлением объекта, который используется для перемещения ссылки на объект через границу домена приложения. <xref:System.Runtime.Remoting.ObjRef> Создание для объекта называется упаковкой. <xref:System.Runtime.Remoting.ObjRef> Можно передать через канал в другой домен приложения (возможно, на другом процессе или компьютере). В другом домене <xref:System.Runtime.Remoting.ObjRef> приложения необходимо выполнить синтаксический анализ, чтобы создать прокси для объекта, обычно подключенный к реальному объекту. Эта операция называется распаковкой. Во время распаковки <xref:System.Runtime.Remoting.ObjRef> анализируется для извлечения сведений о методах удаленного объекта, а также при создании прозрачного прокси-сервера <xref:System.Runtime.Remoting.Proxies.RealProxy> и объектов. Содержимое проанализированных <xref:System.Runtime.Remoting.ObjRef> данных добавляется к прозрачному прокси-серверу до того, как прозрачный прокси-сервер будет зарегистрирован в среде CLR.  
  
 Содержит сведения, <xref:System.Type> описывающие класс и объекта, для которого выполняется маршалинг, универсальный код ресурса (URI), однозначно определяющий конкретный экземпляр объекта, и сведения, связанные с связью, о том, как связаться с подразделением удаленного взаимодействия. <xref:System.Runtime.Remoting.ObjRef> место расположения объекта.  
  
 При первом создании прокси-сервер имеет тип <xref:System.MarshalByRefObject>. При приведении его к разным типам инфраструктура удаленного взаимодействия отслеживает наиболее используемый тип, чтобы избежать необязательной загрузки типа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Экземпляр <see cref="T:System.Runtime.Remoting.ObjRef" />, указанный в параметре <paramref name="objectRef" />, создан с ошибкой.</exception>
        <exception cref="T:System.Security.SecurityException">По крайней мере у одного из вызывающих операторов, находящихся в верхней части стека вызовов, отсутствует разрешение на настройку типов и каналов удаленного взаимодействия.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для настройки инфраструктуры удаленного взаимодействия. Значение спроса: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; Значение разрешения:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>
