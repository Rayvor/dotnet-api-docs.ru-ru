<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5857681ac8d5732c6af8a6885bbec57f01693a37" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69066619" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет кэш объекта и предоставляет базовые методы и свойства для осуществления доступа к кэшу объекта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Caching.ObjectCache> Тип является первичным типом для кэша объектов в памяти. Для разработки пользовательской реализации кэша необходимо наследовать от <xref:System.Runtime.Caching.ObjectCache> класса.  
  
> [!NOTE]
>  Класс является новым, начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]. <xref:System.Runtime.Caching.ObjectCache>  
  
 Встроенный <xref:System.Runtime.Caching.MemoryCache> класс является производным <xref:System.Runtime.Caching.ObjectCache> от класса. Класс — единственная конкретная реализация кэша объектов [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] в <xref:System.Runtime.Caching.ObjectCache> , производная от класса. <xref:System.Runtime.Caching.MemoryCache>  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides"><para>Поскольку тип представляет только общие функции кэша, нет необходимости в <see cref="T:System.Runtime.Caching.ObjectCache" /> том, как экземпляр должен быть создан и получен. <see cref="T:System.Runtime.Caching.ObjectCache" /> Кроме того, нет необходимости в том, что конкретные реализации <see cref="T:System.Runtime.Caching.ObjectCache" /> класса должны быть одноэлементными.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" />не является singleton, но следует создать лишь несколько или потенциально только один <see cref="T:System.Runtime.Caching.MemoryCache" /> экземпляр и код, который кэширует элементы, которые должны использовать эти экземпляры.  
  
</para></block>  
  
 При наследовании от <see cref="T:System.Runtime.Caching.ObjectCache" /> класса необходимо переопределить его методы.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах, чтобы инициализировать класс <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш без обязательного возврата существующей записи кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache.Add%2A> метода пытаются вставить запись в кэш, не переписывая или не удаляя существующую запись кэша, имеющую тот же ключ. Запись кэша может быть типизированным <xref:System.Runtime.Caching.CacheItem> объектом или универсальным объектом.  
  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache.Add%2A>методови перегрузки методов имеют одно существенное различие. <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Когда эти методы вставляют запись в кэш, если соответствующая запись найдена в кэше, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки метода возвращают существующую запись кэша, <xref:System.Runtime.Caching.ObjectCache.Add%2A> но перегрузки метода не имеют. Наличие этих различных перегрузок методов позволяет вызывающим объектам оптимизировать свой код в зависимости от того, нужна ли им существующая запись кэша. В распределенных кэшах возврат существующего значения с помощью <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> метода может оказаться более дорогим, чем возврат логического значения с помощью <xref:System.Runtime.Caching.ObjectCache.Add%2A> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе пытается вставить запись в кэш как экземпляр <see cref="T:System.Runtime.Caching.CacheItem" /> и добавляет сведения о том, как следует удалить эту запись.</summary>
        <returns>Значение <see langword="true" />, если вставка выполнена успешно, или <see langword="false" />, если в кэше уже имеется запись с таким же ключом, как у <paramref name="item" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache> <xref:System.Runtime.Caching.ObjectCache.Add%2A> <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>метода являются виртуальными (не абстрактными) для класса, так как метод внутренне вызывает. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Это сокращает количество перегрузок методов, которые должен предоставить разработчик кэша. Если реализация кэша не требует какого-либо специального поведения для <xref:System.Runtime.Caching.ObjectCache.Add%2A> метода, она может просто <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> реализовать перегрузки метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша. Этот параметр обязательно указывается при вызове метода <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе используется для вставки записи в кэш, без перезаписи существующей в кэше записи.</summary>
        <returns>Значение <see langword="true" />, если вставка выполнена успешно, или <see langword="false" />, если в кэше уже имеется запись с таким же ключом, как у <paramref name="key" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache> <xref:System.Runtime.Caching.ObjectCache.Add%2A> <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>метода являются виртуальными (не абстрактными) для класса, так как метод внутренне вызывает. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Это сокращает количество перегрузок методов, которые должен предоставить разработчик кэша. Если реализация кэша не требует какого-либо специального поведения для <xref:System.Runtime.Caching.ObjectCache.Add%2A> метода, она может просто <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> реализовать перегрузки метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о способе удаления записи.</summary>
        <returns>Значение <see langword="true" />, если вставка производится успешно, или <see langword="false" />, если в кэше уже есть запись с таким же ключом, как у <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache> <xref:System.Runtime.Caching.ObjectCache.Add%2A> <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>метода являются виртуальными (не абстрактными) для класса, так как метод внутренне вызывает. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Это сокращает количество перегрузок методов, которые должен предоставить разработчик кэша. Если реализация кэша не требует какого-либо специального поведения для <xref:System.Runtime.Caching.ObjectCache.Add%2A> метода, она может просто <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> реализовать перегрузки метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе пытается вставить запись в кэш и возвращает существующую запись кэша с соответствующим ключом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> метода вставляют запись в кэш. Если запись кэша с совпадающим ключом уже существует, она возвращает существующую запись. Запись кэша может быть <xref:System.Runtime.Caching.CacheItem> объектом или универсальным объектом.  
  
 Между <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузками <xref:System.Runtime.Caching.ObjectCache.Add%2A> и перегрузками существует одно различие. Когда эти перегруженные методы пытаются вставить запись кэша, если обнаружена существующая запись, имеющая ключ, совпадающий с существующей вставленной записью кэша, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> перегрузки возвращают существующую запись кэша. <xref:System.Runtime.Caching.ObjectCache.Add%2A> Перегрузки не имеют.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет заданный объект <see cref="T:System.Runtime.Caching.CacheItem" /> в кэш и задает сведения о способе удаления записи.</summary>
        <returns>Если существует запись кэша с таким же ключом, указанная запись кэша; в противном случае — значение <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, используя ключ, объект для записи кэша, абсолютное значение срока действия и (необязательно) область кэша для добавления.</summary>
        <returns>Заданное значение записи кэша, если существует запись кэша с таким же ключом; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> перегрузка метода возвращает значение объекта, а <xref:System.Runtime.Caching.CacheItem> не объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш, задавая ключ и значение для записи кэша и сведения о способе удаления этой записи.</summary>
        <returns>Заданное значение записи кэша, если существует запись кэша с таким же ключом; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает значение объекта, а <xref:System.Runtime.Caching.CacheItem> не объект. <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которой может быть найден кэш, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе проверяет, существует ли такая запись в кэше.</summary>
        <returns>Значение <see langword="true" />, если в кэше содержится запись с таким же ключом, как <paramref name="key" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Уникальные идентификаторы записей кэша, которые необходимо отслеживать.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которой могут существовать ключи кэша в параметре <paramref name="keys" />, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе создает объект <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />, который может активировать события в ответ на изменения указанных записей кэша.</summary>
        <returns>Монитор изменений, следящий за записями в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если производный <xref:System.Runtime.Caching.ObjectCache> класс переопределяет базовый <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> метод, реализация <xref:System.Runtime.Caching.CacheEntryChangeMonitor> кэша должна создать объект. Этот специализированный монитор изменений уведомляет вызывающие объекты при наличии изменений в записях кэша, указанных в `keys` параметре. Например, если отслеживаемый элемент в `keys` параметре обновляется или удаляется из кэша, монитор изменений, созданный этим методом, активирует событие.  
  
 Если реализация кэша поддерживает именованные области кэша, в качестве `regionName` параметра можно указать строковое значение. В противном случае параметр по умолчанию имеет `null`значение.  
  
> [!NOTE]
>  Не все реализации кэша поддерживают мониторы изменений записи кэша. Чтобы определить, поддерживает <xref:System.Runtime.Caching.CacheEntryChangeMonitor> ли реализация кэша объекты, см. документацию по конкретной реализации кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание функций, предоставляемых реализацией кэша.</summary>
        <value>Битовое сочетание флагов, которое указывает возможности реализации кэша по умолчанию.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает из кэша указанную запись кэша в виде объекта.</summary>
        <returns>Запись кэша, определяемая ключом <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша, которую требуется получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую был добавлен кэш, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию равняется <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает из кэша указанную запись кэша в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Запись кэша, определяемая ключом <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка этого метода существует, так как некоторые реализации кэша могут расширять <xref:System.Runtime.Caching.CacheItem> класс. В этом случае <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> перегрузка метода не обязательно будет возвращать всю информацию о кэшированных данных. Однако перегрузка метода позволяет пользовательским кэшам возвращать больше, чем просто значение кэша. <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29>  
  
 Метод похож на <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> <xref:System.Runtime.Caching.CacheItem> метод,заисключениемтого,чтометодвозвращаетзаписькэшавкачествеэкземпляра.<xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный параметр. Именованная область кэша, для которой необходимо вычислить количество записей кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает общее число записей в кэше.</summary>
        <returns>Число записей в кэше. Если значение <paramref name="regionName" /> не равно <see langword="null" />, это число обозначает количество записей в указанной области кэша.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает перечислитель, который может использоваться для перебора записей кэша в коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к записям кэша в кэше.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы реализации кэша могут переопределять и расширять этот метод для предоставления пользовательских средств итерации коллекции записей кэша.  
  
> [!NOTE]
>  Возврат перечислителя обычно является более дорогостоящей операцией, чем возврат всей записи кэша.  
  
 Этот метод вызывается явными реализациями интерфейса, которые <xref:System.Runtime.Caching.ObjectCache> класс имеет <xref:System.Collections.IEnumerable.GetEnumerator%2A> для методов и <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает набор записей кэша.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую были добавлены одна или несколько записей кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе получает набор записей кэша, соответствующих указанным ключам.</summary>
        <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> метода — это оптимизация производительности для распределенных кэшей, которые поддерживают выборку нескольких записей кэша из кэша во время одного сетевого вызова.  
  
 Хотя вызывающий объект может передать в метод один или несколько ключей, нет никакой гарантии, что все ключи представляют записи в кэше. Поэтому возвращаемый словарь может содержать меньше элементов, чем количество ключей, переданных в метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую были добавлены одна или несколько записей кэша, если области реализованы. Поскольку в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] области не реализованы, значение по умолчанию равняется <see langword="null" />.</param>
        <param name="keys">Коллекция уникальных идентификаторов записей кэша, которые необходимо получить.</param>
        <summary>Получает набор записей кэша, соответствующих указанным ключам.</summary>
        <returns>Словарь пар "ключ-значение", представляющих записи кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка метода похожа на <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузку метода, но позволяет передать именованную область с помощью необязательного синтаксиса параметра, поддерживаемого управляемыми языками, такими как. C# <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType>  
  
 Этот метод является виртуальным методом, поскольку <xref:System.Runtime.Caching.ObjectCache> класс предоставляет реализацию по умолчанию, которая `params` передает массив в <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> перегрузку метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на управляемую среду размещения, доступную реализациям <see cref="T:System.Runtime.Caching.ObjectCache" /> и способную предоставить определенные узлом службы реализациям <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Ссылка на управляемую среду размещения, содержащую средства выявления кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предназначено для использования средой [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] размещения и реализациями кэша, которые реализуют поведение, которое зависит от среды узла .NET Framework. <xref:System.Runtime.Caching.ObjectCache.Host%2A>  
  
 В следующей таблице перечислены наборы служб среды размещения, которые могут быть доступны из управляемой среды размещения и доступны для <xref:System.Runtime.Caching.ObjectCache> реализаций <xref:System.Runtime.Caching.ObjectCache.Host%2A> через свойство.  
  
|Служба|Описание|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Позволяет средам размещения предоставлять идентификаторы доменов приложений, которые могут потребоваться в реализации кэша для таких функций, как определение счетчиков производительности.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Позволяет средам размещения предоставлять пользовательскую систему уведомлений об изменениях файлов, вместо того чтобы использовать ту, которая [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]указана в.|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Позволяет реализациям кэша сообщать о потреблении памяти кэшем в среде размещения. Это позволяет средам узла централизованно управлять потреблением памяти в нескольких реализациях кэша.|  
  
> [!NOTE]
>  Вызывающим объектам этого значения свойства требуется неограниченная защита доступа к коду.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присваиваемое свойству, равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка присвоить значение свойству более одного раза.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">для полного доверия для всех методов доступа этого свойства. Это свойство не может использоваться частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, что запись кэша не имеет абсолютного срока действия.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запись кэша, вставляемая в кэш со <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> значением поля, заданным как значение срока действия, никогда не должно истечь на основе абсолютной точки во времени. Однако запись кэша с этим параметром может быть удалена из кэша по другим причинам, которые определяются конкретной реализацией кэша, например, вытеснением события монитора изменений, вызванным нехваткой памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша в кэше.</param>
        <summary>Получает или задает индексатор по умолчанию для класса <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Ключ, служащий индексатором для экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение метода доступа set этого свойства аналогично <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> методу. На внутреннем уровне реализация кэша может задавать абсолютный срок действия указанного значения для <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> метода. Однако это поведение в конечном итоге является реализацией кэша.  
  
 Поведение метода доступа Get аналогично вызову <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> метода и использованию `null` для имени региона.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя конкретного экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Имя конкретного экземпляра кэша.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые реализации кэша могут поддерживать несколько экземпляров кэша, выполняющихся в одном приложении. Это свойство позволяет разработчикам кэша возвращать имя, идентифицирующее конкретный экземпляр кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что запись кэша не имеет скользящего срока действия.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Срок действия, основанный на длительности или определенном окне времени, также называется скользящим сроком действия. Как правило, реализация кэша, которая исключает элементы, основанные на скользящем сроке действия, удаляет элемент, к которому нет доступа в указанном окне времени.  
  
 Запись кэша, вставляемая в кэш со <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> значением поля, заданным как значение срока действия, не следует удалять из-за отсутствия активности в скользящем временном интервале. Однако элемент кэша может быть удален, если он имеет абсолютный срок действия или если возникает какое-либо другое событие вытеснения, например монитор изменений или нехватка памяти.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую была добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе удаляет запись из кэша.</summary>
        <returns>Объект, представляющий значение удаленной записи кэша, заданной данным ключом, или значение <see langword="null" />, если заданная запись не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы переопределяете этот метод в реализации пользовательского кэша, если в кэше есть запись, соответствующая `key`, возвращается значение удаленного элемента. Если ничего не было удалено из кэша, метод должен вернуть `null`значение.  
  
> [!NOTE]
>  Некоторые реализации распределенного кэша могут не поддерживать возврат значения, которое было удалено из кэша. Это может быть вызвано тем, что реализация кэша не поддерживает возврат значения удаленного элемента кэша. Это также может быть вызвано тем, что маршалирование объекта в качестве возвращаемого значения слишком дорого. В таких случаях реализации кэша могут возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичным поведением <xref:System.Runtime.Caching.ObjectCache.Set%2A> методов перегрузки является операция вставки или обновления. Запись кэша либо вставляется в качестве новой записи, если указанная запись не существует, либо если запись кэша обновляется новым значением, если оно уже существует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Добавляемый элемент кэша.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш в виде экземпляра <see cref="T:System.Runtime.Caching.CacheItem" /> и задает сведения о способе удаления записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ для `item` не существует, `item` вставляется в качестве новой записи кэша. Если элемент с совпадающим `item` ключом существует, значение из `item` используется для обновления или перезаписи значения существующей записи кэша.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="absoluteExpiration">Фиксированные дата и время истечения срока действия записи кэша.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш и задает сведения о сроке действия на основе диапазона времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если соответствующий `key` элемент не существует в `value` кэше и `key` используется для вставки в качестве новой записи кэша. Если элемент с совпадающим `item` ключом существует, запись кэша обновляется или перезаписывается с помощью. `value`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Уникальный идентификатор записи кэша.</param>
        <param name="value">Вставляемый объект.</param>
        <param name="policy">Объект, содержащий сведения о вытеснении для записи кэша. Этот объект предоставляет больше параметров для вытеснения, чем простой абсолютный срок действия.</param>
        <param name="regionName">Необязательный параметр. Именованная область кэша, в которую может быть добавлена запись кэша, если области реализованы. Значение необязательного параметра по умолчанию — <see langword="null" />.</param>
        <summary>При переопределении в производном классе вставляет запись в кэш.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузка этого метода позволяет предоставить дополнительные сведения о вытеснении или истечении срока действия, чем те, которые доступны в абсолютных сроках действия на основе времени.  
  
 Если соответствующий `key` элемент не существует в `value` кэше и `key` используется для вставки в качестве новой записи кэша. Если элемент с совпадающим `item` ключом существует, запись кэша обновляется или перезаписывается с помощью. `value`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Поддерживает перебор по строго типизированной коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к записям кэша в кэше.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Поддерживает выполнение итерации по универсальной коллекции.</summary>
        <returns>Объект перечислителя, предоставляющий доступ к элементам кэша.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Его можно использовать только при приведении производного <xref:System.Runtime.Caching.ObjectCache> экземпляра <xref:System.Collections.IEnumerable> к интерфейсу.  
  
 Разработчики могут использовать этот метод для прохода по универсальной коллекции записей кэша.  
  
 Это реализация по умолчанию <xref:System.Collections.IEnumerable.GetEnumerator%2A> , которая внутренне <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> вызывает метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
