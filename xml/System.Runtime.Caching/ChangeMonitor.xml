<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67b64376dfff70efe0d957992c978ec33c4627ac" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68399022" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="d25f3-101">Предоставляет базовый класс производного пользовательского типа, отслеживающего изменения в состоянии данных, от которых зависит элемент кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-101">Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-102"><xref:System.Runtime.Caching.ChangeMonitor> Класс используется в качестве базового класса для производных классов мониторинга, которые являются специализированными для конкретных реализаций кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-102">The <xref:System.Runtime.Caching.ChangeMonitor> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</span></span> <span data-ttu-id="d25f3-103"><xref:System.Runtime.Caching.ChangeMonitor> Экземпляр отслеживает изменения в состоянии данных, от которых зависит элемент кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-103">A <xref:System.Runtime.Caching.ChangeMonitor> instance monitors changes in the state of data which a cache item depends on.</span></span> <span data-ttu-id="d25f3-104">Например, элемент может быть файлом или сущностью данных, содержимое которой кэшируется.</span><span class="sxs-lookup"><span data-stu-id="d25f3-104">For example, the item can be a file or data entity whose contents are cached.</span></span> <span data-ttu-id="d25f3-105">Если файл или сущность данных обновлен, связанная запись кэша также должна быть изменена.</span><span class="sxs-lookup"><span data-stu-id="d25f3-105">If the file or data entity is updated, the associated cache entry must be changed also.</span></span> <span data-ttu-id="d25f3-106">К общим элементам, которые можно отслеживать, относятся сущности данных (поля базы данных, значения, строки или таблицы), другая запись кэша, а также файлы и атрибуты файлов.</span><span class="sxs-lookup"><span data-stu-id="d25f3-106">Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</span></span>  
  
 <span data-ttu-id="d25f3-107">Изменение зависимости — это изменение в состоянии зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-107">A dependency change is a change in the state of a dependency.</span></span> <span data-ttu-id="d25f3-108">В типичной реализации кэша после того, <xref:System.Runtime.Caching.ChangeMonitor> как экземпляр уведомляет кэш о том, что зависимость изменилась, кэш выполняет необходимое действие, например недействительность вставленной записи кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-108">In a typical cache implementation, after a <xref:System.Runtime.Caching.ChangeMonitor> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</span></span>  
  
 <span data-ttu-id="d25f3-109">Производные <xref:System.Runtime.Caching.ChangeMonitor> классы могут быть настроены для отслеживания изменений зависимостей для конкретных различных хранилищ данных.</span><span class="sxs-lookup"><span data-stu-id="d25f3-109">Derived <xref:System.Runtime.Caching.ChangeMonitor> classes can be customized to monitor dependency changes for specific different data stores.</span></span> <span data-ttu-id="d25f3-110">Например, существуют реализации кэша для файловой системы, физической памяти или базы данных.</span><span class="sxs-lookup"><span data-stu-id="d25f3-110">For example, there are cache implementations for a file system, physical memory, or a database.</span></span> <span data-ttu-id="d25f3-111"><xref:System.Runtime.Caching.ChangeMonitor> Класс проверяет изменения, происходящие за пределами кэша, а затем оповещает кэш о произошедших изменениях.</span><span class="sxs-lookup"><span data-stu-id="d25f3-111">The <xref:System.Runtime.Caching.ChangeMonitor> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</span></span>  
  
 <span data-ttu-id="d25f3-112">Включает в себя следующие классы, производные от <xref:System.Runtime.Caching.ChangeMonitor> класса: [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d25f3-112">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] includes the following classes that derive from <xref:System.Runtime.Caching.ChangeMonitor> class:</span></span>  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 <span data-ttu-id="d25f3-113">Каждый из этих классов работает с различными типами зависимостей.</span><span class="sxs-lookup"><span data-stu-id="d25f3-113">Each of these classes works with different types of dependencies.</span></span> <span data-ttu-id="d25f3-114">Например, производный <xref:System.Runtime.Caching.FileChangeMonitor> класс отслеживает изменения в кэше для данных файловой системы (файлов и папок), от которых зависит элемент кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-114">For example, the derived <xref:System.Runtime.Caching.FileChangeMonitor> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d25f3-115">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="d25f3-115">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-116">При создании пользовательской реализации кэша или производного монитора изменений необходимо соблюдать определенные рекомендации.</span><span class="sxs-lookup"><span data-stu-id="d25f3-116">If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</span></span> <span data-ttu-id="d25f3-117">В следующем списке приводятся эти рекомендации.</span><span class="sxs-lookup"><span data-stu-id="d25f3-117">The following list summarizes these guidelines.</span></span> <span data-ttu-id="d25f3-118">Дополнительные сведения см. в документации по отдельным методам или свойствам.</span><span class="sxs-lookup"><span data-stu-id="d25f3-118">For more information, see the documentation for individual methods or properties.</span></span>  
  
<span data-ttu-id="d25f3-119">— Конструктор производного класса должен задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> свойство, начать мониторинг и вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод перед возвратом метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-119">-   The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the method returns.</span></span> <span data-ttu-id="d25f3-120">Если конструктор встречает ошибку во время конструкций и должен удалить ресурсы, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> конструктор может вызвать перегрузку только <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> после вызова <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метода, так как перегрузка вызовет исключение <see cref="T:System.InvalidOperationException" /> исключение, если инициализация не завершена.</span><span class="sxs-lookup"><span data-stu-id="d25f3-120">If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called because the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload will throw an <see cref="T:System.InvalidOperationException" /> exception if initialization is not completed.</span></span>  
  
<span data-ttu-id="d25f3-121">— Если изменения вносятся в данные, которые отслеживаются до завершения инициализации, конструктор должен вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызовом метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-121">-   If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method.</span></span>  
  
<span data-ttu-id="d25f3-122">— После создания экземпляра <see cref="T:System.Runtime.Caching.ChangeMonitor" /> производного типа необходимо вставить этот монитор в пользовательскую <see cref="T:System.Runtime.Caching.ObjectCache" /> реализацию.</span><span class="sxs-lookup"><span data-stu-id="d25f3-122">-   After a derived <see cref="T:System.Runtime.Caching.ChangeMonitor" /> type is instantiated, you must insert the monitor into a custom <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation.</span></span> <span data-ttu-id="d25f3-123">Если вы завершили работу с монитором изменений, вызовите <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-123">Or if you are finished using the change monitor, call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.</span></span>  
  
<span data-ttu-id="d25f3-124">— После <see cref="T:System.Runtime.Caching.ChangeMonitor" /> вставки экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" /> в реализацию для <see cref="T:System.Runtime.Caching.ObjectCache" /> экземпляра требуется, чтобы монитор изменений был удален.</span><span class="sxs-lookup"><span data-stu-id="d25f3-124">-   After a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance is inserted into a <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation, the <see cref="T:System.Runtime.Caching.ObjectCache" /> instance require that the change monitor is disposed.</span></span> <span data-ttu-id="d25f3-125">Даже если вставка является недопустимой и вызывает исключение, <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывать перегрузку.</span><span class="sxs-lookup"><span data-stu-id="d25f3-125">Even if the insertion is invalid and causes an exception, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload.</span></span>  
  
<span data-ttu-id="d25f3-126">— После вставки производного монитора изменений в кэш <see cref="T:System.Runtime.Caching.ObjectCache" /> реализация должна вызвать метод <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, передав <see cref="T:System.Runtime.Caching.OnChangedCallback" /> объект.</span><span class="sxs-lookup"><span data-stu-id="d25f3-126">-   After a derived change monitor is inserted into a cache, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, by passing a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object.</span></span> <span data-ttu-id="d25f3-127"><see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Метод можно вызывать только один раз.</span><span class="sxs-lookup"><span data-stu-id="d25f3-127">The <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method can be called only one time.</span></span> <span data-ttu-id="d25f3-128">Если изменение зависимости уже произошло, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет вызываться немедленно при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызове метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-128">If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called.</span></span> <span data-ttu-id="d25f3-129">В противном случае экземпляр будет вызываться только один раз. <see cref="T:System.Runtime.Caching.OnChangedCallback" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-129">Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called only one time.</span></span> <span data-ttu-id="d25f3-130">Этот <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> вызов происходит либо при вызове метода, <see cref="T:System.Runtime.Caching.ChangeMonitor" /> поскольку экземпляр обнаружил <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> изменение, либо когда метод вызывается <see cref="T:System.Runtime.Caching.ChangeMonitor" />в, в зависимости от того, что происходит первым.</span><span class="sxs-lookup"><span data-stu-id="d25f3-130">This one time call occurs either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called because the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance detected a change, or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called on the <see cref="T:System.Runtime.Caching.ChangeMonitor" />, whichever occurs first.</span></span>  
  
<span data-ttu-id="d25f3-131">— Экземпляр, предоставляемый <see cref="T:System.Runtime.Caching.ObjectCache" /> реализацией, должен удалить связанную запись кэша и указать причину с помощью <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> перечисления. <see cref="T:System.Runtime.Caching.OnChangedCallback" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-131">-   The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance that is provided by an <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation should remove the associated cache entry and specify a reason by using the <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeration.</span></span>  
  
<span data-ttu-id="d25f3-132">— Экземпляр может <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> вызывать метод либо перед тем, как реализация кэша вызывала <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод или после. <see cref="T:System.Runtime.Caching.ChangeMonitor" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-132">-   A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method either before a cache implementation has called <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or after.</span></span> <span data-ttu-id="d25f3-133"><see cref="T:System.Runtime.Caching.ChangeMonitor" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Если метод вызывается до <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызова метода, базовая реализация будет уведомлять кэш о том, что это произошло, и будет активировать обратный вызов, который будет передан немедленно при вызове. <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-133">If the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called before <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called, the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is invoked.</span></span> <span data-ttu-id="d25f3-134">Все данные о состоянии, передаваемые в <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод, сохраняются монитором изменений, а затем передаются <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> в метод при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызове метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-134">Any state data that is passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is saved by the change monitor and subsequently passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method when the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method is invoked.</span></span>  
  
<span data-ttu-id="d25f3-135">— Монитор изменений должен реализовывать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-135">-   A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="d25f3-136">Дополнительные сведения см. в документации метода <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-136">For more information, see the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method documentation.</span></span>  
  
<span data-ttu-id="d25f3-137">— Необходимо вызвать перегрузку <see cref="T:System.Runtime.Caching.ChangeMonitor" /> метода для удаления экземпляра. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-137">-   The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload must be called to dispose of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span> <span data-ttu-id="d25f3-138">Ниже приведены правила для вызова Dispose.</span><span class="sxs-lookup"><span data-stu-id="d25f3-138">The rules for calling Dispose are as follows:</span></span> 
<span data-ttu-id="d25f3-139">— Перед вставкой элемента в кэш ответственность за удаление <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра осуществляется вызывающей стороной.</span><span class="sxs-lookup"><span data-stu-id="d25f3-139">-   Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span>  
  
<span data-ttu-id="d25f3-140">-После того как элемент кэша <see cref="T:System.Runtime.Caching.ChangeMonitor" /> и связанные с ним экземпляры передаются в кэш, разработчику кэша необходимо убедиться <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> , что метод вызывается, даже если вставка завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d25f3-140">-   Once cache item and the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances that are associated with it are passed to a cache, the cache implementer must make sure that the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, even if the insert fails.</span></span>  
  
<span data-ttu-id="d25f3-141">— После передачи элемента и связанных <see cref="T:System.Runtime.Caching.ChangeMonitor" /> с ним экземпляров в кэш вызывающий объект не должен удалять зависимость, поскольку <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> при вызове метода вызов обрабатывается так, как если бы зависимость изменилась.</span><span class="sxs-lookup"><span data-stu-id="d25f3-141">-   After an item and its associated <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances are passed to a cache, the caller must not dispose the dependency because when the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, the call is treated as if the dependency has changed.</span></span> <span data-ttu-id="d25f3-142">В результате <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод вызывается автоматически.</span><span class="sxs-lookup"><span data-stu-id="d25f3-142">As a result, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is automatically invoked.</span></span>  
  
<span data-ttu-id="d25f3-143">— Принимая эти правила, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод должен вызываться одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="d25f3-143">-   Taking these rules into consideration, the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method must be called in one of the following ways:</span></span> 
<span data-ttu-id="d25f3-144">— Пользователи должны вызывать перегрузку метода, <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> если они решили не вставлять производный экземпляр монитора изменений в кэш.</span><span class="sxs-lookup"><span data-stu-id="d25f3-144">-   Users must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload if they decide not to insert the derived change-monitor instance into a cache.</span></span>  
  
<span data-ttu-id="d25f3-145">— Если реализация пытается вставить экземпляр монитора изменений в кэш объектов, но вставка завершается неудачей, реализация кэша отвечает за вызов <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="d25f3-145">-   If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload.</span></span> <span data-ttu-id="d25f3-146">Когда в результате попытки вставки вызывается исключение, реализация кэша должна удалить все связанные зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-146">When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</span></span>  
  
<span data-ttu-id="d25f3-147">— Если запись кэша удалена, реализация кэша должна также удалить зависимость.</span><span class="sxs-lookup"><span data-stu-id="d25f3-147">-   If the cache entry is removed, the cache implementation must also dispose of the dependency.</span></span>  
  
<span data-ttu-id="d25f3-148">— Внутренняя реализация <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метода автоматически <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> вызывает метод после вызова метода обратного вызова, зарегистрированного с помощью <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-148">-   The internal implementation of the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method automatically calls the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method after it calls a callback that is registered through <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="d25f3-149">Этот автоматический вызов метода Dispose во время срабатывания события происходит только в том случае, если инициализация <see cref="T:System.Runtime.Caching.ChangeMonitor" /> экземпляра была выполнена ранее.</span><span class="sxs-lookup"><span data-stu-id="d25f3-149">This automatic call to the dispose method during the event firing only occurs if the initialization of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance was previously completed.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="d25f3-150">Когда конструктор производного монитора изменений вызывает <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод, если состояние монитора изменений уже изменилось (то есть состояние, которое отслеживается ранее, когда конструктор еще был активен) <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> , метод будет Автоматическое удаление монитора изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-150">When a derived change monitor's constructor calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method will automatically dispose of the change monitor.</span></span>  
  
<span data-ttu-id="d25f3-151"><see langword="true" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> <see cref="T:System.Runtime.Caching.OnChangedCallback" /> — Свойство устанавливается в значение после того, как метод вызывается производным экземпляром монитора изменений, независимо от того, был ли объект задан вызовом <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метода. <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-151">-   The <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> property is set to <see langword="true" /> after the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called by the derived change-monitor instance, regardless of whether a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object has been set by a call to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or not.</span></span></para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce"><span data-ttu-id="d25f3-152">Кэширование ASP.NET</span><span class="sxs-lookup"><span data-stu-id="d25f3-152">ASP.NET Caching</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d25f3-153">Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-153">Initializes a new instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span> <span data-ttu-id="d25f3-154">Этот конструктор вызывается конструкторами в производных классах для инициализации базового класса.</span><span class="sxs-lookup"><span data-stu-id="d25f3-154">This constructor is called from constructors in derived classes to initialize the base class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-155"><xref:System.Runtime.Caching.ChangeMonitor> Класс содержит конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="d25f3-155">The <xref:System.Runtime.Caching.ChangeMonitor> class has a parameterless constructor.</span></span> <span data-ttu-id="d25f3-156">Однако классы, наследующие от базового <xref:System.Runtime.Caching.ChangeMonitor> класса и определяющие пользовательское поведение мониторинга изменений, должны выполнять инициализацию в конструкторе.</span><span class="sxs-lookup"><span data-stu-id="d25f3-156">However, classes that inherit from the base <xref:System.Runtime.Caching.ChangeMonitor> class and define custom change-monitoring behavior must perform initialization in the constructor.</span></span> <span data-ttu-id="d25f3-157">Дополнительные сведения см. в разделе Примечания для наследников.</span><span class="sxs-lookup"><span data-stu-id="d25f3-157">For more information, see the Notes for Inheritors section.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-158">Конструктор производного класса должен задать <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> свойство, начать мониторинг и <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызвать класс перед возвратом.</span><span class="sxs-lookup"><span data-stu-id="d25f3-158">The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> class before it returns.</span></span> <span data-ttu-id="d25f3-159">Если зависимость изменяется до завершения инициализации (например, если зависимый ключ кэша не найден в кэше), конструктор должен вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> метод перед <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызовом метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-159">If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before it calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method.</span></span> <span data-ttu-id="d25f3-160">В этом случае конструктор может вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> после вызова метода, так как <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод создает исключение, если инициализация не завершена.</span><span class="sxs-lookup"><span data-stu-id="d25f3-160">In this case, constructor can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d25f3-161">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-161">Releases all resources used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-162">Метод используется для <xref:System.Runtime.Caching.ChangeMonitor> освобождения экземпляра и связанных ресурсов. <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-162">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is used to release the <xref:System.Runtime.Caching.ChangeMonitor> instance and related resources.</span></span> <span data-ttu-id="d25f3-163">Открытый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод вызывается для координации процесса реализации с событиями жизненного цикла ключа производных классов отслеживания изменений (например, инициализации), а также для <xref:System.Runtime.Caching.ChangeMonitor> освобождения экземпляра, чтобы экземпляр мог быть собран сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="d25f3-163">The public <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <xref:System.Runtime.Caching.ChangeMonitor> instance so that the instance can be garbage collected.</span></span> <span data-ttu-id="d25f3-164"><xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод реализуется производными классами отслеживания изменений для удаления управляемых и неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="d25f3-164">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d25f3-165">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-165">Releases all resources that are used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-166"><xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Метод вызывает<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод производных классов только один раз, при первом вызове метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-166">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method invokes the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method of derived classes only one time, the first time it is called.</span></span> <span data-ttu-id="d25f3-167">Последующие вызовы <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метода не действуют.</span><span class="sxs-lookup"><span data-stu-id="d25f3-167">Subsequent calls to the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method have no effect.</span></span> <span data-ttu-id="d25f3-168">После вызова <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> метода свойству присваивается `true`значение.</span><span class="sxs-lookup"><span data-stu-id="d25f3-168">After the method has been called, the <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> property is set to `true`.</span></span>  
  
 <span data-ttu-id="d25f3-169">Чтобы удалить<xref:System.Runtime.Caching.ChangeMonitor> экземпляр, необходимо вызвать перегрузку.<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-169">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload must be called to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="d25f3-170">Ниже приведены правила для вызова метода Dispose:</span><span class="sxs-lookup"><span data-stu-id="d25f3-170">The following are the rules for calling the dispose method:</span></span>  
  
-   <span data-ttu-id="d25f3-171">Перед вставкой элемента в кэш вызывающий объект обязан ликвидировать <xref:System.Runtime.Caching.ChangeMonitor> экземпляр.</span><span class="sxs-lookup"><span data-stu-id="d25f3-171">Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
-   <span data-ttu-id="d25f3-172">После того как элемент кэша <xref:System.Runtime.Caching.ChangeMonitor> и связанные с ним экземпляры передаются в кэш, метод реализации кэша должен <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> обеспечивать вызов, даже если вставка завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d25f3-172">Once cache item and the <xref:System.Runtime.Caching.ChangeMonitor> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> is called, even if the insert fails.</span></span>  
  
-   <span data-ttu-id="d25f3-173">После того как элемент и его <xref:System.Runtime.Caching.ChangeMonitor> связанные экземпляры передаются в кэш, вызывающий объект не должен удалять зависимость, поскольку <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> при вызове метода вызов обрабатывается так, как если бы зависимость изменилась.</span><span class="sxs-lookup"><span data-stu-id="d25f3-173">After an item and its associated <xref:System.Runtime.Caching.ChangeMonitor> instances are passed to a cache, the caller must not dispose the dependency because when the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is called, the call is treated as if the dependency has changed.</span></span> <span data-ttu-id="d25f3-174">В результате <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается автоматически.</span><span class="sxs-lookup"><span data-stu-id="d25f3-174">As a result, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is automatically invoked.</span></span>  
  
-   <span data-ttu-id="d25f3-175">Принимая эти правила, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод должен вызываться одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="d25f3-175">Taking these rules into consideration, the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method must be called in one of the following ways:</span></span>  
  
    -   <span data-ttu-id="d25f3-176">Пользователи должны вызывать перегрузку метода, <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> если они решили не вставлять производный экземпляр монитора изменений в кэш.</span><span class="sxs-lookup"><span data-stu-id="d25f3-176">Users must call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method overload if they decide not to insert the derived change-monitor instance into a cache.</span></span>  
  
    -   <span data-ttu-id="d25f3-177">Реализация кэша отвечает за вызов <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> перегрузки, если реализация пытается вставить экземпляр монитора изменений в кэш объектов, но вставка завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d25f3-177">The cache implementation is responsible for calling the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</span></span> <span data-ttu-id="d25f3-178">Когда в результате попытки вставки вызывается исключение, реализация кэша должна удалить все связанные зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-178">When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</span></span>  
  
    -   <span data-ttu-id="d25f3-179">Если запись кэша удалена, реализация кэша должна также ликвидировать зависимость.</span><span class="sxs-lookup"><span data-stu-id="d25f3-179">If the cache entry is removed, the cache implementation must also dispose the dependency.</span></span>  
  
 <span data-ttu-id="d25f3-180">Внутренняя реализация <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метода автоматически <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывает метод после вызова метода обратного вызова <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> , зарегистрированного с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-180">The internal implementation of the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method after it calls a callback that is registered through the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d25f3-181">Автоматическое удаление во время срабатывания события происходит только в том случае, если инициализация <xref:System.Runtime.Caching.ChangeMonitor> экземпляра завершилась ранее.</span><span class="sxs-lookup"><span data-stu-id="d25f3-181">This automatic dispose during the event firing only occurs if the initialization of the <xref:System.Runtime.Caching.ChangeMonitor> instance previously completed.</span></span>  
  
 <span data-ttu-id="d25f3-182">Когда конструктор производного монитора изменений вызывает <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метод, если состояние монитора изменений уже изменилось (то есть состояние, которое отслеживается, уже изменилось, когда конструктор еще активен <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> ), метод будет Автоматическое удаление монитора изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-182">When a derived change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method will automatically dispose the change monitor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d25f3-183">Пользователи не должны вызывать <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-183">Users should not call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="d25f3-184">Однако нельзя запретить пользователям вызывать метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-184">However, you cannot prevent users from calling the method.</span></span> <span data-ttu-id="d25f3-185">Таким образом, если это так, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-185">Therefore, if they do, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked.</span></span> <span data-ttu-id="d25f3-186">В этом случае запись кэша будет уведомлена так, как если бы зависимость была изменена.</span><span class="sxs-lookup"><span data-stu-id="d25f3-186">In that case, the cache entry is notified as if the dependency has changed.</span></span>  
  
 <span data-ttu-id="d25f3-187">Чтобы исключить производные классы от переопределяющего <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метода, метод не является явной реализацией интерфейса.</span><span class="sxs-lookup"><span data-stu-id="d25f3-187">To prevent derived classes from overriding <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method, the method is not an explicit interface implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d25f3-188">Инициализация не завершена в производном классе монитора изменений, который вызвал базовый метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-188">Initialization is not complete in the derived change-monitor class that called the base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.</span></span></exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="d25f3-189">Значение <see langword="true" />, чтобы освободить управляемые и неуправляемые ресурсы и любые ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />; значение <see langword="false" />, чтобы освободить только неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d25f3-189"><see langword="true" /> to release managed and unmanaged resources and any references to a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance; <see langword="false" /> to release only unmanaged resources.</span></span> <span data-ttu-id="d25f3-190">Если передается значение <see langword="false" />, метод <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> вызывается потоком <see langword="finalizer" />, а любые внешние управляемые ссылки в большинстве случаев становятся недействительными, так как они уже были очищены сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="d25f3-190">When <see langword="false" /> is passed, the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method is called by a <see langword="finalizer" /> thread and any external managed references are likely no longer valid because they have already been garbage collected.</span></span></param>
        <summary><span data-ttu-id="d25f3-191">Освобождает все управляемые и неуправляемые ресурсы и все ссылки на экземпляр <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-191">Releases all managed and unmanaged resources and any references to the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span> <span data-ttu-id="d25f3-192">Эту перегрузку необходимо реализовывать в производных классах, контролирующих изменения.</span><span class="sxs-lookup"><span data-stu-id="d25f3-192">This overload must be implemented by derived change-monitor classes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-193">Если значение `disposing` равно `true`, все управляемые и неуправляемые ресурсы удаляются и все ссылки на этот объект освобождаются, чтобы производный экземпляр монитора изменений мог быть собран сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="d25f3-193">When the value of `disposing` value is `true`, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</span></span> <span data-ttu-id="d25f3-194">Гарантируется, что базовый <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод вызовет реализованный <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод только один раз.</span><span class="sxs-lookup"><span data-stu-id="d25f3-194">It is guaranteed that the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method will invoke the implemented <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method only one time.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-195">Монитор изменений должен реализовать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> перегрузку, чтобы освободить все управляемые и неуправляемые ресурсы, если <paramref name="disposing" /> значение равно <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-195">A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload to release all managed and unmanaged resources when the value of <paramref name="disposing" /> is <see langword="true" />.</span></span> <span data-ttu-id="d25f3-196">Перегрузка метода, <paramref name="disposing" /> имеющая значение <see langword="true" /> , вызывается только один раз, а именно, когда экземпляр удаляется в первый раз. <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="d25f3-196">The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method overload that has a <paramref name="disposing" /> value of <see langword="true" /> is called only one time, namely, when the instance is disposed for the first time.</span></span> <span data-ttu-id="d25f3-197">Монитор изменений не должен вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> перегрузку напрямую.</span><span class="sxs-lookup"><span data-stu-id="d25f3-197">A change monitor must not call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload directly.</span></span> <span data-ttu-id="d25f3-198">Производный монитор изменений может вызвать открытый <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод без параметров для базового <see cref="T:System.Runtime.Caching.ChangeMonitor" /> класса.</span><span class="sxs-lookup"><span data-stu-id="d25f3-198">A derived change monitor can call the public parameter-less <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method on the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span>  
  
<span data-ttu-id="d25f3-199">Кроме того, монитор изменений может реализовать метод метода завершения.</span><span class="sxs-lookup"><span data-stu-id="d25f3-199">Alternatively, a change monitor can implement a finalizer method.</span></span> <span data-ttu-id="d25f3-200">В этом случае финализатор может вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> метод и передать <paramref name="disposing" /> ему значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-200">In that case, the finalizer can invoke the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method and pass it a <paramref name="disposing" /> value of <see langword="false" />.</span></span> <span data-ttu-id="d25f3-201">Однако обычно это не требуется.</span><span class="sxs-lookup"><span data-stu-id="d25f3-201">However, this is usually unnecessary.</span></span> <span data-ttu-id="d25f3-202">Мониторинг изменений зависимостей обычно выполняется службой, которая поддерживает ссылку на экземпляр монитора изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-202">Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</span></span> <span data-ttu-id="d25f3-203">Ссылка не позволяет экземпляру быть собрана сборщиком мусора и, следовательно, приводит к необходимости в методе завершения.</span><span class="sxs-lookup"><span data-stu-id="d25f3-203">The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</span></span> <span data-ttu-id="d25f3-204">Чтобы избежать утечек памяти, при изменении <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> зависимости метод удаляет экземпляр монитора изменений (если инициализация не завершена).</span><span class="sxs-lookup"><span data-stu-id="d25f3-204">To avoid memory leaks, when a dependency changes, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method disposes the change-monitor instance (unless initialization has not finished).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d25f3-205">Получает значение, указывающее, что состояние, отслеживаемое классом <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось.</span><span class="sxs-lookup"><span data-stu-id="d25f3-205">Gets a value that indicates that the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class has changed.</span></span></summary>
        <value><span data-ttu-id="d25f3-206">Значение <see langword="true" />, если состояние отслеживаемое экземпляром <see cref="T:System.Runtime.Caching.ChangeMonitor" />, изменилось; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-206"><see langword="true" /> if the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance has changed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-207">Чтобы узнать, изменилась ли зависимость, можно проверить значение <xref:System.Runtime.Caching.ChangeMonitor> этого свойства в производном классе.</span><span class="sxs-lookup"><span data-stu-id="d25f3-207">You can check the value of this property in a derived <xref:System.Runtime.Caching.ChangeMonitor> class to see whether a dependency has changed.</span></span>  
  
 <span data-ttu-id="d25f3-208">Значение устанавливается в, `true` когда происходит изменение зависимости (то есть <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> при вызове метода).</span><span class="sxs-lookup"><span data-stu-id="d25f3-208">The value is set to `true` when a dependency change occurs (that is, when the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called).</span></span> <span data-ttu-id="d25f3-209"><xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> <xref:System.Runtime.Caching.OnChangedCallback> `true` <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> После вызова методапроизводнымклассомзначениесвойствабудет,независимооттого,быллиэкземпляруведомленспомощьювызоваметода.<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-209">After the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called by the derived class, the value of the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property will be `true`, regardless of whether a <xref:System.Runtime.Caching.OnChangedCallback> instance has been notified by a call to the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d25f3-210">Вызывающие объекты могут проверить <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство, чтобы узнать, изменилась ли зависимость.</span><span class="sxs-lookup"><span data-stu-id="d25f3-210">Callers can check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property to see whether a dependency has changed.</span></span> <span data-ttu-id="d25f3-211">Однако в многопоточной среде проще и более сопровождаемый подход заключается в вставке данных в реализацию кэша без проверки <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="d25f3-211">However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property.</span></span> <span data-ttu-id="d25f3-212">Реализации кэша должны проверять <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> свойство и не должны выполнять операцию INSERT или Set, если одна или несколько связанных зависимостей уже были изменены.</span><span class="sxs-lookup"><span data-stu-id="d25f3-212">Cache implementations must check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d25f3-213">Вызывается из конструктора производных классов и указывает на завершение инициализации.</span><span class="sxs-lookup"><span data-stu-id="d25f3-213">Called from the constructor of derived classes to indicate that initialization is finished.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-214">Если зависимость изменяется до завершения инициализации в производном классе, конструктор производного класса должен вызвать <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-214">If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span>  
  
 <span data-ttu-id="d25f3-215">При вызове <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> метода свойство автоматически устанавливается на `true` монитор изменений. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-215">When the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked, the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is automatically set to `true` by the change monitor.</span></span> <span data-ttu-id="d25f3-216">В результате, когда конструктор изменений монитора вызывает <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> метод, базовый класс будет автоматически <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> вызывать метод.</span><span class="sxs-lookup"><span data-stu-id="d25f3-216">As a result, when the change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, the base class will automatically call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="d25f3-217">Если инициализация завершена, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод автоматически удаляет производный экземпляр монитора изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-217">If initialization is complete, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically disposes the derived change-monitor instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-218">Конструктор производного класса должен вызвать базовый <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> метод перед возвратом из конструктора.</span><span class="sxs-lookup"><span data-stu-id="d25f3-218">The constructor of a derived class must call the base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the constructor returns.</span></span> <span data-ttu-id="d25f3-219">Конструктор производного класса может вызывать <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод только после <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> вызова метода, поскольку <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> метод создает исключение, если инициализация не завершена.</span><span class="sxs-lookup"><span data-stu-id="d25f3-219">The constructor of a derived class can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d25f3-220">Получает значение, указывающее, что производный экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" /> удален.</span><span class="sxs-lookup"><span data-stu-id="d25f3-220">Gets a value that indicates that the derived instance of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class is disposed.</span></span></summary>
        <value><span data-ttu-id="d25f3-221">Значение <see langword="true" />, если экземпляр удален; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-221"><see langword="true" /> if the instance is disposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-222">Свойство устанавливается в `true` значение после того, как <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> базовый метод вызывает <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> метод в производном классе для удаления экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d25f3-222">The property is set to `true` after the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method in a derived class to dispose of the instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback"><span data-ttu-id="d25f3-223">Ссылка на метод, вызываемый при изменении зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-223">A reference to a method that is invoked when a dependency has changed.</span></span></param>
        <summary><span data-ttu-id="d25f3-224">Вызывается средствами реализации кэша для регистрации обратного вызова и уведомления экземпляра <see cref="T:System.Runtime.Caching.ObjectCache" /> об изменении зависимости с использованием делегата <see cref="T:System.Runtime.Caching.OnChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-224">Called by Cache implementers to register a callback and notify an <see cref="T:System.Runtime.Caching.ObjectCache" /> instance through the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegate when a dependency has changed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-225">Методы реализации кэша используют этот метод для самостоятельной связи с монитором изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-225">Cache implementers use this method to wire themselves up to a change monitor.</span></span> <span data-ttu-id="d25f3-226">При связывании одного или нескольких мониторов изменений с элементом кэша передается <xref:System.Runtime.Caching.CacheItemPolicy> экземпляр с заполненным свойством Monitoring Monitors в элемент кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-226">If you associate one or more change monitors with the cache item, you pass a <xref:System.Runtime.Caching.CacheItemPolicy> instance with a populated change monitors property to the cache item.</span></span> <span data-ttu-id="d25f3-227">Средство реализации кэша, поддерживающее мониторы изменений, отвечает за перебор <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> свойства и <xref:System.Runtime.Caching.OnChangedCallback> регистрирует делегаты с каждым найденным монитором изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-227">A cache implementer that supports change monitors is responsible for iterating over the <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> property and register the <xref:System.Runtime.Caching.OnChangedCallback> delegates with each change monitor that it finds.</span></span>  
  
 <span data-ttu-id="d25f3-228"><xref:System.Runtime.Caching.OnChangedCallback> Поскольку делегат включает необязательный параметр состояния, реализация конкретного монитора изменений может передавать дополнительные сведения о состоянии.</span><span class="sxs-lookup"><span data-stu-id="d25f3-228">Because the <xref:System.Runtime.Caching.OnChangedCallback> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</span></span> <span data-ttu-id="d25f3-229">Метод реализации кэша определяет, может ли быть выполнена явная зависимость от типа состояния, переданного пользовательским монитором изменений в качестве части обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="d25f3-229">The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d25f3-230">API расширяемости базового кэша не требует явной зависимости от типа состояния.</span><span class="sxs-lookup"><span data-stu-id="d25f3-230">The base cache extensibility API has no requirement for explicit dependency on the type of state.</span></span>  
  
 <span data-ttu-id="d25f3-231">Реализация <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> метода автоматически определяет, было ли состояние монитора уже изменено при вызове метода времени <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> .</span><span class="sxs-lookup"><span data-stu-id="d25f3-231">The implementation of the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method automatically determines whether the state of the monitor has already changed at the time <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called.</span></span> <span data-ttu-id="d25f3-232">Если свойство имеет `true`значение, метод автоматически вызывает <xref:System.Runtime.Caching.OnChangedCallback> <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> обработчик событий, который был зарегистрирован с помощью метода. <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-232">If the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is `true`, then the method automatically calls the <xref:System.Runtime.Caching.OnChangedCallback> event handler, that was registered, through the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span> <span data-ttu-id="d25f3-233">Это происходит потому, что из-за того, что в реализации кэша создается монитор изменений, до того момента, как реализация кэша получает монитор и сами подключаются к нему, состояние базового наблюдаемого состояния изменилось.</span><span class="sxs-lookup"><span data-stu-id="d25f3-233">This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</span></span> <span data-ttu-id="d25f3-234">Если состояние уже изменено, то объект, переданный в <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод, имеет значение. `null`</span><span class="sxs-lookup"><span data-stu-id="d25f3-234">If the state has already changed then the object that is passed to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is `null`.</span></span>  
  
 <span data-ttu-id="d25f3-235"><xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Метод может быть вызван только один раз и будет вызывать исключение при последующих вызовах.</span><span class="sxs-lookup"><span data-stu-id="d25f3-235">The <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method can be invoked only one time, and will throw an exception on subsequent calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d25f3-236">Метод обратного вызова уже вызван.</span><span class="sxs-lookup"><span data-stu-id="d25f3-236">The callback method has already been invoked.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d25f3-237">Свойство <paramref name="onChangedCallback" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-237"><paramref name="onChangedCallback" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-238">1.  Необходимо вызвать <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> метод, чтобы получать уведомления об изменениях зависимостей.</span><span class="sxs-lookup"><span data-stu-id="d25f3-238">1.  You must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method to be notified of any dependency changes.</span></span> <span data-ttu-id="d25f3-239">Если изменение зависимости уже произошло, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> экземпляр будет вызываться при <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> вызове метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-239">If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called.</span></span> <span data-ttu-id="d25f3-240">В противном <see cref="T:System.Runtime.Caching.OnChangedCallback" /> случае экземпляр будет вызываться один раз, как <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> при вызове метода, так и <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> при вызове метода, в зависимости от того, что происходит первым.</span><span class="sxs-lookup"><span data-stu-id="d25f3-240">Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called one time, either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, whichever occurs first.</span></span> <span data-ttu-id="d25f3-241"><see cref="T:System.Runtime.Caching.OnChangedCallback" /> Экземпляр, предоставляемый реализацией кэша, должен удалить запись кэша и, если она запрошена вызывающим кэшем, вызвать необходимое изменение или обновить событие обратно в исходный вызывающий объект кэша.</span><span class="sxs-lookup"><span data-stu-id="d25f3-241">The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</span></span>  
  
<span data-ttu-id="d25f3-242">2.</span><span class="sxs-lookup"><span data-stu-id="d25f3-242">2.</span></span>  <span data-ttu-id="d25f3-243">Реализация кэша объектов должна удалить запись кэша, связанную с изменением зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-243">The object cache implementation must remove the cache entry that is associated with a dependency change.</span></span></para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="d25f3-244">Данные для события изменения.</span><span class="sxs-lookup"><span data-stu-id="d25f3-244">The data for the change event.</span></span> <span data-ttu-id="d25f3-245">Это значение может быть равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-245">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d25f3-246">Вызывается производными классами для создания события при изменении зависимости.</span><span class="sxs-lookup"><span data-stu-id="d25f3-246">Called by derived classes to raise the event when a dependency changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-247">Как правило, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> метод вызывается, когда происходят изменения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="d25f3-247">Typically, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called when dependency changes occur.</span></span> <span data-ttu-id="d25f3-248"><xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Метод также вызывается при удалении экземпляра монитора изменений, но реализация происходит только в том случае, если обратный вызов еще не был вызван.</span><span class="sxs-lookup"><span data-stu-id="d25f3-248">The <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</span></span>  
  
 <span data-ttu-id="d25f3-249">Если метод вызывается <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> до вызова метода, данные о состоянии <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> из вызова метода сохраняются реализацией кэша. <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-249">If the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called before the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called, the state data from the call to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is saved by the cache implementation.</span></span> <span data-ttu-id="d25f3-250">Кроме того, обратный вызов <xref:System.Runtime.Caching.OnChangedCallback> метода вызывается немедленно <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="d25f3-250">Also, the callback to the <xref:System.Runtime.Caching.OnChangedCallback> method is invoked immediately when the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d25f3-251">Получает значение, представляющее экземпляр класса <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span><span class="sxs-lookup"><span data-stu-id="d25f3-251">Gets a value that represents the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class instance.</span></span></summary>
        <value><span data-ttu-id="d25f3-252">Идентификатор экземпляра монитора изменений.</span><span class="sxs-lookup"><span data-stu-id="d25f3-252">The identifier for a change-monitor instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d25f3-253">Значение свойства обычно состоит из Объединенных строковых данных, которые однозначно идентифицируют данные, отслеживаемые <xref:System.Runtime.Caching.ChangeMonitor> экземпляром. <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A></span><span class="sxs-lookup"><span data-stu-id="d25f3-253">The <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="d25f3-254">Значением <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> свойства является строка.</span><span class="sxs-lookup"><span data-stu-id="d25f3-254">The value of the <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property is a string.</span></span> <span data-ttu-id="d25f3-255">Значение строки используется для присвоения уникального идентификатора <xref:System.Runtime.Caching.ChangeMonitor> экземпляра.</span><span class="sxs-lookup"><span data-stu-id="d25f3-255">The value of the string is used to assign the unique ID of the <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-256">Переопределяя свойство, можно определить пользовательскую реализацию для строкового значения свойства, чтобы назначить ей уникальный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="d25f3-256">By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</span></span></para></block>
        <block subset="none" type="overrides"><para><span data-ttu-id="d25f3-257">В производных классах необходимо задать значение свойства в конструкторе.</span><span class="sxs-lookup"><span data-stu-id="d25f3-257">In derived classes, you must set the value of the property in the constructor.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>