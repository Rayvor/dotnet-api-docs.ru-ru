<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="984221b87656454580cf6751da9f457394861e96" /><Meta Name="ms.sourcegitcommit" Value="8544f14c8194a55eb22d46721b0bbe46f345c063" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/21/2019" /><Meta Name="ms.locfileid" Value="69667994" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет базовый класс для реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />. Это абстрактный класс.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider> Можно использовать для создания и получения экземпляров генераторов кода и компиляторов кода. Генераторы кода применяются для создания кода на определенном языке, а компиляторы кода используются для компиляции кода в сборки.  
  
> [!NOTE]
>  В методы [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], доступные в генераторе кода и компиляторе кода, доступны непосредственно из поставщика кода. Вам не нужно вызывать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методы или <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> для доступа к методам, и эти методы помечены как устаревшие. Это относится к уже существовавшим, а также к новым реализациям поставщиков кода.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider> Реализация обычно предоставляет интерфейсы создания кода и (или) компиляции кода для создания кода и управления компиляцией для одного языка программирования. <xref:System.CodeDom.Compiler.CodeDomProvider> Реализации, поставляемые с Windows SDK, поддерживают несколько языков. Эти языки включают C#, Visual Basic, C++и JScript. Разработчики или поставщики компиляторов могут реализовывать <xref:System.CodeDom.Compiler.ICodeGenerator> интерфейсы <xref:System.CodeDom.Compiler.ICodeCompiler> и <xref:System.CodeDom.Compiler.CodeDomProvider> , а также предоставлять, который расширяет поддержку CodeDOM на другие языки программирования.  
  
 [Элемент System. CodeDOM&gt; в файле конфигурации компьютера (Machine. config) предоставляет разработчикам и поставщикам компиляторов механизм добавления параметров конфигурации для дополнительных реализаций. &lt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) <xref:System.CodeDom.Compiler.CodeDomProvider>  
  
 Класс предоставляет статические методы для обнаружения и перечисления <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider> Метод возвращает параметры для всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Метод возвращает параметры для конкретной <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на основе имени языка программирования. <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>  
  
 Дополнительные сведения о параметрах поставщика языка в файле конфигурации см. в разделе [схема параметров поставщика языка и компилятора](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Этот класс выполняет запрос компоновки и требование наследования на уровне класса. <xref:System.Security.SecurityException> Исключение создается, если непосредственный вызывающий объект или производный класс не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md) и [требования наследования](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 Следующий пример программы может создать и скомпилировать исходный код на основе модели CodeDOM программы, которая выводит "Hello World" с помощью <xref:System.Console> класса. Предоставляется Windows Forms пользовательский интерфейс. Пользователь может выбрать целевой язык программирования из нескольких вариантов: C#, Visual Basic и JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот класс нельзя использовать в частично доверенном коде.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Полный уровень доверия для разработчиков производных классов. Этот класс не может наследоваться частично доверенным кодом.</permission>
    <block subset="none" type="overrides"><para>В .NET Framework версиях 1,0 и 1,1 поставщики кода состоят из <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />реализаций <see cref="T:System.CodeDom.Compiler.ICodeParser" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, и <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> В методы ,<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />и <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> являютсяустаревшими<see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> , а методы и доступны непосредственно в классе. <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> Эти методы следует переопределить в реализации поставщика кода, не вызвав базовые методы.</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот класс нельзя использовать в частично доверенном коде.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компиляции.</param>
        <param name="compilationUnits">Массив типа <see cref="T:System.CodeDom.CodeCompileUnit" />, указывающий код для компиляции.</param>
        <summary>Компилирует сборку на основе деревьев <see cref="N:System.CodeDom" />, содержащихся в указанном массиве объектов <see cref="T:System.CodeDom.CodeCompileUnit" />, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метода для совместимости с уже существующими поставщиками, использующими компиляторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует компилятор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компиляции.</param>
        <param name="fileNames">Массив имен файлов для компиляции.</param>
        <summary>Компилирует сборку из исходного кода, содержащегося в указанных файлах, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метода для совместимости с уже существующими поставщиками, использующими компиляторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует компилятор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" />, задающий параметры компилятора для компиляции.</param>
        <param name="sources">Массив строк исходного кода для компиляции.</param>
        <summary>Компилирует сборку из указанного массива строк, содержащего исходный код, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" />, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метода для совместимости с уже существующими поставщиками, использующими компиляторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует компилятор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый компилятор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />, который может использоваться для компиляции представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Взамен рекомендуется вызывать <xref:System.CodeDom.Compiler.ICodeCompiler> методы, которые непосредственно доступны в поставщике кода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В необходимо <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализовать элементы в классе и вызывать исключение <see cref="T:System.NotSupportedException" /> при вызове этого метода. <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается Escape-идентификатор.</param>
        <summary>Создает Escape-идентификатор для заданного значения.</summary>
        <returns>Escape-идентификатор для данного значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A>проверяет, конфликтует ли идентификатор с зарезервированными ключевыми словами или ключевые слова языка, и, если это так, возвращает эквивалентное имя с форматированием кода, зависящим от языка. Это называется экранированным идентификатором. Экранированный идентификатор содержит те же `value` символы, но добавляет форматирование с помощью Escape-кода, чтобы отличать идентификатор от ключевого слова. Два примера реализации перед `value` символом "@" или скобками `value` с "[" и "]".  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Взамен рекомендуется вызывать <xref:System.CodeDom.Compiler.ICodeGenerator> методы, которые непосредственно доступны <xref:System.CodeDom.Compiler.CodeDomProvider> в классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В необходимо <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализовать элементы в классе и вызывать исключение <see cref="T:System.NotSupportedException" /> при вызове этого метода. <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">Объект <see cref="T:System.IO.TextWriter" />, который следует использовать для вывода.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя для вывода указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанный <xref:System.IO.TextWriter> для вывода. Этот метод поддерживает более оптимизированное создание кода, которое постепенно обновляет исходный код.  
  
> [!NOTE]
>  Реализация <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> базового класса вызывает метод, который является устаревшим [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] в и <xref:System.CodeDom.Compiler.ICodeGenerator> приводит к возникновению, <xref:System.NotSupportedException> если объект не возвращается.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла для выходных данных.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя указанное имя файла для выходных данных.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, который может использоваться для генерации представлений исходного кода на основе <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанное имя файла для вывода.  
  
> [!NOTE]
>  Реализация <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> базового класса вызывает метод, который является устаревшим [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] в и <xref:System.CodeDom.Compiler.ICodeGenerator> приводит к возникновению, <xref:System.NotSupportedException> если объект не возвращается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый анализатор кода.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.ICodeParser" />, который может использоваться для анализа исходного кода. Базовая реализация всегда возвращает значение <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод чаще всего используется для создания экземпляра поставщика кода в приложении, которое при необходимости может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>позволяет указать во время выполнения поставщик кода, для которого вы хотите создать экземпляр. Если во время разработки известно, какой поставщик кода следует использовать, следует создать экземпляр этого поставщика кода, а не использовать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод.  
  
 Метод возвращает экземпляр для определенного имени языка; он аналогичен вызову <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода с типом поставщика языка. <xref:System.CodeDom.Compiler.CodeDomProvider> <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Используется <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> , если требуется динамически найти настроенную реализацию поставщика для имени языка.  
  
 Если для имени языка настроено более одной реализации поставщика, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> возвращает экземпляр поставщика для последнего соответствующего элемента конфигурации.  
  
 Используйте перегрузку метода, <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> если требуется реализовать конкретную реализацию поставщика языка. Например, используйте <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод для получения экземпляра поставщика, который поддерживает название `"CSharp"`языка; используйте <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> перегрузку метода, <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> чтобы получить экземпляр поставщика специально для реализации. Следует использовать [\], CultureInfo, объект\<XREF: System. активатор. CreateInstance% 28System. Type% 2CSystem. Reflection. BindingFlags% 2CSystem. Reflection. связыватель% 2CSystem. Object% 5b% 5D% 2CSystem. Globalization. CultureInfo% 2CSystem. Object% 5B% 5D% 29? displayProperty = nameWithType > метод, если имеется несколько поставщиков кода для языка и требуется создать экземпляр определенного поставщика кода.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы одну реализацию поставщика конкретный язык. Имя языка можно проверить с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед его передачей в. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> При передаче в исключение неподдерживаемого имени <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> языка.  
  
 Метод можно использовать для определения всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере, включая дополнительные реализации, предоставляемые разработчиками и поставщиками компиляторов, которые определены в System. CodeDom. <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> [ &lt;&gt;Элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в файле конфигурации компьютера (Machine. config).  
  
 Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>  
  
 В именах языков не учитывается регистр.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализация для языка ввода и отображаются настроенные параметры для поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Для языка, заданного в параметре <paramref name="language" />, на данном компьютере не настроен поставщик.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="language" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <param name="providerOptions">Коллекция параметров поставщика из файла конфигурации.</param>
        <summary>Получает экземпляр <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> для заданного языка и параметров поставщика.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка и параметров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод чаще всего используется для создания экземпляра поставщика кода в приложении, которое при необходимости может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>позволяет указать во время выполнения версию поставщика кода, для которого необходимо создать экземпляр. Если во время разработки известно, какой поставщик кода следует использовать, следует создать экземпляр этого поставщика кода вместо использования <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> метода.  
  
 Используется <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> , если требуется динамически найти настроенную реализацию поставщика для определенного языка и параметров. В именах языков не учитывается регистр. Сведения о поддерживаемых параметрах поставщика см. в документации по конкретному поставщику CodeDOM.  
  
 Сведения о проверке поставщика и вызове поставщика при настройке нескольких реализаций поставщика для имени языка см. в разделе <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> "Примечания" метода.  
  
   
  
## Examples  
 В следующем примере показано, как создать экземпляр поставщика с помощью `providerOptions` параметра.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается допустимый идентификатор.</param>
        <summary>Создает допустимый идентификатор для указанного значения.</summary>
        <returns>Допустимый идентификатор для указанного значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A>проверяет, конфликтует ли идентификатор с зарезервированными ключевыми словами или ключевые слова языка, и, если это так, пытается вернуть допустимое имя идентификатора, которое не конфликтует. Как правило, возвращаемый идентификатор слегка изменяется, чтобы отличать идентификатор от ключевого слова. Например, перед именем может стоять символ подчеркивания ("_").  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расширение имени файла по умолчанию для использования в файлах исходного кода в текущем языке.</summary>
        <value>Расширение имени файла, соответствующее расширению исходных файлов текущего языка. Базовая реализация всегда возвращает значение <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется генераторами кода и компиляторами кода для указания того, какие расширения файлов следует создавать или использовать.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. В примере отображается имя поставщика, хэш-код и расширение имени файла по умолчанию для нового экземпляра поставщика.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit">Объект <see cref="T:System.CodeDom.CodeCompileUnit" />, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанной единицы компиляции объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> метода для создания кода для приложения "Hello World" <xref:System.CodeDom.CodeCompileUnit>из. Этот пример является частью большого примера, <xref:System.CodeDom.Compiler.CodeDomProvider> приведенного для класса.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Объект <see cref="T:System.CodeDom.CodeExpression" />, указывающий выражение, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного выражения объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">Объект <see cref="T:System.CodeDom.CodeTypeMember" />, указывающий член, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного объявления члена объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация базового класса создает исключение <xref:System.NotImplementedException>. См <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> . документацию, описывающую реализацию этого метода.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> метода, реализованного <xref:Microsoft.CSharp.CSharpCodeProvider> классами и <xref:Microsoft.VisualBasic.VBCodeProvider> .  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Этот метод не переопределяется в производном классе.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Объект <see cref="T:System.CodeDom.CodeNamespace" />, указывающий пространство имен, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного пространства имен объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement">Объект <see cref="T:System.CodeDom.CodeStatement" />, содержащий элементы CodeDOM, для которых генерируется код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного оператора языка объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">Объект <see cref="T:System.CodeDom.CodeTypeDeclaration" />, указывающий тип, для которого создается код.</param>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />, указывающий параметры для использования при создании кода.</param>
        <summary>Создает код для указанного объявления типа объектной модели документов кода (CodeDOM) и направляет его указанному модулю записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает параметры поставщика и компилятора языка для данного компьютера.</summary>
        <returns>Массив типа <see cref="T:System.CodeDom.Compiler.CompilerInfo" />, представляющий параметры всех настроенных реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Используйте метод для перечисления параметров поставщика языка на компьютере.  
  
> [!NOTE]
>  В службах поставщики языка по умолчанию, предоставляемые .NET Framework, не указаны [ &lt;в разделе конфигурации компилятора&gt; элемента System. CodeDom](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) и не могут быть удалены, поэтому этот метод возвращает [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] сведения о поставщиках по умолчанию и все указанные в файле конфигурации.  
  
   
  
## Examples  
 В следующем примере кода перечисляются поставщики языка на компьютере и отображаются параметры конфигурации и компилятора для каждого поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Возвращает параметры поставщика и компилятора языка для заданного языка.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerInfo" />, заполненный параметрами настроенной реализации <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Элемент System. CodeDOM&gt; в файле конфигурации компьютера содержит параметры поставщика языка и конфигурации компилятора для каждой реализации на компьютере. &lt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) <xref:System.CodeDom.Compiler.CodeDomProvider> Сведения о файлах конфигурации компьютера см. в разделе "файлы конфигурации компьютера" статьи [Настройка приложений](~/docs/framework/configure-apps/index.md). <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод ищет каждый элемент конфигурации поставщика для указанного имени языка. Возвращаемый <xref:System.CodeDom.Compiler.CompilerInfo> экземпляр содержит настроенный поставщик языка и параметры компилятора.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы одну реализацию поставщика конкретный язык. Имя языка можно проверить с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед его передачей в. <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Это предотвращает вызов исключения <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> при <xref:System.CodeDom.Compiler.CompilerInfo> доступе к экземпляру для неподдерживаемого имени языка.  
  
 Если для имени языка ввода настроено несколько реализаций поставщика, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Возвращает параметры последнего соответствующего элемента конфигурации поставщика.  
  
 В именах языков не учитывается регистр.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализация для языка ввода и отображаются настроенные параметры для поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Для языка, заданного в параметре <paramref name="language" />, на данном компьютере не настроен поставщик.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Свойство <paramref name="language" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип объекта, для которого извлекается преобразователь типов.</param>
        <summary>Получает <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа данных.</summary>
        <returns><see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа или <see langword="null" />, если <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный класс может переопределить этот метод, чтобы предоставить определенные типы преобразователей типов для конкретных типов данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Возвращает имя языка, связанное с определенным расширением имени файла, как настроено в разделе конфигурации компилятора <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <returns>Имя языка, связанное с определенным расширением имени файла, как настроено в параметрах конфигурации компилятора <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Элемент System. CodeDOM&gt; в файле конфигурации компьютера (Machine. config) содержит параметры поставщика языка и конфигурации компилятора для каждой реализации на компьютере. &lt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) <xref:System.CodeDom.Compiler.CodeDomProvider> <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> Метод ищет каждый элемент конфигурации поставщика для указанного расширения имени файла.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод проверяет, поддерживает ли хотя бы одну реализацию поставщика определенное расширение имени файла. Расширение имени файла можно проверить с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> перед его передачей в. <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> Это предотвращает <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> создание исключения для неподдерживаемого расширения имени файла.  
  
 Если реализация поставщика поддерживает расширение имени входного файла, и для этого поставщика настроено несколько поддерживаемых языков, то <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя первого языка для этого поставщика. Если для расширения имени входного файла настроено несколько реализаций поставщика, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя языка из последнего соответствующего элемента конфигурации поставщика.  
  
 В именах языков и расширений имен файлов регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализация для расширения имени входного файла и отображаются настроенные параметры для поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Для языка, заданного в параметре <paramref name="extension" />, на данном компьютере не настроен поставщик языка.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.CodeDom.CodeTypeReference" /> указывает возвращаемый тип.</param>
        <summary>Получает тип, на который указывает заданный объект <see cref="T:System.CodeDom.CodeTypeReference" />.</summary>
        <returns>Текстовое представление указанного типа, отформатированное для языка, на котором создается код данным генератором кода. Например, в Visual Basic передача объекта <see cref="T:System.CodeDom.CodeTypeReference" /> для типа <see cref="T:System.Int32" /> вернет "Integer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Проверяет, имеется ли связанная ли с данным расширением имени файла реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, настроенная на данном компьютере.</summary>
        <returns><see langword="true" />, если реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> настроена для определенного имени файла; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Элемент System. CodeDOM&gt; в файле конфигурации компьютера (Machine. config) содержит параметры поставщика языка и конфигурации компилятора для каждой реализации на компьютере. &lt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) <xref:System.CodeDom.Compiler.CodeDomProvider> <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод выполняет поиск по элементам конфигурации поставщика для указанного расширения имени файла.  
  
 Расширения имен файлов не учитывают регистр.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализация для расширения имени входного файла и отображаются настроенные параметры для поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Проверяет, имеется ли связанная ли с данным языком реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, настроенная на данном компьютере.</summary>
        <returns><see langword="true" />, если реализация <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> настроена для заданного языка; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Элемент System. CodeDOM&gt; в файле конфигурации компьютера (Machine. config) содержит параметры поставщика языка и конфигурации компилятора для каждой реализации на компьютере. &lt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) <xref:System.CodeDom.Compiler.CodeDomProvider> <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод выполняет поиск элементов конфигурации поставщика для указанного имени языка.  
  
 В именах языков не учитывается регистр.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализация для языка ввода и отображаются настроенные параметры для поставщика языка. Этот пример кода является частью большого примера, <xref:System.CodeDom.Compiler.CompilerInfo> приведенного для класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Значение для проверки на допустимый идентификатор.</param>
        <summary>Возвращает значение, показывающее, является ли указанное значение допустимым идентификатором для текущего языка.</summary>
        <returns><see langword="true" />, если параметр <paramref name="value" /> является допустимым идентификатором; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет, является ли идентификатор допустимым. Метод <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> зависит от поставщика. Идентификаторы, допустимые для одного поставщика, могут быть недопустимыми для других поставщиков. Если `value` содержит символы за пределами диапазона символов ASCII, проверьте идентификатор для всех языков, которые могут использоваться для компиляции кода.  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> в производном классе разработайте метод, чтобы <see langword="true" /> он возвращал только в том случае, если значение соответствует правилам языка и не конфликтует с ключевым словом.  
  
При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор особенностей языка.</summary>
        <value><see cref="T:System.CodeDom.Compiler.LanguageOptions" /> указывает особенности языка.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">Объект <see cref="T:System.IO.TextReader" />, используемый для чтения анализируемого кода.</param>
        <summary>Компилирует код, прочитанный из заданного текстового потока, в объект <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Объект <see cref="T:System.CodeDom.CodeCompileUnit" />, содержащий представление анализируемого кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeParser> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeParser> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает средство синтаксического анализа в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> метод для совместимости с уже существующими поставщиками, которые используют средства синтаксического анализа кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeParser" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует средство синтаксического анализа кода, вы получите.</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="netframework-1.1;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Объект <see cref="T:System.CodeDom.Compiler.GeneratorSupport" />, указывающий тип поддержки создания кода, который следует проверить.</param>
        <param name="supports">To be added.</param>
        <summary>Возвращает значение, показывающее, обеспечивается ли указанная поддержка создания кода.</summary>
        <returns><see langword="true" />, если указанная поддержка создания кода осуществляется; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать одновременно с несколькими <xref:System.CodeDom.Compiler.GeneratorSupport> флагами, чтобы проверить набор возможностей, присоединив набор соответствующих флагов возможностей вместе с бинарным `OR` оператором (&#124;).  
  
> [!NOTE]
>  В .NET Framework версиях 1,0 и 1,1 Этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацией, возвращаемой <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> методом поставщика. В версии 2,0 этот метод можно вызывать непосредственно в поставщике кода, даже если он не переопределен поставщиком кода. Если поставщик кода не переопределяет этот метод, <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">В производном классе нельзя переопределить ни этот метод, ни метод <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении этого метода не следует вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, используя устаревший <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для совместимости с уже существующими поставщиками, которые используют генераторы кода. Затем метод базового класса вызывает эквивалентный метод в <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. <see cref="T:System.NotImplementedException" /> Если вызвать метод базового класса из поставщика кода, который не использует генератор кода, будет получен вызов.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>
