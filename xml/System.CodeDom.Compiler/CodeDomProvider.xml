<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="10d65c2c6acb521c573e2db518ec80d92ba50400" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65002886" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет базовый класс для <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализаций. Это абстрактный класс.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.CodeDom.Compiler.CodeDomProvider> можно использовать для создания и извлечения экземпляров генераторов кода и компиляторов. Генераторы кода можно использовать для создания кода на определенном языке, а компиляторы кода можно использовать для компиляции кода в сборки.  
  
> [!NOTE]
>  В [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], методы доступны в генератор кода и компилятора кода доступны непосредственно из поставщика кода. Необходимо вызвать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> или <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> для доступа к методам и эти методы помечены как устаревшие. Это относится к ранее существующим и новым реализациям поставщика кода.  
  
 Объект <xref:System.CodeDom.Compiler.CodeDomProvider> реализации обычно предоставляет код создания и/или код компиляции интерфейсы для генерации кода и управления компиляцией для отдельного языка программирования. Несколько языков поддерживается <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций, входящие в состав [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Эти языки C#, Visual Basic, C++ и JScript. Можно реализовать разработчиками или поставщиками компиляторов <xref:System.CodeDom.Compiler.ICodeGenerator> и <xref:System.CodeDom.Compiler.ICodeCompiler> интерфейсы и предоставить <xref:System.CodeDom.Compiler.CodeDomProvider> , расширяет поддержку CodeDOM на другие языки программирования.  
  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера (Machine.config) файл предоставляет механизм для разработчики и поставщики компиляторов добавить параметры конфигурации для дополнительных <xref:System.CodeDom.Compiler.CodeDomProvider>реализаций.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider> Класс предоставляет статические методы для обнаружения и перечисления <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Метод возвращает параметры для всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере. <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод возвращает параметры для конкретного <xref:System.CodeDom.Compiler.CodeDomProvider> реализации, основанной на имя языка программирования. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка.  
  
 Дополнительные сведения о параметрах поставщика языка в файле конфигурации, см. в разделе [компилятора и схема параметров поставщиков языков](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Этот класс выполняет запрос ссылки и требования наследования на уровне класса. Объект <xref:System.Security.SecurityException> создается, если непосредственный вызывающий оператор или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md) и [требования наследования](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 В следующем примере программа может создать и компиляции исходного кода, на основе модели CodeDOM из программы, которая выводит «Hello, World!» с помощью <xref:System.Console> класса. Предоставляется пользовательский интерфейс Windows Forms. Пользователь может выбрать целевой язык из нескольких диапазонов: C#, Visual Basic и JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не может наследоваться кодом с частичным доверием.</permission>
    <block subset="none" type="overrides"><para>В .NET Framework версий 1.0 и 1.1, поставщики кода состоят из реализаций <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, и <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, и <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> методы являются устаревшими и методы <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> и <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> доступны непосредственно в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> класса. Необходимо переопределить эти методы в реализации поставщика кода и не вызывать базовые методы.</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот класс не может использоваться частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> , указывающий параметры компиляции.</param>
        <param name="compilationUnits">Массив объектов типа <see cref="T:System.CodeDom.CodeCompileUnit" /> , указывающий код для компиляции.</param>
        <summary>Компилирует сборку на основе <see cref="N:System.CodeDom" /> деревьев, содержащихся в указанном массиве <see cref="T:System.CodeDom.CodeCompileUnit" /> объекты, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" /> объект, показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> , указывающий параметры компиляции.</param>
        <param name="fileNames">Массив имен файлов для компиляции.</param>
        <summary>Компилирует сборку из исходного кода, содержащегося в указанных файлах, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" /> , показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> , указывающий параметры компилятора для этой компиляции.</param>
        <param name="sources">Массив строк исходного кода для компиляции.</param>
        <summary>Компилирует сборку из указанного массива строк, содержащего исходный код, используя указанные параметры компилятора.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerResults" /> , показывающий результаты компиляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeCompiler> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeCompiler> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> метод в целях совместимости с помощью уже имеющихся поставщиков, использующих компиляторы кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует компилятор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый компилятор кода.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> , Можно использовать для компиляции <see cref="N:System.CodeDom" /> на основе представлений исходного кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Рекомендуемой альтернативой является вызов <xref:System.CodeDom.Compiler.ICodeCompiler> доступные методы непосредственно в код поставщика.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], следует реализовать <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> члены в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> и также вызывают исключения <see cref="T:System.NotSupportedException" /> при вызове этого метода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается Escape-идентификатор.</param>
        <summary>Создает escape-идентификатор для указанного значения.</summary>
        <returns>Escape-идентификатор для значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> тесты ли идентификатор конфликтует с любого зарезервированных слов языка и если да, возвращает соответствующее имя с языковое форматирование кода. Это называется Escape-идентификатор. Escape-идентификатор содержит такое же `value` , но escape-код форматирования добавлено отличать его от ключевого слова. Двух примерах реализации `value` с «@» или скобок `value` с «[» и «]».  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый генератор кода.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> , Можно использовать для создания <see cref="N:System.CodeDom" /> на основе представлений исходного кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. Рекомендуемой альтернативой является вызов <xref:System.CodeDom.Compiler.ICodeGenerator> доступные методы непосредственно в <xref:System.CodeDom.Compiler.CodeDomProvider> класса.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>В [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], следует реализовать <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> члены в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> и также вызывают исключения <see cref="T:System.NotSupportedException" /> при вызове этого метода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">Объект <see cref="T:System.IO.TextWriter" /> для использования в выходных данных.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя указанный <see cref="T:System.IO.TextWriter" /> для выходных данных.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> , Можно использовать для создания <see cref="N:System.CodeDom" /> на основе представлений исходного кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанный <xref:System.IO.TextWriter> для выходных данных. Этот метод поддерживает дополнительные создания оптимизированного кода, который выполняет добавочное обновление исходного кода.  
  
> [!NOTE]
>  Реализация вызывает базовый класс <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метод, который является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] и приводит к <xref:System.NotSupportedException> Если <xref:System.CodeDom.Compiler.ICodeGenerator> не возвращается.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла для выходных данных.</param>
        <summary>При переопределении в производном классе создает новый генератор кода, используя указанное имя файла для выходных данных.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> , Можно использовать для создания <see cref="N:System.CodeDom" /> на основе представлений исходного кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует указанное имя файла для выходных данных.  
  
> [!NOTE]
>  Реализация вызывает базовый класс <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метод, который является устаревшим в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] и приводит к <xref:System.NotSupportedException> Если <xref:System.CodeDom.Compiler.ICodeGenerator> не возвращается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создает новый анализатор кода.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeParser" /> , Можно использовать для анализа исходного кода. Базовая реализация всегда возвращает <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> экземпляра для указанного языка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Получает <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> экземпляра для указанного языка.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод обычно используется для создания экземпляра поставщика кода в приложении, которое может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> можно указать во время выполнения для создания экземпляра поставщика кода. Если известно во время разработки, какой код поставщика будет использоваться, вы должны создать экземпляр этого поставщика кода вместо использования <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Возвращает <xref:System.CodeDom.Compiler.CodeDomProvider> для конкретного языка имя экземпляра; это аналогично вызову <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метод с типом поставщика языка. Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> когда искомое динамически реализацию настроенного поставщика, имя языка.  
  
 Если более чем одной реализации поставщика настроен для имени языка, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> возвращает экземпляр поставщика для последнего соответствующего элемента конфигурации.  
  
 Используйте <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> перегрузку метода, при реализации поставщика конкретного языка. Например, использовать <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> метод, чтобы получить экземпляр поставщика, который поддерживает имя языка `"CSharp"`; используйте <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> перегруженный метод, чтобы получить экземпляр поставщика специально для <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> реализации. Следует использовать [\], CultureInfo, объект\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5b%5D%29?displayProperty=nameWithType > метода, если у вас есть несколько поставщиков кода для языка и необходимы для создания экземпляра поставщика кода.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализации конкретного языка. Вы можете проверить имя языка с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Если передано имя язык не поддерживается для <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> возникает исключение.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> Метод может использоваться для определения всех <xref:System.CodeDom.Compiler.CodeDomProvider> реализаций на компьютере, включая дополнительные реализованных разработчики и поставщики компиляторов, которые определены в [ &lt;system.codedom &gt; Элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в файле конфигурации компьютера (Machine.config).  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> Метод возвращает экземпляр <xref:System.CodeDom.Compiler.CodeDomProvider> реализации для конкретного языка.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="language" /> Не имеет настроенного поставщика на этом компьютере.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <param name="providerOptions">Коллекция параметров поставщика из файла конфигурации.</param>
        <summary>Получает <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> экземпляра для указанного языка и параметров поставщика.</summary>
        <returns>Поставщик CodeDOM, реализованный для заданного имени языка и параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод обычно используется для создания экземпляра поставщика кода в приложении, которое может использовать один из нескольких поставщиков. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> позволяет указать версию поставщика кода, который вы хотите создать экземпляр, во время выполнения. Если вы знаете во время разработки, какой код поставщика будет использоваться, следует создавать экземпляры этого поставщика кода, вместо использования <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> метод.  
  
 Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> когда необходимо динамически найти реализацию настроенного поставщика для конкретного языка и параметры. Имена языка не учитывается. Сведения о поддерживаемых параметрах поставщика см. соответствующую документацию поставщика CodeDOM.  
  
 Сведения о проверке поставщика и вызова поставщика, если более чем одной реализации поставщика настроен для имени языка, см. в разделе "Примечания" <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> метод.  
  
   
  
## Examples  
 В следующем примере показано, как для создания экземпляра поставщика с помощью `providerOptions` параметра.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Строка, для которой создается допустимый идентификатор.</param>
        <summary>Создает допустимый идентификатор для указанного значения.</summary>
        <returns>Допустимый идентификатор для указанного значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> проверяет, является ли идентификатор конфликтует с зарезервированными ключевыми словами языка, и если таким образом, попытается вернуть допустимый идентификатор имя, не конфликтуют. Обычно возвращаемый идентификатор лишь немного изменяется, чтобы отличать его от ключевого слова; например имя может предшествовать знак подчеркивания («_»).  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расширение имени файла по умолчанию для файлов исходного кода в текущем языке.</summary>
        <value>Расширение имени файла, соответствующее расширению исходных файлов текущего языка. Базовая реализация всегда возвращает <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется генераторами и компиляторы кода, чтобы указать, какие расширения файлов, которые следует создать или использовать.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. В примере отображается имя поставщика, хэш код и по умолчанию расширение имени файла для нового экземпляра поставщика.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit">Объект <see cref="T:System.CodeDom.CodeCompileUnit" /> для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> К которому направляется выходной код.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанной единицы компиляции объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> метод для создания кода для приложения «Hello, World!» из <xref:System.CodeDom.CodeCompileUnit>. Этот пример является частью большего примера для <xref:System.CodeDom.Compiler.CodeDomProvider> класса.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Объект <see cref="T:System.CodeDom.CodeExpression" /> объект, указывающий выражение, для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Какие выходные данные отправляется кода.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанного выражения объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">Объект <see cref="T:System.CodeDom.CodeTypeMember" /> объект, указывающий член, для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Какие выходные данные отправляется кода.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанного объявления члена объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает реализацию базового класса <xref:System.NotImplementedException>. См. в разделе <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> для документации, описывающей реализацию этого метода.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> метод, реализуемый <xref:Microsoft.CSharp.CSharpCodeProvider> и <xref:Microsoft.VisualBasic.VBCodeProvider> классы.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Этот метод не переопределен в производном классе.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Объект <see cref="T:System.CodeDom.CodeNamespace" /> объект, указывающий пространство имен, для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Какие выходные данные отправляется кода.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанного пространства имен объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement">Объект <see cref="T:System.CodeDom.CodeStatement" /> содержит элементы CodeDOM, для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Какие выходные данные отправляется кода.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанного оператора объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">Объект <see cref="T:System.CodeDom.CodeTypeDeclaration" /> , указывающий тип, для которого создается код.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Какие выходные данные отправляется кода.</param>
        <param name="options">Объект <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> указывает параметры, используемые для создания кода.</param>
        <summary>Создает код для указанного объявления типа объектной модели документов кода (CodeDOM) и отправляет его в указанный модуль записи текста, используя заданные параметры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает язык, параметры поставщика и компилятора для этого компьютера.</summary>
        <returns>Массив объектов типа <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> представляющий параметры всех настроенных <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализаций.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> метод перечислить параметры поставщика языка на компьютере.  
  
> [!NOTE]
>  В [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], поставщиков языка по умолчанию, предоставляемых платформой .NET Framework не указаны в [ &lt;system.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) конфигурации компилятора разделе и не могут быть удалены, поэтому эта метод возвращает сведения о поставщиков по умолчанию и все заданные в файле конфигурации.  
  
   
  
## Examples  
 В следующем примере кода перечисляет поставщиков языков на компьютере и отображает параметры конфигурации и компилятора для каждого поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Возвращает язык, параметры поставщика и компилятора для указанного языка.</summary>
        <returns>Объект <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> заполненный параметрами настроенной <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютере. Сведения о файлах конфигурации компьютера, см. в разделе файлов конфигурации компьютера в [Настройка приложений](~/docs/framework/configure-apps/index.md). <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Метод выполняет поиск каждого элемента конфигурации поставщика для заданного имени языка. Возвращенный <xref:System.CodeDom.Compiler.CompilerInfo> экземпляр содержит настроенных языковых параметров поставщика и компилятора.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализации конкретного языка. Вы можете проверить имя языка с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Это предотвращает создание <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> при доступе к <xref:System.CodeDom.Compiler.CompilerInfo> экземпляр имени неподдерживаемый язык.  
  
 Если более чем одной реализации поставщика настроена для языка ввода имени, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> Возвращает параметры из последнего соответствующий поставщик элемента конфигурации.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><paramref name="language" /> Не имеет настроенного поставщика на этом компьютере.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип объекта, для которого извлекается преобразователь типов.</param>
        <summary>Получает <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа данных.</summary>
        <returns>Объект <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа, или <see langword="null" /> Если <see cref="T:System.ComponentModel.TypeConverter" /> для указанного типа не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный класс может переопределить этот метод для предоставления определенных типов преобразователей типов для определенных типов данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Возвращает имя языка, связанное с указанным расширением, как настроено в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> разделе конфигурации компилятора.</summary>
        <returns>Имя языка, связанное с расширением имени файла, в соответствии с настройками в <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> параметры конфигурации компилятора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> Метод выполняет поиск каждого элемента конфигурации поставщика для указанного расширения имени файла.  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод проверяет, поддерживает ли хотя бы один поставщик реализацию определенного расширения имен файлов. Вы можете проверить расширение имени файла с помощью <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> перед их передачей <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Это предотвращает <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возникновения <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> для расширением имени файла не поддерживается.  
  
 Если реализация поставщика поддерживает расширение имени входного файла, а также несколько поддерживаемых языков, настроенных для этого поставщика, затем <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя первого языка для данного поставщика. Если более чем одной реализации поставщика для расширения имени входного файла, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> возвращает имя языка из последней соответствующий поставщик элемента конфигурации.  
  
 Имена языков и расширения имен файлов регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализации расширение имени входного файла и отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><paramref name="extension" /> Не настроен поставщик языка на этом компьютере.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Объект <see cref="T:System.CodeDom.CodeTypeReference" /> указывает возвращаемый тип.</param>
        <summary>Получает тип, указываемом заданным <see cref="T:System.CodeDom.CodeTypeReference" />.</summary>
        <returns>Текстовое представление указанного типа, отформатированное для языка, в котором создается код данным генератором кода. В Visual Basic, например, передавая <see cref="T:System.CodeDom.CodeTypeReference" /> для <see cref="T:System.Int32" /> типа вернет «Integer».</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Расширение имени файла.</param>
        <summary>Проверяет, является ли расширение имени файла имеет связанный <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализации, настроенного на компьютере.</summary>
        <returns><see langword="true" /> Если <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализации настроена для указанного расширения имени файла; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> Метод выполняет поиск элементов конфигурации поставщика для указанного расширения имени файла.  
  
 Расширения имен файлов регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализации расширение имени входного файла и отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="extension" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Имя языка.</param>
        <summary>Проверяет, является ли язык имеет <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализации, настроенного на компьютере.</summary>
        <returns><see langword="true" /> Если <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> реализации настроен для заданного языка; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ &lt;System.codedom&gt; элемент](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) в конфигурации компьютера файл (Machine.config) содержит параметры для каждого языка поставщика и компилятора конфигурации <xref:System.CodeDom.Compiler.CodeDomProvider> реализации на компьютер. <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> Метод выполняет поиск элементов конфигурации поставщика для заданного имени языка.  
  
 Имена языка не учитывается.  
  
   
  
## Examples  
 В следующем примере кода определяется <xref:System.CodeDom.Compiler.CodeDomProvider> реализацию для языка ввода, а также отображает настроенные параметры для поставщика языка. Данный пример кода является частью большего примера для <xref:System.CodeDom.Compiler.CompilerInfo> класса.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="language" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего объекта. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Схема параметров поставщиков языков и компиляторов</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Значение для проверки на допустимый идентификатор.</param>
        <summary>Возвращает значение, указывающее, является ли указанное значение допустимым идентификатором для текущего языка.</summary>
        <returns><see langword="true" /> Если <paramref name="value" /> параметр является допустимым идентификатором; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет, является ли допустимым идентификатор. <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> Метод зависит от поставщика. Идентификаторы, допустимые для одного поставщика, не могут быть допустимыми для других поставщиков. Если `value` содержит символы вне диапазона символов ASCII, проверьте этот идентификатор для всех языков, которые могут использоваться для компиляции кода.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> в производном классе, спроектировать метод вернет <see langword="true" /> только в том случае, если значение соответствует правилам языка и не конфликтует с ключевым словом.  
  
Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор возможностей языка.</summary>
        <value><see cref="T:System.CodeDom.Compiler.LanguageOptions" />, который указывает специальные возможности языка.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">Объект <see cref="T:System.IO.TextReader" /> объект, используемый для чтения анализируемого кода.</param>
        <summary>Компилирует код, прочитанный из указанный текстовый поток в <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Объект <see cref="T:System.CodeDom.CodeCompileUnit" /> , содержащий представление анализируемого кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeParser> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeParser> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает средство синтаксического анализа в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие средства синтаксического анализа кода. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeParser" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует средство синтаксического анализа кода.</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="netframework-1.1;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Объект <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> , указывающий тип поддержки создания кода для проверки.</param>
        <param name="supports">To be added.</param>
        <summary>Возвращает значение, указывающее, является ли указанная поддержка создания кода предоставлено.</summary>
        <returns><see langword="true" /> Если указанная поддержка создания кода предоставляется; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться с количеством <xref:System.CodeDom.Compiler.GeneratorSupport> флагами, чтобы проверить набор возможностей путем объединения набора соответствующих флагов возможностей с помощью двоичного `OR` оператор (&#124;).  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, этот метод предоставляется <xref:System.CodeDom.Compiler.ICodeGenerator> реализацию, которая возвращается <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> метода поставщика. В версии 2.0 этот метод может вызываться непосредственно на поставщика кода, даже если он не переопределен атрибутом поставщика кода. Если поставщик кода не переопределяет этот метод <xref:System.CodeDom.Compiler.ICodeGenerator> реализация вызывается базовым классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ни одна из этого метода ни <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> переопределяется в производном классе.</exception>
        <block subset="none" type="overrides"><para>Если переопределить этот метод нельзя вызывать соответствующий метод базового класса. Метод базового класса создает генератор в производном классе, с помощью устаревшего <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> метод для обеспечения совместимости с созданной ранее поставщики, использующие генераторы кодов. Затем метод базового класса вызывает эквивалентный метод <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> реализации для выполнения этой функции. Вы получите <see cref="T:System.NotImplementedException" /> при вызове метода базового класса из поставщика кода, который не использует генератор кода.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>