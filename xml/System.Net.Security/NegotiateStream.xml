<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7fc23e3b224b5eca5416e4f6be86a8dadb674534" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69113308" /></Metadata><TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет поток, использующий протокол безопасности Negotiate для проверки подлинности клиента, и, при необходимости, сервера при обмене данными в системе клиент-сервер.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Security.NegotiateStream> Используйте класс для проверки подлинности и защиты данных, передаваемых между клиентом и сервером. С <xref:System.Net.Security.NegotiateStream>помощью можно выполнять следующие действия.  
  
-   Отправка учетных данных клиента на сервер для олицетворения или делегирования.  
  
-   Запрос проверки подлинности сервера.  
  
-   Зашифруйте и/или Подпишите данные перед передачей.  
  
 Перед передачей информации необходимо выполнить проверку подлинности. Клиенты запрашивают проверку подлинности с помощью синхронных <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> методов, которые блокируются до завершения проверки подлинности, или асинхронных <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> методов, которые не блокируются при ожидании завершения проверки подлинности. Серверы запрашивают проверку подлинности с <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> помощью синхронных <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> или асинхронных методов. Клиент и, при необходимости, сервер проходят проверку подлинности с помощью протокола безопасности Negotiate. В системах Windows 95/98 используется протокол Windows NT LAN Manager (NTLM), используемый для проверки подлинности. На других платформах протокол Kerberos используется для проверки подлинности, если он поддерживается и клиентом, и сервером. в противном случае используется NTLM. Подробное описание этих протоколов см. в документации по пакету SDK для платформы на сайте MSDN по адресу msdn.microsoft.com/library/. <xref:System.Net.Security.NegotiateStream> Класс выполняет проверку подлинности с помощью интерфейса поставщика поддержки безопасности (SSPI).  
  
 После выполнения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, <xref:System.Net.Security.NegotiateStream> какие службы безопасности будут использоваться для защиты данных во время передачи. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности. Сведения об удаленном клиенте или сервере можно получить с помощью <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> свойства.  
  
 В случае сбоя проверки подлинности вы получите <xref:System.Security.Authentication.AuthenticationException> <xref:System.Security.Authentication.InvalidCredentialException>или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 Данные отправляются с помощью <xref:System.Net.Security.NegotiateStream.Write%2A> синхронных <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> или асинхронных методов. Вы получаете данные с помощью синхронных <xref:System.Net.Security.NegotiateStream.Read%2A> или асинхронных <xref:System.Net.Security.NegotiateStream.BeginRead%2A> методов. Если службы безопасности, такие как шифрование или подписание, включены, они автоматически применяются к данным <xref:System.Net.Security.NegotiateStream>.  
  
 Объект <xref:System.Net.Security.NegotiateStream> передает данные с помощью потока, который вы предпредоставиле при <xref:System.Net.Security.NegotiateStream>создании. При указании этого базового потока можно указать, закрывается ли <xref:System.Net.Security.NegotiateStream> также базовый поток.  
  
   
  
## Examples  
В следующем примере показана клиентская сторона соединения « <xref:System.Net.Security.NegotiateStream>клиент-сервер», использующая. Клиент выполняет проверку подлинности и отправляет сообщение на сервер в асинхронном режиме.  
  
[!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
[!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
[!code-vb[NclNegoAsyncClient#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#0)] 

В следующем примере кода показана серверная часть соединения « <xref:System.Net.Security.NegotiateStream> клиент-сервер», использующая для проверки подлинности клиента и чтения сообщения, отправленного клиентом.  
  
[!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
[!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Изменения проверки подлинности NTLM для HTTPWebRequest в версии 3,5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Security.NegotiateStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить <xref:System.Net.Security.NegotiateStream> закрытие предоставленного потока, <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> используйте конструктор.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Объект <see cref="T:System.IO.Stream" />, используемый потоком <see cref="T:System.Net.Security.NegotiateStream" /> для отправки и получения данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Security.NegotiateStream" /> с использованием указанного объекта <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода демонстрируется вызов этого конструктора.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Объект <see cref="T:System.IO.Stream" />, используемый потоком <see cref="T:System.Net.Security.NegotiateStream" /> для отправки и получения данных.</param>
        <param name="leaveInnerStreamOpen">Значение <see langword="true" /> указывает, что закрытие этого потока <see cref="T:System.Net.Security.NegotiateStream" /> не влияет на поток, заданный параметром <paramref name="innerStream" />; значение <see langword="false" /> указывает, что закрытие потока <see cref="T:System.Net.Security.NegotiateStream" /> приводит также к закрытию потока <paramref name="innerStream" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Security.NegotiateStream" />, используя заданный поток <see cref="T:System.IO.Stream" /> и параметр, указывающий поведение потока при закрытии.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании `true` `leaveStreamOpen` для параметра закрытие <xref:System.Net.Security.NegotiateStream> не оказывает влияния на `innerStream` поток; необходимо явно закрывать `innerStream` , если он больше не нужен.  
  
   
  
## Examples  
В следующем примере демонстрируется вызов этого конструктора. Этот пример кода является частью большого примера, <xref:System.Net.Security.NegotiateStream> приведенного для класса.  
  
[!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
[!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
[!code-vb[NclNegoAsyncClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#1)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="innerStream" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="innerStream" /> равно <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>клиент. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные клиента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные клиента и привязку канала.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 Значение <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> , используемое для расширенной защиты, передаваемое этому методу `binding` в параметре, будет извлечено <xref:System.Net.Security.SslStream.TransportContext%2A> приложением из свойства связанного <xref:System.Net.Security.SslStream>объекта.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="targetName" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> не является допустимым значением.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetName" /> имеет значение null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается клиентами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные, параметры проверки подлинности и привязку канала.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Значение <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> , используемое для расширенной защиты, передаваемое этому методу `binding` в параметре, будет извлечено <xref:System.Net.Security.SslStream.TransportContext%2A> приложением из свойства связанного <xref:System.Net.Security.SslStream>объекта.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> — <see langword="null" />.  
  
-или- 
 Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> не является допустимым значением.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>клиент. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные клиента.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные клиента и привязку канала.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, и запрашивается взаимная проверка подлинности. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 Значение <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> , используемое для расширенной защиты, передаваемое этому методу `binding` в параметре, будет извлечено <xref:System.Net.Security.SslStream.TransportContext%2A> приложением из свойства связанного <xref:System.Net.Security.SslStream>объекта.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> — <see langword="null" />.  
  
- или - 
 Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> не является допустимым значением.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetName" /> имеет значение null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается клиентами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные, параметры проверки подлинности и привязку канала.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Значение <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> , используемое для расширенной защиты, передаваемое этому методу `binding` в параметре, будет извлечено <xref:System.Net.Security.SslStream.TransportContext%2A> приложением из свойства связанного <xref:System.Net.Security.SslStream>объекта.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="targetName" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> не является допустимым значением.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет проверку подлинности со стороны сервера в соединении клиент-сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти методы блокируются, пока выполняется проверка подлинности. Чтобы предотвратить блокировку приложения во время ожидания завершения проверки подлинности, используйте <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается серверами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, а уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Этот метод блокируется до завершения операции. Чтобы предотвратить блокировку до завершения операции, используйте одну из <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <summary>Вызывается серверами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданную политику расширенной защиты.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, а уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Этот метод блокируется до завершения операции. Чтобы предотвратить блокировку до завершения операции, используйте одну из <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации сервера.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается серверами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Этот метод блокируется до завершения операции. Чтобы предотвратить блокировку до завершения операции, используйте одну из <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается серверами для проверки подлинности клиента и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера, параметры проверки подлинности и политику расширенной защиты.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Этот метод блокируется до завершения операции. Чтобы предотвратить блокировку до завершения операции, используйте одну из <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обрабатывает серверную сторону аутентификации для соединения клиент-сервер как асинхронная операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается серверами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, а уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <summary>Вызывается серверами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданную политику расширенной защиты.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, а уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации сервера.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается серверами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <summary>Вызывается серверами аутентификации клиента, и, при необходимости, сервера в соединении клиент-сервер как асинхронная операция. Процесс проверки подлинности использует заданные учетные данные сервера, параметры проверки подлинности и политику расширенной защиты.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию для проверки подлинности клиентской стороны соединения клиент-сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки этого метода не блокируются, пока выполняется проверка подлинности. Чтобы заблокировать ожидание завершения проверки подлинности, используйте один из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> методов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения о данной операции. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается клиентами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>клиент. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, а уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. <xref:System.Net.Security.NegotiateStream> Класс будет создавать имя участника-службы, используемого для взаимной проверки подлинности.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
   
  
## Examples  
В следующем примере демонстрируется вызов этого метода для запуска асинхронной проверки подлинности для клиента.  
  
[!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
[!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
[!code-vb[NclNegoAsyncClient#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#2)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается клиентами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> — <see langword="null" />.  
  
- или - 
 Свойство <paramref name="targetName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается клиентами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные и привязку канала. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="targetName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается клиентами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> — <see langword="null" />.  
  
- или - 
 Свойство <paramref name="targetName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="binding">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />, который используется для расширенной защиты.</param>
        <param name="targetName">Имя участника-службы (SPN), уникально определяющее сервер, подлинность которого проверяется.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="allowedImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается клиентами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные, параметры проверки подлинности и привязку канала. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует <xref:System.Net.Security.ProtectionLevel> , что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="targetName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны сервера. Этот поток нельзя использовать для повторной проверки подлинности со стороны клиента.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию для проверки подлинности серверной стороны соединения клиент-сервер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки этого метода не блокируются, пока выполняется проверка подлинности. Чтобы заблокировать ожидание завершения проверки подлинности, используйте <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения о данной операции. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается серверами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается серверами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданную политику расширенной защиты. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При проверке подлинности используется <xref:System.Net.CredentialCache.DefaultCredentials%2A>сервер. Для сервера не указано имя участника-службы (SPN). Уровень олицетворения — <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, уровень безопасности — <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> перегрузок метода.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения о данной операции. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается серверами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера и параметры проверки подлинности. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует, <xref:System.Net.Security.ProtectionLevel> что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
-или-
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для использования явного <see cref="T:System.Net.NetworkCredential" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Учетные данные <see cref="T:System.Net.NetworkCredential" />, используемые для установления идентификации клиента.</param>
        <param name="policy">Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты.</param>
        <param name="requiredProtectionLevel">Одно из значений перечисления <see cref="T:System.Net.Security.ProtectionLevel" />, указывающее службы безопасности для потока.</param>
        <param name="requiredImpersonationLevel">Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, указывающее, как сервер может использовать учетные записи клиента для доступа к ресурсам.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, который ссылается на метод, вызываемый после выполнения проверки подлинности.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Вызывается серверами для начала асинхронной операции проверки подлинности клиента, и, при необходимости, сервера в соединении клиент-сервер. Процесс проверки подлинности использует заданные учетные данные сервера, параметры проверки подлинности и политику расширенной защиты. Этот метод не блокируется.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте параметр `requiredProtectionLevel` , чтобы запросить службы безопасности для данных, передаваемых с помощью потока, прошедшего проверку подлинности. Например, чтобы данные были зашифрованы и подписаны, укажите <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> значение. Успешная проверка подлинности не гарантирует, <xref:System.Net.Security.ProtectionLevel> что запрошенный запрос был предоставлен. Необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются.  
  
 Если параметр имеет `null`значение, используется расширенная <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> политика защиты, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которой задано значение. `policy`  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> перегрузок метода.  
  
 Асинхронную операцию проверки подлинности необходимо выполнить путем <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Оба свойства <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> и <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> в расширенной политике защиты, переданной параметром <paramref name="policy" />, имеют значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="credential" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="requiredImpersonationLevel" /> должен иметь значение <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> или <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности уже выполнена.  
  
- или -
  
 Этот поток уже использовался ранее при попытке проверки подлинности со стороны клиента. Этот поток нельзя использовать для повторной проверки подлинности со стороны сервера.</exception>
        <exception cref="T:System.NotSupportedException">Системы Windows 95 и Windows 98 не поддерживаются.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Параметру <paramref name="policy" /> было присвоено значение параметра <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, которая не поддерживает расширенную защиту.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив элементов <see cref="T:System.Byte" />, куда помещаются байты, считанные из потока.</param>
        <param name="offset">Расположение (начиная с 0) в массиве, заданном параметром <paramref name="buffer" />, с которого начинается сохранение данных, считанных из этого потока.</param>
        <param name="count">Максимальное число байтов, которое должно быть считано из потока.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать после завершения операции чтения.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения о данной операции. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Начинает асинхронную операцию чтения, которая считывает данные из потока и сохраняет их в заданном массиве.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если шифрование, подписывание или шифрование и подписывание разрешены, операция чтения считывает данные из базового потока, проверяет целостность данных и расшифровывает их. Если службы безопасности, такие как шифрование данных или подписывание, не используются, этот метод запускает асинхронную операцию чтения в базовом потоке.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте <xref:System.Net.Security.NegotiateStream.Read%2A> метод.  
  
 Асинхронная операция чтения должна быть завершена путем вызова <xref:System.Net.Security.NegotiateStream.EndRead%2A> метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.NegotiateStream> Класс не поддерживает несколько одновременных операций чтения. При попытке запустить операцию чтения, пока другая операция чтения уже выполняется в том же потоке, <xref:System.NotSupportedException> будет создано исключение.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
   
  
## Examples  
 В следующем примере кода показано, как запустить асинхронную операцию чтения. Этот пример кода является частью большого примера, <xref:System.Net.Security.NegotiateStream> приведенного для класса.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Сумма значений <paramref name="offset" /> и <paramref name="count" /> превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Сбой операции чтения.  
  
-или-
  
 Используется шифрование, но не удается расшифровать данные.</exception>
        <exception cref="T:System.NotSupportedException">Уже существует выполняющаяся операция чтения.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности не выполнялась.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив элементов <see cref="T:System.Byte" />, предоставляющий байты для записи в поток.</param>
        <param name="offset">Расположение (начиная с нуля) в массиве<paramref name="buffer" />, с которого требуется начать считывать байты, предназначенные для записи в поток.</param>
        <param name="count">Значение <see cref="T:System.Int32" />, определяющее количество байт, которые требуется считать из массива <paramref name="buffer" />.</param>
        <param name="asyncCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать после завершения операции записи.</param>
        <param name="asyncState">Пользовательский объект, содержащий сведения об операции записи. Этот объект передается делегату <paramref name="asyncCallback" /> после завершения операции.</param>
        <summary>Начинает асинхронную операцию записи, которая записывает байты (<see cref="T:System.Byte" />) из указанного буфера в поток.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, указывающий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если шифрование, подписывание или шифрование и подпись включены, этот метод считывает данные из буфера, шифрует, подписывает или шифрует и подписывает их, а затем передает их с помощью базового потока. Если службы безопасности, такие как шифрование данных или подписывание, не используются, этот метод запускает асинхронную операцию записи в базовом потоке.  
  
 Этот метод является асинхронным и не блокируется до завершения операции. Для блокировки до завершения операции используйте <xref:System.Net.Security.NegotiateStream.Read%2A> метод.  
  
 Асинхронная операция чтения должна быть завершена путем вызова <xref:System.Net.Security.NegotiateStream.EndWrite%2A> метода. Как правило, метод вызывается `asyncCallback` делегатом. Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 <xref:System.Net.Security.NegotiateStream> Класс не поддерживает несколько одновременных операций записи. При попытке запустить операцию записи, когда другая операция записи уже выполняется в том же потоке, <xref:System.NotSupportedException> будет создано исключение.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
   
  
## Examples  
В следующем примере показано, как начать асинхронную операцию записи.  
  
[!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
[!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
[!code-vb[NclNegoAsyncClient#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#3)] 

При завершении операции вызывается следующий метод.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Сумма значений <paramref name="offset" /> и count превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить операцию записи.  
  
- или -
  
 Используется шифрование, но не удается зашифровать данные.</exception>
        <exception cref="T:System.NotSupportedException">Уже существует выполняющаяся операция записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности не выполнялась.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, разрешено ли чтение из базового потока.</summary>
        <value>Значение <see langword="true" />, если проверка подлинности выполнена, а чтение из базового потока разрешено; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В случае успешной проверки подлинности это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.CanRead%2A> свойства в базовом потоке. Базовый поток указывается при создании экземпляра <xref:System.Net.Security.NegotiateStream> класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, разрешен ли поиск в базовом потоке.</summary>
        <value>Данное свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует пытаться задать расположение <xref:System.Net.Security.NegotiateStream> объекта или его базового потока. Базовый поток указывается при создании экземпляра <xref:System.Net.Security.NegotiateStream> класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, поддерживает ли базовый поток использование времени ожидания.</summary>
        <value>Значение <see langword="true" />, если базовый поток поддерживает время ожидания; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.CanTimeout%2A> свойства в базовом потоке. Базовый поток указывается при создании экземпляра <xref:System.Net.Security.NegotiateStream> класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, разрешена ли запись в базовый поток.</summary>
        <value>Значение <see langword="true" />, если проверка подлинности выполнена, а запись в базовый поток разрешена; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В случае успешной проверки подлинности это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.CanWrite%2A> свойства в базовом потоке. Базовый поток указывается при создании экземпляра <xref:System.Net.Security.NegotiateStream> класса.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Net.Security.NegotiateStream" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` методом <xref:System.Object.Finalize%2A> и методом. `Dispose()`вызывает защищенный `Dispose(Boolean)` метод с параметром `disposing` , для `true`которого задано значение. <xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. `Dispose`  
  
 Если параметр имеет значение true, этот метод освобождает все ресурсы, удерживаемые всеми управляемыми объектами <xref:System.Net.Security.NegotiateStream> , на которые ссылается эта ссылка. `disposing` Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении <see langword="Dispose(Boolean)" /> следует избегать ссылок на объекты, которые были удалены ранее при предыдущем <see langword="Dispose" />вызове метода. Дополнительные сведения о реализации <see langword="Dispose(Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
<see langword="Dispose" /> Дополнительные сведения о <see cref="M:System.Object.Finalize" />и см. в разделе Очистка неуправляемых [ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и переопределение [метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="negotiateStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно освобождает неуправляемые и управляемые ресурсы, используемые классом <see cref="T:System.Net.Security.NegotiateStream" />.</summary>
        <returns>Задача, представляющая асинхронную операцию закрытия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет выполнять ресурсоемкие операции удаления без блокировки основного потока. 

 Этот метод также удаляет внутренний поток, если <xref:System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen> имеет значение `false`; в противном случае внутренний поток просто очищается.
 
 Вызов `DisposeAsync` позволяет перераспределить ресурсы, используемые <xref:System.Net.Security.NegotiateStream> в, для других целей. Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Экземпляр <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</param>
        <summary>Завершает находящуюся в состоянии ожидания асинхронную операцию проверки подлинности клиента, которая была до этого запущена вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится. После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 Чтобы выполнить эту операцию синхронно, используйте один из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> методов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Нет ожидающей завершения операции проверки подлинности клиента.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Экземпляр <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
        <summary>Завершает находящуюся в состоянии ожидания асинхронную операцию проверки подлинности клиента, которая была до этого запущена вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 После завершения проверки подлинности необходимо проверить <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> свойства и <xref:System.Net.Security.NegotiateStream.IsSigned%2A> , чтобы определить, какие <xref:System.Net.Security.NegotiateStream>службы безопасности используются. <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> Проверьте свойство, чтобы определить, была ли выполнена взаимная проверка подлинности.  
  
 Если проверка подлинности завершается неудачно <xref:System.Security.Authentication.InvalidCredentialException>, вы получаете <xref:System.Security.Authentication.AuthenticationException> или. В этом случае можно повторить попытку проверки подлинности с другими учетными данными.  
  
 Чтобы выполнить эту операцию синхронно, используйте <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Сбой проверки подлинности. Этот объект можно использовать для повторной проверки подлинности.</exception>
        <exception cref="T:System.InvalidOperationException">Нет ожидающей завершения операции проверки подлинности.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Экземпляр <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Заканчивает асинхронную операцию чтения, запущенную до этого вызовом метода <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Значение <see cref="T:System.Int32" />, указывающее количество байтов, считанное из базового потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Чтобы выполнить эту операцию синхронно, используйте <xref:System.Net.Security.NegotiateStream.Read%2A> метод.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
   
  
## Examples  
 В следующем примере кода показано завершение асинхронной операции чтения. Пример, демонстрирующий запуск операции, см. в <xref:System.Net.Security.NegotiateStream.BeginRead%2A>разделе.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение asyncResult не было создано при вызове метода <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Нет ожидающей завершения операции чтения.

- или -

Проверка подлинности не выполнялась.</exception>
        <exception cref="T:System.IO.IOException">Сбой операции чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Экземпляр <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Заканчивает асинхронную операцию чтения, запущенную до этого вызовом метода <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
 Чтобы выполнить эту операцию синхронно, используйте <xref:System.Net.Security.NegotiateStream.Write%2A> метод.  
  
   
  
## Examples  
В следующем примере показан метод, который вызывается для завершения асинхронной операции записи. Пример, демонстрирующий запуск операции, см. в <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>разделе.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение asyncResult не было создано при вызове метода <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Нет ожидающей завершения операции записи.

- или -

Проверка подлинности не выполнялась.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить операцию записи.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно записывает все буферизированные данные в базовое устройство.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает <xref:System.IO.Stream.Flush%2A> в базовом потоке.  
  
   
  
## Examples  
 В следующем примере кода показано, как сбросить поток.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, как сервер может использовать учетные данные клиента.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо успешно пройти проверку подлинности перед вызовом этого метода. Клиенты указывают уровень олицетворения при запросе проверки подлинности путем вызова одного из <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> методов или. <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> Если выполняется проверка подлинности <xref:System.Security.Principal.TokenImpersonationLevel> без <xref:System.Security.Principal.TokenImpersonationLevel.Identification> указания, используется.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности завершилась неудачно или не выполнялась.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, была ли проверка подлинности успешной.</summary>
        <value>Значение <see langword="true" />, если произошла успешная проверка подлинности; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиенты проходят проверку подлинности <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> путем вызова <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> методов или. Серверы проходят проверку подлинности <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> путем вызова <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> методов или.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, использует ли данный поток <see cref="T:System.Net.Security.NegotiateStream" /> шифрование данных.</summary>
        <value>Значение <see langword="true" />, если данные шифруются до передачи по сети и дешифруются при достижении удаленной конечной точки; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шифрование помогает защитить конфиденциальность данных. а именно, это помогает гарантировать, что при передаче данные не могут быть расшифрованы третьими сторонами.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, что и сервер, и клиент прошли проверку подлинности.</summary>
        <value>Значение <see langword="true" />, если подлинность сервера была проверена, иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Взаимная проверка подлинности задается клиентом, когда клиенту требуется, чтобы сервер предоставил учетные данные для проверки подлинности. По умолчанию клиенты запрашивают взаимную проверку подлинности.  
  
 Протокол Negotiate выбирает NTLM или Kerberos в зависимости от протоколов безопасности, поддерживаемых клиентом и сервером. NTLM не поддерживает взаимную проверку подлинности.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, прошла ли локальная сторона соединения, используемого данным потоком <see cref="T:System.Net.Security.NegotiateStream" />, проверку подлинности как сервер.</summary>
        <value>Значение <see langword="true" />, если локальная конечная точка успешно прошла проверку подлинности как серверная сторона соединения с проверкой подлинности; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если проверка подлинности не удалась или не произошла `false`, это свойство возвращает значение.  
  
 Для проверки подлинности в качестве сервера <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> вызовите методы или <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> .  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение типа <see cref="T:System.Boolean" />, указывающее, подписаны ли данные, отправленные с помощью данного потока.</summary>
        <value>Значение <see langword="true" />, если данные были подписаны перед передачей; иначе — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подписывание данных помогает защитить целостность данных. а именно, он помогает получателю определить, были ли данные изменены во время передачи.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длину данных в базовом потоке.</summary>
        <value>Значение <see cref="T:System.Int64" />, указывающее длину базового потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.Length%2A> свойства в базовом потоке. Если базовый поток недоступен для поиска, это свойство, как правило, вызывает исключение. Тип времени выполнения базового потока определяет тип времени выполнения создаваемого исключения.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Возвращение значения данного свойства не поддерживается, если базовый поток является экземпляром класса <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущую позицию в базовом потоке.</summary>
        <value>Значение <see cref="T:System.Int64" />, указывающее текущую позицию в базовом потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.Position%2A> свойства в базовом потоке. Если базовый поток недоступен для поиска, это свойство, как правило, вызывает исключение. Тип времени выполнения базового потока определяет тип времени выполнения создаваемого исключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Задание данного свойства не поддерживается.  
  
- или - 
Возвращение значения данного свойства не поддерживается, если базовый поток является экземпляром класса <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив элементов <see cref="T:System.Byte" />, куда помещаются байты, считанные из потока.</param>
        <param name="offset">Значение <see cref="T:System.Int32" />, содержащее расположение (начиная с нуля) в массиве <paramref name="buffer" />, с которого следует начинать сохранение данных, считанных их этого потока.</param>
        <param name="count">Значение <see cref="T:System.Int32" />, содержащее максимальное количество байтов, которое требуется считать из потока.</param>
        <summary>Считывает данные из этого потока и сохраняет их в заданном массиве.</summary>
        <returns>Значение <see cref="T:System.Int32" />, указывающее количество байтов, считанное из базового потока. Когда данных для чтения не остается, возвращает 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает максимум `count` байт из текущего потока и сохраняет их в `buffer` начале `offset`.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
 Чтобы выполнить эту операцию асинхронно, используйте <xref:System.Net.Security.NegotiateStream.BeginRead%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано чтение из <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Сбой операции чтения.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности не выполнялась.</exception>
        <exception cref="T:System.NotSupportedException">Операция <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> уже выполняется в настоящее время.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает временной интервал, в течение которого операция чтения будет блокироваться, ожидая получения данных.</summary>
        <value>Значение типа <see cref="T:System.Int32" />, указывающее период времени (в миллисекундах), по истечении которого происходит сбой операции чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.ReadTimeout%2A> свойства в базовом потоке. При задании этого свойства <xref:System.IO.Stream.ReadTimeout%2A> значение в базовом потоке устанавливается в указанное значение.  
  
 Если базовый поток имеет значение <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> то параметр находится в миллисекундах и по умолчанию имеет значение <xref:System.Threading.Timeout.Infinite> , чтобы не истекает время ожидания операций чтения.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о идентификации удаленной стороны, использующей данный поток с проверкой подлинности.</summary>
        <value>Объект <see cref="T:System.Security.Principal.IIdentity" />, описывающий идентификацию удаленной конечной точки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При доступе к клиенту это свойство возвращает значение, <xref:System.Security.Principal.GenericIdentity> содержащее имя участника-службы (SPN) сервера и используемый протокол проверки подлинности. При доступе к серверу это свойство возвращает объект <xref:System.Security.Principal.WindowsIdentity> , описывающий клиент. Если объект <xref:System.Security.Principal.WindowsIdentity> недоступен, сведения о клиенте возвращаются на сервер <xref:System.Security.Principal.GenericIdentity>в.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности завершилась неудачно или не выполнялась.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Это значение игнорируется.</param>
        <param name="origin">Это значение игнорируется.</param>
        <summary>Выдает исключение <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Всегда создает исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не следует вызывать. Он наследуется, но не поддерживается <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Поиск в потоке <see cref="T:System.Net.Security.NegotiateStream" /> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение <see cref="T:System.Int64" />, указывающее длину потока.</param>
        <summary>Задает длину данных в базовом потоке.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив элементов <see cref="T:System.Byte" />, предоставляющий байты для записи в поток.</param>
        <param name="offset">Значение <see cref="T:System.Int32" />, содержащее расположение (начиная с нуля) в массиве <paramref name="buffer" />, с которого требуется начать чтение байтов, записываемых в поток.</param>
        <param name="count">Значение <see cref="T:System.Int32" />, содержащее количество байтов, считываемых из массива <paramref name="buffer" />.</param>
        <summary>Записывает указанное количество элементов <see cref="T:System.Byte" /> в базовый поток, используя заданный буфер (параметр buffer) и начальное расположение (параметр offset).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если шифрование, подписывание или шифрование и подпись включены, этот метод считывает данные из буфера, шифрует, подписывает или шифрует и подписывает их, а затем передает их с помощью базового потока. Если службы безопасности, такие как шифрование данных или подписывание, не используются, этот метод вызывает <xref:System.IO.Stream.Write%2A> в базовом потоке.  
  
 Этот метод блокируется, пока операция записи завершается. Чтобы предотвратить блокировку во время выполнения операции, используйте <xref:System.Net.Security.NegotiateStream.Write%2A> метод.  
  
 Этот метод нельзя вызвать до тех пор, пока не будет выполнена проверка подлинности. Для проверки подлинности вызовите <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>один <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>из <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>методов, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> , или.  
  
 <xref:System.Net.Security.NegotiateStream> Класс не поддерживает несколько одновременных операций записи. При попытке запустить операцию записи, когда другая операция записи уже выполняется в том же потоке, <xref:System.NotSupportedException> будет создано исключение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется запись в <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Сумма значений <paramref name="offset" /> и count превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Не удалось выполнить операцию записи.  
  
-или-
  
 Используется шифрование, но не удается зашифровать данные.</exception>
        <exception cref="T:System.NotSupportedException">Уже существует выполняющаяся операция записи.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Проверка подлинности не выполнялась.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает период времени, в течение которого операция записи блокирует выполнение, ожидая данных.</summary>
        <value>Значение типа <see cref="T:System.Int32" />, указывающее период времени (в миллисекундах), по истечении которого происходит сбой операции записи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение, возвращаемое путем вызова <xref:System.IO.Stream.WriteTimeout%2A> свойства в базовом потоке. Для операций set указанное значение задает <xref:System.IO.Stream.WriteTimeout%2A> значение в базовом потоке.  
  
 Если базовый поток имеет значение <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> то параметр находится в миллисекундах и по умолчанию имеет значение <xref:System.Threading.Timeout.Infinite> , поэтому операции записи не имеют времени ожидания.  
  
   
  
## Examples  
 В следующем примере кода показано, как отобразить значение этого свойства.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
