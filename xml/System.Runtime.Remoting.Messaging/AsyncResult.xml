<Type Name="AsyncResult" FullName="System.Runtime.Remoting.Messaging.AsyncResult">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86d9f9efffb7c0dc19f27c755a3d44de159c380e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69267057" /></Metadata><TypeSignature Language="C#" Value="public class AsyncResult : IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit AsyncResult extends System.Object implements class System.IAsyncResult, class System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.AsyncResult" />
  <TypeSignature Language="VB.NET" Value="Public Class AsyncResult&#xA;Implements IAsyncResult, IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsyncResult : IAsyncResult, System::Runtime::Remoting::Messaging::IMessageSink" />
  <TypeSignature Language="F#" Value="type AsyncResult = class&#xA;    interface IAsyncResult&#xA;    interface IMessageSink" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Messaging.IMessageSink</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Инкапсулирует результаты асинхронной операции на делегате.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult> Класс используется в сочетании с асинхронными вызовами методов, выполненными с помощью делегатов. Объект <xref:System.IAsyncResult> , возвращаемый `BeginInvoke` методом делегата, <xref:System.Runtime.Remoting.Messaging.AsyncResult>может быть приведен к типу. <xref:System.Runtime.Remoting.Messaging.AsyncResult> Содержитсвойство,содержащееобъектделегата,длякоторогобыл<xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> вызван асинхронный вызов.  
  
 Дополнительные сведения о `BeginInvoke` и асинхронных вызовах с помощью делегатов см. в разделе [Асинхронное программирование с использованием делегатов](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> свойства для <xref:System.Threading.WaitHandle>получения и ожидания асинхронного вызова в делегате. Объект <xref:System.Threading.WaitHandle> получает сигнал после завершения асинхронного вызова; его можно дождаться путем вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и дополнительные примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md">Асинхронное программирование с использованием делегатов</related>
  </Docs>
  <Members>
    <Member MemberName="AsyncDelegate">
      <MemberSignature Language="C#" Value="public virtual object AsyncDelegate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncDelegate As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncDelegate { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncDelegate : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект делегата, для которого был вызван асинхронный вызов.</summary>
        <value>Объект делегата, для которого был вызван асинхронный вызов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> Свойство может быть приведено к фактическому классу определяемого пользователем делегата.  
  
 Например, если делегат, который использовался для выполнения асинхронного вызова, имеет тип `MyDelegate`, то делегат, возвращаемый этим свойством, должен быть приведен к `MyDelegate`типу. Затем метод обратного вызова может вызвать `EndInvoke` метод делегата с правильной сигнатурой для получения результатов асинхронного вызова метода.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> свойство для получения делегата, который использовался для выполнения асинхронного вызова, чтобы вызвать. `EndInvoke` В этом примере <xref:System.IAsyncResult> <xref:System.Runtime.Remoting.Messaging.AsyncResult> объект, который является единственным параметром метода обратного вызова, приводится к объекту.  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения о способах работы этого примера обратного вызова и о других примерах асинхронного вызова методов с помощью делегатов см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberSignature Language="F#" Value="abstract member AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl&#xA;override this.AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl" Usage="asyncResult.AsyncProcessMessage (msg, replySink)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">Интерфейс запроса <see cref="T:System.Runtime.Remoting.Messaging.IMessage" />.</param>
        <param name="replySink">Интерфейс ответа <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />.</param>
        <summary>Реализует интерфейс <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />.</summary>
        <returns>Возвращаемое значение отсутствует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод интерфейса не имеет отношения к классу. <xref:System.Runtime.Remoting.Messaging.AsyncResult> <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage%2A> <xref:System.Runtime.Remoting.Messaging.IMessageSink> Реализация посредством <xref:System.Runtime.Remoting.Messaging.AsyncResult> <xref:System.NotSupportedException>создает исключение. Вместо этого получите <xref:System.Runtime.Remoting.Messaging.AsyncResult> путем <xref:System.IAsyncResult> приведения интерфейса, возвращенного асинхронным вызовом, сделанным с помощью делегата.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public virtual object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект, предоставленный как последний параметр вызова метода <see langword="BeginInvoke" />.</summary>
        <value>Объект, предоставленный как последний параметр вызова метода <see langword="BeginInvoke" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о методе `BeginInvoke` см. в разделе [Асинхронное программирование с использованием делегатов](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A> как свойство используется для передачи сведений в метод обратного вызова. Последний параметр `BeginInvoke` вызова метода — это строка формата, которую метод обратного вызова использует для форматирования выходного сообщения.  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения о способах работы этого примера обратного вызова и о других примерах асинхронного вызова методов с помощью делегатов см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncWaitHandle">
      <MemberSignature Language="C#" Value="public virtual System.Threading.WaitHandle AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Threading::WaitHandle ^ AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncWaitHandle : System.Threading.WaitHandle" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Threading.WaitHandle" />, который инкапсулирует дескрипторы синхронизации Win32 и разрешает реализацию различных схем синхронизации.</summary>
        <value><see cref="T:System.Threading.WaitHandle" />, который инкапсулирует дескрипторы синхронизации Win32 и разрешает реализацию различных схем синхронизации.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Threading.WaitHandle> , возвращаемый этим методом, автоматически сигнализирует о завершении асинхронной операции.  
  
 Маркер ожидания не закрывается автоматически при вызове `EndInvoke` в делегате, который использовался для асинхронного вызова метода. Если удалить все ссылки на дескриптор ожидания, системные ресурсы будут освобождены при удалении дескриптора ожидания сборщиком мусора. Чтобы освободить системные ресурсы сразу после завершения использования маркера ожидания, вызовите <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> метод. Сборка мусора более эффективна, когда удаляемые объекты явным образом закрываются или удаляются.  
  
> [!CAUTION]
>  Объект <xref:System.Threading.WaitHandle> , содержащийся <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> в свойстве, можно использовать для блокировки текущего потока до завершения асинхронного вызова. Однако параметр <xref:System.Threading.WaitHandle> будет <xref:System.AsyncCallback>игнорировать, если `BeginInvoke` он был указан во время вызова. Поэтому может произойти ситуация, когда приложение завершает работу до <xref:System.AsyncCallback> завершения выполнения, даже если объект <xref:System.Threading.WaitHandle> используется для блокировки до завершения асинхронного вызова. Пример такой ситуации см. в примере для <xref:System.Runtime.Remoting.Messaging.AsyncResult> класса и <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> удалите оператор.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> свойства для <xref:System.Threading.WaitHandle>получения и ожидания асинхронного вызова в делегате. Объект <xref:System.Threading.WaitHandle> получает сигнал после завершения асинхронного вызова; его можно дождаться путем вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и дополнительные примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
    <Member MemberName="CompletedSynchronously">
      <MemberSignature Language="C#" Value="public virtual bool CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CompletedSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedSynchronously : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, завершен ли вызов <see langword="BeginInvoke" /> синхронно.</summary>
        <value><see langword="true" />, если вызов <see langword="BeginInvoke" /> завершен синхронно; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если обнаруживается, что `BeginInvoke` вызов завершен синхронно <xref:System.AsyncCallback> в делегате, вероятно, поток, который вызвал BeginInvoke, является текущим потоком. Большинство поставщиков <xref:System.IAsyncResult> интерфейса не будут использовать эту возможность и будут возвращать значение по умолчанию `false`.  
  
 Текущая реализация <xref:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously%2A> всегда возвращает значение `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeCalled">
      <MemberSignature Language="C#" Value="public bool EndInvokeCalled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndInvokeCalled" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberSignature Language="VB.NET" Value="Public Property EndInvokeCalled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndInvokeCalled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EndInvokeCalled : bool with get, set" Usage="System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, вызван ли <see langword="EndInvoke" /> в текущем <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" />.</summary>
        <value><see langword="true" />, если <see langword="EndInvoke" /> вызван в текущем <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" />; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReplyMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage GetReplyMessage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage GetReplyMessage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReplyMessage () As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ GetReplyMessage();" />
      <MemberSignature Language="F#" Value="abstract member GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.GetReplyMessage " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сообщение ответа на асинхронный вызов.</summary>
        <returns>Сообщение удаленного взаимодействие, которое должно представлять ответ на вызов метода удаленного объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод может возвращать объект <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> после вызова метода. <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> Возвращаемое значение может быть приведено <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>к типу. <xref:System.Runtime.Remoting.Messaging.IMessage>  
  
 Однако не нужно вызывать ни один из этих методов напрямую. Они предназначены для использования инфраструктурой удаленного взаимодействия .NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public virtual bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершил ли сервер вызов.</summary>
        <value><see langword="true" /> после завершения вызова сервером; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сервер не должен использовать ресурсы, предоставляемые клиентом, за пределами согласованной семантики совместного использования <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> после установки `true`для свойства значения. Таким способом, клиент может безвозвратно уничтожить ресурсы после того, как <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> свойство вернет `true`значение.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IAsyncResult.IsCompleted%2A> свойство объекта, <xref:System.Runtime.Remoting.Messaging.AsyncResult> возвращаемого методом `BeginInvoke` , для обнаружения завершения асинхронного вызова. Это можно делать, когда асинхронный вызов выполнен из потока, обслуживающего пользовательский интерфейс. Опрос завершения позволяет вызывающему потоку продолжить выполнение при асинхронном вызове для потока <xref:System.Threading.ThreadPool> .  
  
 Пример состоит из двух классов: класса, содержащего метод, который вызывается асинхронно, и класс, содержащий `Main` метод, который выполняет вызов.  
  
 Дополнительные сведения и дополнительные примеры асинхронного вызова методов с помощью делегатов см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#4](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
[!code-csharp[AsyncDelegateExamples#4](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
[!code-vb[AsyncDelegateExamples#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSink : System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает следующий приемник сообщений в цепочке приемников.</summary>
        <value>Интерфейс <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />, представляющий следующий приемник сообщений в цепочке приемников.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущая реализация возвращаемых <xref:System.Runtime.Remoting.Messaging.AsyncResult.NextSink%2A> `null`данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMessageCtrl">
      <MemberSignature Language="C#" Value="public virtual void SetMessageCtrl (System.Runtime.Remoting.Messaging.IMessageCtrl mc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMessageCtrl(class System.Runtime.Remoting.Messaging.IMessageCtrl mc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMessageCtrl (mc As IMessageCtrl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMessageCtrl(System::Runtime::Remoting::Messaging::IMessageCtrl ^ mc);" />
      <MemberSignature Language="F#" Value="abstract member SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit&#xA;override this.SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit" Usage="asyncResult.SetMessageCtrl mc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mc" Type="System.Runtime.Remoting.Messaging.IMessageCtrl" />
      </Parameters>
      <Docs>
        <param name="mc"><see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> для текущего удаленного вызова метода.</param>
        <summary>Задает <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> для текущего вызова удаленного метода, что позволяет управлять асинхронными сообщениями после их отправки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывать <xref:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl%2A> метод не нужно.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberSignature Language="F#" Value="abstract member SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.SyncProcessMessage msg" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Сообщение ответа на вызов метода удаленного объекта.</param>
        <summary>Синхронно обрабатывает сообщение ответа, возвращенное вызовом метода удаленного объекта.</summary>
        <returns>Возвращает <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> Метод<xref:System.Runtime.Remoting.Messaging.IMessageSink> реализует интерфейс. Вам не нужно вызывать этот метод напрямую. Он предназначен для использования инфраструктурой удаленного взаимодействия .NET Framework.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A>вызывает <xref:System.AsyncCallback> делегат кода потребителя. Он также задает <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> экземпляр, возвращаемый <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> методом. Если параметр имеет тип <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>, то тот же объект возвращается методом <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>. `msg` В противном случае возвращается ответное сообщение, содержащее исключение удаленного взаимодействия.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A>также изменяет значение, возвращаемое <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> свойством.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
