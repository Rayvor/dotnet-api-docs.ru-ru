<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3bbea36b17f443851517ccfbeca4383a06386061" /><Meta Name="ms.sourcegitcommit" Value="47aee60cbc5001a16d5b9cdd0500df890fb1cdec" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/26/2019" /><Meta Name="ms.locfileid" Value="74529834" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет статические методы для создания, перемещения и перечисления в каталогах и вложенных каталогах. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте класс <xref:System.IO.Directory> для стандартных операций, таких как копирование, перемещение, переименование, создание и удаление каталогов.  
  
-   Чтобы создать каталог, используйте один из методов <xref:System.IO.Directory.CreateDirectory%2A>.  
  
-   Чтобы удалить каталог, используйте один из методов <xref:System.IO.Directory.Delete%2A>.  
  
-   Чтобы получить или задать текущий каталог для приложения, используйте метод <xref:System.IO.Directory.GetCurrentDirectory%2A> или <xref:System.IO.Directory.SetCurrentDirectory%2A>.  
  
-   Чтобы управлять <xref:System.DateTime> сведениями, связанными с созданием, доступом и записью каталога, используйте такие методы, как <xref:System.IO.Directory.SetLastAccessTime%2A> и <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Статические методы класса <xref:System.IO.Directory> выполняют проверку безопасности для всех методов. Если вы собираетесь повторно использовать объект несколько раз, рассмотрите возможность использования соответствующего метода экземпляра <xref:System.IO.DirectoryInfo> вместо этого, так как проверка безопасности не всегда будет требоваться.  
  
 Если вы выполняете только одно действие, связанное с каталогом, возможно, более эффективно использовать статический <xref:System.IO.Directory> метод, а не соответствующий метод экземпляра <xref:System.IO.DirectoryInfo>. Для большинства методов <xref:System.IO.Directory> требуется путь к каталогу, к которому выполняется управление.  
  
> [!NOTE]
>  В членах, принимающих строковый `path` параметр, этот путь должен иметь правильный формат или возникнет исключение. Например, если путь является полным, но начинается с пробела ("c:\temp"), строка пути не усекается, поэтому путь считается некорректным и возникает исключение. Кроме того, путь или сочетание путей не могут быть полностью определены дважды. Например, "c:\temp c:\Windows" также вызывает исключение. При использовании методов, принимающих строку пути, убедитесь, что пути имеют правильный формат. Дополнительные сведения см. в разделе <xref:System.IO.Path>.  
  
 В членах, принимающих путь, путь может ссылаться на файл или каталог. Можно использовать полный путь, относительный путь или путь в формате UNC для имени сервера и общего ресурса. Например, все следующие допустимые пути:  
  
-   "c:\\\Мидир" in C#или "к:\мидир" в Visual Basic.  
  
-   "MyDir\\\Мисубдир" in C#или "мидир\мисубдир" в Visual Basic.  
  
-   "\\\\\\\Мисервер\\\Мишаре" in C#или "\\\MyServer\MyShare" в Visual Basic.  
  
 По умолчанию всем пользователям предоставляется полный доступ на чтение и запись к новым каталогам. Однако приложение должно иметь правильную защиту для доступа к существующим каталогам.  
  
 Чтобы запросить разрешения для каталога и всех его подкаталогов, Завершите строку пути с помощью символа разделителя каталога. (Например, "C:\Temp\\" предоставляет доступ к C:\Temp\ и всем его подкаталогам.) Чтобы запросить разрешения только для определенного каталога, Завершите строку пути точкой. (Например, «C:\Temp\\». предоставляет доступ только к C:\Temp\\, а не к его подкаталогам.)  
  
 В членах, принимающих параметр `searchPattern`, строка поиска может быть любым сочетанием литеральных символов и двумя подстановочными знаками. \* и?. Этот параметр не распознает регулярные выражения. Дополнительные сведения см. в описании метода <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> или любого другого метода, использующего параметр `searchPattern`.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> и <xref:System.IO.DirectoryInfo> не поддерживаются в приложениях [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]. Сведения о доступе к файлам и папкам в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложениях см. в разделе [доступ к данным и файлам (приложения для Магазина Windows)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 В следующем примере показано, как извлечь все текстовые файлы из каталога и переместить их в новый каталог. После перемещения файлы больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 В следующем примере показано, как использовать метод <xref:System.IO.Directory.EnumerateFiles%2A> для получения коллекции текстовых файлов из каталога, а затем использовать эту коллекцию в запросе для поиска всех строк, содержащих "example".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 В следующем примере показано, как переместить каталог и все его файлы в новый каталог. Исходный каталог больше не существует после перемещения.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает все каталоги по заданному пути.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, который необходимо создать.</param>
        <summary>Создает все каталоги и подкаталоги по указанному пути, если они еще не существуют.</summary>
        <returns>Объект, представляющий каталог по указанному пути. Этот объект возвращается вне зависимости от того, существует ли уже каталог по указанному пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все каталоги, указанные в `path`, создаются, если они еще не существуют или не являются допустимыми частью `path`. Если каталог уже существует, этот метод не создает новый каталог, но возвращает объект <xref:System.IO.DirectoryInfo> для существующего каталога.  
  
 Параметр `path` указывает путь к каталогу, а не путь к файлу.  
  
 Конечные пробелы удаляются из конца параметра `path` перед созданием каталога.  
  
 Вы можете создать каталог на удаленном компьютере в общей папке, к которой у вас есть доступ для записи. Поддерживаются пути в формате UNC; Например, можно указать следующие сведения для `path`: `\\2009\Archives\December` в Visual Basic и `\\\\2009\\Archives\\December` в C#.  
  
 Создание каталога только с символом двоеточия (:) не поддерживается и приведет к возникновению `NotSupportedException`.  
  
   
  
## Examples  
 В следующем примере создается и удаляется указанный каталог.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Чтобы создать каталог C:\Users\User1\Public\Html, если текущим каталогом является C:\Users\User1, используйте любой из следующих вызовов, чтобы убедиться, что обратная косая черта правильно интерпретируется.  
  
 В Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 В C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 В C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, является файлом.  
  
- или - 
Имя сети неизвестно.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="path" /> начинается с символа двоеточия (:) или содержит только двоеточие.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> содержит двоеточие (:), которое не является частью метки диска (C:\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов или каталогов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, который необходимо создать.</param>
        <param name="directorySecurity">Элемент управления доступом, который необходимо применить к каталогу.</param>
        <summary>Создает все каталоги по указанному пути, если они еще не существуют, с применением заданных параметров безопасности Windows.</summary>
        <returns>Объект, представляющий каталог по указанному пути. Этот объект возвращается вне зависимости от того, существует ли уже каталог по указанному пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода для создания каталога с контролем доступа, поэтому нет возможности получить доступ к каталогу до применения безопасности.  
  
 Все каталоги, указанные в параметре `path`, создаются, если они еще не существуют или не являются допустимыми частью `path`. Параметр `path` указывает путь к каталогу, а не путь к файлу. Если каталог уже существует, этот метод не создает новый каталог, но возвращает объект <xref:System.IO.DirectoryInfo> для существующего каталога.  
  
 Конечные пробелы удаляются из конца параметра `path` перед созданием каталога.  
  
 Вы можете создать каталог на удаленном компьютере в общей папке, к которой у вас есть доступ для записи. Поддерживаются пути в формате UNC; Например, можно указать следующие сведения для `path`: `\\2009\Archives\December` в Visual Basic и `\\\\2009\\Archives\\December` в C#.  
  
 Создание каталога только с символом двоеточия (:) не поддерживается и вызывает исключение `NotSupportedException`.  
  
   
  
## Examples  
 В следующем примере создается новый каталог с правилами доступа для двух учетных записей пользователей.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, является файлом.  
  
- или - 
Имя сети неизвестно.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="path" /> начинается с символа двоеточия (:) или содержит только двоеточие.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> содержит двоеточие (:), которое не является частью метки диска (C:\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов и каталогов, а также для доступа к каталогу назначения. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет заданный каталог и при необходимости все подкаталоги.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя пустого каталога, который необходимо удалить. Этот каталог должен поддерживать запись и быть пустым.</param>
        <summary>Удаляет пустой каталог по заданному пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ведет себя так же, как <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> с `false`, указанным для второго параметра.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметра `path` перед удалением каталога.  
  
 Этот метод создает исключение <xref:System.IO.IOException>, если каталог, указанный в параметре `path`, содержит файлы или подкаталоги.  
  
 Параметр `path` не учитывает регистр.  
  
 В некоторых случаях, если указанный каталог открыт в проводнике, метод <xref:System.IO.Directory.Delete%2A> может не суметь удалить его.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый каталог и подкаталог, а затем удалить только подкаталог.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Файл с тем же именем и расположении, заданном <paramref name="path" />, уже существует.  
  
- или - 
Каталог является текущим рабочим каталогом приложения.  
  
- или - 
Каталог, заданный параметром <paramref name="path" />, не пустой.  
  
- или - 
Каталог доступен только для чтения или содержит файл, доступный только для чтения.  
  
- или - 
Каталог используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не существует или не найден.  
  
- или - 
Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Имя каталога, который необходимо удалить.</param>
        <param name="recursive">Значение <see langword="true" /> позволяет удалить каталоги, подкаталоги и файлы по заданному <paramref name="path" />, в противном случае — значение <see langword="false" />.</param>
        <summary>Удаляет заданный каталог и, при наличии соответствующей инструкции, все подкаталоги и файлы в нем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметра `path` перед удалением каталога.  
  
 Параметр `path` не учитывает регистр.  
  
 Если параметр `recursive` имеет значение `true`, пользователь должен иметь разрешение на запись для текущего каталога, а также для всех подкаталогов.  
  
 Поведение этого метода немного отличается при удалении каталога, содержащего точку повторного анализа, например символическую ссылку или точку подключения. Если точка повторного анализа является каталогом, например точкой подключения, она отключается и точка подключения удаляется. Этот метод не выполняет рекурсивный перебор точки повторного анализа. Если точка повторного анализа является символьной ссылкой на файл, то точка повторного анализа удаляется, а не целевой объект символьной ссылки.  
  
 В некоторых случаях, если указанный каталог открыт в проводнике, метод <xref:System.IO.Directory.Delete%2A> может не суметь удалить его.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый каталог, подкаталог и файл в подкаталоге, а затем рекурсивно удалить все новые элементы.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Файл с тем же именем и расположении, заданном <paramref name="path" />, уже существует.  
  
- или - 
Каталог, заданный параметром <paramref name="path" />, доступен только для чтения, или <paramref name="recursive" /> имеет значение <see langword="false" /> и <paramref name="path" /> не является пустым каталогом.  
  
- или - 
Каталог является текущим рабочим каталогом приложения.  
  
- или - 
Каталог содержит файл только для чтения.  
  
- или - 
Каталог используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не существует или не найден.  
  
- или - 
Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию полных имен каталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен каталогов, расположенных по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В параметре `path` можно указать сведения относительного или абсолютного пути. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>. Перед возвращаемыми именами каталогов указывается значение, указанное в параметре `path`. Например, если указать относительный путь в параметре `path`, возвращаемые имена каталогов будут содержать относительный путь.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисляются каталоги верхнего уровня по указанному пути.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которую необходимо сравнивать с именами каталогов, расположенных по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен каталогов, соответствующих шаблону поиска по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, указанном в <paramref name="path" />, которые соответствуют указанному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 В параметре `path` можно указать сведения относительного или абсолютного пути. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>. Перед возвращаемыми именами каталогов указывается значение, указанное в параметре `path`. Например, если указать относительный путь в параметре `path`, возвращаемые имена каталогов будут содержать относительный путь.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисляются каталоги верхнего уровня по указанному пути, которые соответствуют указанному шаблону поиска.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которую необходимо сравнивать с именами каталогов, расположенных по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен каталогов, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, указанном в <paramref name="path" />, которые соответствуют заданному шаблону поиска и параметрам перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ровно один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

 В параметре `path` можно указать сведения относительного или абсолютного пути. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>. Перед возвращаемыми именами каталогов указывается значение, указанное в параметре `path`. Например, если указать относительный путь в параметре `path`, возвращаемые имена каталогов будут содержать относительный путь.

 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.

 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которую необходимо сравнивать с именами каталогов, расположенных по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах. Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен каталогов, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, указанном в <paramref name="path" />, которые соответствуют заданному шаблону и параметрам поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ровно один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 В параметре `path` можно указать сведения относительного или абсолютного пути. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>. Перед возвращаемыми именами каталогов указывается значение, указанное в параметре `path`. Например, если указать относительный путь в параметре `path`, возвращаемые имена каталогов будут содержать относительный путь.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисляются каталоги по указанному пути, которые соответствуют указанному шаблону поиска. Он использует параметр `searchOption`, чтобы указать, что в поиск должны включаться все подкаталоги.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию полных имен файлов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен файлов, расположенных по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере показано, как получить все файлы в каталоге и переместить их в новый каталог. После перемещения файлы больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 В следующем примере выполняется перечисление файлов в указанном каталоге, чтение каждой строки файла и отображение строки, если она содержит строку "Европа".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен файлов, соответствующих шаблону поиска по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, указанном в параметре <paramref name="path" />, которые соответствуют заданному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере показано, как получить все текстовые файлы в каталоге и переместить их в новый каталог. После перемещения файлы больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 В следующем примере выполняется перечисление файлов в указанном каталоге, имеющих расширение txt, считывает каждую строку файла и отображает строку, если она содержит строку "Европа".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен файлов, соответствующих шаблону поиска и параметрам перечисления по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, указанном в <paramref name="path" />, которые соответствуют заданному шаблону поиска и параметрам перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ноль или один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:
> 
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".
> 
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.

 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах. Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию полных имен файлов, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, указанном в параметре <paramref name="path" />, которые соответствуют указанному шаблону и параметрам поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
   
  
## Examples  
 В следующем примере показано, как получить все текстовые файлы в каталоге и его подкаталогах и переместить их в новый каталог. После перемещения файлы больше не существуют в исходных каталогах.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 В следующем примере рекурсивно перечисляются все файлы, имеющие расширение txt, считывает каждую строку файла и отображает строку, если она содержит строку «Microsoft».  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию записей файловой системы, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов и имен каталогов по указанному пути.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.

 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами в записях файловой системы, расположенными по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, заданном параметром <paramref name="path" />, которые соответствуют указанному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков. 
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска и параметрам перечисления.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, указанном параметром <paramref name="path" />, которые соответствуют заданному шаблону поиска и параметрам перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ноль или один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:
> 
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".
> 
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.

 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с записями файловой системы, расположенными по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах. Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию записей файловой системы, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, указанном параметром <paramref name="path" />, который соответствует шаблону и параметру поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращенная коллекция не кэшируется; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> в коллекции запустит новое перечисление.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Проверяемый путь.</param>
        <summary>Определяет, указывает ли заданный путь на существующий каталог на диске.</summary>
        <returns><see langword="true" />, если <paramref name="path" /> ссылается на существующий каталог; значение <see langword="false" />, если каталог не существует или если при попытке определить, существует ли указанный каталог.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога.  
  
 Конечные пробелы удаляются из конца параметра `path` перед проверкой существования каталога.  
  
 Параметр `path` не учитывает регистр.  
  
 Если у вас нет разрешения на доступ только для чтения к каталогу, метод <xref:System.IO.Directory.Exists%2A> возвратит `false`.  
  
 Метод <xref:System.IO.Directory.Exists%2A> возвращает `false` при возникновении любой ошибки при попытке определить, существует ли указанный файл. Это может произойти в ситуациях, когда вызываются такие исключения, как передача имени файла с недопустимыми символами или слишком много символов, неудачный или отсутствующий диск или если вызывающий объект не имеет разрешения на чтение файла.  
  
   
  
## Examples  
 В следующем примере в командной строке принимается массив имен файлов или каталогов, определяется тип имени и обрабатывается соответствующим образом.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает список управления доступом Windows для каталога.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу, в котором содержится объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий сведения о списке управления доступом (ACL) для конкретного файла.</param>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, который инкапсулирует записи списка управления доступом (ACL) для заданного каталога.</summary>
        <returns>Объект, который инкапсулирует правила управления доступом для файла, описанные параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.IO.Directory.GetAccessControl%2A>, чтобы получить записи списка управления доступом (ACL) для каталога.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом или каталогом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет права <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> для родительской папки. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретите <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
   
  
## Examples  
 В следующем примере используются методы <xref:System.IO.Directory.GetAccessControl%2A> и <xref:System.IO.Directory.SetAccessControl%2A>, чтобы добавить запись списка управления доступом (ACL), а затем удалить запись ACL из каталога.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии каталога возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <exception cref="T:System.SystemException">Произошла ошибка системного уровня, например невозможно найти каталог. Конкретное исключение может быть подклассом <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Параметр <paramref name="path" /> указывает каталог, доступный только для чтения.  
  
- или - 
Эта операция не поддерживается на текущей платформе.  
  
- или - 
У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">разрешение на перечисление списка управления доступом (ACL) для каталога. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Demand.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу, в котором содержится объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий сведения о списке управления доступом (ACL) для конкретного файла.</param>
        <param name="includeSections">Одно из значений <see cref="T:System.Security.AccessControl.AccessControlSections" />, указывающее тип сведений о списке ACL, которые необходимо получить.</param>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, который инкапсулирует записи списка управления доступом (ACL) указанного типа для заданного каталога.</summary>
        <returns>Объект, который инкапсулирует правила управления доступом для файла, описанные параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.IO.Directory.GetAccessControl%2A>, чтобы получить записи списка управления доступом (ACL) для каталога.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом или каталогом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет права <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> для родительской папки. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретите <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии каталога возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <exception cref="T:System.SystemException">Произошла ошибка системного уровня, например невозможно найти каталог. Конкретное исключение может быть подклассом <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Параметр <paramref name="path" /> указывает каталог, доступный только для чтения.  
  
- или - 
Эта операция не поддерживается на текущей платформе.  
  
- или - 
У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">разрешение на перечисление списка управления доступом (ACL) для каталога. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Demand.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <summary>Получает дату и время создания каталога.</summary>
        <returns>Структура, для которой заданы дата и время создания указанного каталога. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Этот метод эквивалентен <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC, настроенное на местное время.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере возвращается время создания указанного каталога.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <summary>Получает время и дату создания каталога в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время создания указанного каталога. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC.  
  
 Этот метод используется для получения времени создания каталога на основе времени в формате UTC.  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает текущий рабочий каталог приложения.</summary>
        <returns>Строка, содержащая абсолютный путь к текущей рабочей папке без обратной косой черты (\\) в конце.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий каталог отличается от исходного каталога, из которого был запущен процесс.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано использование метода `GetCurrentDirectory`.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.NotSupportedException">Операционной системой является Windows CE, которая не поддерживает функциональность текущего каталога.  
  
 Этот метод доступен в .NET Compact Framework, но в настоящее время не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена подкаталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов по указанному пути или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод идентичен <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> со звездочкой (\*), указанной в качестве шаблона поиска, поэтому она возвращает все подкаталоги. Если необходимо выполнить поиск в подкаталогах, используйте метод <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29>, который позволяет указать Поиск подкаталогов с помощью параметра `searchOption`.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Имена, возвращаемые этим методом, добавляются с префиксом, указанным в `path`.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере в командной строке принимается массив имен файлов или каталогов, определяется тип имени и обрабатывается соответствующим образом.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге, соответствующих указанному шаблону поиска.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов в указанном каталоге, которые соответствуют указанному шаблону поиска, или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает все подкаталоги непосредственно в указанном каталоге, который соответствует указанному шаблону поиска. Если в указанном каталоге нет подкаталогов или если подкаталоги не соответствуют параметру `searchPattern`, этот метод возвращает пустой массив. Поиск выполняется только в верхнем каталоге. Если вы хотите также выполнить поиск в подкаталогах, используйте метод <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> и укажите <xref:System.IO.SearchOption.AllDirectories> в параметре `searchOption`.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути и не учитывает регистр.  Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество каталогов в пути, начинающемся с указанной буквы.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге, соответствующих заданному шаблону поиска и параметрам перечисления.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов в указанном каталоге, которые соответствуют шаблону поиска и параметрам перечисления, или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает все подкаталоги непосредственно в указанном каталоге, который соответствует указанному шаблону поиска. Если в указанном каталоге нет подкаталогов или если подкаталоги не соответствуют параметру `searchPattern`, этот метод возвращает пустой массив. Поиск выполняется только в верхнем каталоге. Если вы хотите также выполнить поиск в подкаталогах, используйте метод <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> и укажите <xref:System.IO.SearchOption.AllDirectories> в параметре `searchOption`.

 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ноль или один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

 Параметр `path` может указывать сведения относительного или абсолютного пути и не учитывает регистр.  Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.

 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге, соответствующих указанному шаблону поиска, и при необходимости ведет поиск в подкаталогах.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов, соответствующих указанным критериям, или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `path` может указывать сведения относительного или абсолютного пути и не учитывает регистр. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Методы <xref:System.IO.Directory.EnumerateDirectories%2A> и <xref:System.IO.Directory.GetDirectories%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateDirectories%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetDirectories%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateDirectories%2A> может быть более эффективной.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество каталогов, начинающихся с указанной буквы в пути. Выполняется поиск только в каталоге верхнего уровня.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу.</param>
        <summary>Возвращает для заданного пути сведения о томе и корневом каталоге по отдельности или сразу.</summary>
        <returns>Строка, в которой содержатся сведения о томе, корневом каталоге или одновременно сведения и о томе, и о корневом каталоге для заданного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод получает полное имя пути `path`, возвращенное <xref:System.IO.Path.GetFullPath%2A>, и возвращает сведения о корневом каталоге. Указанный путь не должен существовать.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как задать текущий каталог и отобразить корневой каталог.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена файлов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена файлов (с указанием пути к ним) в указанном каталоге.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Возвращаемые имена файлов добавляются к заданному `path` параметру.  
  
 Этот метод идентичен <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> со звездочкой (\*), указанной в качестве шаблона поиска.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Порядок возвращаемых имен файлов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.IO.Directory.GetFiles%2A> для возврата имен файлов из заданного пользователем расположения. Этот пример настроен для перехвата всех ошибок, общих для данного метода.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
- или - 
Произошла сетевая ошибка.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает имена файлов (включая пути) из указанного каталога, отвечающие условиям заданного шаблона поиска.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге, которые соответствуют указанному шаблону поиска, или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемые имена файлов добавляются к указанному параметру `path` и порядок возвращаемых имен файлов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
> [!NOTE]
>  Так как этот метод проверяет имена файлов как в формате имени файла 8,3, так и в формате длинного имени файла, шаблон поиска, аналогичный "\*1\*. txt", может возвращать непредвиденные имена файлов. Например, при использовании шаблона поиска «\*1\*. txt» возвращается «лонгфиленаме. txt», так как формат имени файла 8,3 имеет эквивалент «ЛОНГФИ ~ 1. TXT».  
  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество файлов, начинающихся с указанной буквы.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
- или - 
Произошла сетевая ошибка.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает имена файлов (включая пути) в указанном каталоге, соответствующих заданному шаблону поиска и параметрам перечисления.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге, которые соответствуют заданному шаблону поиска и параметрам перечисления, или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемые имена файлов добавляются к указанному параметру `path` и порядок возвращаемых имен файлов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.

 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ноль или один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:
> 
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".
> 
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.

> [!NOTE]
>  Так как этот метод проверяет имена файлов как в формате имени файла 8,3, так и в формате длинного имени файла, шаблон поиска, аналогичный "\*1\*. txt", может возвращать непредвиденные имена файлов. Например, при использовании шаблона поиска «\*1\*. txt» возвращается «лонгфиленаме. txt», так как формат имени файла 8,3 имеет эквивалент «ЛОНГФИ ~ 1. TXT».

 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.

 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Параметр `path` не учитывает регистр.

 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
- или - 
Произошла сетевая ошибка.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.</param>
        <summary>Возвращает имена файлов (включая пути) в заданном каталоге, отвечающие условиям шаблона поиска, используя значение, которое определяет, выполнять ли поиск в подкаталогах.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге, которые соответствуют указанному шаблону и параметру поиска, или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемые имена файлов добавляются к указанному параметру `path` и порядок возвращаемых имен файлов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, тогда как шаблон поиска" филе*. txt "возвращает оба файла.  
  
> [!NOTE]
>  Так как этот метод проверяет имена файлов как в формате имени файла 8,3, так и в формате длинного имени файла, шаблон поиска, аналогичный "\*1\*. txt", может возвращать непредвиденные имена файлов. Например, при использовании шаблона поиска «\*1\*. txt» возвращается «лонгфиленаме. txt», так как формат имени файла 8,3 имеет эквивалент «ЛОНГФИ ~ 1. TXT».  
  
 Методы <xref:System.IO.Directory.EnumerateFiles%2A> и <xref:System.IO.Directory.GetFiles%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFiles%2A>можно начать перечисление коллекции имен перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFiles%2A>необходимо дождаться, пока будет возвращен весь массив имен, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Имена файлов включают полный путь.  
  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchpattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
- или - 
Произошла сетевая ошибка.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена всех файлов и подкаталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена всех файлов и подкаталогов по указанному пути.</summary>
        <returns>Массив имен файлов и подкаталогов в указанном каталоге или пустой массив, если файлы или подкаталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращаемых имен файлов и каталогов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Этот метод идентичен <xref:System.IO.Directory.GetFileSystemEntries%2A> со звездочкой (\*), указанной в качестве шаблона поиска.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере метод <xref:System.IO.Directory.GetFileSystemEntries%2A> используется для заполнения массива строк именами всех файлов и подкаталогов в заданном пользователем расположении и печати каждой строки в массиве в консоли. Этот пример настроен для перехвата всех ошибок, общих для данного метода.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами файла и каталогов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает массив имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска.</summary>
        <returns>Массив имен файлов и имен каталогов, соответствующих указанным критериям поиска, или пустой массив, если файлы или каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращаемых имен файлов и каталогов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.IO.Directory.GetFileSystemEntries%2A> для заполнения массива строк именами всех файлов, совпадающими с указанным пользователем фильтром в определенном месте, и выводит каждую строку в массиве на консоль. Этот пример настроен для перехвата всех ошибок, общих для данного метода.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути к текущему каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="enumerationOptions">Объект, описывающий конфигурацию поиска и перечисления для использования.</param>
        <summary>Возвращает массив имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска и параметрам перечисления.</summary>
        <returns>Массив имен файлов и имен каталогов, соответствующих указанному шаблону поиска и параметрам перечисления, или пустой массив, если файлы или каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращаемых имен файлов и каталогов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.

 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.

|Спецификатор подстановочного знака|Число соответствий|
|------------------------|-------------|
|\* (звездочка)|Ноль или более символов в этой должности.|
|? (вопросительный знак)|Ноль или один символ в этой позиции.|

 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".

 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.

> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:
> 
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".
> 
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.

 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Параметр `path` не учитывает регистр.

 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).

          ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.

- или -

          <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов и каталогов в параметре <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах. Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает массив всех имен файлов и каталогов по указанному пути, соответствующих шаблону поиска, и при необходимости ведет поиск в подкаталогах.</summary>
        <returns>Массив имен файлов и имен каталогов, соответствующих указанным критериям поиска, или пустой массив, если файлы или каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращаемых имен файлов и каталогов не гарантируется; Используйте метод <xref:System.Array.Sort%2A>, если требуется конкретный порядок сортировки.  
  
 `searchPattern` может быть сочетанием литеральных символов и подстановочных знаков, но не поддерживает регулярные выражения. В `searchPattern`разрешены следующие описатели подстановочных знаков.  
  
|Спецификатор подстановочного знака|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой должности.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочных знаков, являются литеральными символами. Например, `searchPattern` строка "\*t" ищет все имена в `path`, заканчивая буквой "t". Строка `searchPattern` "s\*" ищет все имена в `path`, начиная с буквы "s".  
  
 `searchPattern` не может заканчиваться двумя точками ("..") или содержать две точки (".."), за которыми следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, а также не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символа-шаблона звездочки в `searchPattern`, например "\*. txt", число символов в указанном расширении влияет на поиск следующим образом:  
>   
> -   Если указанное расширение имеет длину ровно три символа, метод возвращает файлы с расширениями, которые начинаются с указанного расширения. Например, "\*. xls" возвращает оба значения: "Book. xls" и "Book. xlsx".  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанному расширению. Например, "\*. AI" возвращает "file.ai", но не "File. AIF".  
>   
>  Если используется символ-шаблон вопросительного знака, этот метод возвращает только файлы, соответствующие указанному расширению файла. Например, при наличии двух файлов "file1. txt" и "file1. ткстосер" в каталоге шаблон поиска "File?". txt "возвращает только первый файл, а шаблон поиска" File\*. txt "возвращает оба файла.  
  
 Методы <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> и <xref:System.IO.Directory.GetFileSystemEntries%2A> различаются следующим образом: при использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>можно начать перечисление коллекции записей перед возвратом всей коллекции. При использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>необходимо дождаться возврата всего массива записей, прежде чем можно будет получить доступ к массиву. Поэтому при работе с множеством файлов и каталогов <xref:System.IO.Directory.EnumerateFiles%2A> может быть более эффективной.  
  
 Можно указать сведения об относительном пути с помощью параметра `path`. Сведения относительного пути обрабатываются относительно текущего рабочего каталога, который можно определить с помощью метода <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, информацию о дате и времени обращения к которому следует получить.</param>
        <summary>Возвращает время и дату последнего обращения к указанному файлу или каталогу.</summary>
        <returns>Структура, для которой заданы дата и время последнего доступа к указанному файлу или каталогу. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Этот метод идентичен <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC, настроенное на местное время.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> имеет недопустимый формат.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, информацию о дате и времени обращения к которому следует получить.</param>
        <summary>Возвращает дату и время последнего доступа к заданному файлу или каталогу в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время последнего доступа к указанному файлу или каталогу. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> имеет недопустимый формат.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, дату и время изменения которого следует получить.</param>
        <summary>Возвращает время и дату последней операции записи в указанный файл или каталог.</summary>
        <returns>Структура, для которой заданы дата и время последней операции записи в указанный файл или каталог. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC, настроенное на местное время.  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, дату и время изменения которого следует получить.</param>
        <summary>Возвращает дату и время последней операции записи в заданный файл или каталог в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время последней операции записи в указанный файл или каталог. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, поскольку в нем используются собственные функции, значения которых могут не обновляться операционной системой постоянно.  
  
 Если каталог, описанный в параметре `path`, не существует, этот метод возвращает 12:00 полночь, 1 января 1601 г. н. э. эры Время в формате UTC.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает имена логических дисков данного компьютера в формате "&lt;буква диска&gt;:\\".</summary>
        <returns>Логические устройства данного компьютера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Жетлогикалдривес возвращает все доступные диски на определенном компьютере, включая флоппи-дисковод и дисководы оптических дисков.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере метод <xref:System.IO.Directory.GetLogicalDrives%2A> используется для назначения имени каждого диска вызывающего компьютера массиву строк. После этого все элементы этого массива строк выводятся на консоль. Этот пример настроен для перехвата всех ошибок, общих для данного метода.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода, например вызова машинного кода с помощью PInvoke или COM-взаимодействия. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, для которого необходимо извлечь родительский каталог.</param>
        <summary>Извлекает родительский каталог, на который указывает абсолютный или относительный путь.</summary>
        <returns>Родительский каталог или значение <see langword="null" />, если <paramref name="path" /> является корневым каталогом, в том числе корнем сервера UNC или именем общего ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `path` может указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметра `path` перед получением каталога.  
  
 Строка, возвращаемая этим методом, состоит из всех символов в пути вплоть до, но не включая последний <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>. Например, передача пути "К:\директори\субдиректори\тест.ткст" в <xref:System.IO.Directory.GetParent%2A> возвращает "К:\директори\субдиректори". При передаче "К:\директори\субдиректори" возвращается значение "К:\директори". Однако передача "К:\директори\субдиректори\\" возвращает "К:\директори\субдиректори", так как конечный разделитель каталогов находится после "подкаталога".  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.IO.Directory.GetParent%2A> для получения родительского каталога указанного пользователем расположения, "Path". Значение, возвращаемое методом <xref:System.IO.Directory.GetParent%2A>, затем распечатывается на консоли. Этот пример настроен для перехвата всех ошибок, общих для данного метода.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, доступен только для чтения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе. Дополнительные сведения см. в разделе <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> задан в недопустимом формате.</exception>
        <exception cref="T:System.Security.SecurityException">Только .NET Framework: У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения из файлов или каталогов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Путь к файлу или каталогу, который необходимо переместить.</param>
        <param name="destDirName">Путь к новому местоположению <paramref name="sourceDirName" />. Если <paramref name="sourceDirName" /> является файлом, то параметр <paramref name="destDirName" /> также должен быть именем файла.</param>
        <summary>Перемещает файл или каталог со всем его содержимым в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает новый каталог с именем, указанным в `destDirName`, и перемещает содержимое `sourceDirName` в созданный каталог назначения. При попытке переместить каталог в уже существующий каталог возникнет <xref:System.IO.IOException>. Например, при попытке переместить к:\мидир в к:\публик возникает исключение, а к:\публик уже существует. Кроме того, можно указать "c:\\\public\\\мидир" в качестве параметра `destDirName`, если "MyDir" не существует в "c:\\\public", или указать новое имя каталога, например "c:\\\невдир".  
  
 Аргументы `sourceDirName` и `destDirName` могут указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметров пути перед перемещением каталога.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  


> [!NOTE]
>  Начиная с .NET Core 3,0, метод `Move` создает <xref:System.IO.IOException> во всех платформах, если `destDirName` уже существует. В .NET Core 2,2 и предыдущих версиях исключение было вызвано только в Windows, и другие платформы могли либо завершиться сбоем, либо перезаписать `destDirName`. См. раздел [ C++ Rename](https://linux.die.net/man/2/rename).
   
  
## Examples  
 В следующем примере показано, как переместить каталог и все его файлы в новый каталог. Исходный каталог больше не существует после перемещения.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Была предпринята попытка переместить каталог в другой том.
  
- или - 
 <paramref name="destDirName" /> уже существует. См. раздел примечаний.
  
- или - 
Параметры <paramref name="sourceDirName" /> и <paramref name="destDirName" /> указывают на один и тот же файл или каталог.  
  
- или - 
Каталог или находящийся в нем файл используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> или <paramref name="destDirName" /> представляет собой строку нулевой длины, строку, содержащую только пробелы, или строку, содержащую один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="sourceDirName" /> или <paramref name="destDirName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Путь, указанный <paramref name="sourceDirName" />, является недопустимым (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения из <paramref name="sourceDirName" /> и записи в <paramref name="sourceDirName" /> и <paramref name="destDirName" />. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, в который необходимо добавить или из которого нужно удалить записи списка управления доступом.</param>
        <param name="directorySecurity">Объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий запись ACL, которую требуется применить к каталогу, описанному параметром <paramref name="path" />.</param>
        <summary>Применяет к заданному каталогу записи списка управления доступом (ACL), описанные объектом <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.Directory.SetAccessControl%2A> применяет записи списка управления доступом (ACL) к файлу, который представляет неунаследованный список ACL.  
  
> [!CAUTION]
>  Список управления доступом, указанный для параметра `directorySecurity`, заменяет существующий список ACL для каталога. Чтобы добавить разрешения для нового пользователя, используйте метод <xref:System.IO.Directory.GetAccessControl%2A>, чтобы получить существующий список управления доступом и изменить его.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом или каталогом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Метод <xref:System.IO.Directory.SetAccessControl%2A> сохраняет только объекты <xref:System.Security.AccessControl.DirectorySecurity>, которые были изменены после создания объекта.  Если объект <xref:System.Security.AccessControl.DirectorySecurity> не был изменен, он не будет сохранен в файл.  Таким образом, невозможно получить объект <xref:System.Security.AccessControl.DirectorySecurity> из одного файла и повторно применить тот же объект к другому файлу.  
  
 Чтобы скопировать данные ACL из одного файла в другой:  
  
1.  Используйте метод <xref:System.IO.Directory.GetAccessControl%2A> для получения объекта <xref:System.Security.AccessControl.DirectorySecurity> из исходного файла.  
  
2.  Создайте новый объект <xref:System.Security.AccessControl.DirectorySecurity> для целевого файла.  
  
3.  Используйте метод <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> объекта <xref:System.Security.AccessControl.DirectorySecurity> источника для получения сведений ACL.  
  
4.  Используйте метод <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>, чтобы скопировать данные, полученные на шаге 3, в целевой <xref:System.Security.AccessControl.DirectorySecurity> объект.  
  
5.  Установите целевой объект <xref:System.Security.AccessControl.DirectorySecurity> в конечный файл с помощью метода <xref:System.IO.Directory.SetAccessControl%2A>.  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет права <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> для родительской папки. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретите <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
   
  
## Examples  
 В следующем примере используются методы <xref:System.IO.Directory.GetAccessControl%2A> и <xref:System.IO.Directory.SetAccessControl%2A>, чтобы добавить запись списка управления доступом (ACL), а затем удалить запись ACL из каталога.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directorySecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Не удается найти каталог.</exception>
        <exception cref="T:System.ArgumentException">Задан недопустимый <paramref name="path" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий процесс не может получить доступ к каталогу, заданному <paramref name="path" />.  
  
- или - 
Текущий процесс не имеет необходимых прав для задания записи ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">разрешение на перечисление списка управления доступом (ACL) для каталога. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Demand.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время создания.</param>
        <param name="creationTime">Дата и время последней записи в файл или каталог. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время создания заданного файла или каталога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время создания.</param>
        <param name="creationTimeUtc">Дата и время создания каталога или файла. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время создания указанного файла или папки в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, который должен быть назначен рабочему каталогу.</param>
        <summary>Устанавливает заданный каталог в качестве текущего рабочего каталога приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После завершения работы приложения рабочий каталог восстанавливается в исходное расположение (каталог, в котором был запущен процесс).  
  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметра `path` перед настройкой каталога.  
  
 Параметр `path` не учитывает регистр.  
  
 Если вы настраиваете каталог на диск со съемным носителем (например, "E:" для USB-накопителя), можно определить, готов ли диск к использованию свойства <xref:System.IO.DriveInfo.IsReady%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как задать текущий каталог и отобразить корневой каталог.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для доступа к неуправляемому коду.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный каталог не найден.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в файлы или каталоги. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время доступа.</param>
        <param name="lastAccessTime">Объект, содержащий значение, которое необходимо присвоить дате и времени доступа к <paramref name="path" />. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает время и дату последнего обращения к заданному файлу или каталогу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время доступа.</param>
        <param name="lastAccessTimeUtc">Объект, содержащий значение, которое необходимо присвоить дате и времени доступа к <paramref name="path" />. Значение выражено в формате всемирного координированного времени (UTC).</param>
        <summary>Устанавливает дату и время последнего доступа к заданному файлу или каталогу в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <param name="lastWriteTime">Дата и время последней записи в файл или каталог. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время последней записи в файл или каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <param name="lastWriteTimeUtc">Дата и время последней записи в файл или каталог. Значение выражено в формате всемирного координированного времени (UTC).</param>
        <summary>Устанавливает дату и время последней записи в заданный каталог в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для параметра `path` разрешено указывать сведения относительного или абсолютного пути. Сведения об относительном пути интерпретируется как относительно текущего рабочего каталога. Сведения о получении текущего рабочего каталога см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Параметр `path` не учитывает регистр.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате всемирного координированного времени (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
  </Members>
</Type>
