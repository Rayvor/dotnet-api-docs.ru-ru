<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ed1028eda1dd42497237086ace1d72ebae64c40" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73388189" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ожидает уведомления файловой системы об изменениях и инициирует события при изменениях каталога или файла в каталоге.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.FileSystemWatcher>, чтобы отслеживать изменения в указанном каталоге. Вы можете отслеживать изменения в файлах и подкаталогах указанного каталога. Можно создать компонент для просмотра файлов на локальном компьютере, на сетевом диске или на удаленном компьютере.  
  
 Чтобы отслеживать изменения во всех файлах, присвойте свойству <xref:System.IO.FileSystemWatcher.Filter%2A> пустую строку ("") или используйте подстановочные знаки ("*".\*"). Чтобы просмотреть конкретный файл, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> имя файла. Например, чтобы отслеживать изменения в файле Мидок. txt, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> значение "Мидок. txt". Кроме того, можно отслеживать изменения в файле определенного типа. Например, чтобы отслеживать изменения в текстовых файлах, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> значение "\*. txt".  
  
 Существует несколько типов изменений, которые можно отслеживать в каталоге или файле. Например, можно отслеживать изменения в `Attributes`, `LastWrite` дату и время, а также `Size` файлов или каталогов. Это можно сделать, задав для свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> одно из значений <xref:System.IO.NotifyFilters>. Дополнительные сведения о типе изменений, которые можно отслеживать, см. в разделе <xref:System.IO.NotifyFilters>.  
  
 Вы можете отслеживать переименование, удаление или создание файлов или каталогов. Например, чтобы отслеживать переименование текстовых файлов, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> значение "*. txt" и вызовите метод <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> с <xref:System.IO.WatcherChangeTypes.Renamed>, указанным для его параметра.  
  
 Операционная система Windows уведомляет компонент об изменениях файлов в буфере, созданном <xref:System.IO.FileSystemWatcher>. Если в течение короткого промежутка времени произошло много изменений, буфер может переполниться. В результате компонент теряет возможность отслеживания изменений в каталоге и предоставит только общие уведомления. Увеличение размера буфера с помощью свойства <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> является дорогостоящим, так как оно поступает из нестраничной памяти, которую невозможно переключить на диск, поэтому размер буфера должен быть небольшим, достаточно большим, чтобы не пропускать события изменения файла. Чтобы избежать переполнения буфера, используйте свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, чтобы можно было отфильтровать ненужные уведомления об изменениях.  
  
 Список начальных значений свойств для экземпляра <xref:System.IO.FileSystemWatcher> см. в разделе Конструктор <xref:System.IO.FileSystemWatcher.%23ctor%2A>.  
  
 При использовании класса <xref:System.IO.FileSystemWatcher> Обратите внимание на следующее.  
  
-   Скрытые файлы не пропускаются.  
  
-   В некоторых системах <xref:System.IO.FileSystemWatcher> сообщает об изменениях в файлах, используя краткий формат имени файла 8,3. Например, изменение "Лонгфиленаме. Лонжекстенсион" может быть получено как "Лонгфил ~. Долгота ".  
  
-   Этот класс содержит требования связывания и наследования на уровне класса, которые применяются ко всем элементам. Если непосредственно вызывающий оператор или производный класс не имеет разрешения полного доверия, возникает исключение <xref:System.Security.SecurityException>. Дополнительные сведения о требованиях безопасности см. в разделе [Требования связывания](~/docs/framework/misc/link-demands.md).  
  
-   Максимальный размер, который можно задать для свойства <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> для мониторинга каталога по сети, составляет 64 КБ.  
  
> [!NOTE]
>  Запуск <xref:System.IO.FileSystemWatcher> в Windows 98 не поддерживается.  
  
## <a name="copying-and-moving-folders"></a>Копирование и перемещение папок  
 Операционная система и <xref:System.IO.FileSystemWatcher> объект обрабатывают действие вырезания и вставки или действие перемещения как действие переименования для папки и ее содержимого. При вырезании и вставке папки с файлами в отслеживаемую папку объект <xref:System.IO.FileSystemWatcher> сообщает только о новой папке, но не ее содержимом, так как они по сути переименованы.  
  
 Чтобы получать уведомления о том, что содержимое папок было перемещено или скопировано в наблюдаемую папку, укажите методы обработчика событий <xref:System.IO.FileSystemWatcher.OnChanged%2A> и <xref:System.IO.FileSystemWatcher.OnRenamed%2A>, как описано в следующей таблице.  
  
|Обработчик событий|Обработано событий|Выполняем|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Отчет об изменениях в атрибутах файлов, созданных файлах и удаленных файлах.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Перечислите старый и новый пути переименованных файлов и папок, при необходимости рекурсивно развернув их.|  
  
## <a name="events-and-buffer-sizes"></a>События и размеры буферов  
 Обратите внимание, что некоторые факторы могут влиять на то, какие события изменения файловой системы вызываются, как описано ниже:  
  
-   Общие операции файловой системы могут вызвать более одного события. Например, при перемещении файла из одного каталога в другой могут возникнуть несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые события <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A>. Перемещение файла — это сложная операция, состоящая из нескольких простых операций, в результате чего вызывается несколько событий. Аналогичным образом, некоторые приложения (например, антивирусная программа) могут вызвать дополнительные события файловой системы, обнаруженные <xref:System.IO.FileSystemWatcher>.  
  
-   <xref:System.IO.FileSystemWatcher> может просматривать диски, пока они не переключаются или не удаляются. <xref:System.IO.FileSystemWatcher> не создает события для компакт-дисков и DVD-дисков, так как метки времени и свойства не могут изменяться. Для правильной работы компонента на удаленных компьютерах должна быть установлена одна из необходимых платформ.  
  
-   Если несколько объектов <xref:System.IO.FileSystemWatcher> отслеживают один и тот же UNC-путь в Windows XP, предшествующий пакету обновления 1 (SP1) или Windows 2000 SP2 или более ранней версии, то событие будет вызвано только одним из этих объектов. На компьютерах под управлением Windows XP с пакетом обновления 1 (SP1) и более поздних версий, Windows 2000 SP3 или более поздней версии или Windows Server 2003 все объекты <xref:System.IO.FileSystemWatcher> будут вызывать соответствующие события.  
  
 Обратите внимание, что <xref:System.IO.FileSystemWatcher> может пропускать событие при превышении размера буфера. Чтобы избежать отсутствия событий, следуйте приведенным ниже рекомендациям.  
  
-   Увеличьте размер буфера, задав свойство <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
-   Избегайте просмотра файлов с длинными именами файлов, так как полное имя файла будет заполнять буфер. Рекомендуется переименовать эти файлы, используя более короткие имена.  
  
-   Постарайтесь, чтобы код обработки событий был как можно более коротким.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` времени, создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу выводится на консоль. При переименовании файла старый и новый пути выводятся на консоль.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">для наследования от класса <see cref="T:System.Diagnostics.ProcessStartInfo" />. Значение требования: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Именованные наборы разрешений: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Использование компонента FileSystemWatcher в форме Windows Forms</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нельзя наблюдать за удаленным компьютером, на котором не установлена ОС Windows NT или Windows 2000. Невозможно наблюдать за удаленным компьютером Windows NT 4,0 с компьютера Windows NT 4,0.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.IO.FileSystemWatcher>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|побитовое или сочетание `LastWrite`, `FileName`и `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"(Смотреть все файлы)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|пустая строка ("")|  
  
> [!NOTE]
>  Компонент не будет наблюдать за указанным каталогом, пока не закончится <xref:System.IO.FileSystemWatcher.Path%2A>, а <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Объект <xref:System.IO.FileSystemWatcher> наблюдает за изменениями в `LastWrite` и `LastAccess` раз, а также для создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу отображается в консоли. При переименовании файла старый и новый пути отображаются в консоли.  
  
 В этом примере используются пространства имен <xref:System.Diagnostics> и <xref:System.IO>.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Контролируемый каталог в стандартной записи или в записи UNC.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" /> с заданным каталогом для контроля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Компонент не будет наблюдать за указанным каталогом, пока не закончится <xref:System.IO.FileSystemWatcher.Path%2A>, а <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`.  
  
 Компонент может просматривать файлы на личном компьютере, сетевом диске или на удаленном компьютере.  
  
 Нельзя наблюдать за удаленным компьютером, на котором не установлена ОС Windows NT или Windows 2000. Невозможно наблюдать за удаленным компьютером Windows NT 4,0 с компьютера Windows NT 4,0. Для просмотра всех файлов свойство <xref:System.IO.FileSystemWatcher.Filter%2A> установлено по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> представляет собой пустую строку ("").  
  
- или - 
Путь, заданный параметром <paramref name="path" />, не существует.</exception>
        <exception cref="T:System.IO.PathTooLongException">Параметр <paramref name="path" /> имеет слишком большую длину.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Контролируемый каталог в стандартной записи или в записи UNC.</param>
        <param name="filter">Тип отслеживаемых файлов. Например, *.txt означает отслеживание изменений во всех текстовых файлах.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" /> с заданным каталогом и типом файлов для контроля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Компонент не будет наблюдать за указанным каталогом, пока не закончится <xref:System.IO.FileSystemWatcher.Path%2A>, а <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`.  
  
 Компонент может просматривать файлы на личном компьютере, сетевом диске или на удаленном компьютере.  
  
 Нельзя наблюдать за удаленным компьютером, на котором не установлена ОС Windows NT или Windows 2000. Невозможно наблюдать за удаленным компьютером Windows NT 4,0 с компьютера Windows NT 4,0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> представляет собой пустую строку ("").  
  
- или - 
Путь, заданный параметром <paramref name="path" />, не существует.</exception>
        <exception cref="T:System.IO.PathTooLongException">Параметр <paramref name="path" /> имеет слишком большую длину.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Полный уровень доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию класса <see cref="T:System.IO.FileSystemWatcher" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.IO.FileSystemWatcher.EndInit%2A> завершает инициализацию. Использование методов <xref:System.IO.FileSystemWatcher.BeginInit%2A> и <xref:System.IO.FileSystemWatcher.EndInit%2A> предотвращает использование элемента управления до полной инициализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.IO.FileSystemWatcher.Changed> возникает при внесении изменений в размер, системные атрибуты, время последней записи, время последнего доступа или разрешения безопасности файла или каталога в отслеживаемом каталоге.  
  
> [!NOTE]
>  Общие операции файловой системы могут вызвать более одного события. Например, при перемещении файла из одного каталога в другой могут возникнуть несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые события <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A>. Перемещение файла — это сложная операция, состоящая из нескольких простых операций, в результате чего вызывается несколько событий. Аналогичным образом, некоторые приложения (например, антивирусная программа) могут вызвать дополнительные события файловой системы, обнаруженные <xref:System.IO.FileSystemWatcher>.  
  
 Используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, чтобы ограничить количество уведомлений, создаваемых при обработке этого события.  
  
> [!NOTE]
>  Событие <xref:System.IO.FileSystemWatcher.Changed> неожиданно вызывается при переименовании файла, но не вызывается при переименовании каталога. Чтобы отслеживать переименование, используйте событие <xref:System.IO.FileSystemWatcher.Renamed>.  
  
> [!NOTE]
>  Порядок, в котором событие <xref:System.IO.FileSystemWatcher.Changed> возникает в связи с другими событиями <xref:System.IO.FileSystemWatcher>, может измениться, если свойство <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> не `null`.  
  
   
  
## Examples  
 В следующем примере используется событие <xref:System.IO.FileSystemWatcher.Changed> для вывода пути к файлу консоли при каждом изменении наблюдаемого файла.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при создании файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые распространенные случаи, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно событию, но эти случаи вызывают события. При копировании файла или каталога система создает событие <xref:System.IO.FileSystemWatcher.Created> в каталоге, в который был скопирован файл, если этот каталог контролируется. Если копируемый каталог был просмотрен другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не будет вызвано. Например, можно создать два экземпляра <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлен для просмотра «Мои документы», а FileSystemWatcher2 — «К:\йоур Documents». Если скопировать файл из папки «Мои документы» в папку «Мои документы», FileSystemWatcher2 будет вызывать событие <xref:System.IO.FileSystemWatcher.Created>, но для FileSystemWatcher1 не порождается событие. В отличие от копирования, перемещение файла или каталога вызовет два события. В предыдущем примере, если вы переместили файл из папки "Мои документы" в "Мои документы" <xref:System.IO.FileSystemWatcher.Created>, FileSystemWatcher2 событие будет вызвано исключением, а <xref:System.IO.FileSystemWatcher.Deleted> будет вызвано событием FileSystemWatcher1.  
  
> [!NOTE]
>  Общие операции файловой системы могут вызвать более одного события. Например, при перемещении файла из одного каталога в другой могут возникнуть несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые события <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A>. Перемещение файла — это сложная операция, состоящая из нескольких простых операций, в результате чего вызывается несколько событий. Аналогичным образом, некоторые приложения (например, антивирусная программа) могут вызвать дополнительные события файловой системы, обнаруженные <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Порядок, в котором событие <xref:System.IO.FileSystemWatcher.Created> возникает в связи с другими событиями <xref:System.IO.FileSystemWatcher>, может измениться, если свойство <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> не `null`.  
  
 Событие <xref:System.IO.FileSystemWatcher.OnCreated%2A> возникает сразу же после создания файла. Если файл копируется или передается в наблюдаемый каталог, будет немедленно вызвано событие <xref:System.IO.FileSystemWatcher.OnCreated%2A>, за которым следует одно или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> событий.  
  
   
  
## Examples  
 В следующем примере используется событие <xref:System.IO.FileSystemWatcher.Created> для вывода пути к файлу консоли при каждом создании наблюдаемого файла.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые распространенные случаи, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно событию, но эти случаи вызывают события. При копировании файла или каталога система создает событие <xref:System.IO.FileSystemWatcher.Created> в каталоге, в который был скопирован файл, если этот каталог контролируется. Если копируемый каталог был просмотрен другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не будет вызвано. Например, можно создать два экземпляра <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлен для просмотра «Мои документы», а FileSystemWatcher2 — «К:\йоур Documents». Если скопировать файл из папки «Мои документы» в папку «Мои документы», FileSystemWatcher2 будет вызывать событие <xref:System.IO.FileSystemWatcher.Created>, но для FileSystemWatcher1 не порождается событие. В отличие от копирования, перемещение файла или каталога вызовет два события. В предыдущем примере, если вы переместили файл из папки "Мои документы" в "Мои документы" <xref:System.IO.FileSystemWatcher.Created>, FileSystemWatcher2 событие будет вызвано исключением, а <xref:System.IO.FileSystemWatcher.Deleted> будет вызвано событием FileSystemWatcher1.  
  
> [!NOTE]
>  Общие операции файловой системы могут вызвать более одного события. Например, при перемещении файла из одного каталога в другой могут возникнуть несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые события <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A>. Перемещение файла — это сложная операция, состоящая из нескольких простых операций, в результате чего вызывается несколько событий. Аналогичным образом, некоторые приложения (например, антивирусная программа) могут вызвать дополнительные события файловой системы, обнаруженные <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Порядок, в котором событие <xref:System.IO.FileSystemWatcher.Deleted> возникает в связи с другими событиями <xref:System.IO.FileSystemWatcher>, может измениться, если свойство <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> не `null`.  
  
   
  
## Examples  
 В следующем примере используется событие <xref:System.IO.FileSystemWatcher.Deleted> для вывода пути к файлу консоли при каждом удалении наблюдаемого файла.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает неуправляемые ресурсы, используемые <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.IO.FileSystemWatcher" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается с помощью открытого метода <xref:System.ComponentModel.Component.Dispose%2A> и метода <xref:System.Object.Finalize%2A>. <xref:System.ComponentModel.Component.Dispose%2A> вызывает защищенный метод <xref:System.IO.FileSystemWatcher.Dispose%2A> с параметром `disposing`, для которого задано значение `true`. <xref:System.Object.Finalize%2A> вызывает <xref:System.IO.FileSystemWatcher.Dispose%2A> с `disposing`, установленным в `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.IO.Compression.DeflateStream>. Этот метод вызывает метод <xref:System.ComponentModel.Component.Dispose%2A> каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see cref="M:System.ComponentModel.Component.Dispose" /> может вызываться несколько раз другими объектами. При переопределении <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> следует избегать ссылок на объекты, которые ранее были удалены в предыдущем вызове <see cref="M:System.ComponentModel.Component.Dispose" />. Дополнительные сведения о реализации <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see cref="M:System.ComponentModel.Component.Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, доступен ли данный компонент.</summary>
        <value><see langword="true" />, если данный компонент разрешен; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />. При использовании этого компонента в конструкторе в [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], значение по умолчанию равно <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Компонент не будет создавать события, если для <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> не задано значение `true`.  
  
> [!NOTE]
>  Компонент не будет наблюдать за указанным каталогом, пока не за<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> свойство <xref:System.IO.FileSystemWatcher.Path%2A> и не `true`.  
  
 Метод <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> позволяет вызывать обработчики событий для реагирования на изменения файлов, даже если это свойство имеет значение `false`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` времени, создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу выводится на консоль. При переименовании файла старый и новый пути выводятся на консоль.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.IO.FileSystemWatcher" /> был удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти каталог, указанный в <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException">Объект <see cref="P:System.IO.FileSystemWatcher.Path" /> не был задан или является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заканчивается инициализация объекта <see cref="T:System.IO.FileSystemWatcher" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.IO.FileSystemWatcher.BeginInit%2A> запускает инициализацию. Использование методов <xref:System.IO.FileSystemWatcher.BeginInit%2A> и <xref:System.IO.FileSystemWatcher.EndInit%2A> предотвращает использование элемента управления до полной инициализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда экземпляру <see cref="T:System.IO.FileSystemWatcher" /> не удается продолжить отслеживание изменений, или при переполнении внутреннего буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает всякий раз, когда что-либо предотвращает отслеживание изменений в объекте <xref:System.IO.FileSystemWatcher>. Например, если объект отслеживает изменения в удаленном каталоге и подключение к этому каталогу потеряно, возникает событие <xref:System.IO.FileSystemWatcher.Error>.  
  
 Система уведомляет вас об изменениях в файлах и сохраняет эти изменения в буфере, который создается компонентом и передается интерфейсам API. Если в течение короткого промежутка времени произошло много изменений, буфер может переполниться. В результате компонент теряет возможность отслеживания изменений в каталоге и предоставит только общие уведомления. Увеличение размера буфера занимает много ресурсов, так как оно поступает из памяти, не являющейся страничной, и не может быть переключена на диск, поэтому буфер должен быть как можно более мелким. Чтобы избежать переполнения буфера, используйте свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, чтобы отфильтровать ненужные уведомления об изменениях.  
  
> [!NOTE]
>  Общие операции файловой системы могут вызвать более одного события. Например, при перемещении файла из одного каталога в другой могут возникнуть несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые события <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A>. Перемещение файла — это сложная операция, состоящая из нескольких простых операций, в результате чего вызывается несколько событий. Аналогичным образом, некоторые приложения (например, антивирусная программа) могут вызвать дополнительные события файловой системы, обнаруженные <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку фильтра, используемую для определения файлов, контролируемых в каталоге.</summary>
        <value>Строка фильтра. Значение по умолчанию — "*.\*"(отслеживание всех файлов)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы просмотреть изменения во всех файлах, присвойте свойству <xref:System.IO.FileSystemWatcher.Filter%2A> пустую строку (""). Чтобы просмотреть конкретный файл, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> имя файла. Например, чтобы отслеживать изменения в файле Мидок. txt, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> значение "Мидок. txt". Кроме того, можно отслеживать изменения в файле определенного типа. Например, чтобы отслеживать изменения в любом текстовом файле, задайте для свойства <xref:System.IO.FileSystemWatcher.Filter%2A> значение "*. txt". Использование нескольких фильтров, например "\*. txt&#124;\*. doc", не поддерживается.  
  
 Свойство <xref:System.IO.FileSystemWatcher.Filter%2A> можно изменить после того, как объект <xref:System.IO.FileSystemWatcher> начал получать события.  
  
 Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе Свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> принимает подстановочные знаки для совпадающих файлов, как показано в следующих примерах.  
  
|Строка фильтра|Наблюдает за следующими файлами|  
|-------------------|---------------------------------|  
|*.\*|Все файлы (по умолчанию). Пустая строка ("") также отслеживает все файлы.|  
|*. txt|Все файлы с расширением "txt".|  
|* рецепт. doc|Все файлы, которые заканчиваются на "рецепт", с расширением "doc".|  
|вин*. XML|Все файлы, начинающиеся с "Win", с расширением "XML".|  
|Продажи * 200?. XLS|Соответствует следующему:<br /><br />-Sales Июль 2001 г. xls <br/>-Sales авг 2002. xls <br/>-Sales март 2004. xls<br /><br /> но не соответствует:<br /><br />-Sales ноября 1999 г. xls|  
|Под MyReport. doc|Наблюдает только под MyReport. doc|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` времени, создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу выводится на консоль. При переименовании файла старый и новый пути выводятся на консоль.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех фильтров, используемых для определения файлов, контролируемых в каталоге.</summary>
        <value>Коллекция фильтров.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, удерживаемые текущим экземпляром.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> Код приложения не вызывает этот метод. он автоматически вызывается во время сборки мусора, если окончательное завершение сборщика мусора не отключено. Дополнительные сведения см. в разделах <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> и <xref:System.Object.Finalize>. Этот метод переопределяет метод <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее необходимость контроля вложенных каталогов по указанному пути.</summary>
        <value><see langword="true" />, если требует контроль вложенных каталогов; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте для параметра <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> значение `true`, если требуется отслеживать уведомления об изменениях для файлов и каталогов, содержащихся в каталоге, указанном с помощью свойства <xref:System.IO.FileSystemWatcher.Path%2A> и его подкаталогов. Установка свойства <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> в значение `false` помогает уменьшить количество уведомлений, отправляемых во внутренний буфер. Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе Свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
 При `true`<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> является рекурсивным по всему поддереву, а не только к непосредственным дочерним каталогам. Относительный путь к файлу или каталогу во вложенном дереве возвращается в свойстве <xref:System.IO.FileSystemEventArgs.Name%2A> <xref:System.IO.FileSystemEventArgs> и свойстве <xref:System.IO.RenamedEventArgs.OldName%2A> <xref:System.IO.RenamedEventArgs>в зависимости от наблюдаемых изменений. Полный путь можно получить из свойства <xref:System.IO.FileSystemEventArgs.FullPath%2A> <xref:System.IO.FileSystemEventArgs> и свойства <xref:System.IO.RenamedEventArgs.OldFullPath%2A> <xref:System.IO.RenamedEventArgs>в зависимости от наблюдаемых изменений.  
  
 Если каталог создается в поддереве отслеживаемого каталога и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> `true`, этот каталог будет автоматически отслеживаться.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает размер (в байтах) внутреннего буфера.</summary>
        <value>Размер внутреннего буфера в байтах. Значение по умолчанию — 8192 (8 КБ).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер буфера можно задать в 4 КБ или больше, но он не должен превышать 64 КБ. Если вы попытаетесь задать для свойства <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> значение меньше 4096 байт, оно будет удалено, а свойство <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> — в значение 4096 байт. Для достижения оптимальной производительности используйте несколько из 4 КБ на компьютерах на базе процессоров Intel.  
  
 Система уведомляет компонент об изменениях файла и сохраняет эти изменения в буфере, который создается компонентом и передается в интерфейсы API. Каждое событие может использовать до 16 байт памяти, не включая имя файла. Если в течение короткого промежутка времени произошло много изменений, буфер может переполниться. В результате компонент теряет возможность отслеживания изменений в каталоге и предоставит только общие уведомления. Увеличение размера буфера может препятствовать отсутствию событий изменения файловой системы. Однако увеличение размера буфера занимает много ресурсов, так как происходит из нестраничной памяти, которую невозможно переключить на диск, поэтому размер буфера должен быть как можно меньше. Чтобы избежать переполнения буфера, используйте свойства <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, чтобы отфильтровать ненужные уведомления об изменениях.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип отслеживаемых изменений.</summary>
        <value>Одно из значений перечисления <see cref="T:System.IO.NotifyFilters" />. По умолчанию это побитовое сочетание OR-значений <see langword="LastWrite" />, <see langword="FileName" /> и <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Члены перечислений <xref:System.IO.NotifyFilters> можно объединять для отслеживания нескольких типов изменений за один раз. Например, можно отслеживать изменения размера файла, а также изменения времени `LastWrite`. Это вызывает событие в любое время, когда изменяется размер файла или папки или изменяется время `LastWrite` файла или папки.  
  
 Это один из способов фильтрации нежелательных уведомлений. Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе Свойства <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` времени, создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу выводится на консоль. При переименовании файла старый и новый пути выводятся на консоль.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Эта величина не является действительным побитовым сочетанием OR-значений <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Задаваемое значение является недопустимым.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> вызывается при внесении изменений в размер, системные атрибуты, время последней записи, время последнего доступа или разрешения безопасности файла или каталога в отслеживаемом каталоге.  
  
 Используйте свойство <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, чтобы ограничить количество событий, возникающих при обработке события <xref:System.IO.FileSystemWatcher.Changed>.  
  
 Событие <xref:System.IO.FileSystemWatcher.OnCreated%2A> возникает сразу же после создания файла. Если файл копируется или передается в наблюдаемый каталог, будет немедленно вызвано событие <xref:System.IO.FileSystemWatcher.OnCreated%2A>, за которым следует одно или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> событий.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [Обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> в производном классе обязательно вызовите метод <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> базового класса.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> вызывается при создании файла или каталога в отслеживаемом каталоге.  
  
 Некоторые распространенные случаи, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно событию, но эти случаи вызывают события. При копировании файла или каталога система создает событие <xref:System.IO.FileSystemWatcher.Created> в каталоге, в который был скопирован файл, если этот каталог контролируется. Если копируемый каталог был просмотрен другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не будет вызвано. Например, можно создать два экземпляра <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлен для просмотра «Мои документы», а FileSystemWatcher2 — «К:\йоур Documents». Если скопировать файл из папки «Мои документы» и вставить его в «мои документы», то в FileSystemWatcher2 будет создано событие <xref:System.IO.FileSystemWatcher.Created>, но для FileSystemWatcher1 не порождается событие. В отличие от копирования, перемещение файла или каталога вызывает два события. В предыдущем примере, если вы переместили файл из папки "Мои документы" в "Мои документы", в FileSystemWatcher2 будет создано событие <xref:System.IO.FileSystemWatcher.Created>, а в FileSystemWatcher1 будет создано событие <xref:System.IO.FileSystemWatcher.Deleted>.  
  
 Событие <xref:System.IO.FileSystemWatcher.OnCreated%2A> возникает сразу же после создания файла. Если файл копируется или передается в наблюдаемый каталог, будет немедленно вызвано событие <xref:System.IO.FileSystemWatcher.OnCreated%2A>, за которым следует одно или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> событий.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [Обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> в производном классе обязательно вызовите метод <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> базового класса.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> вызывается при удалении файла или каталога в отслеживаемом каталоге.  
  
 Некоторые распространенные случаи, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно событию, но эти случаи вызывают события. При копировании файла или каталога система создает событие <xref:System.IO.FileSystemWatcher.Created> в каталоге, в который был скопирован файл, если этот каталог контролируется. Если копируемый каталог был просмотрен другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не будет вызвано. Например, можно создать два экземпляра <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлен для просмотра «Мои документы», а FileSystemWatcher2 — «К:\йоур Documents». Если скопировать файл из папки «Мои документы» в папку «Мои документы», FileSystemWatcher2 будет вызывать событие <xref:System.IO.FileSystemWatcher.Created>, но для FileSystemWatcher1 не порождается событие. В отличие от копирования, перемещение файла или каталога вызывает два события. В предыдущем примере, если вы переместили файл из папки "Мои документы" в "Мои документы" <xref:System.IO.FileSystemWatcher.Created>, FileSystemWatcher2 событие будет вызвано исключением, а <xref:System.IO.FileSystemWatcher.Deleted> будет вызвано событием FileSystemWatcher1.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [Обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> в производном классе обязательно вызовите метод <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> базового класса.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.IO.ErrorEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> вызывается при возникновении ошибки.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [Обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> в производном классе обязательно вызовите метод <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> базового класса.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.RenamedEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> вызывается при переименовании файла или каталога в отслеживаемом каталоге. Его <xref:System.IO.RenamedEventArgs> аргумент содержит сведения об операции переименования, такие как тип изменения, старый и новый путь, а также старое и новое имя. Обратите внимание, что свойство <xref:System.IO.FileSystemEventArgs.Name> может иметь значение NULL для переименованных событий, если <xref:System.IO.FileSystemWatcher> не получает совпадающих старых и новых событий имени из операционной системы. 
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [Обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> в производном классе обязательно вызовите метод <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> базового класса.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает путь отслеживаемого каталога.</summary>
        <value>Путь для отслеживания. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это полный путь к каталогу. Если свойство <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> имеет значение `true`, то это корневой каталог, в котором система наблюдает за изменениями; в противном случае это единственный отслеживаемый каталог. Чтобы просмотреть определенный файл, задайте для свойства <xref:System.IO.FileSystemWatcher.Path%2A> полное имя, правильный каталог, а в свойстве <xref:System.IO.FileSystemWatcher.Filter%2A> значение имени файла.  
  
 Свойство <xref:System.IO.FileSystemWatcher.Path%2A> поддерживает пути в формате UNC.  
  
> [!NOTE]
>  Это свойство должно быть установлено до того, как компонент может отслеживать изменения.  
  
 При переименовании каталога <xref:System.IO.FileSystemWatcher> автоматически повторно присоединяется к вновь переименованному элементу. Например, если задать для свойства <xref:System.IO.FileSystemWatcher.Path%2A> значение "\ мои документы", а затем вручную переименовать каталог в "документы К:\йоур", компонент продолжит прослушивать уведомления об изменениях во вновь переименованном каталоге. Однако при запросе свойства <xref:System.IO.FileSystemWatcher.Path%2A> оно содержит старый путь. Это происходит потому, что компонент определяет, какой каталог отслеживается на основе этого маркера, а не имени каталога. Переименование не влияет на этот обработчик. Таким образом, если вы уничтожаете компонент, а затем воссоздаете его без обновления свойства <xref:System.IO.FileSystemWatcher.Path%2A>, произойдет сбой приложения, так как каталог больше не существует.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для просмотра каталога, указанного во время выполнения. Компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` времени, создания, удаления или переименования текстовых файлов в каталоге. Если файл был изменен, создан или удален, путь к файлу выводится на консоль. При переименовании файла старый и новый пути выводятся на консоль.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Заданный путь не существует или не может быть найден.  
  
 - или -  
  
 Заданный путь содержит подстановочные знаки.  
  
 - или -  
  
 Заданный путь содержит недопустимые символы.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переименовании файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие `Renamed` является делегатом <xref:System.IO.RenamedEventHandler>, который имеет следующую сигнатуру:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Объект <xref:System.IO.RenamedEventArgs> предоставляет сведения об операции переименования, такие как тип переименования (свойство <xref:System.IO.FileSystemEventArgs.ChangeType>), старое и новое имя, а также старый и новый путь. Обратите внимание, что свойство <xref:System.IO.FileSystemEventArgs.Name> может иметь значение NULL для переименованных событий, если <xref:System.IO.FileSystemWatcher> не получает совпадающих старых и новых событий имени из операционной системы.

 Переименование просматриваемого каталога не приведет к появлению уведомления. Уведомления создаются только для записей внутри отслеживаемого каталога.  
  
   
  
## Examples  
 В следующем примере используется событие <xref:System.IO.FileSystemWatcher.Renamed> для вывода пути к файлу консоли при каждом переименовании наблюдаемого файла.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип <see cref="T:System.ComponentModel.ISite" /> для объекта <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>Интерфейс <see cref="T:System.ComponentModel.ISite" /> для <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сайты привязывают <xref:System.ComponentModel.Component> к <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> и обеспечивают обмен данными между ними, а также предоставляют контейнеру способ управления его компонентами.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, инициированных в результате изменения каталога.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />, который описывает объект, используемый для маршалинга вызовов обработчика событий, инициированных в результате изменения каталога. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> `null`, методы, обрабатывающие события <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>и <xref:System.IO.FileSystemWatcher.Renamed>, вызываются в потоке из пула системных потоков. Дополнительные сведения о пулах системных потоков см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда события <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>и <xref:System.IO.FileSystemWatcher.Renamed> обрабатываются компонентом Visual Windows Forms, например <xref:System.Windows.Forms.Button>, доступ к компоненту через пул системных потоков может не работать или может привести к исключению. Избегайте этого, установив <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> в Windows Forms компоненте, который вызывает вызов методов, обрабатывающих события <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>и <xref:System.IO.FileSystemWatcher.Renamed>, в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.IO.FileSystemWatcher> используется в [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> автоматически задается элементу управления, содержащему <xref:System.IO.FileSystemWatcher>. Например, при помещении <xref:System.IO.FileSystemWatcher> в конструктор для Form1 (который наследуется от <xref:System.Windows.Forms.Form>) свойству <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> <xref:System.IO.FileSystemWatcher> присваивается экземпляр Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Отслеживаемый объект <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях, с заданным типом изменений, которые вы хотите контролировать.</summary>
        <returns>Объект <see cref="T:System.IO.WaitForChangedResult" />, содержащий сведения о произошедших изменениях.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ожидает бесконечно до тех пор, пока не произойдет первое изменение, а затем вернет. Это аналогично использованию <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> с параметром `timeout`, установленным в значение-1.  
  
> [!NOTE]
>  Этот метод позволяет вызывать обработчик событий для реагирования на изменения файла, даже если свойство <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> имеет значение `false`.  
  
 В некоторых системах <xref:System.IO.FileSystemWatcher> сообщает об изменениях в файлах, используя краткий формат имени файла 8,3. Например, изменение "Лонгфиленаме. Лонжекстенсион" может быть получено как "Лонгфи ~. Долгота ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Отслеживаемый объект <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <param name="timeout">Время ожидания (в миллисекундах) до таймаута.</param>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях, с заданным типом изменений, которые вы хотите контролировать, и временем ожидания (в мс) до блокировки по ожиданию.</summary>
        <returns>Объект <see cref="T:System.IO.WaitForChangedResult" />, содержащий сведения о произошедших изменениях.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ожидает, пока не произойдет изменение или не истечет время ожидания. Значение-1 для параметра `timeout` означает неограниченное время ожидания.  
  
> [!NOTE]
>  Этот метод позволяет вызывать обработчик событий для реагирования на изменения файла, даже если свойство <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> имеет значение `false`.  
  
 В некоторых системах <xref:System.IO.FileSystemWatcher> сообщает об изменениях в файлах, используя краткий формат имени файла 8,3. Например, изменение "Лонгфиленаме. Лонжекстенсион" может быть получено как "Лонгфи ~. Долгота ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
