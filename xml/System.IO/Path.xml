<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbceb05c56c65218177af6b97840c0c9b2ab8ae0" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74386287" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information. These operations are performed in a cross-platform manner.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Путь — это строка, которая предоставляет расположение файла или каталога. Путь не обязательно указывает на расположение на диске; Например, путь может сопоставляться с расположением в памяти или на устройстве. Точный формат пути определяется текущей платформой. Например, в некоторых системах путь может начинаться с буквы диска или тома, а этот элемент отсутствует в других системах. В некоторых системах пути к файлам могут содержать расширения, которые указывают тип данных, хранящихся в файле. Формат расширения имени файла зависит от платформы; Например, некоторые системы ограничивают расширения тремя символами, а другие — нет. Текущая платформа также определяет набор символов, используемых для разделения элементов пути, и набор символов, которые не могут быть использованы при указании путей. Из-за этих различий поля класса `Path`, а также точное поведение некоторых членов класса `Path` являются зависимыми от платформы.  
  
 Путь может содержать абсолютные или относительные сведения о расположении. Абсолютные пути полностью указывают расположение: файл или каталог могут быть однозначно идентифицированы независимо от текущего расположения. Относительные пути указывают на неполное расположение: текущее расположение используется в качестве отправной точки при поиске файла, указанного относительного пути. Чтобы определить текущий каталог, вызовите <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  

 .NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают доступ к объектам файловой системы, которые являются именами устройств, например "\\? \c:\".

Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).

 Большинство членов класса `Path` не взаимодействуют с файловой системой и не проверяют существование файла, указанного в строке пути. `Path` члены класса, которые изменяют строку пути, например <xref:System.IO.Path.ChangeExtension%2A>, не влияют на имена файлов в файловой системе. Однако `Path` члены выполняют проверку содержимого указанной строки пути и вызывают исключение <xref:System.ArgumentException>, если строка содержит недопустимые символы в строках пути, как определено в символах, возвращаемых методом <xref:System.IO.Path.GetInvalidPathChars%2A>. Например, на настольных платформах Windows недопустимые символы пути могут содержать кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и символы Юникода от 16 до 18 и от 20 до 25.  
  
 Члены класса `Path` позволяют быстро и легко выполнять стандартные операции, такие как определение того, является ли расширение имени файла частью пути, и объединение двух строк в одно имя пути.  
  
 Все члены класса `Path` являются статическими и поэтому могут быть вызваны без наличия экземпляра пути.  
  
> [!NOTE]
>  В членах, принимающих путь в качестве входной строки, этот путь должен иметь правильный формат или возникнет исключение. Например, если путь является полным, но начинается с пробела, путь не усекается в методах класса. Поэтому путь имеет неправильный формат и возникает исключение. Аналогично, путь или сочетание путей не могут быть полными и дважды. Например, "c:\temp c:\Windows" также вызывает исключение в большинстве случаев. При использовании методов, принимающих строку пути, убедитесь, что пути имеют правильный формат.  
  
 В членах, принимающих путь, путь может ссылаться на файл или только на каталог. Указанный путь может также ссылаться на относительный путь или путь в формате UNC для имени сервера и общего ресурса. Например, все следующие допустимые пути:  
  
-   "c:\\\Мидир\\\Мифиле.ткст" in C#или "к:\мидир\мифиле.ткст" в Visual Basic.  
  
-   "c:\\\Мидир" in C#или "к:\мидир" в Visual Basic.  
  
-   "MyDir\\\Мисубдир" in C#или "мидир\мисубдир" в Visual Basic.  
  
-   "\\\\\\\Мисервер\\\Мишаре" in C#или "\\\MyServer\MyShare" в Visual Basic.  
  
 Так как все эти операции выполняются на строках, невозможно проверить, являются ли результаты допустимыми во всех сценариях. Например, метод <xref:System.IO.Path.GetExtension%2A> анализирует строку, которую вы передали в нее, и возвращает расширение из этой строки. Однако это не означает, что на диске существует файл с таким расширением.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).   
  
## Examples  
 В следующем примере показаны некоторые из основных элементов класса `Path`.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Это поле может иметь то же значение, что и <xref:System.IO.Path.DirectorySeparatorChar>. `AltDirectorySeparatorChar` и <xref:System.IO.Path.DirectorySeparatorChar> допустимы для разделения уровней каталога в строке пути.  
  
Значением этого поля является косая черта ("/") в операционных системах Windows и UNIX.  
  
## Examples  

В следующем примере отображаются значения полей <xref:System.IO.Path> в Windows и в системах на базе UNIX. Обратите внимание, что Windows поддерживает либо прямую косую черту (которая возвращается полем <xref:System.IO.Path.AltDirectorySeparatorChar>), либо обратную косую черту (которая возвращается полем <xref:System.IO.Path.DirectorySeparatorChar>) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path information to modify. The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">The new extension (with or without a leading period). Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</param>
        <summary>Changes the extension of a path string.</summary>
        <returns>The modified path information.  
  
On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified. If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed. If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ни `path`, ни `extension` не содержат точку (.), `ChangeExtension` добавляет точку.  
  
 Параметр `extension` может содержать несколько точек, а также любые допустимые символы пути и могут иметь любую длину. Если `extension` `null`, возвращаемая строка содержит содержимое `path` с последним периодом и все символы после него удалены.  
  
 Если `extension` является пустой строкой, возвращаемая строка пути содержит содержимое `path` с любыми символами после последнего удаленного периода.  
  
 Если `path` не имеет расширения и `extension` не `null`, возвращаемая строка содержит `path`, за которой следует `extension`.  
  
 Если `extension` не `null` и не содержит начальную точку, добавляется точка.  
  
 Если `path` содержит несколько расширений, разделенных несколькими точками, возвращаемая строка содержит содержимое `path` с последним периодом, а все символы после него заменены на `extension`. Например, если `path` имеет значение "\Dir1\examples\pathtests.CSX.txt", а `extension` — "CS", измененный путь — "\Dir1\examples\pathtests.CSX.cs".  
  
 Невозможно проверить, что возвращенные результаты являются допустимыми во всех сценариях. Например, если `path` пустой, добавляется `extension`.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода `ChangeExtension`.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combines strings into a path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Этот метод предназначен для сцепления отдельных строк в одну строку, представляющую путь к файлу. Однако если аргумент, отличный от первого, содержит корневой путь, все компоненты предыдущего пути игнорируются, а возвращаемая строка начинается с этого компонента корневого пути. В качестве альтернативы методу `Combine` можно использовать методы <xref:System.IO.Path.Join%2A> или <xref:System.IO.Path.TryJoin%2A>.

> [!IMPORTANT]
> В этом методе предполагается, что первый аргумент представляет собой абсолютный путь, а следующий аргумент или аргументы являются относительными путями. Если это не так, и, в частности, если какие-либо последующие аргументы являются строками, введенными пользователем, вызовите метод <xref:System.IO.Path.Join%2A> или <xref:System.IO.Path.TryJoin%2A>.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">An array of parts of the path.</param>
        <summary>Combines an array of strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` должен быть массивом частей пути для объединения. Если один из последующих путей представляет собой абсолютный путь, операция объединения сбрасывается, начиная с этого абсолютного пути, отменяя все предыдущие объединенные пути.  

Если какой-либо элемент в `paths`, но последний из них не является диском и не заканчивается ни <xref:System.IO.Path.DirectorySeparatorChar>, ни <xref:System.IO.Path.AltDirectorySeparatorChar> символом, метод `Combine` добавляет символ <xref:System.IO.Path.DirectorySeparatorChar> между этим элементом и следующим. Обратите внимание, что если элемент заканчивается в символе разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Строки нулевой длины опускаются из Объединенного пути.  
  
 Параметры не анализируются, если они содержат пробелы.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется методом `Combine`.  
  
## Examples  
 В следующем примере массив строк объединяется в путь.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">One of the strings in the array is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <summary>Combines two strings into a path.</summary>
        <returns>The combined paths. If one of the specified paths is a zero-length string, this method returns the other path. If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `path1` не является ссылкой на диск (т. е. "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> добавляется к `path1` перед объединением. Обратите внимание, что если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет символ разделителя исходного пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` включает корень, возвращается `path2`.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1` вместо возврата только `path2`.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется методом `Combine`.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода `Combine` на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <param name="path3">The third path to combine.</param>
        <summary>Combines three strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик"). Если `path2` или `path3` также является абсолютным путем, операция объединения удаляет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.  
  
 Строки нулевой длины опускаются из Объединенного пути.  
  
 Если `path1` или `path2` не является ссылкой на диск (то есть "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> добавляется к `path1` или `path2` перед объединением. Обратите внимание, что если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` включает корень, возвращается `path2`.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1`.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется методом `Combine`.  
  
   
  
## Examples  
 В следующем примере объединяются три пути.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <param name="path3">The third path to combine.</param>
        <param name="path4">The fourth path to combine.</param>
        <summary>Combines four strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик"). Если один из последующих путей также является абсолютным путем, операция объединения отменяет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.  
  
 Строки нулевой длины опускаются из Объединенного пути.  
  
 Если `path1`, `path2`или `path3` не является ссылкой на диск (то есть "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, перед сцеплением добавляется к нему <xref:System.IO.Path.DirectorySeparatorChar>. Обратите внимание, что если `path1`, `path2`или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` включает корень, возвращается `path2`.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1`.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется методом `Combine`.  
  
   
  
## Examples  
 В следующем примере объединяются четыре пути.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> и `DirectorySeparatorChar` допустимы для разделения уровней каталога в строке пути.  
  
При использовании .NET Core для разработки приложений, работающих на нескольких платформах:

- Если вы предпочитаете жестко кодировать символ разделителя каталогов, следует использовать символ косой черты (`/`). Это единственный распознаваемый символ-разделитель в системах UNIX, так как выходные данные в примере показаны и являются <xref:System.IO.Path.AltDirectorySeparatorChar> в Windows.

- Используйте объединение строк для динамического извлечения символа разделителя пути во время выполнения и его включения в пути файловой системы. Пример: 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   Можно также получить значение из свойства <xref:System.IO.Path.AltDirectorySeparatorChar>, так как оно одинаково в системах на базе Windows и Ункс.

- Получение свойства <xref:System.IO.Path.AltDirectorySeparatorChar>

Если приложение не является кросс-платформенным, можно использовать разделитель, соответствующий вашей системе.

## Examples  

В следующем примере отображаются значения полей <xref:System.IO.Path> в Windows и в системах на базе UNIX. Обратите внимание, что Windows поддерживает либо прямую косую черту (которая возвращается полем <xref:System.IO.Path.AltDirectorySeparatorChar>), либо обратную косую черту (которая возвращается полем <xref:System.IO.Path.DirectorySeparatorChar>) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to analyze.</param>
        <summary>Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</summary>
        <returns><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to analyze.</param>
        <summary>Returns a value that indicates whether the specified path ends in a directory separator.</summary>
        <returns><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to retrieve the directory information from.</param>
        <summary>Returns the directory information for the specified path represented by a character span.</summary>
        <returns>Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of a file or directory.</param>
        <summary>Returns the directory information for the specified path string.</summary>
        <returns>Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null. Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев строка, возвращаемая этим методом, состоит из всех символов в пути вплоть до, но не включает последние <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>. Если путь состоит из корневого каталога, например "c:\\", возвращается значение null. Обратите внимание, что этот метод не поддерживает пути, использующие "file:". Так как возвращаемый путь не включает <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, передача возвращенного пути обратно в метод <xref:System.IO.Path.GetDirectoryName%2A> приведет к усечению одного уровня папки на последующий вызов в результирующей строке. Например, передача пути "К:\директори\субдиректори\тест.ткст" в метод <xref:System.IO.Path.GetDirectoryName%2A> возвратит "К:\директори\субдиректори". Передача этой строки "К:\директори\субдиректори" в <xref:System.IO.Path.GetDirectoryName%2A> приведет к появлению "К:\директори".  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода `GetDirectoryName` на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  
  
</para>
          </block>  
  
 The <paramref name="path" /> parameter is longer than the system-defined maximum length.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The file path from which to get the extension.</param>
        <summary>Returns the extension of a file path that is represented by a read-only character span.</summary>
        <returns>The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Этот метод получает расширение `path` путем поиска `path` в течение точки ("."), начиная с последнего символа в диапазоне, доступном только для чтения, и заканчивая его первым символом. Если точка обнаруживается до <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar> символа, возвращаемый диапазон, предназначенный только для чтения, содержит точку и символы после него. в противном случае возвращается <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path string from which to get the extension.</param>
        <summary>Returns the extension (including the period ".") of the specified path string.</summary>
        <returns>The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />. If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />. If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Этот метод получает расширение `path` путем поиска `path` в течение точки (.), начиная с последнего символа в `path` и заканчивая первым символом. Если точка обнаруживается до <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar> символа, возвращаемая строка содержит точку и символы после него; в противном случае возвращается <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
 
## Examples  
 В следующем примере демонстрируется использование метода `GetExtension` на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span that contains the path from which to obtain the file name and extension.</param>
        <summary>Returns the file name and extension of a file path that is represented by a read-only character span.</summary>
        <returns>The characters after the last directory separator character in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Возвращаемый диапазон только для чтения содержит символы пути, следующие за последним разделителем в `path`. Если последним символом в `path` является символ или разделитель каталога, метод возвращает <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>. Если `path` не содержит символа разделителя, метод возвращает `path`.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path string from which to obtain the file name and extension.</param>
        <summary>Returns the file name and extension of the specified path string.</summary>
        <returns>The characters after the last directory separator character in <paramref name="path" />. If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />. If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Возвращаемое значение `null`, если путь к файлу `null`.  
  
Символы разделения, используемые для определения начала имени файла, — это <xref:System.IO.Path.DirectorySeparatorChar> и <xref:System.IO.Path.AltDirectorySeparatorChar>.  

Поскольку *\\* является допустимым именем файла в Unix, `GetFileName`, выполняемые на платформах UNIX, не могут правильно вернуть имя файла из пути на основе Windows, например *C:\\MyDir\\MyFile. ext*, но `GetFileName` выполняется в Платформы на основе Windows могут правильно возвращать имя файла из пути на основе UNIX, например */ТМП/мифиле.екст*, поэтому поведение метода `GetFileName` не является строго одинаковым на платформах на базе UNIX и Windows.

Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется поведение метода `GetFileName` на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span that contains the path from which to obtain the file name without the extension.</param>
        <summary>Returns the file name without the extension of a file path that is represented by a read-only character span.</summary>
        <returns>The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of the file.</param>
        <summary>Returns the file name of the specified path string without the extension.</summary>
        <returns>The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не проверяет существование пути или имени файла.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода `GetFileNameWithoutExtension`.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The file or directory for which to obtain absolute path information.</param>
        <summary>Returns the absolute path for the specified path string.</summary>
        <returns>The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Абсолютный путь включает все сведения, необходимые для поиска файла или каталога в системе.  
  
 Файл или каталог, заданный `path`, не обязательно должен существовать. Например, если *к:\темп\невдир* является текущим каталогом, вызов `GetFullPath` для имени файла, например *Test. txt* , возвращает *к:\темп\невдир\тест.ткст*. Файл не должен существовать.  

> [!IMPORTANT]
> Если `path` является относительным путем, эта перегрузка возвращает полный путь, который может быть основан на текущем диске и текущем каталоге. Текущий диск и текущий каталог могут измениться в любое время при выполнении приложения. В результате путь, возвращаемый этой перегрузкой, не может быть определен заранее. Чтобы вернуть детерминированный путь, вызовите перегрузку <xref:System.IO.Path.GetFullPath(System.String,System.String)>. Можно также вызвать метод <xref:System.IO.Path.IsPathFullyQualified%2A>, чтобы определить, является ли путь полным или относительным, и, следовательно, требуется ли вызов `GetFullPath`.

 Однако если `path` существует, вызывающий объект должен иметь разрешение на получение сведений о пути для `path`. Обратите внимание, что, в отличие от большинства членов класса <xref:System.IO.Path>, этот метод обращается к файловой системе.  
  
 Этот метод использует сведения о текущем каталоге и текущем томе для полного определения `path`. Если имя файла указывается только в `path`, `GetFullPath` возвращает полный путь к текущему каталогу.  
  
 Если передать короткое имя файла, оно будет расширено до длинного имени файла.  
  
 Если путь не содержит значащих символов, он является недопустимым, если он не содержит один или несколько символов ".", за которыми следует любое количество пробелов; Затем он будет проанализирован как "." или "..".  

.NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают пути, включающие имена устройств, например "\\? \c:\".

Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md). Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
  
## Examples  
 В следующем примере демонстрируется метод `GetFullPath` на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-or- 
The system could not retrieve the absolute path.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A relative path to concatenate to <paramref name="basePath" />.</param>
        <param name="basePath">The beginning of a fully qualified path.</param>
        <summary>Returns an absolute path from a fully qualified base path and a relative path.</summary>
        <returns>The absolute path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Если `path` является пустым путем, метод возвращает `basePath`. Если `path` является полным путем, метод передает `path` методу <xref:System.IO.Path.GetFullPath(System.String)> и возвращает результат.

Этот метод используется для возврата детерминированного пути на основе указанного тома и корневого каталога при использовании относительных путей. Использование предопределенной `basePath`, а не на основе текущего каталога диска, защищает от нежелательных путей к файлам, вызванных непредвиденными изменениями в текущем диске и каталоге. 

## <a name="example"></a>Пример

В следующем примере определяется переменная `basePath`для представления текущего каталога приложения. Затем он передает его методу `GetFullPath`, чтобы получить полный путь к каталогу данных приложения.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> is not a fully qualified path.

-or-

<paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array containing the characters that are not allowed in file names.</summary>
        <returns>An array containing the characters that are not allowed in file names.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.IO.Path.GetInvalidFileNameChars%2A> и метод <xref:System.IO.Path.GetInvalidPathChars%2A> для получения недопустимых символов.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array containing the characters that are not allowed in path names.</summary>
        <returns>An array containing the characters that are not allowed in path names.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
   
  
## Examples  
 В следующем примере демонстрируется метод <xref:System.IO.Path.GetInvalidFileNameChars%2A> и метод <xref:System.IO.Path.GetInvalidPathChars%2A> для получения недопустимых символов.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span of characters containing the path from which to obtain root directory information.</param>
        <summary>Gets the root directory information from the path contained in the specified character span.</summary>
        <returns>A read-only span of characters containing the root directory of <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод не проверяет, существует ли путь или файл.

В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.

`ReadOnlySpan<System.Char>` является "фактически пустым", если:

- В Windows вызов <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> для этого диапазона символов возвращает `true`, или все его символы являются пробелами ("").
- В UNIX вызов <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> для этого диапазона символов возвращает `true`.

Ниже приведены возможные шаблоны для диапазона символов только для чтения, возвращаемого этим методом.

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` был <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` указан относительный путь к текущему диску или тому).

- "\" (UNIX: `path` указан абсолютный путь на текущем диске).

- "X:" (Windows: `path` указывает относительный путь на диске, где *X* представляет букву диска или тома).

- "X:\" (Windows: `path` указали абсолютный путь на заданном диске).

- "\\\Компутернаме\шаредфолдер" (Windows: путь UNC).

- "\\\\\?\c:" (Windows: путь к устройству DOS, поддерживаемый в .NET Core 1,1 и более поздних версиях, а в .NET Framework 4.6.2 и более поздних версий).
 
Дополнительные сведения о путях к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md). Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A string containing the path from which to obtain root directory information.</param>
        <summary>Gets the root directory information from the path contained in the specified string.</summary>
        <returns>The root directory of <paramref name="path" /> if it is rooted.

-or- 
<see cref="P:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.

-or- 
<see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод не проверяет, существует ли путь или файл.

Этот метод позволяет нормализовать разделители каталогов.

Строка "фактически пуста", если:

- В Windows вызов `IsEmpty` для этой строки возвращает `true`, либо все символы являются пробелами ("").
- В UNIX вызов <xref:System.String.IsNullOrEmpty%2A> для этой строки возвращает `true`.

Ниже приведены возможные шаблоны для строки, возвращаемой этим методом.

- `null` (`path` имеет значение null или пустая строка).

- Пустая строка (`path` указан относительный путь к текущему диску или тому).

- "\" (UNIX: `path` указан абсолютный путь на текущем диске).

- "X:" (Windows: `path` указывает относительный путь на диске, где *X* представляет букву диска или тома).

- "X:\" (Windows: `path` указали абсолютный путь на заданном диске).

- "\\\Компутернаме\шаредфолдер" (Windows: путь UNC).

- "\\\\\?\c:" (Windows: путь к устройству DOS, поддерживаемый в .NET Core 1,1 и более поздних версиях, а в .NET Framework 4.6.2 и более поздних версий).
 
Дополнительные сведения о путях к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md). Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).

## Examples
В следующем примере демонстрируется использование метода `GetPathRoot`.

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.

-or-

.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a random folder name or file name.</summary>
        <returns>A random folder name or file name.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.Path.GetRandomFileName%2A> возвращает криптографически надежную, случайную строку, которую можно использовать как имя папки или имя файла. В отличие от <xref:System.IO.Path.GetTempFileName%2A><xref:System.IO.Path.GetRandomFileName%2A> не создает файл. Когда безопасность файловой системы имеет первостепенное значение, этот метод следует использовать вместо <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 В следующем примере показаны выходные данные метода <xref:System.IO.Path.GetRandomFileName%2A>.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">The source path the result should be relative to. This path is always considered to be a directory.</param>
        <param name="path">The destination path.</param>
        <summary>Returns a relative path from one path to another.</summary>
        <returns>The relative path, or <paramref name="path" /> if the paths don't share the same root.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Пути разрешаются путем вызова метода <xref:System.IO.Path.GetFullPath%2A> перед вычислением разницы. Метод использует сравнение по пути к файлам по умолчанию для текущей платформы (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> для Windows и MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> для Linux. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</summary>
        <returns>The full path of the temporary file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает временный файл с. Расширение файла TMP. Временный файл создается во временной папке пользователя, которая является путем, возвращаемым методом <xref:System.IO.Path.GetTempPath%2A>.  
  
 Метод <xref:System.IO.Path.GetTempFileName%2A> вызовет <xref:System.IO.IOException>, если он используется для создания более чем 65535 файлов без удаления предыдущих временных файлов.  
  
 Метод <xref:System.IO.Path.GetTempFileName%2A> вызовет <xref:System.IO.IOException>, если уникальное имя временного файла недоступно. Чтобы устранить эту ошибку, удалите все ненужные временные файлы.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs, such as no unique temporary file name is available.  
  
-or-
  
 This method was unable to create a temporary file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи во временный каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the path of the current user's temporary folder.</summary>
        <returns>The path to the temporary folder, ending with a backslash.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет наличие переменных среды в следующем порядке и использует первый найденный путь:  
  
1.  Путь, заданный переменной среды TMP.  
  
2.  Путь, заданный переменной среды TEMP.  
  
3.  Путь, заданный переменной среды USERPROFILE.  
  
4.  Каталог Windows.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов метода <xref:System.IO.Path.GetTempPath%2A>.  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 В этом примере создаются выходные данные, аналогичные приведенным ниже.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для неограниченного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to search for an extension.</param>
        <summary>Determines whether the path represented by the specified character span includes a file name extension.</summary>
        <returns><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Завершающий период в `path` не считается расширением.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path to search for an extension.</param>
        <summary>Determines whether a path includes a file name extension.</summary>
        <returns><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с конца `path`этот метод ищет точку (.), за которой следует по крайней мере один символ. Если этот шаблон найден до тех пор, пока встречается <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar> символ, этот метод возвращает `true`.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `HasExtension`.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
> [!CAUTION]
>  Не используйте <xref:System.IO.Path.InvalidPathChars> если вы считаете, что код может выполняться в том же домене приложения, что и ненадежный код. <xref:System.IO.Path.InvalidPathChars> является массивом, поэтому его элементы могут быть перезаписаны. Если ненадежный код перезаписывает элементы <xref:System.IO.Path.InvalidPathChars>, это может привести к неправильному использованию кода.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование свойства `InvalidPathChars`.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Returns a value that indicates whether a file path is fully qualified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Перегрузки метода `IsPathFullyQualified` обработают пути, в которых используются как <xref:System.IO.Path.DirectorySeparatorChar>, так и <xref:System.IO.Path.AltDirectorySeparatorChar> символы. Проверка пути, переданного в качестве аргумента, не выполняется. В результате URI интерпретируется как относительные пути и возвращают `false`. 

Существует разница между полным путем (как указано в методе `IsPathFullyQualified`) и корневым путем (как указано в методе <xref:System.IO.Path.IsPathRooted%2A>). *Полный* путь или *абсолютный путь* всегда определяет точный путь от конкретного диска или устройства к целевому файлу или каталогу и не зависит от текущего диска или текущего каталога. Например, в Windows Systems, *C:/Users/User1/Documents/Reports/2019/Январь/основные сведения. PDF* определяет абсолютный путь от корня диска C: к целевому файлу, *подсвечивает. PDF*. *Корневой путь* указывает либо начальный диск, либо корневой каталог, но зависит либо от текущего каталога (если он находится в корневом каталоге на указанном диске), либо от текущего диска (если он корневым каталогом). В следующем примере показано различие между полными путями и корневыми путями.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A file path.</param>
        <summary>Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</summary>
        <returns><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A file path.</param>
        <summary>Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</summary>
        <returns><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод обрабатывает пути, использующие разделитель альтернативного каталога. Часто возникает ошибка, когда предполагается, что пути с корнем (<xref:System.IO.Path.IsPathRooted(System.String)>) не относительны. Например, "К:а" — это относительный диск, то есть он разрешается в текущий каталог для C: (с корнем, но относительно). "К:\а" является корневым и относительным, т. е. текущий каталог не используется для изменения пути.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Returns a value that indicates whether a file path contains a root.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

**Путь к корневому каталогу** — это путь к файлу, исправленный на определенный диск или Уник путь; Он отличается от пути, относящегося к текущему диску или рабочему каталогу. Например, в системах Windows корневой путь начинается с обратной косой черты (например, "\Documents") или буквы диска и двоеточия (например, "К:документс"). 

Обратите внимание, что корневые пути могут быть абсолютными (то есть полными) или относительными. Абсолютный корневой путь — это полный путь от корня диска к определенному каталогу. Относительный корневой путь указывает диск, но его полный путь разрешается в текущий каталог. В следующем примере демонстрируется это различие.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to test.</param>
        <summary>Returns a value that indicates whether the specified character span that represents a file path contains a root.</summary>
        <returns><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path to test.</param>
        <summary>Returns a value indicating whether the specified path string contains a root.</summary>
        <returns><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.Path.IsPathRooted%2A> возвращает `true`, если первый символ является символом разделителя каталога, например "\\", или если путь начинается с буквы диска и двоеточия (:). Например, он возвращает `true` для `path` строк, таких как "\\\Мидир\\\Мифиле.ткст", "C:\\\Мидир" или "К:Мидир". Он возвращает `false` для строк `path`, таких как "MyDir".  
  
 Этот метод не проверяет существование пути или имени файла.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  

## Examples  
 В следующем примере показано, как можно использовать метод `IsPathRooted` для проверки трех строк.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">An array of paths.</param>
        <summary>Concatenates an array of paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто сцепляет все строки в `paths` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует. Если <xref:System.String.Length> любого из путей в `paths` равен нулю, Метод сцепляет оставшиеся аргументы. Если результирующая Объединенная строка имеет нулевую длину, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если любой из путей в `paths`, за исключением последнего, заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (То есть, если какой-либо из путей в `paths`, за исключением последнего, является абсолютным путем, метод `Join` не удаляет предыдущие пути, как метод <xref:System.IO.Path.Combine%2A>.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <summary>Concatenates two path components into a single path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Этот метод просто объединяет `path` и `path2` и добавляет символ разделителя каталога между двумя компонентами пути, если он еще не существует в конце `path1` или в начале `path2`. Если <xref:System.ReadOnlySpan%601.Length> либо `path1`, либо `path2` равны нулю, метод возвращает другой путь. Если <xref:System.ReadOnlySpan%601.Length> обоих `path1` и `path2` равны нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>. 

Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows. 

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (То есть, если `path2` является абсолютным путем, метод `Join` не удаляет `path1` и возвращает `path2`, как и метод <xref:System.IO.Path.Combine%2A>.) В следующем примере показана разница в путях, возвращаемых двумя методами. Если источник `path2` является входными данными пользователя, метод <xref:System.IO.Path.Combine%2A> позволяет пользователю получить доступ к ресурсу файловой системы (например, *C:/Users/User1/Documents/Financial/* в случае примера), который приложение не предполагало сделать доступным.  

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его. 

## <a name="example"></a>Пример

В следующем примере показана разница в путях, возвращаемых методами <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> и <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType>. Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты. Во втором и третьем вызове метода `ShowPathInformation` строки, возвращаемые двумя методами, расходятся. Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом. Метод `Join` объединяет две строки и сохраняет дублирующиеся разделители путей. Метод `Combine` отменяет диск и возвращает корневой каталог на текущем диске. Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:. Наконец, поскольку оба аргумента в третьем вызове `ShowPathInformation` являются корневыми, метод `Join` просто добавляет их для создания пути к файлу бессмысленное, а метод `Combine` удаляет первую строку и возвращает вторую. Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <summary>Concatenates two paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path` и `path2` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если длина `path1` или `path2` равна нулю, метод объединяет оставшийся аргумент. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (Т. е. Если `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <summary>Concatenates three path components into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Этот метод просто объединяет `path`, `path2`и `path3` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если <xref:System.ReadOnlySpan%601.Length> любого из аргументов `path1`, `path2`или `path3` равен нулю, Метод сцепляет оставшиеся аргументы. Если <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равен нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (То есть, если `path2` или `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.
  
Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

## <a name="example"></a>Пример

В следующем примере показана разница в путях, возвращаемых методами <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> и <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType>. Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты. Во втором и третьем вызове метода `ShowPathInformation` строки, возвращаемые двумя методами, расходятся. Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом. Метод `Join` объединяет две строки и сохраняет дублирующиеся разделители путей. Вызов метода <xref:System.IO.Path.GetFullPath%2A> исключит дублирование. Метод `Combine` отменяет диск и возвращает корневой каталог на текущем диске. Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:. Наконец, поскольку последний аргумент в третьем вызове `ShowPathInformation` является корневым, метод `Join` просто добавляет его к первым двум аргументам, чтобы создать путь к файлу бессмысленное, а метод `Combine` удаляет первые две строки и возвращает третий. Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <param name="path3">The third path to join.</param>
        <summary>Concatenates three paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path`, `path2`и `path3` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если длина любого из аргументов `path1`, `path2` или `path3` равна нулю, Метод сцепляет оставшиеся аргументы. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (То есть, если `path2` или `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <param name="path4">A character span that contains the fourth path to join.</param>
        <summary>Concatenates four path components into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path`, `path2`, `path3` и `path4` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если <xref:System.ReadOnlySpan%601.Length> любого из `path1`, `path2`, `path3` или `path4` аргумент равен нулю, Метод сцепляет оставшиеся аргументы. Если <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равен нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если `path1` или `path2` или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (Т. е. Если `path2` или `path2` или `path3` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <param name="path3">The third path to join.</param>
        <param name="path4">The fourth path to join.</param>
        <summary>Concatenates four paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path`, `path2`, `path3` и `path4` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если длина любого из аргументов `path1`, `path2`, `path3` или `path4` равна нулю, Метод сцепляет оставшиеся аргументы. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.

Если `path1` или `path2` или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.

В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути. (Т. е. Если `path2` или `path2` или `path3` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска. Таким образом, метод `Join` успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A platform-specific separator character used to separate path strings in environment variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На настольных платформах под управлением Windows значением этого поля является точка с запятой (;) по умолчанию, но может различаться на других платформах.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование поля `PathSeparator`.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to trim.</param>
        <summary>Trims one trailing directory separator beyond the root of the specified path.</summary>
        <returns>The <paramref name="path" /> without any trailing directory separators.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to trim.</param>
        <summary>Trims one trailing directory separator beyond the root of the specified path.</summary>
        <returns>The <paramref name="path" /> without any trailing directory separators.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Диапазон символов назначения должен быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в следующем примере.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="destination">A character span to hold the concatenated path.</param>
        <param name="charsWritten">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</param>
        <summary>Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <returns><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Размер `destination` должен быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в примере.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <param name="destination">A character span to hold the concatenated path.</param>
        <param name="charsWritten">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</param>
        <summary>Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <returns><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Размер `destination` должен быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в примере.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific volume separator character.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого поля является двоеточием (:) в ОС Windows и Macintosh и косая черта (/) в операционных системах UNIX. Это наиболее полезно для таких путей синтаксического анализа, как c:\Windows или Макволуме: системная папка.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование поля `VolumeSeparatorChar`.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
  </Members>
</Type>
