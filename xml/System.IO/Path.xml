<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbceb05c56c65218177af6b97840c0c9b2ab8ae0" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/06/2019" /><Meta Name="ms.locfileid" Value="74386287" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8d67e-101">Выполняет операции для экземпляров класса <see cref="T:System.String" />, содержащих сведения о пути к файлу или каталогу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="8d67e-102">Эти операции выполняются межплатформенным способом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8d67e-103">Путь — это строка, которая предоставляет расположение файла или каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="8d67e-104">Путь не обязательно указывает на расположение на диске; Например, путь может сопоставляться с расположением в памяти или на устройстве.</span><span class="sxs-lookup"><span data-stu-id="8d67e-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="8d67e-105">Точный формат пути определяется текущей платформой.</span><span class="sxs-lookup"><span data-stu-id="8d67e-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="8d67e-106">Например, в некоторых системах путь может начинаться с буквы диска или тома, а этот элемент отсутствует в других системах.</span><span class="sxs-lookup"><span data-stu-id="8d67e-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="8d67e-107">В некоторых системах пути к файлам могут содержать расширения, которые указывают тип данных, хранящихся в файле.</span><span class="sxs-lookup"><span data-stu-id="8d67e-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="8d67e-108">Формат расширения имени файла зависит от платформы; Например, некоторые системы ограничивают расширения тремя символами, а другие — нет.</span><span class="sxs-lookup"><span data-stu-id="8d67e-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="8d67e-109">Текущая платформа также определяет набор символов, используемых для разделения элементов пути, и набор символов, которые не могут быть использованы при указании путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="8d67e-110">Из-за этих различий поля класса `Path`, а также точное поведение некоторых членов класса `Path` являются зависимыми от платформы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="8d67e-111">Путь может содержать абсолютные или относительные сведения о расположении.</span><span class="sxs-lookup"><span data-stu-id="8d67e-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="8d67e-112">Абсолютные пути полностью указывают расположение: файл или каталог могут быть однозначно идентифицированы независимо от текущего расположения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="8d67e-113">Относительные пути указывают на неполное расположение: текущее расположение используется в качестве отправной точки при поиске файла, указанного относительного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="8d67e-114">Чтобы определить текущий каталог, вызовите <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="8d67e-115">.NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают доступ к объектам файловой системы, которые являются именами устройств, например "\\? \c:\".</span><span class="sxs-lookup"><span data-stu-id="8d67e-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8d67e-116">Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="8d67e-117">Большинство членов класса `Path` не взаимодействуют с файловой системой и не проверяют существование файла, указанного в строке пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="8d67e-118">`Path` члены класса, которые изменяют строку пути, например <xref:System.IO.Path.ChangeExtension%2A>, не влияют на имена файлов в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="8d67e-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="8d67e-119">Однако `Path` члены выполняют проверку содержимого указанной строки пути и вызывают исключение <xref:System.ArgumentException>, если строка содержит недопустимые символы в строках пути, как определено в символах, возвращаемых методом <xref:System.IO.Path.GetInvalidPathChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="8d67e-120">Например, на настольных платформах Windows недопустимые символы пути могут содержать кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и символы Юникода от 16 до 18 и от 20 до 25.</span><span class="sxs-lookup"><span data-stu-id="8d67e-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="8d67e-121">Члены класса `Path` позволяют быстро и легко выполнять стандартные операции, такие как определение того, является ли расширение имени файла частью пути, и объединение двух строк в одно имя пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="8d67e-122">Все члены класса `Path` являются статическими и поэтому могут быть вызваны без наличия экземпляра пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d67e-123">В членах, принимающих путь в качестве входной строки, этот путь должен иметь правильный формат или возникнет исключение.</span><span class="sxs-lookup"><span data-stu-id="8d67e-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="8d67e-124">Например, если путь является полным, но начинается с пробела, путь не усекается в методах класса.</span><span class="sxs-lookup"><span data-stu-id="8d67e-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="8d67e-125">Поэтому путь имеет неправильный формат и возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="8d67e-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="8d67e-126">Аналогично, путь или сочетание путей не могут быть полными и дважды.</span><span class="sxs-lookup"><span data-stu-id="8d67e-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="8d67e-127">Например, "c:\temp c:\Windows" также вызывает исключение в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="8d67e-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="8d67e-128">При использовании методов, принимающих строку пути, убедитесь, что пути имеют правильный формат.</span><span class="sxs-lookup"><span data-stu-id="8d67e-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="8d67e-129">В членах, принимающих путь, путь может ссылаться на файл или только на каталог.</span><span class="sxs-lookup"><span data-stu-id="8d67e-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="8d67e-130">Указанный путь может также ссылаться на относительный путь или путь в формате UNC для имени сервера и общего ресурса.</span><span class="sxs-lookup"><span data-stu-id="8d67e-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="8d67e-131">Например, все следующие допустимые пути:</span><span class="sxs-lookup"><span data-stu-id="8d67e-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="8d67e-132">"c:\\\Мидир\\\Мифиле.ткст" in C#или "к:\мидир\мифиле.ткст" в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8d67e-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8d67e-133">"c:\\\Мидир" in C#или "к:\мидир" в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8d67e-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8d67e-134">"MyDir\\\Мисубдир" in C#или "мидир\мисубдир" в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8d67e-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8d67e-135">"\\\\\\\Мисервер\\\Мишаре" in C#или "\\\MyServer\MyShare" в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8d67e-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="8d67e-136">Так как все эти операции выполняются на строках, невозможно проверить, являются ли результаты допустимыми во всех сценариях.</span><span class="sxs-lookup"><span data-stu-id="8d67e-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="8d67e-137">Например, метод <xref:System.IO.Path.GetExtension%2A> анализирует строку, которую вы передали в нее, и возвращает расширение из этой строки.</span><span class="sxs-lookup"><span data-stu-id="8d67e-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="8d67e-138">Однако это не означает, что на диске существует файл с таким расширением.</span><span class="sxs-lookup"><span data-stu-id="8d67e-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="8d67e-139">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="8d67e-140">В следующем примере показаны некоторые из основных элементов класса `Path`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-141">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-142">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-143">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="8d67e-144">Практическое руководство. Считывание из нового файла данных и запись в этот файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-145">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d67e-146">Предоставляет дополнительный символ, задаваемый платформой, для разделения уровней каталогов в строке пути, в которой отражена иерархическая организация файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8d67e-147">Это поле может иметь то же значение, что и <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="8d67e-148">`AltDirectorySeparatorChar` и <xref:System.IO.Path.DirectorySeparatorChar> допустимы для разделения уровней каталога в строке пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8d67e-149">Значением этого поля является косая черта ("/") в операционных системах Windows и UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="8d67e-150">В следующем примере отображаются значения полей <xref:System.IO.Path> в Windows и в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8d67e-151">Обратите внимание, что Windows поддерживает либо прямую косую черту (которая возвращается полем <xref:System.IO.Path.AltDirectorySeparatorChar>), либо обратную косую черту (которая возвращается полем <xref:System.IO.Path.DirectorySeparatorChar>) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.</span><span class="sxs-lookup"><span data-stu-id="8d67e-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-152">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-153">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-154">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-155">Сведения о пути, которые нужно изменить.</span><span class="sxs-lookup"><span data-stu-id="8d67e-155">The path information to modify.</span></span> <span data-ttu-id="8d67e-156">Путь не может содержать символы, определенные в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="8d67e-157">Новое расширение (начинающееся с точки или без нее).</span><span class="sxs-lookup"><span data-stu-id="8d67e-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="8d67e-158">Задает <see langword="null" /> для удаления существующего расширения из параметра <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="8d67e-159">Изменяет расширение строки пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-160">Измененные сведения о пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-160">The modified path information.</span></span>  
  
<span data-ttu-id="8d67e-161">В настольных системах, работающих под управлением Windows, сведения о пути возвращаются без изменений, если значение параметра <paramref name="path" /> равно <see langword="null" /> или пустой строке ("").</span><span class="sxs-lookup"><span data-stu-id="8d67e-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="8d67e-162">Если значение параметра <paramref name="extension" /> равно <see langword="null" />, возвращаемая строка содержит указанный путь без расширения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="8d67e-163">Если <paramref name="path" /> не имеет расширения и значение параметра <paramref name="extension" /> не равно <see langword="null" />, возвращаемая строка пути содержит <paramref name="extension" />, добавленное в конец <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-164">Если ни `path`, ни `extension` не содержат точку (.), `ChangeExtension` добавляет точку.</span><span class="sxs-lookup"><span data-stu-id="8d67e-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="8d67e-165">Параметр `extension` может содержать несколько точек, а также любые допустимые символы пути и могут иметь любую длину.</span><span class="sxs-lookup"><span data-stu-id="8d67e-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="8d67e-166">Если `extension` `null`, возвращаемая строка содержит содержимое `path` с последним периодом и все символы после него удалены.</span><span class="sxs-lookup"><span data-stu-id="8d67e-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="8d67e-167">Если `extension` является пустой строкой, возвращаемая строка пути содержит содержимое `path` с любыми символами после последнего удаленного периода.</span><span class="sxs-lookup"><span data-stu-id="8d67e-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="8d67e-168">Если `path` не имеет расширения и `extension` не `null`, возвращаемая строка содержит `path`, за которой следует `extension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="8d67e-169">Если `extension` не `null` и не содержит начальную точку, добавляется точка.</span><span class="sxs-lookup"><span data-stu-id="8d67e-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="8d67e-170">Если `path` содержит несколько расширений, разделенных несколькими точками, возвращаемая строка содержит содержимое `path` с последним периодом, а все символы после него заменены на `extension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="8d67e-171">Например, если `path` имеет значение "\Dir1\examples\pathtests.CSX.txt", а `extension` — "CS", измененный путь — "\Dir1\examples\pathtests.CSX.cs".</span><span class="sxs-lookup"><span data-stu-id="8d67e-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="8d67e-172">Невозможно проверить, что возвращенные результаты являются допустимыми во всех сценариях.</span><span class="sxs-lookup"><span data-stu-id="8d67e-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="8d67e-173">Например, если `path` пустой, добавляется `extension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="8d67e-174">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-175">В следующем примере демонстрируется использование метода `ChangeExtension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-176">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-177">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-178">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-179">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-180">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d67e-181">Объединяет строки в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8d67e-182">Этот метод предназначен для сцепления отдельных строк в одну строку, представляющую путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="8d67e-183">Однако если аргумент, отличный от первого, содержит корневой путь, все компоненты предыдущего пути игнорируются, а возвращаемая строка начинается с этого компонента корневого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="8d67e-184">В качестве альтернативы методу `Combine` можно использовать методы <xref:System.IO.Path.Join%2A> или <xref:System.IO.Path.TryJoin%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8d67e-185">В этом методе предполагается, что первый аргумент представляет собой абсолютный путь, а следующий аргумент или аргументы являются относительными путями.</span><span class="sxs-lookup"><span data-stu-id="8d67e-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="8d67e-186">Если это не так, и, в частности, если какие-либо последующие аргументы являются строками, введенными пользователем, вызовите метод <xref:System.IO.Path.Join%2A> или <xref:System.IO.Path.TryJoin%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="8d67e-187">Массив частей пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="8d67e-188">Объединяет массив строк в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-189">Объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8d67e-190">`paths` должен быть массивом частей пути для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="8d67e-191">Если один из последующих путей представляет собой абсолютный путь, операция объединения сбрасывается, начиная с этого абсолютного пути, отменяя все предыдущие объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="8d67e-192">Если какой-либо элемент в `paths`, но последний из них не является диском и не заканчивается ни <xref:System.IO.Path.DirectorySeparatorChar>, ни <xref:System.IO.Path.AltDirectorySeparatorChar> символом, метод `Combine` добавляет символ <xref:System.IO.Path.DirectorySeparatorChar> между этим элементом и следующим.</span><span class="sxs-lookup"><span data-stu-id="8d67e-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="8d67e-193">Обратите внимание, что если элемент заканчивается в символе разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8d67e-194">В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.</span><span class="sxs-lookup"><span data-stu-id="8d67e-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="8d67e-195">Строки нулевой длины опускаются из Объединенного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8d67e-196">Параметры не анализируются, если они содержат пробелы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="8d67e-197">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-198">Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-199">Поэтому он успешно интерпретируется методом `Combine`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="8d67e-200">В следующем примере массив строк объединяется в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-201">Одна из строк в массиве содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-202">Одна из строк в массиве имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-203">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-204">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-205">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="8d67e-206">Объединяет две строки в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-207">Объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-207">The combined paths.</span></span> <span data-ttu-id="8d67e-208">Если один из указанных путей является строкой нулевой длины, этот метод возвращает другой путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="8d67e-209">Если в качестве значения параметра <paramref name="path2" /> задан абсолютный путь, этот метод возвращает <paramref name="path2" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-210">Если `path1` не является ссылкой на диск (т. е. "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> добавляется к `path1` перед объединением.</span><span class="sxs-lookup"><span data-stu-id="8d67e-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="8d67e-211">Обратите внимание, что если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет символ разделителя исходного пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8d67e-212">В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.</span><span class="sxs-lookup"><span data-stu-id="8d67e-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="8d67e-213">Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя.</span><span class="sxs-lookup"><span data-stu-id="8d67e-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8d67e-214">Если `path2` включает корень, возвращается `path2`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8d67e-215">Параметры не анализируются, если они содержат пробелы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8d67e-216">Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1` вместо возврата только `path2`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="8d67e-217">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-218">Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-219">Поэтому он успешно интерпретируется методом `Combine`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="8d67e-220">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-221">В следующем примере демонстрируется использование метода `Combine` на платформе настольных компьютеров под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-222">Параметр <paramref name="path1" /> или <paramref name="path2" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-223">Значение параметра <paramref name="path1" /> или <paramref name="path2" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-224">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-225">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-226">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-227">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-228">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-229">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-230">Третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="8d67e-231">Объединяет три строки в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-232">Объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-233">`path1` должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик").</span><span class="sxs-lookup"><span data-stu-id="8d67e-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="8d67e-234">Если `path2` или `path3` также является абсолютным путем, операция объединения удаляет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8d67e-235">Строки нулевой длины опускаются из Объединенного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8d67e-236">Если `path1` или `path2` не является ссылкой на диск (то есть "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> добавляется к `path1` или `path2` перед объединением.</span><span class="sxs-lookup"><span data-stu-id="8d67e-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="8d67e-237">Обратите внимание, что если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8d67e-238">В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.</span><span class="sxs-lookup"><span data-stu-id="8d67e-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="8d67e-239">Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя.</span><span class="sxs-lookup"><span data-stu-id="8d67e-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8d67e-240">Если `path2` включает корень, возвращается `path2`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8d67e-241">Параметры не анализируются, если они содержат пробелы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8d67e-242">Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8d67e-243">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-244">Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-245">Поэтому он успешно интерпретируется методом `Combine`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-246">В следующем примере объединяются три пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-247"><paramref name="path1" />, <paramref name="path2" /> или <paramref name="path3" /> содержит по крайней мере один из недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-248">Значение параметра <paramref name="path1" />, <paramref name="path2" /> или <paramref name="path3" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-249">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-250">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-251">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-252">Третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="8d67e-253">Четвертый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="8d67e-254">Объединяет четыре строки в путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-255">Объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-256">`path1` должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик"). Если один из последующих путей также является абсолютным путем, операция объединения отменяет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8d67e-257">Строки нулевой длины опускаются из Объединенного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8d67e-258">Если `path1`, `path2`или `path3` не является ссылкой на диск (то есть "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar>, перед сцеплением добавляется к нему <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="8d67e-259">Обратите внимание, что если `path1`, `path2`или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Combine` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8d67e-260">В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.</span><span class="sxs-lookup"><span data-stu-id="8d67e-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="8d67e-261">Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя.</span><span class="sxs-lookup"><span data-stu-id="8d67e-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8d67e-262">Если `path2` включает корень, возвращается `path2`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8d67e-263">Параметры не анализируются, если они содержат пробелы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8d67e-264">Таким образом, если `path2` включает пробел (например, "\филе.ткст"), метод <xref:System.IO.Path.Combine%2A> добавляет `path2` к `path1`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8d67e-265">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Combine`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-266">Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недопустимым, если бы вы создавали файл из него, он будет действителен как строка поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-267">Поэтому он успешно интерпретируется методом `Combine`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-268">В следующем примере объединяются четыре пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> или <paramref name="path4" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-270">Параметр <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> или <paramref name="path4" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-271">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d67e-272">Предоставляет символ, задаваемый платформой, для разделения уровней папок в строке пути, в которой отражена иерархическая организация файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8d67e-273"><xref:System.IO.Path.AltDirectorySeparatorChar> и `DirectorySeparatorChar` допустимы для разделения уровней каталога в строке пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8d67e-274">При использовании .NET Core для разработки приложений, работающих на нескольких платформах:</span><span class="sxs-lookup"><span data-stu-id="8d67e-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="8d67e-275">Если вы предпочитаете жестко кодировать символ разделителя каталогов, следует использовать символ косой черты (`/`).</span><span class="sxs-lookup"><span data-stu-id="8d67e-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="8d67e-276">Это единственный распознаваемый символ-разделитель в системах UNIX, так как выходные данные в примере показаны и являются <xref:System.IO.Path.AltDirectorySeparatorChar> в Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="8d67e-277">Используйте объединение строк для динамического извлечения символа разделителя пути во время выполнения и его включения в пути файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="8d67e-278">Например, примененная к объекту директива</span><span class="sxs-lookup"><span data-stu-id="8d67e-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   <span data-ttu-id="8d67e-279">Можно также получить значение из свойства <xref:System.IO.Path.AltDirectorySeparatorChar>, так как оно одинаково в системах на базе Windows и Ункс.</span><span class="sxs-lookup"><span data-stu-id="8d67e-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="8d67e-280">Получение свойства <xref:System.IO.Path.AltDirectorySeparatorChar></span><span class="sxs-lookup"><span data-stu-id="8d67e-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="8d67e-281">Если приложение не является кросс-платформенным, можно использовать разделитель, соответствующий вашей системе.</span><span class="sxs-lookup"><span data-stu-id="8d67e-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="8d67e-282">В следующем примере отображаются значения полей <xref:System.IO.Path> в Windows и в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8d67e-283">Обратите внимание, что Windows поддерживает либо прямую косую черту (которая возвращается полем <xref:System.IO.Path.AltDirectorySeparatorChar>), либо обратную косую черту (которая возвращается полем <xref:System.IO.Path.DirectorySeparatorChar>) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.</span><span class="sxs-lookup"><span data-stu-id="8d67e-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-284">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-285">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-286">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-287">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-288">Путь для анализа.</span><span class="sxs-lookup"><span data-stu-id="8d67e-288">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="8d67e-289">Возвращает значение, указывающее, заканчивается ли путь, заданный в качестве диапазона, доступного только для чтения, в разделителе каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-289">Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="8d67e-290">Значение <see langword="true" />, если путь заканчивается в разделителе каталогов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-290"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-291">Путь для анализа.</span><span class="sxs-lookup"><span data-stu-id="8d67e-291">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="8d67e-292">Возвращает значение, указывающее, заканчивается ли заданный путь в разделителе каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-292">Returns a value that indicates whether the specified path ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="8d67e-293">Значение <see langword="true" />, если путь заканчивается в разделителе каталогов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-293"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-294">Путь для получения сведений о каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-294">The path to retrieve the directory information from.</span></span></param>
        <summary><span data-ttu-id="8d67e-295">Возвращает сведения о каталоге для указанного пути, представленного диапазоном символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-295">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="8d67e-296">Сведения о каталоге для <paramref name="path" /> либо пустой диапазон, если значение <paramref name="path" /> — <see langword="null" />, пустой диапазон или корневая папка, например \, C: или \\server\share.</span><span class="sxs-lookup"><span data-stu-id="8d67e-296">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-297">В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-297">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-298">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-298">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-299">Путь к файлу или каталогу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-299">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="8d67e-300">Возвращает для указанной строки пути сведения о каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-300">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-301">Сведения о каталоге для <paramref name="path" />, или значение <see langword="null" />, если путь <paramref name="path" /> указывает на корневой каталог или равен NULL.</span><span class="sxs-lookup"><span data-stu-id="8d67e-301">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="8d67e-302">Возвращает <see cref="F:System.String.Empty" />, если параметр <paramref name="path" /> не содержит сведения о каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-302">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-303">В большинстве случаев строка, возвращаемая этим методом, состоит из всех символов в пути вплоть до, но не включает последние <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-303">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="8d67e-304">Если путь состоит из корневого каталога, например "c:\\", возвращается значение null.</span><span class="sxs-lookup"><span data-stu-id="8d67e-304">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="8d67e-305">Обратите внимание, что этот метод не поддерживает пути, использующие "file:".</span><span class="sxs-lookup"><span data-stu-id="8d67e-305">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="8d67e-306">Так как возвращаемый путь не включает <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, передача возвращенного пути обратно в метод <xref:System.IO.Path.GetDirectoryName%2A> приведет к усечению одного уровня папки на последующий вызов в результирующей строке.</span><span class="sxs-lookup"><span data-stu-id="8d67e-306">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="8d67e-307">Например, передача пути "К:\директори\субдиректори\тест.ткст" в метод <xref:System.IO.Path.GetDirectoryName%2A> возвратит "К:\директори\субдиректори".</span><span class="sxs-lookup"><span data-stu-id="8d67e-307">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="8d67e-308">Передача этой строки "К:\директори\субдиректори" в <xref:System.IO.Path.GetDirectoryName%2A> приведет к появлению "К:\директори".</span><span class="sxs-lookup"><span data-stu-id="8d67e-308">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="8d67e-309">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-309">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-310">В следующем примере демонстрируется использование метода `GetDirectoryName` на платформе настольных компьютеров под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-310">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-311">Параметр <paramref name="path" /> пустой или содержит недопустимые символы либо только пробелы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-311">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="8d67e-312">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-312">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="8d67e-313">Имя параметра <paramref name="path" /> превышает максимально допустимую в системе длину.</span><span class="sxs-lookup"><span data-stu-id="8d67e-313">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-314">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-314">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-315">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-316">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-317">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-318">Путь к файлу, из которого необходимо получить расширение.</span><span class="sxs-lookup"><span data-stu-id="8d67e-318">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-319">Возвращает расширение из пути к файлу, представленного диапазоном символов только для чтения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-319">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8d67e-320">Расширение указанного пути (включая точку — ".") или <see cref="P:System.ReadOnlySpan`1.Empty" />, если в <paramref name="path" /> отсутствуют сведения о расширении.</span><span class="sxs-lookup"><span data-stu-id="8d67e-320">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8d67e-321">Этот метод получает расширение `path` путем поиска `path` в течение точки ("."), начиная с последнего символа в диапазоне, доступном только для чтения, и заканчивая его первым символом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-321">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="8d67e-322">Если точка обнаруживается до <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar> символа, возвращаемый диапазон, предназначенный только для чтения, содержит точку и символы после него. в противном случае возвращается <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-323">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-323">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-324">Строка пути, из которой нужно получить расширение.</span><span class="sxs-lookup"><span data-stu-id="8d67e-324">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-325">Возвращает расширение указанной строки пути (включая точку ".").</span><span class="sxs-lookup"><span data-stu-id="8d67e-325">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-326">Расширение указанного пути (включая точку ".") или значение <see langword="null" /> или <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-326">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8d67e-327">Если параметр <paramref name="path" /> имеет значение <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> возвращает <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-327">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="8d67e-328">Если параметр <paramref name="path" /> не содержит сведений о расширении, <see cref="M:System.IO.Path.GetExtension(System.String)" /> возвращает <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-328">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8d67e-329">Этот метод получает расширение `path` путем поиска `path` в течение точки (.), начиная с последнего символа в `path` и заканчивая первым символом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-329">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="8d67e-330">Если точка обнаруживается до <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar> символа, возвращаемая строка содержит точку и символы после него; в противном случае возвращается <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-330">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="8d67e-331">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-331">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="8d67e-332">В следующем примере демонстрируется использование метода `GetExtension` на платформе настольных компьютеров под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-332">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-333">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-333"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-334">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-334">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-335">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-335">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-336">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-336">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-337">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-337">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-338">Диапазон только для чтения, содержащий путь, из которого нужно получить имя и расширение файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-338">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-339">Возвращает имя и расширение файла из пути к файлу, представленного диапазоном символов только для чтения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-339">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8d67e-340">Символы, следующие за последним символом разделителя каталогов в пути <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-340">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8d67e-341">Возвращаемый диапазон только для чтения содержит символы пути, следующие за последним разделителем в `path`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-341">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="8d67e-342">Если последним символом в `path` является символ или разделитель каталога, метод возвращает <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-342">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d67e-343">Если `path` не содержит символа разделителя, метод возвращает `path`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-343">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-344">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-344">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-345">Строка пути, из которой нужно получить имя файла и расширение.</span><span class="sxs-lookup"><span data-stu-id="8d67e-345">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-346">Возвращает имя файла и расширение указанной строки пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-346">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-347">Символы, следующие за последним символом разделителя каталогов в пути <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-347">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="8d67e-348">Если последним символом параметра <paramref name="path" /> является символ разделения тома или каталога, этот метод возвращает <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-348">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8d67e-349">Если значением параметра <paramref name="path" /> является <see langword="null" />, метод возвращает <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-349">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8d67e-350">Возвращаемое значение `null`, если путь к файлу `null`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-350">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="8d67e-351">Символы разделения, используемые для определения начала имени файла, — это <xref:System.IO.Path.DirectorySeparatorChar> и <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-351">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="8d67e-352">Так как *\\* является допустимым именем файла в Unix, `GetFileName`, работающие под управлением UNIX, не могут правильно возвращать имя файла из пути на основе Windows, например *C:\\MyDir\\MyFile. ext*, но `GetFileName`, работающие под управлением Windows, могут правильно возвращать имя файла из пути на основе UNIX, например */тмп/мифиле.екст*, поэтому поведение метода `GetFileName` не является строго одинаковым на платформах на базе UNIX и Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-352">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="8d67e-353">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-353">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-354">В следующем примере демонстрируется поведение метода `GetFileName` на платформе настольных компьютеров под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-354">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-355">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-355"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-356">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-356">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-357">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-357">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-358">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-358">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-359">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-359">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-360">Диапазон только для чтения, содержащий путь, из которого нужно получить имя файла без расширения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-360">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-361">Возвращает имя файла без расширения из пути к файлу, представленного диапазоном символов только для чтения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-361">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8d67e-362">Символы в диапазоне только для чтения, возвращенные методом <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, кроме последней точки (.) и всех следующих за ней символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-362">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-363">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-363">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-364">Путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-364">The path of the file.</span></span></param>
        <summary><span data-ttu-id="8d67e-365">Возвращает имя файла указанной строки пути без расширения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-365">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="8d67e-366">Строка, возвращенная методом <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, кроме последней точки (.) и всех следующих за ней символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-366">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-367">Этот метод не проверяет существование пути или имени файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-367">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8d67e-368">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-369">В следующем примере демонстрируется использование метода `GetFileNameWithoutExtension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-369">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-370">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-370"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-371">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-371">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-372">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-373">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-374">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-375">Файл или каталог, для которых нужно получить сведения об абсолютном пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-375">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="8d67e-376">Возвращает для указанной строки пути абсолютный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-376">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-377">Полное расположение <paramref name="path" />, например "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="8d67e-377">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8d67e-378">Абсолютный путь включает все сведения, необходимые для поиска файла или каталога в системе.</span><span class="sxs-lookup"><span data-stu-id="8d67e-378">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="8d67e-379">Файл или каталог, заданный `path`, не обязательно должен существовать.</span><span class="sxs-lookup"><span data-stu-id="8d67e-379">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="8d67e-380">Например, если *к:\темп\невдир* является текущим каталогом, вызов `GetFullPath` для имени файла, например *Test. txt* , возвращает *к:\темп\невдир\тест.ткст*.</span><span class="sxs-lookup"><span data-stu-id="8d67e-380">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="8d67e-381">Файл не должен существовать.</span><span class="sxs-lookup"><span data-stu-id="8d67e-381">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8d67e-382">Если `path` является относительным путем, эта перегрузка возвращает полный путь, который может быть основан на текущем диске и текущем каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-382">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="8d67e-383">Текущий диск и текущий каталог могут измениться в любое время при выполнении приложения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-383">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="8d67e-384">В результате путь, возвращаемый этой перегрузкой, не может быть определен заранее.</span><span class="sxs-lookup"><span data-stu-id="8d67e-384">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="8d67e-385">Чтобы вернуть детерминированный путь, вызовите перегрузку <xref:System.IO.Path.GetFullPath(System.String,System.String)>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-385">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="8d67e-386">Можно также вызвать метод <xref:System.IO.Path.IsPathFullyQualified%2A>, чтобы определить, является ли путь полным или относительным, и, следовательно, требуется ли вызов `GetFullPath`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-386">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="8d67e-387">Однако если `path` существует, вызывающий объект должен иметь разрешение на получение сведений о пути для `path`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-387">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="8d67e-388">Обратите внимание, что, в отличие от большинства членов класса <xref:System.IO.Path>, этот метод обращается к файловой системе.</span><span class="sxs-lookup"><span data-stu-id="8d67e-388">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="8d67e-389">Этот метод использует сведения о текущем каталоге и текущем томе для полного определения `path`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-389">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="8d67e-390">Если имя файла указывается только в `path`, `GetFullPath` возвращает полный путь к текущему каталогу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-390">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="8d67e-391">Если передать короткое имя файла, оно будет расширено до длинного имени файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-391">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="8d67e-392">Если путь не содержит значащих символов, он является недопустимым, если он не содержит один или несколько символов ".", за которыми следует любое количество пробелов; Затем он будет проанализирован как "." или "..".</span><span class="sxs-lookup"><span data-stu-id="8d67e-392">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="8d67e-393">.NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают пути, включающие имена устройств, например "\\? \c:\".</span><span class="sxs-lookup"><span data-stu-id="8d67e-393">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8d67e-394">Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-394">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8d67e-395">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-395">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="8d67e-396">В следующем примере демонстрируется метод `GetFullPath` на платформе настольных компьютеров под управлением Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-396">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-397"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов, как указано в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-397"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="8d67e-398">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-398">-or-</span></span> 
<span data-ttu-id="8d67e-399">Система не может извлечь абсолютный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-399">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d67e-400">У вызывающего объекта отсутствуют необходимые разрешения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-400">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-401">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-401"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8d67e-402"><paramref name="path" /> содержит двоеточие (:), которое не является частью идентификатора тома (например, "c:\\").</span><span class="sxs-lookup"><span data-stu-id="8d67e-402"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="8d67e-403">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</span><span class="sxs-lookup"><span data-stu-id="8d67e-403">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8d67e-404">для доступа к пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-404">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-405">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-405">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-406">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-407">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-408">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-409">Относительный путь для сцепления с <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-409">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="8d67e-410">Начало полного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-410">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="8d67e-411">Возвращает абсолютный путь из базового полного пути и относительного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-411">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-412">Абсолютный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-412">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8d67e-413">Если `path` является пустым путем, метод возвращает `basePath`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-413">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="8d67e-414">Если `path` является полным путем, метод передает `path` методу <xref:System.IO.Path.GetFullPath(System.String)> и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="8d67e-414">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="8d67e-415">Этот метод используется для возврата детерминированного пути на основе указанного тома и корневого каталога при использовании относительных путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-415">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="8d67e-416">Использование предопределенной `basePath`, а не на основе текущего каталога диска, защищает от нежелательных путей к файлам, вызванных непредвиденными изменениями в текущем диске и каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-416">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="8d67e-417">Пример</span><span class="sxs-lookup"><span data-stu-id="8d67e-417">Example</span></span>

<span data-ttu-id="8d67e-418">В следующем примере определяется переменная `basePath`для представления текущего каталога приложения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-418">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="8d67e-419">Затем он передает его методу `GetFullPath`, чтобы получить полный путь к каталогу данных приложения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-419">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-420">Значение параметра <paramref name="path" /> или <paramref name="basePath" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-420"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-421"><paramref name="basePath" /> — это не полный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-421"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="8d67e-422">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-422">-or-</span></span>

<span data-ttu-id="8d67e-423"><paramref name="path" /> или <paramref name="basePath" /> содержит недопустимые символы, такие как U+0000.</span><span class="sxs-lookup"><span data-stu-id="8d67e-423"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d67e-424">Возвращает массив, содержащий символы, которые не разрешены в именах файлов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-424">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="8d67e-425">Массив, содержащий символы, которые не разрешены в именах файлов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-425">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-426">Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-426">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8d67e-427">Полный набор недопустимых символов может зависеть от файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-427">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8d67e-428">Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="8d67e-428">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-429">В следующем примере демонстрируется метод <xref:System.IO.Path.GetInvalidFileNameChars%2A> и метод <xref:System.IO.Path.GetInvalidPathChars%2A> для получения недопустимых символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-429">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d67e-430">Возвращает массив, содержащий символы, которые не разрешены в именах путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-430">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="8d67e-431">Массив, содержащий символы, которые не разрешены в именах путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-431">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-432">Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-432">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8d67e-433">Полный набор недопустимых символов может зависеть от файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-433">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8d67e-434">Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="8d67e-434">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-435">В следующем примере демонстрируется метод <xref:System.IO.Path.GetInvalidFileNameChars%2A> и метод <xref:System.IO.Path.GetInvalidPathChars%2A> для получения недопустимых символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-435">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-436">Доступная только для чтения область символов, содержащая путь, из которого нужно получить сведения о корневом каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-436">A read-only span of characters containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8d67e-437">Получает сведения о корневом каталоге из пути, содержащегося в указанном диапазоне символов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-437">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="8d67e-438">Диапазон символов только для чтения, содержащий корневой каталог <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-438">A read-only span of characters containing the root directory of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-439">Этот метод не проверяет, существует ли путь или файл.</span><span class="sxs-lookup"><span data-stu-id="8d67e-439">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="8d67e-440">В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-440">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

<span data-ttu-id="8d67e-441">`ReadOnlySpan<System.Char>` является "фактически пустым", если:</span><span class="sxs-lookup"><span data-stu-id="8d67e-441">A `ReadOnlySpan<System.Char>` is "effectively empty" if:</span></span>

- <span data-ttu-id="8d67e-442">В Windows вызов <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> для этого диапазона символов возвращает `true`, или все его символы являются пробелами ("").</span><span class="sxs-lookup"><span data-stu-id="8d67e-442">In Windows, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="8d67e-443">В UNIX вызов <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> для этого диапазона символов возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-443">In Unix, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`.</span></span>

<span data-ttu-id="8d67e-444">Ниже приведены возможные шаблоны для диапазона символов только для чтения, возвращаемого этим методом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-444">Possible patterns for the read-only character span returned by this method are as follows:</span></span>

- <span data-ttu-id="8d67e-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` был <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` was <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="8d67e-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` указан относительный путь к текущему диску или тому).</span><span class="sxs-lookup"><span data-stu-id="8d67e-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="8d67e-447">"\" (UNIX: `path` указан абсолютный путь на текущем диске).</span><span class="sxs-lookup"><span data-stu-id="8d67e-447">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="8d67e-448">"X:" (Windows: `path` указывает относительный путь на диске, где *X* представляет букву диска или тома).</span><span class="sxs-lookup"><span data-stu-id="8d67e-448">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="8d67e-449">"X:\" (Windows: `path` указали абсолютный путь на заданном диске).</span><span class="sxs-lookup"><span data-stu-id="8d67e-449">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="8d67e-450">"\\\Компутернаме\шаредфолдер" (Windows: путь UNC).</span><span class="sxs-lookup"><span data-stu-id="8d67e-450">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="8d67e-451">"\\\\\?\c:" (Windows: путь к устройству DOS, поддерживаемый в .NET Core 1,1 и более поздних версиях, а в .NET Framework 4.6.2 и более поздних версий).</span><span class="sxs-lookup"><span data-stu-id="8d67e-451">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="8d67e-452">Дополнительные сведения о путях к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-452">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8d67e-453">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-453">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-454">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-454">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-455">Строка, содержащая путь, из которого нужно получить сведения о корневом каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-455">A string containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8d67e-456">Получает сведения о корневом каталоге из пути, содержащегося в указанной строке.</span><span class="sxs-lookup"><span data-stu-id="8d67e-456">Gets the root directory information from the path contained in the specified string.</span></span></summary>
        <returns><span data-ttu-id="8d67e-457">Корневой каталог <paramref name="path" />, если он является корневым.</span><span class="sxs-lookup"><span data-stu-id="8d67e-457">The root directory of <paramref name="path" /> if it is rooted.</span></span>

<span data-ttu-id="8d67e-458">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-458">-or-</span></span> 
<span data-ttu-id="8d67e-459"><see cref="P:System.String.Empty" />, если <paramref name="path" /> не содержит сведения о корневом каталоге.</span><span class="sxs-lookup"><span data-stu-id="8d67e-459"><see cref="P:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.</span></span>

<span data-ttu-id="8d67e-460">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-460">-or-</span></span> 
<span data-ttu-id="8d67e-461"><see langword="null" />, если <paramref name="path" /> имеет значение <see langword="null" /> или является фактически пустым.</span><span class="sxs-lookup"><span data-stu-id="8d67e-461"><see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-462">Этот метод не проверяет, существует ли путь или файл.</span><span class="sxs-lookup"><span data-stu-id="8d67e-462">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="8d67e-463">Этот метод позволяет нормализовать разделители каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-463">This method will normalize directory separators.</span></span>

<span data-ttu-id="8d67e-464">Строка "фактически пуста", если:</span><span class="sxs-lookup"><span data-stu-id="8d67e-464">A string is "effectively empty" if:</span></span>

- <span data-ttu-id="8d67e-465">В Windows вызов `IsEmpty` для этой строки возвращает `true`, либо все символы являются пробелами ("").</span><span class="sxs-lookup"><span data-stu-id="8d67e-465">In Windows, calling `IsEmpty` on this string returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="8d67e-466">В UNIX вызов <xref:System.String.IsNullOrEmpty%2A> для этой строки возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-466">In Unix, calling <xref:System.String.IsNullOrEmpty%2A> on this string returns `true`.</span></span>

<span data-ttu-id="8d67e-467">Ниже приведены возможные шаблоны для строки, возвращаемой этим методом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-467">Possible patterns for the string returned by this method are as follows:</span></span>

- <span data-ttu-id="8d67e-468">`null` (`path` имеет значение null или пустая строка).</span><span class="sxs-lookup"><span data-stu-id="8d67e-468">`null` (`path` was null or an empty string).</span></span>

- <span data-ttu-id="8d67e-469">Пустая строка (`path` указан относительный путь к текущему диску или тому).</span><span class="sxs-lookup"><span data-stu-id="8d67e-469">An empty string (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="8d67e-470">"\" (UNIX: `path` указан абсолютный путь на текущем диске).</span><span class="sxs-lookup"><span data-stu-id="8d67e-470">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="8d67e-471">"X:" (Windows: `path` указывает относительный путь на диске, где *X* представляет букву диска или тома).</span><span class="sxs-lookup"><span data-stu-id="8d67e-471">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="8d67e-472">"X:\" (Windows: `path` указали абсолютный путь на заданном диске).</span><span class="sxs-lookup"><span data-stu-id="8d67e-472">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="8d67e-473">"\\\Компутернаме\шаредфолдер" (Windows: путь UNC).</span><span class="sxs-lookup"><span data-stu-id="8d67e-473">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="8d67e-474">"\\\\\?\c:" (Windows: путь к устройству DOS, поддерживаемый в .NET Core 1,1 и более поздних версиях, а в .NET Framework 4.6.2 и более поздних версий).</span><span class="sxs-lookup"><span data-stu-id="8d67e-474">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="8d67e-475">Дополнительные сведения о путях к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-475">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8d67e-476">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-476">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>

## Examples
<span data-ttu-id="8d67e-477">В следующем примере демонстрируется использование метода `GetPathRoot`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-477">The following example demonstrates a use of the `GetPathRoot` method.</span></span>

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-478">Только для .NET Framework: <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-478">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>

<span data-ttu-id="8d67e-479">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-479">-or-</span></span>

<span data-ttu-id="8d67e-480">Только для .NET Framework: <see cref="F:System.String.Empty" /> передается <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-480">.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-481">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-481">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-482">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-482">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-483">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-483">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-484">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-484">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d67e-485">Возвращает произвольное имя каталога или файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-485">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="8d67e-486">Произвольное имя каталога или файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-486">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-487">Метод <xref:System.IO.Path.GetRandomFileName%2A> возвращает криптографически надежную, случайную строку, которую можно использовать как имя папки или имя файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-487">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="8d67e-488">В отличие от <xref:System.IO.Path.GetTempFileName%2A><xref:System.IO.Path.GetRandomFileName%2A> не создает файл.</span><span class="sxs-lookup"><span data-stu-id="8d67e-488">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="8d67e-489">Когда безопасность файловой системы имеет первостепенное значение, этот метод следует использовать вместо <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-489">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-490">В следующем примере показаны выходные данные метода <xref:System.IO.Path.GetRandomFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-490">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="8d67e-491">Исходный путь, относительно которого должен указываться результат.</span><span class="sxs-lookup"><span data-stu-id="8d67e-491">The source path the result should be relative to.</span></span> <span data-ttu-id="8d67e-492">Этот путь всегда считается каталогом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-492">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="8d67e-493">Целевой путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-493">The destination path.</span></span></param>
        <summary><span data-ttu-id="8d67e-494">Возвращает относительный путь от одного пути к другому.</span><span class="sxs-lookup"><span data-stu-id="8d67e-494">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="8d67e-495">Относительный путь или <paramref name="path" />, если в нескольких путях используются разные корневые папки.</span><span class="sxs-lookup"><span data-stu-id="8d67e-495">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8d67e-496">Пути разрешаются путем вызова метода <xref:System.IO.Path.GetFullPath%2A> перед вычислением разницы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-496">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="8d67e-497">Метод использует сравнение по пути к файлам по умолчанию для текущей платформы (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> для Windows и MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> для Linux.</span><span class="sxs-lookup"><span data-stu-id="8d67e-497">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-498">Значение параметра <paramref name="relativeTo" /> или <paramref name="path" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-498"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-499">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-499">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d67e-500">Создает на диске временный пустой файл с уникальным именем и возвращает полный путь этого файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-500">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="8d67e-501">Полный путь к временному файлу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-501">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-502">Этот метод создает временный файл с. Расширение файла TMP.</span><span class="sxs-lookup"><span data-stu-id="8d67e-502">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="8d67e-503">Временный файл создается во временной папке пользователя, которая является путем, возвращаемым методом <xref:System.IO.Path.GetTempPath%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-503">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="8d67e-504">Метод <xref:System.IO.Path.GetTempFileName%2A> вызовет <xref:System.IO.IOException>, если он используется для создания более чем 65535 файлов без удаления предыдущих временных файлов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-504">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="8d67e-505">Метод <xref:System.IO.Path.GetTempFileName%2A> вызовет <xref:System.IO.IOException>, если уникальное имя временного файла недоступно.</span><span class="sxs-lookup"><span data-stu-id="8d67e-505">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="8d67e-506">Чтобы устранить эту ошибку, удалите все ненужные временные файлы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-506">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="8d67e-507">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-507">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="8d67e-508">Возникает ошибка ввода-вывода, например, отсутствует уникальное имя временного файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-508">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="8d67e-509">- или -</span><span class="sxs-lookup"><span data-stu-id="8d67e-509">-or-</span></span>
  
 <span data-ttu-id="8d67e-510">Этот метод не смог создать временный файл.</span><span class="sxs-lookup"><span data-stu-id="8d67e-510">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8d67e-511">для записи во временный каталог.</span><span class="sxs-lookup"><span data-stu-id="8d67e-511">for writing to the temporary directory.</span></span> <span data-ttu-id="8d67e-512">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="8d67e-512">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-513">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-514">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-515">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d67e-516">Возвращает путь к временной папке текущего пользователя.</span><span class="sxs-lookup"><span data-stu-id="8d67e-516">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="8d67e-517">Путь к временной папке, заканчивающийся обратной косой чертой.</span><span class="sxs-lookup"><span data-stu-id="8d67e-517">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-518">Этот метод проверяет наличие переменных среды в следующем порядке и использует первый найденный путь:</span><span class="sxs-lookup"><span data-stu-id="8d67e-518">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="8d67e-519">Путь, заданный переменной среды TMP.</span><span class="sxs-lookup"><span data-stu-id="8d67e-519">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="8d67e-520">Путь, заданный переменной среды TEMP.</span><span class="sxs-lookup"><span data-stu-id="8d67e-520">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="8d67e-521">Путь, заданный переменной среды USERPROFILE.</span><span class="sxs-lookup"><span data-stu-id="8d67e-521">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="8d67e-522">Каталог Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-522">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-523">В следующем примере кода демонстрируется вызов метода <xref:System.IO.Path.GetTempPath%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-523">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="8d67e-524">В этом примере создаются выходные данные, аналогичные приведенным ниже.</span><span class="sxs-lookup"><span data-stu-id="8d67e-524">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d67e-525">У вызывающего объекта отсутствуют необходимые разрешения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-525">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="8d67e-526">для неограниченного доступа к переменным среды.</span><span class="sxs-lookup"><span data-stu-id="8d67e-526">for unrestricted access to environment variables.</span></span> <span data-ttu-id="8d67e-527">Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="8d67e-527">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-528">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-528">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-529">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-529">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-530">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-530">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-531">Путь для поиска расширения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-531">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-532">Определяет, включает ли путь, представленный указанным диапазоном символов, расширение имени файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-532">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8d67e-533">Значение <see langword="true" />, если символы, следующие за последним символом разделителя каталогов или за разделителем томов (:) в пути, включают точку (.), за которой следует один или несколько символов. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-533"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8d67e-534">Завершающий период в `path` не считается расширением.</span><span class="sxs-lookup"><span data-stu-id="8d67e-534">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-535">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-535">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-536">Путь для поиска расширения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-536">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8d67e-537">Определяет, включает ли путь расширение имени файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-537">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8d67e-538">Значение <see langword="true" />, если знаки, следующие за последним разделителем каталога (\\\ или /) или разделителем тома (:) в пути, включают точку (.), за которой следует один или несколько символов. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-538"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-539">Начиная с конца `path`этот метод ищет точку (.), за которой следует по крайней мере один символ.</span><span class="sxs-lookup"><span data-stu-id="8d67e-539">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="8d67e-540">Если этот шаблон найден до тех пор, пока встречается <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>или <xref:System.IO.Path.VolumeSeparatorChar> символ, этот метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-540">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="8d67e-541">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-541">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-542">В следующем примере иллюстрируется использование метода `HasExtension`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-542">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-543">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-543"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-544">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-544">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-545">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-545">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-546">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-546">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-547">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-547">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d67e-548">Предоставляет массив символов, задаваемых платформой, которые не могут быть указаны в аргументах строки пути, передаваемых в элементы класса <see cref="T:System.IO.Path" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-548">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-549">Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-549">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8d67e-550">Полный набор недопустимых символов может зависеть от файловой системы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-550">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8d67e-551">Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше (\<), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="8d67e-551">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8d67e-552">Не используйте <xref:System.IO.Path.InvalidPathChars> если вы считаете, что код может выполняться в том же домене приложения, что и ненадежный код.</span><span class="sxs-lookup"><span data-stu-id="8d67e-552">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="8d67e-553"><xref:System.IO.Path.InvalidPathChars> является массивом, поэтому его элементы могут быть перезаписаны.</span><span class="sxs-lookup"><span data-stu-id="8d67e-553"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="8d67e-554">Если ненадежный код перезаписывает элементы <xref:System.IO.Path.InvalidPathChars>, это может привести к неправильному использованию кода.</span><span class="sxs-lookup"><span data-stu-id="8d67e-554">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-555">В следующем примере демонстрируется использование свойства `InvalidPathChars`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-555">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-556">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-556">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-557">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-557">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-558">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-558">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="8d67e-559">Возвращает значение, которое показывает, является ли путь к файлу полным.</span><span class="sxs-lookup"><span data-stu-id="8d67e-559">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8d67e-560">Перегрузки метода `IsPathFullyQualified` обработают пути, в которых используются как <xref:System.IO.Path.DirectorySeparatorChar>, так и <xref:System.IO.Path.AltDirectorySeparatorChar> символы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-560">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="8d67e-561">Проверка пути, переданного в качестве аргумента, не выполняется.</span><span class="sxs-lookup"><span data-stu-id="8d67e-561">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="8d67e-562">В результате URI интерпретируется как относительные пути и возвращают `false`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-562">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="8d67e-563">Существует разница между полным путем (как указано в методе `IsPathFullyQualified`) и корневым путем (как указано в методе <xref:System.IO.Path.IsPathRooted%2A>).</span><span class="sxs-lookup"><span data-stu-id="8d67e-563">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="8d67e-564">*Полный* путь или *абсолютный путь* всегда определяет точный путь от конкретного диска или устройства к целевому файлу или каталогу и не зависит от текущего диска или текущего каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-564">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="8d67e-565">Например, в Windows Systems, *C:/Users/User1/Documents/Reports/2019/Январь/основные сведения. PDF* определяет абсолютный путь от корня диска C: к целевому файлу, *подсвечивает. PDF*.</span><span class="sxs-lookup"><span data-stu-id="8d67e-565">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="8d67e-566">*Корневой путь* указывает либо начальный диск, либо корневой каталог, но зависит либо от текущего каталога (если он находится в корневом каталоге на указанном диске), либо от текущего диска (если он корневым каталогом).</span><span class="sxs-lookup"><span data-stu-id="8d67e-566">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="8d67e-567">В следующем примере показано различие между полными путями и корневыми путями.</span><span class="sxs-lookup"><span data-stu-id="8d67e-567">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-568">Путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-568">A file path.</span></span></param>
        <summary><span data-ttu-id="8d67e-569">Возвращает значение, которое показывает, является ли путь к файлу, представленный указанным диапазоном символов, фиксированным для определенного диска или UNC-пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-569">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-570">Значение <see langword="true" />, если путь привязан к определенному диску или UNC-пути; <see langword="false" /> — если путь задается относительно текущего диска или рабочей папки.</span><span class="sxs-lookup"><span data-stu-id="8d67e-570"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-571">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-571">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-572">Путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-572">A file path.</span></span></param>
        <summary><span data-ttu-id="8d67e-573">Возвращает значение, которое показывает, является ли указанный путь к файлу фиксированным для определенного диска или UNC-пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-573">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-574">Значение <see langword="true" />, если путь привязан к определенному диску или UNC-пути; <see langword="false" /> — если путь задается относительно текущего диска или рабочей папки.</span><span class="sxs-lookup"><span data-stu-id="8d67e-574"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-575">Этот метод обрабатывает пути, использующие разделитель альтернативного каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-575">This method handles paths that use the alternate directory separator.</span></span> <span data-ttu-id="8d67e-576">Часто возникает ошибка, когда предполагается, что пути с корнем (<xref:System.IO.Path.IsPathRooted(System.String)>) не относительны.</span><span class="sxs-lookup"><span data-stu-id="8d67e-576">It's a frequent mistake to assume that rooted paths (<xref:System.IO.Path.IsPathRooted(System.String)>) aren't relative.</span></span> <span data-ttu-id="8d67e-577">Например, "К:а" — это относительный диск, то есть он разрешается в текущий каталог для C: (с корнем, но относительно).</span><span class="sxs-lookup"><span data-stu-id="8d67e-577">For example, "C:a" is drive relative, that is, it's resolved against the current directory for C: (rooted, but relative).</span></span> <span data-ttu-id="8d67e-578">"К:\а" является корневым и относительным, т. е. текущий каталог не используется для изменения пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-578">"C:\a" is rooted and not relative, that is, the current directory isn't used to modify the path.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d67e-579">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-579"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-580">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-580">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="8d67e-581">Возвращает значение, показывающее, содержит ли путь к файлу корневую папку.</span><span class="sxs-lookup"><span data-stu-id="8d67e-581">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8d67e-582">**Путь к корневому каталогу** — это путь к файлу, исправленный на определенный диск или Уник путь; Он отличается от пути, относящегося к текущему диску или рабочему каталогу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-582">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="8d67e-583">Например, в системах Windows корневой путь начинается с обратной косой черты (например, "\Documents") или буквы диска и двоеточия (например, "К:документс").</span><span class="sxs-lookup"><span data-stu-id="8d67e-583">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="8d67e-584">Обратите внимание, что корневые пути могут быть абсолютными (то есть полными) или относительными.</span><span class="sxs-lookup"><span data-stu-id="8d67e-584">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="8d67e-585">Абсолютный корневой путь — это полный путь от корня диска к определенному каталогу.</span><span class="sxs-lookup"><span data-stu-id="8d67e-585">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="8d67e-586">Относительный корневой путь указывает диск, но его полный путь разрешается в текущий каталог.</span><span class="sxs-lookup"><span data-stu-id="8d67e-586">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="8d67e-587">В следующем примере демонстрируется это различие.</span><span class="sxs-lookup"><span data-stu-id="8d67e-587">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-588">Проверяемый путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-588">The path to test.</span></span></param>
        <summary><span data-ttu-id="8d67e-589">Возвращает значение, которое показывает, содержит ли указанный диапазон символов, являющийся путем к файлу, корневую папку.</span><span class="sxs-lookup"><span data-stu-id="8d67e-589">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="8d67e-590">Значение <see langword="true" />, если параметр <paramref name="path" /> содержит корневую папку; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-590"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-591">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-591">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-592">Проверяемый путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-592">The path to test.</span></span></param>
        <summary><span data-ttu-id="8d67e-593">Возвращает значение, показывающее, содержит ли указанная строка пути корневую папку.</span><span class="sxs-lookup"><span data-stu-id="8d67e-593">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="8d67e-594">Значение <see langword="true" />, если параметр <paramref name="path" /> содержит корневую папку; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-594"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-595">Метод <xref:System.IO.Path.IsPathRooted%2A> возвращает `true`, если первый символ является символом разделителя каталога, например "\\", или если путь начинается с буквы диска и двоеточия (:).</span><span class="sxs-lookup"><span data-stu-id="8d67e-595">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="8d67e-596">Например, он возвращает `true` для `path` строк, таких как "\\\Мидир\\\Мифиле.ткст", "C:\\\Мидир" или "К:Мидир".</span><span class="sxs-lookup"><span data-stu-id="8d67e-596">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="8d67e-597">Он возвращает `false` для строк `path`, таких как "MyDir".</span><span class="sxs-lookup"><span data-stu-id="8d67e-597">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="8d67e-598">Этот метод не проверяет существование пути или имени файла.</span><span class="sxs-lookup"><span data-stu-id="8d67e-598">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8d67e-599">Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8d67e-599">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="8d67e-600">В следующем примере показано, как можно использовать метод `IsPathRooted` для проверки трех строк.</span><span class="sxs-lookup"><span data-stu-id="8d67e-600">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d67e-601">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-601"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-602">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-602">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-603">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-603">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-604">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-604">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-605">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-605">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="8d67e-606">Массив путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-606">An array of paths.</span></span></param>
        <summary><span data-ttu-id="8d67e-607">Сцепляет массив путей в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-607">Concatenates an array of paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-608">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-608">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-609">Этот метод просто сцепляет все строки в `paths` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-609">This method simply concatenates all the strings in `paths` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-610">Если <xref:System.String.Length> любого из путей в `paths` равен нулю, Метод сцепляет оставшиеся аргументы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-610">If the <xref:System.String.Length> of any of the paths in `paths` is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8d67e-611">Если результирующая Объединенная строка имеет нулевую длину, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-611">If the resulting concatenated string's length is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-612">Если любой из путей в `paths`, за исключением последнего, заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-612">If any of the paths in `paths`, except for the last one, ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-613">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-613">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-614">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-614">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-615">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-615">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-616">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-616">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-617">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-617">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-618">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-618">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-619">(То есть, если какой-либо из путей в `paths`, за исключением последнего, является абсолютным путем, метод `Join` не удаляет предыдущие пути, как метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-619">(That is, if any of the paths in `paths`, except for the last one, is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8d67e-620">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-620">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-621">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-621">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-622">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-622">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-623">Диапазон символов, содержащий первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-623">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-624">Диапазон символов, содержащий второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-624">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-625">Сцепляет два компонента пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-625">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-626">Объединенные пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-626">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8d67e-627">Этот метод просто объединяет `path` и `path2` и добавляет символ разделителя каталога между двумя компонентами пути, если он еще не существует в конце `path1` или в начале `path2`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-627">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="8d67e-628">Если <xref:System.ReadOnlySpan%601.Length> либо `path1`, либо `path2` равны нулю, метод возвращает другой путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-628">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="8d67e-629">Если <xref:System.ReadOnlySpan%601.Length> обоих `path1` и `path2` равны нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-629">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="8d67e-630">Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет символ разделителя исходного пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-630">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-631">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-631">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-632">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-632">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-633">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-633">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-634">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-634">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-635">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-635">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="8d67e-636">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-636">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-637">(То есть, если `path2` является абсолютным путем, метод `Join` не удаляет `path1` и возвращает `path2`, как и метод <xref:System.IO.Path.Combine%2A>.) В следующем примере показана разница в путях, возвращаемых двумя методами.</span><span class="sxs-lookup"><span data-stu-id="8d67e-637">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="8d67e-638">Если источник `path2` является входными данными пользователя, метод <xref:System.IO.Path.Combine%2A> позволяет пользователю получить доступ к ресурсу файловой системы (например, *C:/Users/User1/Documents/Financial/* в случае примера), который приложение не предполагало сделать доступным.</span><span class="sxs-lookup"><span data-stu-id="8d67e-638">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="8d67e-639">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-639">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-640">Например, хотя `Path.Join("c:\\", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-640">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-641">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-641">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="8d67e-642">Пример</span><span class="sxs-lookup"><span data-stu-id="8d67e-642">Example</span></span>

<span data-ttu-id="8d67e-643">В следующем примере показана разница в путях, возвращаемых методами <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> и <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-643">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8d67e-644">Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты.</span><span class="sxs-lookup"><span data-stu-id="8d67e-644">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8d67e-645">Во втором и третьем вызове метода `ShowPathInformation` строки, возвращаемые двумя методами, расходятся.</span><span class="sxs-lookup"><span data-stu-id="8d67e-645">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8d67e-646">Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-646">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8d67e-647">Метод `Join` объединяет две строки и сохраняет дублирующиеся разделители путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-647">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8d67e-648">Метод `Combine` отменяет диск и возвращает корневой каталог на текущем диске.</span><span class="sxs-lookup"><span data-stu-id="8d67e-648">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8d67e-649">Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:.</span><span class="sxs-lookup"><span data-stu-id="8d67e-649">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8d67e-650">Наконец, поскольку оба аргумента в третьем вызове `ShowPathInformation` являются корневыми, метод `Join` просто добавляет их для создания пути к файлу бессмысленное, а метод `Combine` удаляет первую строку и возвращает вторую.</span><span class="sxs-lookup"><span data-stu-id="8d67e-650">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="8d67e-651">Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.</span><span class="sxs-lookup"><span data-stu-id="8d67e-651">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-652">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-652">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-653">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-653">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-654">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-654">The second path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-655">Сцепляет два пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-655">Concatenates two paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-656">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-656">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-657">Этот метод просто объединяет `path` и `path2` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-657">This method simply concatenates `path` and `path2` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-658">Если длина `path1` или `path2` равна нулю, метод объединяет оставшийся аргумент.</span><span class="sxs-lookup"><span data-stu-id="8d67e-658">If the length of either `path1` or `path2` is zero, the method concatenates the remaining argument.</span></span> <span data-ttu-id="8d67e-659">Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-659">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-660">Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет символ разделителя исходного пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-660">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-661">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-661">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-662">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-662">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-663">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-663">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-664">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-664">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-665">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-665">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-666">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-666">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-667">(Т. е. Если `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-667">(That is, if `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8d67e-668">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-668">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-669">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-669">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-670">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-670">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-671">Диапазон символов, содержащий первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-671">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-672">Диапазон символов, содержащий второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-672">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-673">Диапазон символов, содержащий третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-673">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-674">Сцепляет три компонента пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-674">Concatenates three path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-675">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-675">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8d67e-676">Этот метод просто объединяет `path`, `path2`и `path3` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-676">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-677">Если <xref:System.ReadOnlySpan%601.Length> любого из аргументов `path1`, `path2`или `path3` равен нулю, Метод сцепляет оставшиеся аргументы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-677">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` arguments is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8d67e-678">Если <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равен нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-678">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-679">Если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-679">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-680">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-680">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-681">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-681">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-682">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-682">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-683">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-683">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-684">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-684">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-685">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-685">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-686">(То есть, если `path2` или `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-686">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>
  
<span data-ttu-id="8d67e-687">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-687">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-688">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-688">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-689">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-689">The `Join` method therefore successfully interprets it.</span></span>

## <a name="example"></a><span data-ttu-id="8d67e-690">Пример</span><span class="sxs-lookup"><span data-stu-id="8d67e-690">Example</span></span>

<span data-ttu-id="8d67e-691">В следующем примере показана разница в путях, возвращаемых методами <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> и <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-691">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8d67e-692">Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты.</span><span class="sxs-lookup"><span data-stu-id="8d67e-692">When the first string is a fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8d67e-693">Во втором и третьем вызове метода `ShowPathInformation` строки, возвращаемые двумя методами, расходятся.</span><span class="sxs-lookup"><span data-stu-id="8d67e-693">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8d67e-694">Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом.</span><span class="sxs-lookup"><span data-stu-id="8d67e-694">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8d67e-695">Метод `Join` объединяет две строки и сохраняет дублирующиеся разделители путей.</span><span class="sxs-lookup"><span data-stu-id="8d67e-695">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8d67e-696">Вызов метода <xref:System.IO.Path.GetFullPath%2A> исключит дублирование.</span><span class="sxs-lookup"><span data-stu-id="8d67e-696">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="8d67e-697">Метод `Combine` отменяет диск и возвращает корневой каталог на текущем диске.</span><span class="sxs-lookup"><span data-stu-id="8d67e-697">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8d67e-698">Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:.</span><span class="sxs-lookup"><span data-stu-id="8d67e-698">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8d67e-699">Наконец, поскольку последний аргумент в третьем вызове `ShowPathInformation` является корневым, метод `Join` просто добавляет его к первым двум аргументам, чтобы создать путь к файлу бессмысленное, а метод `Combine` удаляет первые две строки и возвращает третий.</span><span class="sxs-lookup"><span data-stu-id="8d67e-699">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="8d67e-700">Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.</span><span class="sxs-lookup"><span data-stu-id="8d67e-700">Using this string for file access could give the application unintended access to sensitive files.</span></span>

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-701">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-701">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-702">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-702">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-703">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-703">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-704">Третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-704">The third path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-705">Сцепляет три пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-705">Concatenates three paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-706">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-706">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-707">Этот метод просто объединяет `path`, `path2`и `path3` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-707">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-708">Если длина любого из аргументов `path1`, `path2` или `path3` равна нулю, Метод сцепляет оставшиеся аргументы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-708">If the length of any of `path1`, `path2` or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8d67e-709">Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-709">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-710">Если `path1` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-710">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-711">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-711">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-712">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-712">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-713">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-713">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-714">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-714">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-715">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-715">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-716">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-716">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-717">(То есть, если `path2` или `path2` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-717">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8d67e-718">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-718">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-719">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-719">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-720">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-720">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-721">Диапазон символов, содержащий первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-721">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-722">Диапазон символов, содержащий второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-722">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-723">Диапазон символов, содержащий третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-723">A character span that contains the third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="8d67e-724">Диапазон символов, содержащий четвертый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-724">A character span that contains the fourth path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-725">Сцепляет четыре компонента пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-725">Concatenates four path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-726">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-726">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-727">Этот метод просто объединяет `path`, `path2`, `path3` и `path4` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-727">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-728">Если <xref:System.ReadOnlySpan%601.Length> любого из `path1`, `path2`, `path3` или `path4` аргумент равен нулю, Метод сцепляет оставшиеся аргументы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-728">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8d67e-729">Если <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равен нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-729">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-730">Если `path1` или `path2` или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-730">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-731">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-731">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-732">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-732">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-733">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-733">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-734">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-734">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-735">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-735">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-736">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-736">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-737">(Т. е. Если `path2` или `path2` или `path3` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-737">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8d67e-738">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-738">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-739">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-739">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-740">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-740">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-741">Первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-741">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-742">Второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-742">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-743">Третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-743">The third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="8d67e-744">Четвертый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-744">The fourth path to join.</span></span></param>
        <summary><span data-ttu-id="8d67e-745">Сцепляет четыре пути в один путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-745">Concatenates four paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-746">Сцепленный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-746">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d67e-747">Этот метод просто объединяет `path`, `path2`, `path3` и `path4` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует.</span><span class="sxs-lookup"><span data-stu-id="8d67e-747">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8d67e-748">Если длина любого из аргументов `path1`, `path2`, `path3` или `path4` равна нулю, Метод сцепляет оставшиеся аргументы.</span><span class="sxs-lookup"><span data-stu-id="8d67e-748">If the length of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8d67e-749">Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-749">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8d67e-750">Если `path1` или `path2` или `path3` заканчиваются символом разделителя пути, который не подходит для целевой платформы, метод `Join` сохраняет исходный символ разделителя пути и добавляет поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="8d67e-750">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8d67e-751">Эта проблема возникает в жестко запрограммированных путях, в которых используется символ обратной косой черты Windows (\"), который не распознается как разделитель пути в системах на базе UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-751">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8d67e-752">Чтобы обойти эту ошибку, можно:</span><span class="sxs-lookup"><span data-stu-id="8d67e-752">To work around this issue, you can:</span></span>

- <span data-ttu-id="8d67e-753">Получите значение свойства <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>, а не жестко запрограммированный символ разделителя каталога.</span><span class="sxs-lookup"><span data-stu-id="8d67e-753">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8d67e-754">В качестве символа разделителя каталога следует использовать косую черту ("/").</span><span class="sxs-lookup"><span data-stu-id="8d67e-754">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8d67e-755">Этот символ возвращается свойством <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> в системах на базе UNIX и свойством <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="8d67e-755">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8d67e-756">В отличие от метода <xref:System.IO.Path.Combine%2A>, метод <xref:System.IO.Path.Join%2A> не пытается получить корень возвращаемого пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-756">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8d67e-757">(Т. е. Если `path2` или `path2` или `path3` является абсолютным путем, метод `Join` не удаляет предыдущие пути, как это делает метод <xref:System.IO.Path.Combine%2A>.</span><span class="sxs-lookup"><span data-stu-id="8d67e-757">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8d67e-758">Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми методом `Join`, так как эти символы можно использовать для поиска подстановочных знаков.</span><span class="sxs-lookup"><span data-stu-id="8d67e-758">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8d67e-759">Например, хотя `Path.Join("c:\\", "temp", "*.txt")` может быть недопустимым при создании файла, он допустим в качестве строки поиска.</span><span class="sxs-lookup"><span data-stu-id="8d67e-759">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8d67e-760">Таким образом, метод `Join` успешно интерпретирует его.</span><span class="sxs-lookup"><span data-stu-id="8d67e-760">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d67e-761">Разделитель, задаваемый платформой, который используется в переменных среды для разделения строк пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-761">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-762">На настольных платформах под управлением Windows значением этого поля является точка с запятой (;) по умолчанию, но может различаться на других платформах.</span><span class="sxs-lookup"><span data-stu-id="8d67e-762">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-763">В следующем примере демонстрируется использование поля `PathSeparator`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-763">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-764">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-764">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-765">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-765">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-766">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-766">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-767">Обрезаемый путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-767">The path to trim.</span></span></param>
        <summary><span data-ttu-id="8d67e-768">Обрезает один конечный разделитель каталогов за пределами корня указанного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-768">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-769"><paramref name="path" /> без конечных разделителей каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-769">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8d67e-770">Обрезаемый путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-770">The path to trim.</span></span></param>
        <summary><span data-ttu-id="8d67e-771">Обрезает один конечный разделитель каталогов за пределами корня указанного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-771">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="8d67e-772"><paramref name="path" /> без конечных разделителей каталогов.</span><span class="sxs-lookup"><span data-stu-id="8d67e-772">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="8d67e-773">Пытается сцепить отдельные компоненты пути в предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</span><span class="sxs-lookup"><span data-stu-id="8d67e-773">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8d67e-774">Диапазон символов назначения должен быть достаточно большим, чтобы вместить Объединенный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-774">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8d67e-775">Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="8d67e-775">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-776">Диапазон символов, содержащий первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-776">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-777">Диапазон символов, содержащий второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-777">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8d67e-778">Диапазон символов для указания объединенного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-778">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8d67e-779">При возврате метода это значение показывает количество символов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-779">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8d67e-780">Пытается сцепить два компонента пути в один предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</span><span class="sxs-lookup"><span data-stu-id="8d67e-780">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8d67e-781">Значение <see langword="true" />, если операция объединения выполнена успешно; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-781"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8d67e-782">Размер `destination` должен быть достаточно большим, чтобы вместить Объединенный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-782">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8d67e-783">Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в примере.</span><span class="sxs-lookup"><span data-stu-id="8d67e-783">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-784">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-784">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8d67e-785">Диапазон символов, содержащий первый путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-785">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8d67e-786">Диапазон символов, содержащий второй путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-786">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8d67e-787">Диапазон символов, содержащий третий путь для объединения.</span><span class="sxs-lookup"><span data-stu-id="8d67e-787">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8d67e-788">Диапазон символов для указания объединенного пути.</span><span class="sxs-lookup"><span data-stu-id="8d67e-788">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8d67e-789">При возврате метода это значение показывает количество символов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-789">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8d67e-790">Пытается сцепить два компонента пути в один предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</span><span class="sxs-lookup"><span data-stu-id="8d67e-790">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8d67e-791">Значение <see langword="true" />, если операция объединения выполнена успешно; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8d67e-791"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8d67e-792">Размер `destination` должен быть достаточно большим, чтобы вместить Объединенный путь.</span><span class="sxs-lookup"><span data-stu-id="8d67e-792">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8d67e-793">Затем можно получить Объединенный путь, вызвав метод <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>, как показано в примере.</span><span class="sxs-lookup"><span data-stu-id="8d67e-793">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8d67e-794">Форматы путей к файлам в системах Windows</span><span class="sxs-lookup"><span data-stu-id="8d67e-794">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d67e-795">Предоставляет разделитель томов, задаваемый платформой.</span><span class="sxs-lookup"><span data-stu-id="8d67e-795">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d67e-796">Значение этого поля является двоеточием (:) в ОС Windows и Macintosh и косая черта (/) в операционных системах UNIX.</span><span class="sxs-lookup"><span data-stu-id="8d67e-796">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="8d67e-797">Это наиболее полезно для таких путей синтаксического анализа, как c:\Windows или Макволуме: системная папка.</span><span class="sxs-lookup"><span data-stu-id="8d67e-797">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d67e-798">В следующем примере демонстрируется использование поля `VolumeSeparatorChar`.</span><span class="sxs-lookup"><span data-stu-id="8d67e-798">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8d67e-799">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="8d67e-799">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8d67e-800">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="8d67e-800">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8d67e-801">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="8d67e-801">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
