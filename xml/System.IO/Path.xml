<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3785566e0d4957f8a6fa5ee5900cc8179064b119" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70343415" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Выполняет операции для экземпляров класса <see cref="T:System.String" />, содержащих сведения о пути к файлу или каталогу. Эти операции выполняются межплатформенным способом.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Путь — это строка, которая предоставляет расположение файла или каталога. Путь не обязательно указывает на расположение на диске; Например, путь может сопоставляться с расположением в памяти или на устройстве. Точный формат пути определяется текущей платформой. Например, в некоторых системах путь может начинаться с буквы диска или тома, а этот элемент отсутствует в других системах. В некоторых системах пути к файлам могут содержать расширения, которые указывают тип данных, хранящихся в файле. Формат расширения имени файла зависит от платформы; Например, некоторые системы ограничивают расширения тремя символами, а другие — нет. Текущая платформа также определяет набор символов, используемых для разделения элементов пути, и набор символов, которые не могут быть использованы при указании путей. Из-за этих различий поля `Path` класса, а также точное поведение некоторых членов `Path` класса являются зависимыми от платформы.  
  
 Путь может содержать абсолютные или относительные сведения о расположении. Абсолютные пути полностью указывают расположение: файл или каталог могут быть однозначно идентифицированы независимо от текущего расположения. Относительные пути указывают на неполное расположение: текущее расположение используется в качестве отправной точки при поиске файла, указанного относительного пути. Чтобы определить текущий каталог, вызовите <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  

 .NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают доступ к объектам файловой системы, которые являются именами\\устройств, например\""? \c:.

Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md).

 Большинство членов `Path` класса не взаимодействуют с файловой системой и не проверяют существование файла, указанного в строке пути. `Path`члены класса, которые изменяют строку пути, <xref:System.IO.Path.ChangeExtension%2A>например, не влияют на имена файлов в файловой системе. `Path`Однако члены проверяют содержимое указанной строки пути и создают <xref:System.ArgumentException> исключение, если строка содержит недопустимые символы в строках пути, как определено в символах, возвращаемых <xref:System.IO.Path.GetInvalidPathChars%2A> методом. Например, на настольных платформах Windows недопустимые символы пути могут содержать кавычки ("), меньше\<(), больше (>), pipe (&#124;), Backspace (\b), null (\ 0) и символы Юникода от 16 до 18 и от 20 до 25.  
  
 Члены `Path` класса позволяют быстро и легко выполнять стандартные операции, такие как определение того, является ли расширение имени файла частью пути, и объединяет две строки в одно имя пути.  
  
 Все члены `Path` класса являются статическими и поэтому могут быть вызваны без наличия экземпляра пути.  
  
> [!NOTE]
>  В членах, принимающих путь в качестве входной строки, этот путь должен иметь правильный формат или возникнет исключение. Например, если путь является полным, но начинается с пробела, путь не усекается в методах класса. Поэтому путь имеет неправильный формат и возникает исключение. Аналогично, путь или сочетание путей не могут быть полными и дважды. Например, "c:\temp c:\Windows" также вызывает исключение в большинстве случаев. При использовании методов, принимающих строку пути, убедитесь, что пути имеют правильный формат.  
  
 В членах, принимающих путь, путь может ссылаться на файл или только на каталог. Указанный путь может также ссылаться на относительный путь или путь в формате UNC для имени сервера и общего ресурса. Например, все следующие допустимые пути:  
  
-   "c:\\\мидир\\\мифиле.ткст" in C#или "к:\мидир\мифиле.ткст" в Visual Basic.  
  
-   "c:\\\мидир" in C#или "к:\мидир" в Visual Basic.  
  
-   «MyDir\\\мисубдир» в C#или «мидир\мисубдир» в Visual Basic.  
  
-   «\\\\ C#\Мисервер \мишаре» в или«\\\MyServer\MyShare» в Visual Basic.\\\\  
  
 Так как все эти операции выполняются на строках, невозможно проверить, являются ли результаты допустимыми во всех сценариях. Например, <xref:System.IO.Path.GetExtension%2A> метод анализирует строку, которую вы передали в нее, и возвращает расширение из этой строки. Однако это не означает, что на диске существует файл с таким расширением.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).   
  
## Examples  
 В следующем примере показаны некоторые основные члены `Path` класса.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет дополнительный символ, задаваемый платформой, для разделения уровней каталогов в строке пути, в которой отражена иерархическая организация файловой системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Это поле может иметь то же значение, <xref:System.IO.Path.DirectorySeparatorChar>что и. `AltDirectorySeparatorChar`и <xref:System.IO.Path.DirectorySeparatorChar> являются допустимыми для разделения уровней каталога в строке пути.  
  
Значением этого поля является косая черта ("/") в операционных системах Windows и UNIX.  
  
## Examples  

В следующем примере значения <xref:System.IO.Path> полей отображаются в Windows и системах на базе UNIX. Обратите внимание, что Windows поддерживает либо прямую косую черту ( <xref:System.IO.Path.AltDirectorySeparatorChar> которая возвращается полем), либо обратную косую черту (которая возвращается <xref:System.IO.Path.DirectorySeparatorChar> полем) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Сведения о пути, которые нужно изменить. Путь не может содержать символы, определенные в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">Новое расширение (начинающееся с точки или без нее). Задает <see langword="null" /> для удаления существующего расширения из параметра <paramref name="path" />.</param>
        <summary>Изменяет расширение строки пути.</summary>
        <returns>Измененные сведения о пути.  
  
В настольных системах, работающих под управлением Windows, сведения о пути возвращаются без изменений, если значение параметра <paramref name="path" /> равно <see langword="null" /> или пустой строке (""). Если значение параметра <paramref name="extension" /> равно <see langword="null" />, возвращаемая строка содержит указанный путь без расширения. Если <paramref name="path" /> не имеет расширения и значение параметра <paramref name="extension" /> не равно <see langword="null" />, возвращаемая строка пути содержит <paramref name="extension" />, добавленное в конец <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не содержит точку (.), `ChangeExtension` добавляет точку. `extension` `path`  
  
 `extension` Параметр может содержать несколько точек, а также любые допустимые символы пути и могут иметь любую длину. Если `extension` имеет `null`значение, возвращаемая `path` строка содержит содержимое с последним периодом и все символы после него удалены.  
  
 Если `extension` является пустой строкой, возвращаемая строка пути содержит `path` содержимое со всеми символами после последнего удаленного периода.  
  
 Если `path` не имеет расширения и `extension` не является `null`, возвращаемая строка содержит `path` , за которой следует `extension`.  
  
 `extension` Если`null` параметр не равен и не содержит точку в начале, добавляется точка.  
  
 Если `path` содержит несколько расширений, разделенных несколькими точками, возвращаемая строка содержит `path` содержимое с последним периодом, а все `extension`символы, следующие за ними, заменены на. Например, если `path` имеет значение "\Dir1\examples\pathtests.CSX.txt" и `extension` имеет значение "CS", измененный путь — "\Dir1\examples\pathtests.CSX.cs".  
  
 Невозможно проверить, что возвращенные результаты являются допустимыми во всех сценариях. Например, если `path` пусто, `extension` добавляется.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `ChangeExtension` метода.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Объединяет строки в путь.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Этот метод предназначен для сцепления отдельных строк в одну строку, представляющую путь к файлу. Однако если аргумент, отличный от первого, содержит корневой путь, все компоненты предыдущего пути игнорируются, а возвращаемая строка начинается с этого компонента корневого пути. В качестве альтернативы `Combine` методу рекомендуется <xref:System.IO.Path.Join%2A> использовать методы или <xref:System.IO.Path.TryJoin%2A> .

> [!IMPORTANT]
> В этом методе предполагается, что первый аргумент представляет собой абсолютный путь, а следующий аргумент или аргументы являются относительными путями. Если это не так, и, в частности, если все последующие аргументы являются строками, введенными пользователем, <xref:System.IO.Path.Join%2A> вызовите метод или <xref:System.IO.Path.TryJoin%2A> .

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Массив частей пути.</param>
        <summary>Объединяет массив строк в путь.</summary>
        <returns>Объединенные пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths`должен быть массивом частей пути для объединения. Если один из последующих путей представляет собой абсолютный путь, операция объединения сбрасывается, начиная с этого абсолютного пути, отменяя все предыдущие объединенные пути.  

Если какой-либо `paths` элемент в, но последний из них не является диском и не заканчивается <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> символом `Combine` или, метод добавляет <xref:System.IO.Path.DirectorySeparatorChar> символ между этим элементом и следующим. Обратите внимание, что, если элемент заканчивается в символе разделителя пути, который не подходит для целевой платформы, `Combine` метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Строки нулевой длины опускаются из Объединенного пути.  
  
 Параметры не анализируются, если они содержат пробелы.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Combine` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недействительным, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется `Combine` методом.  
  
## Examples  
 В следующем примере массив строк объединяется в путь.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Одна из строк в массиве содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Одна из строк в массиве имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <summary>Объединяет две строки в путь.</summary>
        <returns>Объединенные пути. Если один из указанных путей является строкой нулевой длины, этот метод возвращает другой путь. Если в качестве значения параметра <paramref name="path2" /> задан абсолютный путь, этот метод возвращает <paramref name="path2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `path1` не является ссылкой на диск (т. е. "C:" или "D:") и не заканчивается допустимым символом-разделителем, как <xref:System.IO.Path.AltDirectorySeparatorChar>определено <xref:System.IO.Path.VolumeSeparatorChar>в <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar>, или, добавляется к `path1` перед сцеплением. Обратите внимание `path1` , что если заканчивается символом разделителя пути, который не подходит для целевой платформы `Combine` , метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` содержит корень, `path2` возвращается значение.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, `path2` если включает пробел (например, "\филе.ткст") <xref:System.IO.Path.Combine%2A> , метод добавляется `path2` к, а `path1` не только `path2`к возврату.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Combine` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недействительным, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется `Combine` методом.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `Combine` метода на настольной платформе под управлением Windows.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path1" /> или <paramref name="path2" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path1" /> или <paramref name="path2" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <param name="path3">Третий путь для объединения.</param>
        <summary>Объединяет три строки в путь.</summary>
        <returns>Объединенные пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1`должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик"). Если `path2` или`path3` также является абсолютным путем, операция объединения удаляет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.  
  
 Строки нулевой длины опускаются из Объединенного пути.  
  
 Если `path1` или <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> `path1` <xref:System.IO.Path.VolumeSeparatorChar>не является ссылкой на диск (т. е. "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в, или, добавляется к или `path2` `path2` перед объединением. Обратите внимание `path1` , `path2` что если или заканчивается символом разделителя пути, который не подходит для целевой платформы, `Combine` метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` содержит корень, `path2` возвращается значение.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, `path2` если включает пробел (например, "\филе.ткст") <xref:System.IO.Path.Combine%2A> , метод добавляет `path2` к `path1`.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Combine` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недействительным, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется `Combine` методом.  
  
   
  
## Examples  
 В следующем примере объединяются три пути.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> или <paramref name="path3" /> содержит по крайней мере один из недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path1" />, <paramref name="path2" /> или <paramref name="path3" /> равно <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <param name="path3">Третий путь для объединения.</param>
        <param name="path4">Четвертый путь для объединения.</param>
        <summary>Объединяет четыре строки в путь.</summary>
        <returns>Объединенные пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1`должен быть абсолютным путем (например, "д:\арчивес" или "\\\арчивес\публик"). Если один из последующих путей также является абсолютным путем, операция объединения отменяет все ранее объединенные пути и сбрасывает их до этого абсолютного пути.  
  
 Строки нулевой длины опускаются из Объединенного пути.  
  
 Если `path1`, <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.VolumeSeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> или не является ссылкой на диск (то есть "C:" или "D:") и не заканчивается допустимым символом-разделителем, как определено в, или, добавляется к нему. `path3` `path2` перед объединением. Обратите внимание `path1`, `path2`что если `path3` , или заканчивается символом разделителя пути, который `Combine` не подходит для целевой платформы, метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. В следующем примере сравнивается результат в системах на базе Windows и UNIX, если в качестве символа разделителя пути используется обратная косая черта. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Если `path2` не включает корень (например, если `path2` не начинается с символа разделителя или из спецификации диска), результатом является объединение двух путей с помощью символа промежуточного разделителя. Если `path2` содержит корень, `path2` возвращается значение.  
  
 Параметры не анализируются, если они содержат пробелы. Таким образом, `path2` если включает пробел (например, "\филе.ткст") <xref:System.IO.Path.Combine%2A> , метод добавляет `path2` к `path1`.  
  
 Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Combine` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Combine("c:\\", "*.txt")` может быть недействительным, если бы вы создавали файл из него, он будет действителен как строка поиска. Поэтому он успешно интерпретируется `Combine` методом.  
  
   
  
## Examples  
 В следующем примере объединяются четыре пути.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> или <paramref name="path4" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> или <paramref name="path4" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет символ, задаваемый платформой, для разделения уровней папок в строке пути, в которой отражена иерархическая организация файловой системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar>и `DirectorySeparatorChar` являются допустимыми для разделения уровней каталога в строке пути.  
  
При использовании .NET Core для разработки приложений, работающих на нескольких платформах:

- Если вы предпочитаете жестко кодировать символ разделителя каталогов, следует использовать символ косой черты (`/`). Это единственный распознаваемый символ-разделитель в системах UNIX, так как выходные данные в примере показаны и являются <xref:System.IO.Path.AltDirectorySeparatorChar> в Windows.

- Используйте объединение строк для динамического извлечения символа разделителя пути во время выполнения и его включения в пути файловой системы. Например, примененная к объекту директива 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   Можно также получить значение из <xref:System.IO.Path.AltDirectorySeparatorChar> свойства, так как оно одинаково для систем на основе Windows и Ункс.

- <xref:System.IO.Path.AltDirectorySeparatorChar> Получение свойства

Если приложение не является кросс-платформенным, можно использовать разделитель, соответствующий вашей системе.

## Examples  

В следующем примере значения <xref:System.IO.Path> полей отображаются в Windows и системах на базе UNIX. Обратите внимание, что Windows поддерживает либо прямую косую черту ( <xref:System.IO.Path.AltDirectorySeparatorChar> которая возвращается полем), либо обратную косую черту (которая возвращается <xref:System.IO.Path.DirectorySeparatorChar> полем) в качестве символов разделителя пути, тогда как системы на базе UNIX поддерживают только косую черту.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь для анализа.</param>
        <summary>Возвращает значение, указывающее, заканчивается ли путь, заданный в качестве диапазона, доступного только для чтения, в разделителе каталогов.</summary>
        <returns>Значение <see langword="true" />, если путь заканчивается в разделителе каталогов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь для анализа.</param>
        <summary>Возвращает значение, указывающее, заканчивается ли заданный путь в разделителе каталогов.</summary>
        <returns>Значение <see langword="true" />, если путь заканчивается в разделителе каталогов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь для получения сведений о каталоге.</param>
        <summary>Возвращает сведения о каталоге для указанного пути, представленного диапазоном символов.</summary>
        <returns>Сведения о каталоге для <paramref name="path" /> либо пустой диапазон, если значение <paramref name="path" /> — <see langword="null" />, пустой диапазон или корневая папка, например \, C: или \\server\share.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу.</param>
        <summary>Возвращает для указанной строки пути сведения о каталоге.</summary>
        <returns>Сведения о каталоге для <paramref name="path" />, или значение <see langword="null" />, если путь <paramref name="path" /> указывает на корневой каталог или равен NULL. Возвращает <see cref="F:System.String.Empty" />, если параметр <paramref name="path" /> не содержит сведения о каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В большинстве случаев строка, возвращаемая этим методом, состоит из всех символов в пути вплоть до, но не включая последний <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>. Если путь состоит из корневого каталога, например "c:\\", возвращается значение null. Обратите внимание, что этот метод не поддерживает пути, использующие "file:". Так как возвращаемый путь не включает <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, передача <xref:System.IO.Path.GetDirectoryName%2A> возвращенного пути обратно в метод приведет к усечению одного уровня папки для последующего вызова в результирующей строке. Например, при передаче пути "к:\директори\субдиректори\тест.ткст" <xref:System.IO.Path.GetDirectoryName%2A> в метод будет возвращено значение "к:\директори\субдиректори". Передача этой строки "к:\директори\субдиректори" в приведет к <xref:System.IO.Path.GetDirectoryName%2A> появлению "к:\директори".  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `GetDirectoryName` метода на настольной платформе под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> пустой или содержит недопустимые символы либо только пробелы.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Имя параметра <paramref name="path" /> превышает максимально допустимую в системе длину.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу, из которого необходимо получить расширение.</param>
        <summary>Возвращает расширение из пути к файлу, представленного диапазоном символов только для чтения.</summary>
        <returns>Расширение указанного пути (включая точку — ".") или <see cref="P:System.ReadOnlySpan`1.Empty" />, если в <paramref name="path" /> отсутствуют сведения о расширении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Этот метод получает расширение `path` , выполняя поиск `path` точки ("."), начиная с последнего символа в диапазоне, доступном только для чтения, и заканчивая его первым символом. Если точка находится перед <xref:System.IO.Path.DirectorySeparatorChar> символом или <xref:System.IO.Path.AltDirectorySeparatorChar> , возвращаемый диапазон только для чтения содержит точку и символы <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> после него; в противном случае возвращается значение.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Строка пути, из которой нужно получить расширение.</param>
        <summary>Возвращает расширение указанной строки пути (включая точку ".").</summary>
        <returns>Расширение указанного пути (включая точку ".") или значение <see langword="null" /> или <see cref="F:System.String.Empty" />. Если параметр <paramref name="path" /> имеет значение <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> возвращает <see langword="null" />. Если параметр <paramref name="path" /> не содержит сведений о расширении, <see cref="M:System.IO.Path.GetExtension(System.String)" /> возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Этот метод получает расширение `path` путем поиска `path` точки (.), начиная с последнего символа в `path` и заканчивая первым символом. Если точка находится перед <xref:System.IO.Path.DirectorySeparatorChar> символом или <xref:System.IO.Path.AltDirectorySeparatorChar> , возвращаемая строка содержит точку и символы <xref:System.String.Empty?displayProperty=nameWithType> после него; в противном случае возвращается значение.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
 
## Examples  
 В следующем примере демонстрируется использование `GetExtension` метода на настольной платформе под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Диапазон только для чтения, содержащий путь, из которого нужно получить имя и расширение файла.</param>
        <summary>Возвращает имя и расширение файла из пути к файлу, представленного диапазоном символов только для чтения.</summary>
        <returns>Символы, следующие за последним символом разделителя каталогов в пути <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Возвращаемый диапазон только для чтения содержит символы пути, следующие за последним разделителем в `path`. Если последним символом в `path` является символ или разделитель каталога, метод возвращает <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>значение. Если `path` не содержит символа разделителя, метод возвращает `path`значение.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Строка пути, из которой нужно получить имя файла и расширение.</param>
        <summary>Возвращает имя файла и расширение указанной строки пути.</summary>
        <returns>Символы, следующие за последним символом разделителя каталогов в пути <paramref name="path" />. Если последним символом параметра <paramref name="path" /> является символ разделения тома или каталога, этот метод возвращает <see cref="F:System.String.Empty" />. Если значением параметра <paramref name="path" /> является <see langword="null" />, метод возвращает <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Возвращаемое значение — `null` , если путь к файлу `null`—.  
  
Символы разделения, используемые для определения начала имени файла, — это <xref:System.IO.Path.DirectorySeparatorChar> и. <xref:System.IO.Path.AltDirectorySeparatorChar>  

Поскольку *\\* является допустимым именем файла в UNIX, `GetFileName` работа с платформами на платформе UNIX не может правильно вернуть имя файла из пути на основе Windows, например *C\\:\\MyDir MyFile. ext*, `GetFileName` но Работа с платформами на основе Windows может корректно возвращать имя файла из пути на основе UNIX, например */ТМП/мифиле.екст*, поэтому поведение `GetFileName` метода не является строго одинаковым на платформах на базе UNIX и Windows.

Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется поведение `GetFileName` метода на настольной платформе под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Диапазон только для чтения, содержащий путь, из которого нужно получить имя файла без расширения.</param>
        <summary>Возвращает имя файла без расширения из пути к файлу, представленного диапазоном символов только для чтения.</summary>
        <returns>Символы в диапазоне только для чтения, возвращенные методом <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, кроме последней точки (.) и всех следующих за ней символов.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу.</param>
        <summary>Возвращает имя файла указанной строки пути без расширения.</summary>
        <returns>Строка, возвращенная методом <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, кроме последней точки (.) и всех следующих за ней символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не проверяет существование пути или имени файла.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `GetFileNameWithoutExtension` метода.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которых нужно получить сведения об абсолютном пути.</param>
        <summary>Возвращает для указанной строки пути абсолютный путь.</summary>
        <returns>Полное расположение <paramref name="path" />, например "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Абсолютный путь включает все сведения, необходимые для поиска файла или каталога в системе.  
  
 Файл или каталог, заданный `path` параметром, не обязательно должен существовать. Например, если *к:\темп\невдир* является текущим каталогом, вызов `GetFullPath` по имени файла, например *Test. txt* , возвращает *к:\темп\невдир\тест.ткст*. Файл не должен существовать.  

> [!IMPORTANT]
> Если `path` является относительным путем, эта перегрузка возвращает полный путь, который может быть основан на текущем диске и текущем каталоге. Текущий диск и текущий каталог могут измениться в любое время при выполнении приложения. В результате путь, возвращаемый этой перегрузкой, не может быть определен заранее. Чтобы получить детерминированный путь, вызовите <xref:System.IO.Path.GetFullPath(System.String,System.String)> перегрузку. Можно также вызвать <xref:System.IO.Path.IsPathFullyQualified%2A> метод, чтобы определить, является ли путь полным или относительным, и, следовательно, требуется `GetFullPath` ли вызов.

 Однако если `path` существует, вызывающий объект должен иметь разрешение на получение сведений о пути для `path`. Обратите внимание, что, в отличие <xref:System.IO.Path> от большинства членов класса, этот метод обращается к файловой системе.  
  
 Этот метод использует сведения о текущем каталоге и текущем томе для полной квалификации `path`. Если указать имя файла только в `path`, `GetFullPath` возвращает полный путь к текущему каталогу.  
  
 Если передать короткое имя файла, оно будет расширено до длинного имени файла.  
  
 Если путь не содержит значащих символов, он является недопустимым, если он не содержит один или несколько символов ".", за которыми следует любое количество пробелов; Затем он будет проанализирован как "." или "..".  

.NET Core 1,1 и более поздние версии и .NET Framework 4.6.2 и более поздних версий также поддерживают пути, включающие имена\\устройств, например\""? \c:.

Дополнительные сведения о форматах путей к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md). Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).
  
## Examples  
 В следующем примере демонстрируется `GetFullPath` метод на платформе настольных компьютеров под управлением Windows.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов, как указано в <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
- или - 
Система не может извлечь абсолютный путь.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> содержит двоеточие (:), которое не является частью идентификатора тома (например, "c:\\").</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Относительный путь для сцепления с <paramref name="basePath" />.</param>
        <param name="basePath">Начало полного пути.</param>
        <summary>Возвращает абсолютный путь из базового полного пути и относительного пути.</summary>
        <returns>Абсолютный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Если `path` является пустым путем, метод возвращает `basePath`значение. Если `path` является полным путем, метод передает `path` <xref:System.IO.Path.GetFullPath(System.String)> метод и возвращает результат.

Этот метод используется для возврата детерминированного пути на основе указанного тома и корневого каталога при использовании относительных путей. Использование предопределенной `basePath` , а не на основе текущего каталога диска предотвращает нежелательные пути к файлам, вызванные непредвиденными изменениями в текущем диске и каталоге. 

## <a name="example"></a>Пример

В следующем примере определяется переменная, `basePath`для представления текущего каталога приложения. Затем он передает его `GetFullPath` методу, чтобы получить полный путь к каталогу данных приложения.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="basePath" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> — это не полный путь.

- или -

<paramref name="path" /> или <paramref name="basePath" /> содержит недопустимые символы, такие как U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив, содержащий символы, которые не разрешены в именах файлов.</summary>
        <returns>Массив, содержащий символы, которые не разрешены в именах файлов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше\<(), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.IO.Path.GetInvalidFileNameChars%2A> метод <xref:System.IO.Path.GetInvalidPathChars%2A> и метод для получения недопустимых символов.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив, содержащий символы, которые не разрешены в именах путей.</summary>
        <returns>Массив, содержащий символы, которые не разрешены в именах путей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше\<(), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.IO.Path.GetInvalidFileNameChars%2A> метод <xref:System.IO.Path.GetInvalidPathChars%2A> и метод для получения недопустимых символов.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь, из которого нужно получить сведения о корневом каталоге.</param>
        <summary>Получает сведения о корневом каталоге из пути, содержащегося в указанном диапазоне символов.</summary>
        <returns>Диапазон символов, содержащий корневой каталог пути `path`.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

В отличие от перегрузки строки, этот метод не нормализует разделители каталогов.

          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, из которого нужно получить сведения о корневом каталоге.</param>
        <summary>Возвращает сведения о корневом каталоге для указанного пути.</summary>
        <returns>Корневой каталог параметра <paramref name="path" /> или <see langword="null" />, если параметр <paramref name="path" /> имеет значение <see langword="null" />, или пустая строка, если параметр <paramref name="path" /> не содержит сведений о корневом каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не проверяет существование пути или имени файла.  
  
 Ниже приведены возможные шаблоны для строки, возвращаемой этим методом.  
  
- Пустая строка (`path` указан относительный путь на текущем диске или томе).  
  
- "\" (`path` указан абсолютный путь на текущем диске).  
  
- "X:" (`path` указывает относительный путь на диске, где X представляет букву диска или тома).  
  
- "X:\" (`path` указан абсолютный путь на заданном диске).  
  
- "\\\Компутернаме\шаредфолдер" (UNC-путь).  
  
- "\\\C:"\?(путь к устройству DOS, поддерживаемый в .NET Core 1,1 и более поздних версиях и в .NET Framework 4.6.2 и более поздних версиях)\\
   
 Дополнительные сведения о путях к файлам в Windows см. в разделе [форматы путей к файлам в системах Windows](~/docs/standard/io/file-path-formats.md). Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
## Examples  
 В следующем примере демонстрируется использование `GetPathRoot` метода.  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 Компонент <see cref="F:System.String.Empty" /> был передан в <paramref name="path" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает произвольное имя каталога или файла.</summary>
        <returns>Произвольное имя каталога или файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.GetRandomFileName%2A> Метод возвращает криптографически надежную, случайную строку, которую можно использовать как имя папки или имя файла. В отличие <xref:System.IO.Path.GetTempFileName%2A>от <xref:System.IO.Path.GetRandomFileName%2A> , не создает файл. Когда безопасность файловой системы имеет первостепенное значение, этот метод следует использовать вместо <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 В следующем примере показаны выходные данные <xref:System.IO.Path.GetRandomFileName%2A> метода.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Исходный путь, относительно которого должен указываться результат. Этот путь всегда считается каталогом.</param>
        <param name="path">Целевой путь.</param>
        <summary>Возвращает относительный путь от одного пути к другому.</summary>
        <returns>Относительный путь или <paramref name="path" />, если в нескольких путях используются разные корневые папки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Пути разрешаются путем вызова <xref:System.IO.Path.GetFullPath%2A> метода перед вычислением разницы. Метод использует сравнение по пути к файлам по умолчанию для текущей платформы<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> (для Windows и MacOs <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> для Linux). 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="relativeTo" /> или <paramref name="path" /> — <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает на диске временный пустой файл с уникальным именем и возвращает полный путь этого файла.</summary>
        <returns>Полный путь к временному файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает временный файл с. Расширение файла TMP. Временный файл создается во временной папке пользователя, которая является путем, возвращаемым <xref:System.IO.Path.GetTempPath%2A> методом.  
  
 Метод вызовет исключение, <xref:System.IO.IOException> если он используется для создания более чем 65535 файлов без удаления предыдущих временных файлов. <xref:System.IO.Path.GetTempFileName%2A>  
  
 Метод вызовет исключение, <xref:System.IO.IOException> если уникальное имя временного файла недоступно. <xref:System.IO.Path.GetTempFileName%2A> Чтобы устранить эту ошибку, удалите все ненужные временные файлы.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Возникает ошибка ввода-вывода, например, отсутствует уникальное имя временного файла.  
  
-или-
  
 Этот метод не смог создать временный файл.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи во временный каталог. Связанное перечисление:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает путь к временной папке текущего пользователя.</summary>
        <returns>Путь к временной папке, заканчивающийся обратной косой чертой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет наличие переменных среды в следующем порядке и использует первый найденный путь:  
  
1.  Путь, заданный переменной среды TMP.  
  
2.  Путь, заданный переменной среды TEMP.  
  
3.  Путь, заданный переменной среды USERPROFILE.  
  
4.  Каталог Windows.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов метода <xref:System.IO.Path.GetTempPath%2A>.  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 В этом примере создаются выходные данные, аналогичные приведенным ниже.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для неограниченного доступа к переменным среды. Связанное перечисление:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь для поиска расширения.</param>
        <summary>Определяет, включает ли путь, представленный указанным диапазоном символов, расширение имени файла.</summary>
        <returns>Значение <see langword="true" />, если символы, следующие за последним символом разделителя каталогов или за разделителем томов (:) в пути, включают точку (.), за которой следует один или несколько символов. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Завершающий период в `path` не считается расширением.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь для поиска расширения.</param>
        <summary>Определяет, включает ли путь расширение имени файла.</summary>
        <returns>Значение <see langword="true" />, если знаки, следующие за последним разделителем каталога (\\\ или /) или разделителем тома (:) в пути, включают точку (.), за которой следует один или несколько символов. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с конца `path`, этот метод ищет точку (.), за которой следует хотя бы один символ. Если этот шаблон найден перед <xref:System.IO.Path.DirectorySeparatorChar>обнаруженным символом, <xref:System.IO.Path.VolumeSeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar>или, этот метод возвращает значение `true`.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `HasExtension`.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет массив символов, задаваемых платформой, которые не могут быть указаны в аргументах строки пути, передаваемых в элементы класса <see cref="T:System.IO.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Массив, возвращаемый из этого метода, не обязательно должен содержать полный набор символов, недопустимых в именах файлов и каталогов. Полный набор недопустимых символов может зависеть от файловой системы. Например, на настольных платформах Windows недопустимые символы пути могут содержать символы ASCII/Unicode от 1 до 31, а также кавычки ("), меньше\<(), больше чем (>), pipe&#124;(), Backspace (\b), null (\ 0) и Tab (\t).  
  
> [!CAUTION]
>  Не используйте <xref:System.IO.Path.InvalidPathChars> , если вы считаете, что код может выполняться в том же домене приложения, что и ненадежный код. <xref:System.IO.Path.InvalidPathChars>является массивом, поэтому его элементы могут быть перезаписаны. Если ненадежный код перезаписывает элементы <xref:System.IO.Path.InvalidPathChars>, это может привести к неправильному использованию кода.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `InvalidPathChars` свойства.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Возвращает значение, которое показывает, является ли путь к файлу полным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Перегрузки `IsPathFullyQualified` метода обрабатывали пути, в которых используются <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> символы и. Проверка пути, переданного в качестве аргумента, не выполняется. В результате URI интерпретируется как относительные пути и возвращается `false`. 

Существует разница между полным путем (как указано в `IsPathFullyQualified` методе) и корневым путем (как указано в <xref:System.IO.Path.IsPathRooted%2A> методе). *Полный* путь или абсолютный *путь* всегда определяет точный путь от конкретного диска или устройства к целевому файлу или каталогу и не зависит от текущего диска или текущего каталога. Например, в Windows Systems, *C:/Users/User1/Documents/Reports/2019/Январь/основные сведения. PDF* определяет абсолютный путь от корня диска C: к целевому файлу, *подсвечивает. PDF*. *Корневой путь* указывает либо начальный диск, либо корневой каталог, но зависит либо от текущего каталога (если он находится в корневом каталоге на указанном диске), либо от текущего диска (если он корневым каталогом). В следующем примере показано различие между полными путями и корневыми путями.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу.</param>
        <summary>Возвращает значение, которое показывает, является ли путь к файлу, представленный указанным диапазоном символов, фиксированным для определенного диска или UNC-пути.</summary>
        <returns>Значение <see langword="true" />, если путь привязан к определенному диску или UNC-пути; <see langword="false" /> — если путь задается относительно текущего диска или рабочей папки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу.</param>
        <summary>Возвращает значение, которое показывает, является ли указанный путь к файлу фиксированным для определенного диска или UNC-пути.</summary>
        <returns>Значение <see langword="true" />, если путь привязан к определенному диску или UNC-пути; <see langword="false" /> — если путь задается относительно текущего диска или рабочей папки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод обрабатывает пути, использующие разделитель альтернативного каталога. Часто возникает ошибка, когда предполагается, что корневые пути<xref:System.IO.Path.IsPathRooted(System.String)>() не являются относительными. Например, "К:а" — это относительный диск, то есть он разрешается в текущий каталог для C: (с корнем, но относительно). "К:\а" является корневым и относительным, т. е. текущий каталог не используется для изменения пути.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Возвращает значение, показывающее, содержит ли путь к файлу корневую папку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

**Путь** к корневому каталогу — это путь к файлу, исправленный на определенный диск или Уник путь; Он отличается от пути, относящегося к текущему диску или рабочему каталогу. Например, в системах Windows корневой путь начинается с обратной косой черты (например, "\Documents") или буквы диска и двоеточия (например, "К:документс"). 

Обратите внимание, что корневые пути могут быть абсолютными (то есть полными) или относительными. Абсолютный корневой путь — это полный путь от корня диска к определенному каталогу. Относительный корневой путь указывает диск, но его полный путь разрешается в текущий каталог. В следующем примере демонстрируется это различие.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Проверяемый путь.</param>
        <summary>Возвращает значение, которое показывает, содержит ли указанный диапазон символов, являющийся путем к файлу, корневую папку.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="path" /> содержит корневую папку; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Проверяемый путь.</param>
        <summary>Возвращает значение, показывающее, содержит ли указанная строка пути корневую папку.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="path" /> содержит корневую папку; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает `true` , если первый символ является символом разделителя каталога, например "\\", или если путь начинается с буквы диска и двоеточия (:). <xref:System.IO.Path.IsPathRooted%2A> Например, он возвращает `true` для `path` таких строк, как "\\\мидир\\\мифиле.ткст", "C:\\\мидир" или "к:Мидир". Он возвращает `false` для `path` таких строк, как "MyDir".  
  
 Этот метод не проверяет существование пути или имени файла.  
  
 Список общих задач ввода-вывода см. в разделе [Общие задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  

## Examples  
 В следующем примере показано, `IsPathRooted` как метод можно использовать для проверки трех строк.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> содержит один или несколько недопустимых символов, определенных в <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Массив путей.</param>
        <summary>Сцепляет массив путей в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет все строки в `paths` и добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если значение <xref:System.String.Length> любого из путей в `paths` равно нулю, Метод сцепляет оставшиеся аргументы. Если результирующая Объединенная строка имеет нулевую длину, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если любой из путей в `paths`, за исключением последнего, заканчивается символом разделителя пути, который не подходит для целевой платформы `Join` , метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть, если любой из путей в `paths`, за исключением последнего, является абсолютным путем `Join` , метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Диапазон символов, содержащий первый путь для объединения.</param>
        <param name="path2">Диапазон символов, содержащий второй путь для объединения.</param>
        <summary>Сцепляет два компонента пути в один путь.</summary>
        <returns>Объединенные пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Этот метод просто `path` объединяет и `path2` добавляет символ разделителя каталогов между двумя компонентами пути, если он еще не `path1` существует в конце или в начале `path2`. Если значение <xref:System.ReadOnlySpan%601.Length> `path1` параметра или`path2` равно нулю, метод возвращает другой путь. Если значение <xref:System.ReadOnlySpan%601.Length> `path1` обоих элементов и `path2` равно нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение. 

Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы `Join` , метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows. 

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть, если `path2` является абсолютным путем `Join` , метод не удаляет `path1` и не возвращает `path2` , как это <xref:System.IO.Path.Combine%2A> делает метод.) В следующем примере показана разница в путях, возвращаемых двумя методами. Если источником `path2` является вход пользователя <xref:System.IO.Path.Combine%2A> , метод позволяет пользователю получить доступ к ресурсу файловой системы (например, *C:/Users/User1/Documents/Financial/* в случае примера), который приложение не планировало делать. обращать.  

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его. 

## <a name="example"></a>Пример

В следующем примере показана разница в путях, возвращаемых <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> методами и. <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты. Во втором и третьем вызове `ShowPathInformation` метода строки, возвращаемые двумя методами, расходятся. Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом. `Join` Метод объединяет две строки и сохраняет дублирующиеся разделители путей. `Combine` Метод отменяет диск и возвращает корневой каталог на текущем диске. Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:. Наконец, поскольку оба аргумента в третьем вызове `ShowPathInformation` являются корневыми `Join` , метод просто добавляет их для создания пути к `Combine` файлу бессмысленное, а метод отменяет первую строку и возвращает вторую. Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <summary>Сцепляет два пути в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path` и `path2` добавляет символ разделителя каталогов между любыми компонентами пути, если он еще не существует. Если значение параметра `path1` или `path2` равно нулю, метод объединяет оставшийся аргумент. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если `path1` заканчивается символом разделителя пути, который не подходит для целевой платформы `Join` , метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть, если `path2` является абсолютным путем `Join` , метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Диапазон символов, содержащий первый путь для объединения.</param>
        <param name="path2">Диапазон символов, содержащий второй путь для объединения.</param>
        <param name="path3">Диапазон символов, содержащий третий путь для объединения.</param>
        <summary>Сцепляет три компонента пути в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Этот метод просто объединяет `path`, и `path2` `path3` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует. Если значение <xref:System.ReadOnlySpan%601.Length> любого из `path1`аргументов, `path2`или `path3` равно нулю, метод объединяет остальные аргументы. Если значение <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равно нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если `path1` `Join` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть, если `path2` или `path2` является абсолютным путем, `Join` метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.
  
Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

## <a name="example"></a>Пример

В следующем примере показана разница в путях, возвращаемых <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> методами и. <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> Если первая строка представляет собой полный путь, включающий диск и корневой каталог, а второй — относительный путь от первого пути, два метода дают одинаковые результаты. Во втором и третьем вызове `ShowPathInformation` метода строки, возвращаемые двумя методами, расходятся. Во втором вызове метода первый строковый аргумент является диском, а второй — корневым каталогом. `Join` Метод объединяет две строки и сохраняет дублирующиеся разделители путей. Вызов <xref:System.IO.Path.GetFullPath%2A> метода приведет к исключению дублирования. `Combine` Метод отменяет диск и возвращает корневой каталог на текущем диске. Если текущий диск приложения — C:\ и строка используется для доступа к файлу или файлам в каталоге, он будет иметь доступ к C: вместо D:. Наконец, поскольку последний аргумент в третьем вызове `ShowPathInformation` `Join` метода является корневым, метод просто добавляет его к первым двум аргументам для создания пути к `Combine` файлу бессмысленное, а метод отменяет первые две строки и возвращает Третий. Использование этой строки для доступа к файлу может предоставить приложению непреднамеренной доступ к конфиденциальным файлам.

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <param name="path3">Третий путь для объединения.</param>
        <summary>Сцепляет три пути в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод просто объединяет `path`, и `path2` `path3` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует. Если длина любого из `path1` `path2` аргументов или `path3` равна нулю, Метод сцепляет оставшиеся аргументы. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если `path1` `Join` или `path2` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть, если `path2` или `path2` является абсолютным путем, `Join` метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Диапазон символов, содержащий первый путь для объединения.</param>
        <param name="path2">Диапазон символов, содержащий второй путь для объединения.</param>
        <param name="path3">Диапазон символов, содержащий третий путь для объединения.</param>
        <param name="path4">Диапазон символов, содержащий четвертый путь для объединения.</param>
        <summary>Сцепляет четыре компонента пути в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`path`Этот метод просто объединяет `path2` `path3` , и`path4` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует. Если значение <xref:System.ReadOnlySpan%601.Length> любого из `path1`аргументов, `path2` `path3` или`path4` равно нулю, метод объединяет остальные аргументы. Если значение <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> всех компонентов равно нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если `path1` или `path2` или `Join` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. `path3` Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть если `path2` или `path2` или `path3` является абсолютным путем, `Join` метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Первый путь для объединения.</param>
        <param name="path2">Второй путь для объединения.</param>
        <param name="path3">Третий путь для объединения.</param>
        <param name="path4">Четвертый путь для объединения.</param>
        <summary>Сцепляет четыре пути в один путь.</summary>
        <returns>Сцепленный путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`path`Этот метод просто объединяет `path2` `path3` , и`path4` и добавляет символ разделителя каталога между любыми компонентами пути, если он еще не существует. Если длина `path1`любого из аргументов `path3` , `path2`или `path4` равна нулю, Метод сцепляет оставшиеся аргументы. Если длина результирующей объединенной строки равна нулю, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.

Если `path1` или `path2` или `Join` заканчивается символом разделителя пути, который не подходит для целевой платформы, метод сохраняет символ разделителя исходного пути и добавляет поддерживаемый. `path3` Эта проблема возникает в жестко запрограммированных путях, использующих символ обратной косой черты Windows ("\"), который не распознается как разделитель пути в системах на базе UNIX. Чтобы обойти эту ошибку, можно:

- Получите значение свойства, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> а не жестко запрограммированный символ разделителя каталога.

- В качестве символа разделителя каталога следует использовать косую черту ("/"). Этот символ возвращается <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> свойством в системах на базе UNIX и <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> свойством в системах Windows.

<xref:System.IO.Path.Combine%2A> В<xref:System.IO.Path.Join%2A> отличие от метода, метод не пытается получить корень возвращаемого пути. (То есть если `path2` или `path2` или `path3` является абсолютным путем, `Join` метод не удаляет предыдущие пути, как это <xref:System.IO.Path.Combine%2A> делает метод.

Не все недопустимые символы в именах каталогов и файлов считаются неприемлемыми `Join` для метода, так как эти символы можно использовать для поиска подстановочных знаков. Например, хотя `Path.Join("c:\\", "temp", "*.txt")` при создании файла может быть недопустимым, он допустим в качестве строки поиска. Таким `Join` образом, метод успешно интерпретирует его.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разделитель, задаваемый платформой, который используется в переменных среды для разделения строк пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На настольных платформах под управлением Windows значением этого поля является точка с запятой (;) по умолчанию, но может различаться на других платформах.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `PathSeparator` поля.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Обрезаемый путь.</param>
        <summary>Обрезает один конечный разделитель каталогов за пределами корня указанного пути.</summary>
        <returns><paramref name="path" /> без конечных разделителей каталогов.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Обрезаемый путь.</param>
        <summary>Обрезает один конечный разделитель каталогов за пределами корня указанного пути.</summary>
        <returns><paramref name="path" /> без конечных разделителей каталогов.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Пытается сцепить отдельные компоненты пути в предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Диапазон символов назначения должен быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> метод, как показано в следующем примере.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Диапазон символов, содержащий первый путь для объединения.</param>
        <param name="path2">Диапазон символов, содержащий второй путь для объединения.</param>
        <param name="destination">Диапазон символов для указания объединенного пути.</param>
        <param name="charsWritten">При возврате метода это значение показывает количество символов, записанных в <paramref name="destination" />.</param>
        <summary>Пытается сцепить два компонента пути в один предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</summary>
        <returns>Значение <see langword="true" />, если операция объединения выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination`значение должно быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> метод, как показано в примере.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Диапазон символов, содержащий первый путь для объединения.</param>
        <param name="path2">Диапазон символов, содержащий второй путь для объединения.</param>
        <param name="path3">Диапазон символов, содержащий третий путь для объединения.</param>
        <param name="destination">Диапазон символов для указания объединенного пути.</param>
        <param name="charsWritten">При возврате метода это значение показывает количество символов, записанных в <paramref name="destination" />.</param>
        <summary>Пытается сцепить два компонента пути в один предварительно выделенный диапазон символов и возвращает значение, показывающее, успешно ли выполнена эта операция.</summary>
        <returns>Значение <see langword="true" />, если операция объединения выполнена успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination`значение должно быть достаточно большим, чтобы вместить Объединенный путь. Затем можно получить Объединенный путь, вызвав <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> метод, как показано в примере.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Форматы путей к файлам в системах Windows</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет разделитель томов, задаваемый платформой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого поля является двоеточием (:) в ОС Windows и Macintosh и косая черта (/) в операционных системах UNIX. Это наиболее полезно для таких путей синтаксического анализа, как c:\Windows или Макволуме: системная папка.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `VolumeSeparatorChar` поля.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
  </Members>
</Type>
