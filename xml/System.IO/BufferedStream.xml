<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a8aa1218db5193bcc9f2f2074ac014229ff4fee8" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68543463" /></Metadata><TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f6d1f-101">Осуществляет буферизацию в операциях чтения и записи в другие потоки.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-101">Adds a buffering layer to read and write operations on another stream.</span></span> <span data-ttu-id="f6d1f-102">Этот класс не наследуется.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-103">Буфер — это блок байтов памяти, используемый для кэширования данных, тем самым уменьшая количество вызовов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="f6d1f-104">Буферы улучшают производительность операций чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="f6d1f-105">Буфер можно использовать как для чтения, так и для записи, но никогда не одновременно.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="f6d1f-106">Методы <xref:System.IO.BufferedStream.Read%2A> и <xref:System.IO.BufferedStream.Write%2A> для`BufferedStream` автоматически обслуживают буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6d1f-107">Этот тип реализует интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f6d1f-108">По окончании использования выдаленную ему память следует прямо или косвенно освободить.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f6d1f-109">Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f6d1f-110">Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f6d1f-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f6d1f-111">Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f6d1f-112">`BufferedStream`может состоять из некоторых типов потоков.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="f6d1f-113">Он предоставляет реализации для чтения и записи байтов в базовый источник данных или репозиторий.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="f6d1f-114">Используйте <xref:System.IO.BinaryReader>длячтенияи записидругихтиповданных.<xref:System.IO.BinaryWriter></span><span class="sxs-lookup"><span data-stu-id="f6d1f-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="f6d1f-115">`BufferedStream`предназначен для предотвращения замедления ввода и вывода буфера, когда буфер не нужен.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="f6d1f-116">Если всегда производится чтение и запись для размеров, превышающих размер внутреннего буфера, `BufferedStream` может даже не выделить внутренний буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="f6d1f-117">`BufferedStream`также буферы считывают и записываются в общий буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="f6d1f-118">Предполагается, что вы почти всегда выполняете ряд операций чтения или записи, но редко они меняются между ними.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-119">В следующем примере кода показано, как использовать `BufferedStream` класс `NetworkStream` для класса, чтобы повысить производительность определенных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="f6d1f-120">Запустите сервер на удаленном компьютере перед запуском клиента.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="f6d1f-121">При запуске клиента укажите имя удаленного компьютера в качестве аргумента командной строки.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="f6d1f-122">Изменяют `streamBufferSize` константы идляпросмотраихвлияниянапроизводительность.`dataArraySize`</span><span class="sxs-lookup"><span data-stu-id="f6d1f-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="f6d1f-123">В первом примере показан код, который выполняется на клиенте, а во втором примере показан код, выполняемый на сервере.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="f6d1f-124">**Пример 1. Код, выполняемый на клиенте**</span><span class="sxs-lookup"><span data-stu-id="f6d1f-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="f6d1f-125">**Пример 2: Код, выполняемый на сервере**</span><span class="sxs-lookup"><span data-stu-id="f6d1f-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-126">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-126">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-127">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-127">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-128">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-128">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6d1f-129">Инициализирует новый экземпляр класса <see cref="T:System.IO.BufferedStream" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-129">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="f6d1f-130">Текущий поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-130">The current stream.</span></span></param>
        <summary><span data-ttu-id="f6d1f-131">Инициализирует новый экземпляр класса <see cref="T:System.IO.BufferedStream" /> со стандартным размером буфера 4096 байт.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-131">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-132">Общий буфер чтения/записи выделяется при первом `BufferedStream` инициализации объекта с помощью этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-132">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="f6d1f-133">Общий буфер не используется, если все операции чтения и записи больше или равны `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-133">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-134"><paramref name="stream" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-134"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-135">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-135">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-136">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-136">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-137">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-137">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="f6d1f-138">Текущий поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-138">The current stream.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="f6d1f-139">Размер буфера в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-139">The buffer size in bytes.</span></span></param>
        <summary><span data-ttu-id="f6d1f-140">Инициализирует новый экземпляр класса <see cref="T:System.IO.BufferedStream" /> с заданным размером буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-140">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-141">Общий буфер чтения/записи выделяется при первом `BufferedStream` инициализации объекта с помощью этого конструктора.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-141">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="f6d1f-142">Общий буфер не используется, если все операции чтения и записи больше или равны `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-142">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-143">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-143">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-144"><paramref name="stream" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-144"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-145"><paramref name="bufferSize" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-145"><paramref name="bufferSize" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-146">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-146">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-147">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-147">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-148">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-148">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-149">Буфер, в который необходимо считать данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-149">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-150">Смещение байтов в буфере <paramref name="buffer" />, с которого начинается запись данных, считанных из потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-150">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-151">Максимальное число байтов, предназначенных для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-151">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="f6d1f-152">Дополнительный асинхронный ответный вызов по завершении чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-152">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6d1f-153">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронное чтение от других запросов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-153">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="f6d1f-154">Начинает операцию асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-154">Begins an asynchronous read operation.</span></span> <span data-ttu-id="f6d1f-155">(Рекомендуется использовать <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="f6d1f-155">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="f6d1f-156">Объект, представляющий асинхронную операцию чтения, которая может все еще быть отложена.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-156">An object that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-157">В .NET Framework 4 и более ранних версиях необходимо использовать методы, такие как <xref:System.IO.Stream.BeginRead%2A> и <xref:System.IO.Stream.EndRead%2A> , для реализации асинхронных файловых операций.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-157">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f6d1f-158">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>и <xref:System.IO.BufferedStream.FlushAsync%2A>, упрощают реализацию асинхронных операций с файлами.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-158">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f6d1f-159"><xref:System.IO.BufferedStream.EndWrite%2A>метод должен вызываться только один раз для каждого <xref:System.IO.BufferedStream.BeginRead%2A>вызова метода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-159"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="f6d1f-160">Невозможность завершить процесс чтения до начала другого чтения может привести к нежелательному поведению, например к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-160">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6d1f-161">Используйте свойство <xref:System.IO.BufferedStream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-161">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="f6d1f-162"><xref:System.IO.BufferedStream.EndRead%2A><xref:System.IAsyncResult> для определения числа считанных байтов необходимо вызвать метод.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-162"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-163">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-164"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-164"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-165">Предпринята попытка асинхронного чтения за пределами потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-165">Attempted an asynchronous read past the end of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-166">Длина буфера минус <paramref name="offset" /> меньше <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-166">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-167">Текущий поток не поддерживает операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-167">The current stream does not support the read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-168">Буфер, содержащий данные для записи в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-168">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-169">Отсчитываемое от нуля смещение байтов в буфере <paramref name="buffer" />, с которого начинается копирование байтов в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-169">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-170">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-170">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="f6d1f-171">Метод, вызываемый после завершения операции асинхронной записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-171">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="f6d1f-172">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронную запись от других запросов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-172">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="f6d1f-173">Начинает операцию асинхронной записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-173">Begins an asynchronous write operation.</span></span> <span data-ttu-id="f6d1f-174">(Рекомендуется использовать <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="f6d1f-174">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="f6d1f-175">Объект, который ссылается на асинхронную операцию записи, которая может все еще быть отложена.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-175">An object that references the asynchronous write which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-176">В .NET Framework 4 и более ранних версиях необходимо использовать методы, такие как <xref:System.IO.Stream.BeginWrite%2A> и <xref:System.IO.Stream.EndWrite%2A> , для реализации асинхронных файловых операций.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-176">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f6d1f-177">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>и <xref:System.IO.BufferedStream.FlushAsync%2A>, упрощают реализацию асинхронных операций с файлами.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-177">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f6d1f-178"><xref:System.IO.BufferedStream.EndWrite%2A>метод должен вызываться только один раз <xref:System.IAsyncResult> для <xref:System.IO.BufferedStream.BeginWrite%2A>каждого из.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-178"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="f6d1f-179"><xref:System.IO.BufferedStream.EndWrite%2A>будет блокироваться до завершения операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-179"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-180">Длина <paramref name="buffer" /> минус <paramref name="offset" /> меньше <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-180"><paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-181">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-181"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-182"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-182"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-183">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-183">The stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-184">Возвращает размер буфера в байтах для этого буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-184">Gets the buffer size in bytes for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="f6d1f-185">Целое число, представляющее размер буфера в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-185">An integer representing the buffer size in bytes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-186">Возвращает значение, определяющее в текущем потоке наличие поддержки операций чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-186">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="f6d1f-187">Значение <see langword="true" />, если в потоке поддерживаются операции чтения; значение <see langword="false" />, если поток закрыт или открыт только для записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-187"><see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-188">Если класс, производный <xref:System.IO.Stream> от, не поддерживает чтение, вызовы <xref:System.IO.Stream.EndRead%2A> <xref:System.IO.BufferedStream.Read%2A> <xref:System.IO.Stream.BeginRead%2A> <xref:System.IO.BufferedStream.ReadByte%2A> `Peek` методов <xref:System.IO.StreamReader> ,<xref:System.IO.StringReader>,, и, и <xref:System.IO.TextReader> вызывают исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-188">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f6d1f-189">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-189">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-190">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-190">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-191">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-191">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-192">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-192">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-193">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-193">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-194">Получает значение, определяющее в текущем потоке наличие поддержки операций поиска.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-194">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="f6d1f-195">Значение <see langword="true" /> если поток поддерживает поиск; значение <see langword="false" />, если поток закрыт или создан на базе дескриптора операционной системы, соответствующего каналу или выводу на консоль.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-195"><see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-196">Если класс, производный <xref:System.IO.Stream> от <xref:System.IO.BufferedStream.Length%2A>, не поддерживает поиск, вызовы, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>и <xref:System.IO.BufferedStream.Seek%2A> вызывают исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-196">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f6d1f-197">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-197">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-198">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-198">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-199">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-199">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-200">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-200">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-201">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-201">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-202">Получает значение, определяющее в текущем потоке наличие поддержки операций записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-202">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="f6d1f-203">Значение <see langword="true" />, если поток поддерживает операции записи; значение <see langword="false" />, если поток закрыт или открыт только для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-203"><see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-204">Если класс, производный <xref:System.IO.Stream> от <xref:System.IO.BufferedStream.SetLength%2A> <xref:System.IO.BufferedStream.Write%2A> ,не<xref:System.IO.BufferedStream.WriteByte%2A> поддерживает запись, вызов, или создает исключение. <xref:System.NotSupportedException></span><span class="sxs-lookup"><span data-stu-id="f6d1f-204">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f6d1f-205">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-205">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-206">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-206">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-207">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-207">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-208">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-208">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-209">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-209">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d1f-210">Закрывает поток и освобождает все ресурсы (особенно системные ресурсы, например, сокеты и дескрипторы файлов), связанные с текущим буферизованным потоком.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-210">Closes the stream and releases any resources (especially system resources such as sockets and file handles) associated with the current buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f6d1f-211">Все данные, ранее записанные в буфер, копируются в базовый источник данных или репозиторий перед закрытием буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-211">Any data previously written to the buffer is copied to the underlying data source or repository before the buffered stream is closed.</span></span> <span data-ttu-id="f6d1f-212">Поэтому нет необходимости вызывать метод <xref:System.IO.BufferedStream.Flush> перед вызовом Close.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-212">Therefore, it is not necessary to call <xref:System.IO.BufferedStream.Flush> before invoking Close.</span></span> <span data-ttu-id="f6d1f-213">После вызова функции Close все операции в буферизованном потоке могут вызывать исключения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-213">Following a call to Close, any operations on the buffered stream might raise exceptions.</span></span>

<span data-ttu-id="f6d1f-214">При сбросе потока его базовый кодировщик не очищается, пока не будет <xref:System.IO.BufferedStream.Flush> явно вызвана или закрыта.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-214">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.BufferedStream.Flush> or Close.</span></span> <span data-ttu-id="f6d1f-215"><xref:System.IO.StreamWriter.AutoFlush> Значение true означает, что данные будут сброшены из буфера в поток, но состояние кодировщика не будет сбрасываться.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-215">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="f6d1f-216">Это позволяет кодировщику оставаться в состоянии (частичные символы), чтобы он мог правильно кодировать следующий блок символов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-216">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="f6d1f-217">Этот сценарий влияет на UTF8 и UTF7, где определенные символы могут быть закодированы только после того, как кодировщик получит смежный символ или символы.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-217">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="f6d1f-218">Попытка управления потоком после его закрытия может вызвать <xref:System.ObjectDisposedException>исключение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-218">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="f6d1f-219">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-219">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>

```vb
' When bufStream is closed, netStream is in turn 
' closed, which in turn shuts down the connection 
' and closes clientSocket.
Console.WriteLine(vbCrLf & "Shutting down the connection.")
bufStream.Close()
```

```csharp
// When bufStream is closed, netStream is in turn
// closed, which in turn shuts down the connection
// and closes clientSocket.
Console.WriteLine("\nShutting down the connection.");
bufStream.Close();
```

```cpp
// When bufStream is closed, netStream is in turn closed,
// which in turn shuts down the connection and closes
// clientSocket.
Console::WriteLine( "\nShutting down connection." );
bufStream->Close();

```

]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-220">Произошла ошибка при попытке закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-220">An error occurred while trying to close the stream.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Flush" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-221">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-221">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-222">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-222">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-223">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-223">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="bufferedStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f6d1f-224">Поток, в который будет скопировано содержимое текущего буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-224">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="f6d1f-225">Размер буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-225">The size of the buffer.</span></span> <span data-ttu-id="f6d1f-226">Это значение должно быть больше нуля.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-226">This value must be greater than zero.</span></span> <span data-ttu-id="f6d1f-227">Размер по умолчанию — 81920.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-227">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="f6d1f-228">Считывает байты из текущего буферизованного потока и записывает их в другой поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-228">Reads the bytes from the current buffered stream and writes them to another stream.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-229">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-229"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-230">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-230"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-231">Текущий поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-231">The current stream does not support reading.</span></span>

<span data-ttu-id="f6d1f-232">- или -</span><span class="sxs-lookup"><span data-stu-id="f6d1f-232">-or-</span></span>

<span data-ttu-id="f6d1f-233">Параметр <paramref name="destination" /> не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-233"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-234">Текущий поток или параметр <paramref name="destination" /> был закрыт до вызова метода <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-234">Either the current stream or <paramref name="destination" /> was closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-235">Ошибка ввода/вывода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-235">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f6d1f-236">Поток, в который будет скопировано содержимое текущего буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-236">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="f6d1f-237">Размер (в байтах) буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-237">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="f6d1f-238">Это значение должно быть больше нуля.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-238">This value must be greater than zero.</span></span> <span data-ttu-id="f6d1f-239">Размер по умолчанию — 81920.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-239">The default sizer is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-240">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-240">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="f6d1f-241">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-241">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="f6d1f-242">Асинхронно считывает байты из текущего буферизованного потока и записывает их в другой поток, используя указанный размер буфера и токен отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-242">Asynchronously reads the bytes from the current buffered stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-243">Задача, представляющая асинхронную операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-243">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f6d1f-244">`CopyToAsync` Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-244">The `CopyToAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="f6d1f-245">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-245">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f6d1f-246">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-246">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="f6d1f-247">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-247">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  

<span data-ttu-id="f6d1f-248">Копирование начинается с текущей позиции в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-248">Copying begins at the current position in the current stream.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="f6d1f-249">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-249"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f6d1f-250">Освобождает неуправляемые ресурсы, используемые этим буферизованным потоком. Кроме того, возможно освобождение управляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-250">Releases the unmanaged resources used by the buffered stream and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f6d1f-251">Необходимо освободить все ресурсы, указав `true` для. `disposing`</span><span class="sxs-lookup"><span data-stu-id="f6d1f-251">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="f6d1f-252">Если `disposing` имеет `true`значение, поток также может гарантировать, что данные будут сброшены в базовый буфер, и получить доступ к другим объектам, которые можно финализировать.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-252">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span> <span data-ttu-id="f6d1f-253">Это может быть невозможно при вызове из метода завершения из-за отсутствия упорядочения среди методов завершения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-253">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>

<span data-ttu-id="f6d1f-254">Если поток использует обработчик операционной системы для связи с источником, рассмотрите возможность использования подкласса <xref:System.Runtime.InteropServices.SafeHandle> для этой цели.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-254">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>

<span data-ttu-id="f6d1f-255">Этот метод вызывается открытым <xref:System.ComponentModel.Component.Dispose> методом <xref:System.Object.Finalize%2A> и методом.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-255">This method is called by the public <xref:System.ComponentModel.Component.Dispose> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="f6d1f-256"><xref:System.ComponentModel.Component.Dispose>вызывает защищенный `Dispose(Boolean)` метод с параметром `disposing` , для `true`которого задано значение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-256"><xref:System.ComponentModel.Component.Dispose> invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="f6d1f-257"><xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. `Dispose(Boolean)`</span><span class="sxs-lookup"><span data-stu-id="f6d1f-257"><xref:System.Object.Finalize%2A> invokes `Dispose(Boolean)` with `disposing` set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d1f-258">Асинхронно освобождает неуправляемые ресурсы, используемые буферизованным потоком.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-258">Asynchronously releases the unmanaged resources used by the buffered stream.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-259">Задача, представляющая асинхронную операцию закрытия.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-259">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f6d1f-260">`DisposeAsync` Метод позволяет выполнять ресурсоемкие операции удаления без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-260">The `DisposeAsync` method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="f6d1f-261">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-261">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f6d1f-262">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-262">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="f6d1f-263">Этот метод уничтожает поток, записывая изменения в резервное хранилище и закрывая поток для освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-263">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="f6d1f-264">Вызов `DisposeAsync` позволяет перераспределить ресурсы, используемые <xref:System.IO.BufferedStream> в, для других целей.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-264">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.BufferedStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="f6d1f-265">Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="f6d1f-265">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6d1f-266">Ссылка на ожидаемый отложенный асинхронный запрос.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-266">The reference to the pending asynchronous request to wait for.</span></span></param>
        <summary><span data-ttu-id="f6d1f-267">Ожидает завершения отложенной асинхронной операции чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-267">Waits for the pending asynchronous read operation to complete.</span></span> <span data-ttu-id="f6d1f-268">(Рекомендуется использовать <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="f6d1f-268">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="f6d1f-269">Количество байтов, считанных из потока, от нуля (0) до количества запрошенных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-269">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span></span> <span data-ttu-id="f6d1f-270">Потоки возвращают только 0 только в конце потока, в противном случае они должны блокироваться, пока не будет доступен по крайней мере 1 байт.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-270">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-271">В .NET Framework 4 и более ранних версиях необходимо использовать методы, такие как <xref:System.IO.Stream.BeginRead%2A> и <xref:System.IO.Stream.EndRead%2A> , для реализации асинхронных файловых операций.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-271">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f6d1f-272">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>и <xref:System.IO.BufferedStream.FlushAsync%2A>, упрощают реализацию асинхронных операций с файлами.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-272">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f6d1f-273"><xref:System.IO.BufferedStream.EndRead%2A><xref:System.IAsyncResult> для определения числа считанных байтов необходимо вызвать метод.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-273"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-274">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-274"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-275">Этот объект <see cref="T:System.IAsyncResult" /> не был создан путем вызова <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> для данного класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-275">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6d1f-276">Отложенный асинхронный запрос.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-276">The pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="f6d1f-277">Завершает асинхронную операцию записи и блокирует до тех пор, пока не будет завершена операция ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-277">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span></span> <span data-ttu-id="f6d1f-278">(Рекомендуется использовать <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="f6d1f-278">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-279">В .NET Framework 4 и более ранних версиях необходимо использовать методы, такие как <xref:System.IO.Stream.BeginWrite%2A> и <xref:System.IO.Stream.EndWrite%2A> , для реализации асинхронных файловых операций.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-279">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="f6d1f-280">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>и <xref:System.IO.BufferedStream.FlushAsync%2A>, упрощают реализацию асинхронных операций с файлами.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-280">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="f6d1f-281"><xref:System.IO.BufferedStream.EndWrite%2A>метод должен вызываться только один раз для каждого <xref:System.IO.BufferedStream.BeginRead%2A>вызова метода.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-281"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="f6d1f-282">Не удается завершить процесс чтения до начала другой операции чтения, которая может вызвать взаимоблокировку или другое нежелательное поведение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-282">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-283"><paramref name="asyncResult" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-283"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-284">Этот объект <see cref="T:System.IAsyncResult" /> не был создан в результате вызова <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> в данном классе.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-284">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d1f-285">Очищает все буферы для этого потока и приводит к записи всех буферизованных данных в базовое устройство.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-285">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-286">При сбросе потока его базовый кодировщик не очищается, пока не будет `Flush` явно <xref:System.IO.Stream.Close%2A>вызван метод или.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-286">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="f6d1f-287">При использовании <xref:System.IO.BufferedStream.%23ctor%2A> конструктора с тем, чтобы указать размер буфера при `BufferedStream` создании объекта, содержимое очищается при достижении размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-287">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="f6d1f-288">Например, код `BufferedStream bs = new BufferedStream(bs, 5)` будет очищать содержимое, когда размер буфера достигнет 5 байт.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-288">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="f6d1f-289">Все методы `BufferedStream` чтения и записи автоматически обслуживают буфер, поэтому нет необходимости вызывать `Flush` при переключении между чтением и записью.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-289">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-290">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-290">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-291">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-291">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-292">Источник данных или репозиторий закрыты.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-292">The data source or repository is not open.</span></span></exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-293">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-293">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-294">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-294">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-295">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-295">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-296">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-296">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="f6d1f-297">Асинхронно очищает все буферы данного потока, вызывает запись буферизованных данных в базовое устройство и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-297">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-298">Задача, представляющая асинхронную операцию очистки.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-298">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-299">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-299">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-300">Получает длину потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-300">Gets the stream length in bytes.</span></span></summary>
        <value><span data-ttu-id="f6d1f-301">Длина потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-301">The stream length in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-302">Базовый поток закрыт или его значение равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-302">The underlying stream is <see langword="null" /> or closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-303">Этот поток не поддерживает поиск.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-303">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-304">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-304">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-305">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-305">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-306">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-306">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-307">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-307">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-308">Получает позицию в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-308">Gets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="f6d1f-309">Позиция в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-309">The position within the current stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-310">`get` Метод доступа <xref:System.IO.BufferedStream.Seek%2A> вызывает для получения текущей позицией в базовом потоке, а затем корректирует это значение в соответствии с текущей позицией в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-310">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="f6d1f-311">Метод доступа копирует все данные, записанные ранее в буфер, в базовый поток, а затем <xref:System.IO.BufferedStream.Seek%2A>вызывает. `set`</span><span class="sxs-lookup"><span data-stu-id="f6d1f-311">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="f6d1f-312">Поддерживается поиск в любом расположении, превышающем длину потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-312">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-313">Значение, переданное в <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />, представляет собой отрицательное число.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-313">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-314">Ошибка ввода-вывода, например, указывающая, что поток закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-314">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-315">Поток не поддерживает поиск.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-315">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-316">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-316">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-317">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-317">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-318">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-318">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-319">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-319">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="bufferedStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f6d1f-320">Область памяти.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-320">A region of memory.</span></span> <span data-ttu-id="f6d1f-321">При возвращении данного метода содержимое этой области заменяется байтами, считанными из текущего источника.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-321">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="f6d1f-322">Копирует байты из текущего буферизованного потока в диапазон байтов и перемещает позицию в буферизованном потоке вперед на количество прочитанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-322">Copies bytes from the current buffered stream to a byte span and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-323">Общее количество байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-323">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="f6d1f-324">Это число может быть меньше количества выделенных в буфере байтов, если столько байтов в настоящее время недоступно, а также равняться нулю (0), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-324">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="f6d1f-325">Используйте свойство <xref:System.IO.BufferedStream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-325">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="f6d1f-326"><xref:System.IO.BufferedStream.ReadAsync%2A> Используйте метод для асинхронного чтения из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-326">Use the <xref:System.IO.BufferedStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="f6d1f-327">Реализации этого метода считывают максимум `buffer.Length` байт из текущего потока и сохраняют их в. `buffer`</span><span class="sxs-lookup"><span data-stu-id="f6d1f-327">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="f6d1f-328">Текущая координата в потоке увеличивается на число считанных байтов; Однако при возникновении исключения текущее место в потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-328">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="f6d1f-329">Реализации возвращают число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-329">Implementations return the number of bytes read.</span></span> <span data-ttu-id="f6d1f-330">Реализация будет заблокирована до тех пор, пока не будет прочитан хотя бы один байт данных в случае, если данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-330">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="f6d1f-331">`Read`Возвращает 0 только в том случае, если в потоке больше нет данных и больше не ожидается (например, закрытый сокет или конец файла).</span><span class="sxs-lookup"><span data-stu-id="f6d1f-331">`Read` returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="f6d1f-332">Реализация может возвращать меньше байтов, чем было запрошено, даже если конец потока не был достигнут.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-332">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="f6d1f-333">Используется <xref:System.IO.BinaryReader> для чтения примитивных типов данных.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-333">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f6d1f-334">Буфер, в который необходимо скопировать байты.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-334">The buffer to which bytes are to be copied.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-335">Смещение в буфере (в байтах), с которого начинается чтение байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-335">The byte offset in the buffer at which to begin reading bytes.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-336">Количество байтов, чтение которых необходимо выполнить.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-336">The number of bytes to be read.</span></span></param>
        <summary><span data-ttu-id="f6d1f-337">Копирует байты из текущего буферизованного потока в массив.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-337">Copies bytes from the current buffered stream to an array.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-338">Общее число байтов, считанных в <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-338">The total number of bytes read into <paramref name="array" />.</span></span> <span data-ttu-id="f6d1f-339">Это число может быть меньше, чем количество запрошенных байтов, если столько байтов в настоящее время недоступно, или равняться нулю, если конец файла был достигнут раньше, чем были считаны данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-339">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-340">`Read` Метод возвратит 0, только если достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-340">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="f6d1f-341">Во всех остальных случаях `Read` всегда считывает по крайней мере один байт из потока перед возвратом.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-341">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="f6d1f-342">По определению, если при вызове `Read`из потока данные недоступны `Read` , метод возвращает 0 (конец потока достигается автоматически).</span><span class="sxs-lookup"><span data-stu-id="f6d1f-342">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="f6d1f-343">Реализация может возвращать меньше байтов, чем было запрошено, даже если конец потока не был достигнут.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-343">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="f6d1f-344">Используется <xref:System.IO.BinaryReader> для чтения примитивных типов данных.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-344">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6d1f-345">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-345">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-346">Длина <paramref name="array" /> минус <paramref name="offset" /> меньше <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-346">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-347">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-347"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-348"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-348"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-349">Поток не открыт или его значение равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-349">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-350">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-350">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-351">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-351">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-352">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-352">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-353">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-353">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-354">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-354">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-355">Область памяти, в которую будут записываться данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-355">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-356">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-356">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="f6d1f-357">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-357">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="f6d1f-358">Асинхронно считывает последовательность байтов из текущего буферизованного потока и перемещает позицию внутри буферизованного потока на число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-358">Asynchronously reads a sequence of bytes from the current buffered stream and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-359">Задача, представляющая асинхронную операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-359">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="f6d1f-360">Значение свойства <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> содержит общее число байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-360">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="f6d1f-361">Итоговое значение может быть меньше количества выделенных в буфере байтов, если столько байтов в настоящее время недоступно, или оно может равняться нулю (0), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-361">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f6d1f-362">`ReadAsync` Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-362">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="f6d1f-363">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-363">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f6d1f-364">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-364">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="f6d1f-365">Используйте свойство <xref:System.IO.BufferedStream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-365">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="f6d1f-366">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> значение <xref:System.Threading.Tasks.Task.Status> для свойства.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-366">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-367">Буфер, в который записываются данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-367">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-368">Смещение байтов в <paramref name="buffer" />, с которого начинается запись данных из потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-368">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-369">Максимальное число байтов, предназначенных для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-369">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-370">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-370">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="f6d1f-371">Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию в потоке на число считанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-371">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-372">Задача, представляющая асинхронную операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-372">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="f6d1f-373">Значение параметра <paramref name="TResult" /> содержит общее число байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-373">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="f6d1f-374">Значение результата может быть меньше запрошенного числа байтов, если число доступных в данный момент байтов меньше запрошенного числа, или результат может быть равен 0 (нулю), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-374">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-375">Токен отмены можно создать, создав экземпляр <xref:System.Threading.CancellationTokenSource> класса и <xref:System.Threading.CancellationTokenSource.Token%2A> передав свойство в качестве `cancellationToken` параметра.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-375">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-376">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-377"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-377"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-378">Сумма значений параметров <paramref name="offset" /> и <paramref name="count" /> больше длины буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-378">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-379">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-379">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-380">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-380">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6d1f-381">Поток в настоящее время используется предыдущей операцией чтения.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-381">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6d1f-382">Считывает байт из базового потока и возвращает байт, приведенный к <see langword="int" />, или значение -1 при попытке чтения из конца потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-382">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-383">Байт, приведенный к <see langword="int" />, или значение -1 при попытке чтения из конца потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-383">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-384">Ошибка ввода-вывода, например указывающая, что поток закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-384">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-385">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-385">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-386">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-386">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="f6d1f-387">Реализация по умолчанию <see langword="Stream" /> для создает новый однобайтовый массив, а затем <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />вызывает.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-387">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="f6d1f-388">Хотя это формально верно, это неэффективно.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-388">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="f6d1f-389">Любой поток с внутренним буфером должен переопределить этот метод и предоставить гораздо более эффективную версию, которая считывает буфер напрямую, избегая дополнительного выделения массива при каждом вызове.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-389">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-390">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-390">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-391">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-391">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-392">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-392">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="f6d1f-393">Смещение в байтах относительно <paramref name="origin" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-393">A byte offset relative to <paramref name="origin" />.</span></span></param>
        <param name="origin"><span data-ttu-id="f6d1f-394">Значение типа <see cref="T:System.IO.SeekOrigin" /> определяет точку отсчета, относительно которой указывается новая позиция.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-394">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="f6d1f-395">Задает позицию в текущем буферизованном потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-395">Sets the position within the current buffered stream.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-396">Новая позиция в текущем буферизованном потоке.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-396">The new position within the current buffered stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-397">Если значение параметра `offset` является отрицательным, новая позиция будет предшествовать позиции, заданной параметром `origin`, при этом расстояние между позициями будет равняться числу байтов, заданному параметром `offset`.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-397">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="f6d1f-398">Если `offset` значение равно 0, то новое значение будет равно положению, `origin`заданному параметром.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-398">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="f6d1f-399">Если значение параметра `offset` является положительным, новая позиция будет следовать за позицией, заданной параметром `origin`, при этом расстояние между позициями будет равняться количеству байтов, которое задано параметром `offset`.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-399">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="f6d1f-400">Если объект является базовым потоком <xref:System.IO.StreamReader> для объекта, вызов <xref:System.IO.BufferedStream.Seek%2A> метода может привести к тому, что расположение потока больше не будет соответствовать положению внутреннего буфера в модуле чтения. <xref:System.IO.BufferedStream></span><span class="sxs-lookup"><span data-stu-id="f6d1f-400">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="f6d1f-401">Чтобы сбросить внутренний буфер, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> метод, однако этот метод снижает производительность и должен вызываться только при крайней необходимости.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-401">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="f6d1f-402">Поддерживается поиск в любом расположении, превышающем длину потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-402">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-403">Поток не открыт или его значение равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-403">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-404">Поток не поддерживает поиск.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-404">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-405">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-405">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-406">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-407">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-408">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="f6d1f-409">Целое число, определяющее необходимую длину текущего буферизованного потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-409">An integer indicating the desired length of the current buffered stream in bytes.</span></span></param>
        <summary><span data-ttu-id="f6d1f-410">Задает длину буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-410">Sets the length of the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-411">Буфер очищается перед установкой длины базового источника данных или репозитория.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-411">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="f6d1f-412">Если указанное значение меньше текущей длины буферизованного потока, буферизованный поток усекается.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-412">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="f6d1f-413">Если указанное значение больше текущей длины буферизованного потока, буферизованный поток расширяется.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-413">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="f6d1f-414">Если буферизованный поток развернут, содержимое буферизованного потока между старой и новой длиной не определено.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-414">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="f6d1f-415">`SetLength`При необходимости очищает все буферизованные записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-415">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="f6d1f-416">Поток должен поддерживать как запись, так и поиск `SetLength` для работы.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-416">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-417"><paramref name="value" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-417"><paramref name="value" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-418">Поток не открыт или его значение равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-418">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-419">Этот поток не поддерживает ни поиск, ни запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-419">The stream does not support both writing and seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-420">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-420">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-421">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-421">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-422">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-422">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-423">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-423">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6d1f-424">Возвращает базовый экземпляр <see cref="T:System.IO.Stream" /> для этого буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-424">Gets the underlying <see cref="T:System.IO.Stream" /> instance for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="f6d1f-425">Базовый экземпляр потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-425">The underlying stream instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="bufferedStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-426">Область памяти.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-426">A region of memory.</span></span> <span data-ttu-id="f6d1f-427">Этот метод копирует содержимое данной области в текущий буферизованный поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-427">This method copies the contents of this region to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="f6d1f-428">Записывает последовательность байтов в текущий буферизованный поток и перемещает текущую позицию внутри буферизованного потока на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-428">Writes a sequence of bytes to the current buffered stream and advances the current position within this buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f6d1f-429">Используйте свойство <xref:System.IO.BufferedStream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-429">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="f6d1f-430"><xref:System.IO.BufferedStream.WriteAsync%2A> Используйте метод для асинхронной записи в текущий буферизованный поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-430">Use the <xref:System.IO.BufferedStream.WriteAsync%2A> method to write asynchronously to the current buffered stream.</span></span>

<span data-ttu-id="f6d1f-431">Если операция записи выполнена успешно, то позицию в буферизованном потоке увеличивается на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-431">If the write operation is successful, the position within the buffered stream advances by the number of bytes written.</span></span> <span data-ttu-id="f6d1f-432">При возникновении исключения место в буферизованном потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-432">If an exception occurs, the position within the buffered stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f6d1f-433">Массив байтов, из которого необходимо скопировать <paramref name="count" /> байтов в текущий буферизованный поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-433">The byte array from which to copy <paramref name="count" /> bytes to the current buffered stream.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-434">Смещение в буфере, с которого необходимо начать копирование байтов в текущий буферизованный поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-434">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-435">Количество байтов, которые необходимо записать в текущий буферизованный поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-435">The number of bytes to be written to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="f6d1f-436">Копирует байты в буферизованный поток и перемещает текущую позицию в буферизованном потоке вперед на количество записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-436">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f6d1f-437">Этот пример кода является частью большого примера, <xref:System.IO.BufferedStream> приведенного для класса.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-437">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-438">Длина <paramref name="array" /> минус <paramref name="offset" /> меньше <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-438">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-439"><paramref name="array" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-439"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-440"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-440"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f6d1f-441">Поток закрыт или его значение равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-441">The stream is closed or <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-442">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-442">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-443">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-443">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-444">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-444">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-445">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-445">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-446">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-446">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-447">Область памяти, из которой будут записываться данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-447">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-448">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-448">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="f6d1f-449">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-449">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="f6d1f-450">Асинхронно записывает последовательность байтов в текущий буферизованный поток, перемещает текущую позицию внутри буферизованного потока на число записанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-450">Asynchronously writes a sequence of bytes to the current buffered stream, advances the current position within this buffered stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-451">Задача, представляющая асинхронную операцию записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-451">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f6d1f-452">`WriteAsync` Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-452">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="f6d1f-453">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-453">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="f6d1f-454">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-454">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="f6d1f-455">Используйте свойство <xref:System.IO.BufferedStream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-455">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="f6d1f-456">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> значение <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> для свойства.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-456">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6d1f-457">Буфер, из которого записываются данные.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-457">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="f6d1f-458">Смещение байтов (начиная с нуля) в <paramref name="buffer" />, с которого начинается копирование байтов в поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-458">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="f6d1f-459">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-459">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f6d1f-460">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-460">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="f6d1f-461">Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-461">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f6d1f-462">Задача, представляющая асинхронную операцию записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-462">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6d1f-463">Токен отмены можно создать, создав экземпляр <xref:System.Threading.CancellationTokenSource> класса и <xref:System.Threading.CancellationTokenSource.Token%2A> передав свойство в качестве `cancellationToken` параметра.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-463">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-464">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-464"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6d1f-465"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-465"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6d1f-466">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-466">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-467">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-467">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-468">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-468">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6d1f-469">Поток в настоящее время используется предыдущей операцией записи.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-469">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="f6d1f-470">Байт, который необходимо записать в поток.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-470">A byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="f6d1f-471">Записывает байт в текущую позицию буферизованного потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-471">Writes a byte to the current position in the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f6d1f-472">Используйте свойство <xref:System.IO.BufferedStream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-472">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6d1f-473">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-473">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6d1f-474">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-474"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6d1f-475">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="f6d1f-475">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f6d1f-476">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="f6d1f-476">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f6d1f-477">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="f6d1f-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f6d1f-478">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="f6d1f-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>