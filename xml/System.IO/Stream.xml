<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="097d2ca3663946d99f5df2ac75cb347443cca016" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70343400" /></Metadata><TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="2f525-101">Предоставляет универсальное представление последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-101">Provides a generic view of a sequence of bytes.</span></span> <span data-ttu-id="2f525-102">Этот класс является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="2f525-102">This is an abstract class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-103"><xref:System.IO.Stream>является абстрактным базовым классом для всех потоков.</span><span class="sxs-lookup"><span data-stu-id="2f525-103"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span> <span data-ttu-id="2f525-104">Поток - это абстракция последовательности байтов, например файла, устройства ввода-вывода, межпроцессного канала связи или сокета TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="2f525-104">A stream is an abstraction of a sequence of bytes, such as a file, an input/output device, an inter-process communication pipe, or a TCP/IP socket.</span></span> <span data-ttu-id="2f525-105"><xref:System.IO.Stream> Класс и его производные классы предоставляют общее представление этих различных типов входных и выходных данных и изолируют программиста от конкретных деталей операционной системы и базовых устройств.</span><span class="sxs-lookup"><span data-stu-id="2f525-105">The <xref:System.IO.Stream> class and its derived classes provide a generic view of these different types of input and output, and isolate the programmer from the specific details of the operating system and the underlying devices.</span></span>  
  
 <span data-ttu-id="2f525-106">Потоки включают три основные операции:</span><span class="sxs-lookup"><span data-stu-id="2f525-106">Streams involve three fundamental operations:</span></span>  
  
-   <span data-ttu-id="2f525-107">Можно выполнять чтение из потоков.</span><span class="sxs-lookup"><span data-stu-id="2f525-107">You can read from streams.</span></span> <span data-ttu-id="2f525-108">Чтение — это передача данных из потока в структуру данных, например массив байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-108">Reading is the transfer of data from a stream into a data structure, such as an array of bytes.</span></span>  
  
-   <span data-ttu-id="2f525-109">Можно выполнять запись в потоки.</span><span class="sxs-lookup"><span data-stu-id="2f525-109">You can write to streams.</span></span> <span data-ttu-id="2f525-110">Запись — это передача данных из структуры данных в поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-110">Writing is the transfer of data from a data structure into a stream.</span></span>  
  
-   <span data-ttu-id="2f525-111">Потоки могут поддерживать поиск.</span><span class="sxs-lookup"><span data-stu-id="2f525-111">Streams can support seeking.</span></span> <span data-ttu-id="2f525-112">Поиск ссылается на запрос и изменение текущей позицией в потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-112">Seeking refers to querying and modifying the current position within a stream.</span></span> <span data-ttu-id="2f525-113">Возможность поиска зависит от типа резервного хранилища, в котором находится поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-113">Seek capability depends on the kind of backing store a stream has.</span></span> <span data-ttu-id="2f525-114">Например, сетевые потоки не имеют единой концепции текущей должности, поэтому обычно не поддерживают поиск.</span><span class="sxs-lookup"><span data-stu-id="2f525-114">For example, network streams have no unified concept of a current position, and therefore typically do not support seeking.</span></span>  
  
 <span data-ttu-id="2f525-115">Некоторые из наиболее часто используемых потоков, наследующих от <xref:System.IO.Stream> , <xref:System.IO.FileStream>— и <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="2f525-115">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 <span data-ttu-id="2f525-116">В зависимости от базового источника данных или репозитория потоки могут поддерживать только некоторые из этих возможностей.</span><span class="sxs-lookup"><span data-stu-id="2f525-116">Depending on the underlying data source or repository, streams might support only some of these capabilities.</span></span> <span data-ttu-id="2f525-117">Вы можете запросить <xref:System.IO.Stream.CanRead%2A>его возможности в потоке с помощью свойств <xref:System.IO.Stream> , <xref:System.IO.Stream.CanWrite%2A>и <xref:System.IO.Stream.CanSeek%2A> класса.</span><span class="sxs-lookup"><span data-stu-id="2f525-117">You can query a stream for its capabilities by using the <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, and <xref:System.IO.Stream.CanSeek%2A> properties of the <xref:System.IO.Stream> class.</span></span>  
  
 <span data-ttu-id="2f525-118">Методы <xref:System.IO.Stream.Read%2A> и<xref:System.IO.Stream.Write%2A> считывают и записывают данные в различных форматах.</span><span class="sxs-lookup"><span data-stu-id="2f525-118">The <xref:System.IO.Stream.Read%2A> and <xref:System.IO.Stream.Write%2A> methods read and write data in a variety of formats.</span></span> <span data-ttu-id="2f525-119">Для потоков, поддерживающих поиск, используйте <xref:System.IO.Stream.Seek%2A> методы <xref:System.IO.Stream.SetLength%2A> и и <xref:System.IO.Stream.Position%2A> свойства и <xref:System.IO.Stream.Length%2A> , чтобы запросить и изменить текущую и длину потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-119">For streams that support seeking, use the <xref:System.IO.Stream.Seek%2A> and <xref:System.IO.Stream.SetLength%2A> methods and the <xref:System.IO.Stream.Position%2A> and <xref:System.IO.Stream.Length%2A> properties to query and modify the current position and length of a stream.</span></span>  
  
 <span data-ttu-id="2f525-120">Этот тип реализует интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="2f525-120">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="2f525-121">По окончании использования выдаленную ему память следует прямо или косвенно освободить.</span><span class="sxs-lookup"><span data-stu-id="2f525-121">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="2f525-122">Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`.</span><span class="sxs-lookup"><span data-stu-id="2f525-122">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="2f525-123">Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2f525-123">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="2f525-124">Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="2f525-124">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="2f525-125">Удаление объекта приводит к сбросу всех буферизованных данных и, по сути, <xref:System.IO.Stream.Flush%2A> вызывает метод. <xref:System.IO.Stream></span><span class="sxs-lookup"><span data-stu-id="2f525-125">Disposing a <xref:System.IO.Stream> object flushes any buffered data, and essentially calls the <xref:System.IO.Stream.Flush%2A> method for you.</span></span> <span data-ttu-id="2f525-126"><xref:System.IO.Stream.Dispose%2A>также освобождает ресурсы операционной системы, такие как дескрипторы файлов, сетевые подключения или память, используемые для любой внутренней буферизации.</span><span class="sxs-lookup"><span data-stu-id="2f525-126"><xref:System.IO.Stream.Dispose%2A> also releases operating system resources such as file handles, network connections, or memory used for any internal buffering.</span></span> <span data-ttu-id="2f525-127"><xref:System.IO.BufferedStream> Класс предоставляет возможность упаковки буферизованного потока вокруг другого потока для повышения производительности чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-127">The <xref:System.IO.BufferedStream> class provides the capability of wrapping a buffered stream around another stream in order to improve read and write performance.</span></span>  
  
 <span data-ttu-id="2f525-128">Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.IO.Stream> , класс включает асинхронные методы для упрощения асинхронных операций.</span><span class="sxs-lookup"><span data-stu-id="2f525-128">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.IO.Stream> class includes async methods to simplify asynchronous operations.</span></span> <span data-ttu-id="2f525-129">Асинхронный метод содержит `Async` в своем имени, <xref:System.IO.Stream.ReadAsync%2A>например, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.Stream.FlushAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f525-129">An async method contains `Async` in its name, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>.</span></span> <span data-ttu-id="2f525-130">Эти методы позволяют выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-130">These methods enable you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-131">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-131">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-132">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-132">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-133">При [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] использовании в <xref:System.IO.Stream> приложении включает два метода расширения: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> и <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f525-133">When used in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> includes two extension methods: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span></span> <span data-ttu-id="2f525-134">Эти методы преобразуют <xref:System.IO.Stream> объект в поток [!INCLUDE[wrt](~/includes/wrt-md.md)]в.</span><span class="sxs-lookup"><span data-stu-id="2f525-134">These methods convert a <xref:System.IO.Stream> object to a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)].</span></span> <span data-ttu-id="2f525-135">Можно [!INCLUDE[wrt](~/includes/wrt-md.md)] также преобразовать поток в <xref:System.IO.Stream> в объект с помощью <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> методов и <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> .</span><span class="sxs-lookup"><span data-stu-id="2f525-135">You can also convert a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)] to a <xref:System.IO.Stream> object by using the <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> methods.</span></span> <span data-ttu-id="2f525-136">Дополнительные сведения см. в разделе [Практическое руководство. Преобразование между потоками .NET Framework и потоками среды выполнения Windows](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span><span class="sxs-lookup"><span data-stu-id="2f525-136">For more information, see [How to: Convert Between .NET Framework Streams and Windows Runtime Streams](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span></span>  
  
 <span data-ttu-id="2f525-137">Некоторые реализации потоков выполняют локальную буферизацию базовых данных для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="2f525-137">Some stream implementations perform local buffering of the underlying data to improve performance.</span></span> <span data-ttu-id="2f525-138">Для таких потоков можно использовать <xref:System.IO.Stream.Flush%2A> метод или <xref:System.IO.Stream.FlushAsync%2A> , чтобы очистить все внутренние буферы и убедиться, что все данные записаны в базовый источник данных или репозиторий.</span><span class="sxs-lookup"><span data-stu-id="2f525-138">For such streams, you can use the <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.FlushAsync%2A> method to clear any internal buffers and ensure that all data has been written to the underlying data source or repository.</span></span>  
  
 <span data-ttu-id="2f525-139">Если вам нужен поток без резервного хранилища (также известный как битовый контейнер), используйте <xref:System.IO.Stream.Null> поле для получения экземпляра потока, предназначенного для этой цели.</span><span class="sxs-lookup"><span data-stu-id="2f525-139">If you need a stream with no backing store (also known as a bit bucket), use the <xref:System.IO.Stream.Null> field to retrieve an instance of a stream that is designed for this purpose.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-140">В следующем примере показано, как использовать два <xref:System.IO.FileStream> объекта для асинхронного копирования файлов из одного каталога в другой.</span><span class="sxs-lookup"><span data-stu-id="2f525-140">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another directory.</span></span> <span data-ttu-id="2f525-141">Класс <xref:System.IO.FileStream> является производным от класса <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="2f525-141">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span> <span data-ttu-id="2f525-142">Обратите внимание, что обработчик событий <xref:System.Web.UI.WebControls.Button.Click> для элемента управления <xref:System.Windows.Controls.Button> помечается с помощью модификатора `async` , так как вызывает асинхронный метод.</span><span class="sxs-lookup"><span data-stu-id="2f525-142">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="2f525-143">При реализации класса, производного от <see cref="T:System.IO.Stream" />, необходимо предоставить реализации <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> для методов и <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> .</span><span class="sxs-lookup"><span data-stu-id="2f525-143">When you implement a derived class of <see cref="T:System.IO.Stream" />, you must provide implementations for the <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> methods.</span></span> <span data-ttu-id="2f525-144">Асинхронные методы <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />и <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> используют синхронные методы <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> и <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> в своих реализациях.</span><span class="sxs-lookup"><span data-stu-id="2f525-144">The asynchronous methods <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, and <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> use the synchronous methods <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> in their implementations.</span></span> <span data-ttu-id="2f525-145">Поэтому реализации <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> и <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> будут правильно работать с асинхронными методами.</span><span class="sxs-lookup"><span data-stu-id="2f525-145">Therefore, your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> will work correctly with the asynchronous methods.</span></span> <span data-ttu-id="2f525-146">Реализации <see cref="M:System.IO.Stream.ReadByte" /> по умолчанию и <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> создают новый одноэлементный массив байтов, а затем <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> вызывают реализации методов и <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-146">The default implementations of <see cref="M:System.IO.Stream.ReadByte" /> and <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> create a new single-element byte array, and then call your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="2f525-147">При наследовании от <see cref="T:System.IO.Stream" />рекомендуется переопределять эти методы для доступа к внутреннему буферу, если таковой имеется, для значительно лучшей производительности.</span><span class="sxs-lookup"><span data-stu-id="2f525-147">When you derive from <see cref="T:System.IO.Stream" />, we recommend that you override these methods to access your internal buffer, if you have one, for substantially better performance.</span></span> <span data-ttu-id="2f525-148"><see cref="P:System.IO.Stream.CanRead" />Необходимо также предоставить реализации, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, ,<see cref="P:System.IO.Stream.Position" /> и<see cref="M:System.IO.Stream.SetLength(System.Int64)" />. <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" /></span><span class="sxs-lookup"><span data-stu-id="2f525-148">You must also provide implementations of <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, and <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.</span></span>  
  
<span data-ttu-id="2f525-149">Не переопределяйте <see cref="M:System.IO.Stream.Close" /> метод, вместо этого следует разместить <see cref="T:System.IO.Stream" /> всю логику очистки в <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> методе.</span><span class="sxs-lookup"><span data-stu-id="2f525-149">Do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all the <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="2f525-150">Дополнительные сведения см. [в разделе Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-150">For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span></para></block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-151">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-151">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md"><span data-ttu-id="2f525-152">Практическое руководство. Преобразование между потоками .NET Framework и потоками среды выполнения Windows</span><span class="sxs-lookup"><span data-stu-id="2f525-152">How to: Convert Between .NET Framework Streams and Windows Runtime Streams</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-153">Инициализирует новый экземпляр класса <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-153">Initializes a new instance of the <see cref="T:System.IO.Stream" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-154"><xref:System.IO.Stream>является абстрактным базовым классом для всех потоков.</span><span class="sxs-lookup"><span data-stu-id="2f525-154"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span>  
  
 <span data-ttu-id="2f525-155">Некоторые из наиболее часто используемых потоков, наследующих от <xref:System.IO.Stream> , <xref:System.IO.FileStream>— и <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="2f525-155">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-156">Буфер, в который необходимо считать данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-156">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-157">Смещение байтов в буфере <paramref name="buffer" />, с которого начинается запись данных, считанных из потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-157">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-158">Максимальное число байтов, предназначенных для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-158">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="2f525-159">Дополнительный асинхронный ответный вызов по завершении чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-159">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="2f525-160">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронное чтение от других запросов.</span><span class="sxs-lookup"><span data-stu-id="2f525-160">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="2f525-161">Начинает операцию асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-161">Begins an asynchronous read operation.</span></span> <span data-ttu-id="2f525-162">(Рекомендуется использовать <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="2f525-162">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="2f525-163"><see cref="T:System.IAsyncResult" /> представляет асинхронное чтение, которое может все еще быть отложено.</span><span class="sxs-lookup"><span data-stu-id="2f525-163">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-164">В платформе .NET Framework 4 и более ранних версий для реализации операций асинхронного ввода-вывода необходимо использовать такие методы, как <xref:System.IO.Stream.BeginRead%2A> и <xref:System.IO.Stream.EndRead%2A> .</span><span class="sxs-lookup"><span data-stu-id="2f525-164">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="2f525-165">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.Stream.FlushAsync%2A>, упрощают реализацию асинхронных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-165">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="2f525-166">Реализация `BeginRead` по умолчанию в потоке <xref:System.IO.Stream.Read%2A> вызывает метод синхронно, то есть `Read` может блокировать некоторые потоки.</span><span class="sxs-lookup"><span data-stu-id="2f525-166">The default implementation of `BeginRead` on a stream calls the <xref:System.IO.Stream.Read%2A> method synchronously, which means that `Read` might block on some streams.</span></span> <span data-ttu-id="2f525-167">Однако экземпляры классов, такие как `FileStream` и `NetworkStream` , полностью поддерживают асинхронные операции, если экземпляры были открыты асинхронно.</span><span class="sxs-lookup"><span data-stu-id="2f525-167">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="2f525-168">Таким образом, вызовы `BeginRead` не будут блокироваться в этих потоках.</span><span class="sxs-lookup"><span data-stu-id="2f525-168">Therefore, calls to `BeginRead` will not block on those streams.</span></span> <span data-ttu-id="2f525-169">Можно переопределить `BeginRead` (например, с помощью асинхронных делегатов), чтобы обеспечить асинхронное поведение.</span><span class="sxs-lookup"><span data-stu-id="2f525-169">You can override `BeginRead` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="2f525-170"><xref:System.IO.Stream.EndRead%2A> Передайте `IAsyncResult` возвращаемое значение методу потока, чтобы определить количество считанных байтов и освободить ресурсы операционной системы, используемые для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-170">Pass the `IAsyncResult` return value to the <xref:System.IO.Stream.EndRead%2A> method of the stream to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="2f525-171"><xref:System.IO.Stream.EndRead%2A>должен вызываться один раз для каждого вызова <xref:System.IO.Stream.BeginRead%2A>метода.</span><span class="sxs-lookup"><span data-stu-id="2f525-171"><xref:System.IO.Stream.EndRead%2A> must be called once for every call to <xref:System.IO.Stream.BeginRead%2A>.</span></span> <span data-ttu-id="2f525-172">Это можно сделать с помощью того же кода, который вызвал `BeginRead` или в обратном вызове, переданном в. `BeginRead`</span><span class="sxs-lookup"><span data-stu-id="2f525-172">You can do this either by using the same code that called `BeginRead` or in a callback passed to `BeginRead`.</span></span>  
  
 <span data-ttu-id="2f525-173">Текущая позицией в потоке обновляется при выдаче асинхронного чтения или записи, а не по завершении операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-173">The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</span></span>  
  
 <span data-ttu-id="2f525-174">Несколько одновременных асинхронных запросов отрабатывают порядок выполнения запроса неопределенным образом.</span><span class="sxs-lookup"><span data-stu-id="2f525-174">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="2f525-175">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-175">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="2f525-176">Если поток закрыт или передан недопустимый аргумент, исключения немедленно создаются из `BeginRead`.</span><span class="sxs-lookup"><span data-stu-id="2f525-176">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginRead`.</span></span> <span data-ttu-id="2f525-177">Ошибки, возникающие во время асинхронного запроса чтения, такие как сбой диска во время запроса ввода-вывода, происходят в потоке пула потоков и вызывают исключения при `EndRead`вызове метода.</span><span class="sxs-lookup"><span data-stu-id="2f525-177">Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndRead`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-178">Попытка выполнить чтение в асинхронном режиме за пределами конца потока или ошибка диска.</span><span class="sxs-lookup"><span data-stu-id="2f525-178">Attempted an asynchronous read past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-179">Один или несколько аргументов являются недопустимыми.</span><span class="sxs-lookup"><span data-stu-id="2f525-179">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-180">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-180">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-181">Текущая реализация класса <see langword="Stream" /> не поддерживает операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-181">The current <see langword="Stream" /> implementation does not support the read operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-182">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-182">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-183">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-183">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-184">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-184">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="2f525-185">Асинхронный файловый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-185">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-186">Буфер, из которого записываются данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-186">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-187">Смещение байтов в буфере <paramref name="buffer" />, с которого начинается запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-187">The byte offset in <paramref name="buffer" /> from which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-188">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-188">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="2f525-189">Дополнительный асинхронный обратный вызов по завершении записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-189">An optional asynchronous callback, to be called when the write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="2f525-190">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронную запись от других запросов.</span><span class="sxs-lookup"><span data-stu-id="2f525-190">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="2f525-191">Начинает операцию асинхронной записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-191">Begins an asynchronous write operation.</span></span> <span data-ttu-id="2f525-192">(Рекомендуется использовать <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="2f525-192">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="2f525-193"><see langword="IAsyncResult" /> представляет асинхронную запись, которая может все еще быть отложена.</span><span class="sxs-lookup"><span data-stu-id="2f525-193">An <see langword="IAsyncResult" /> that represents the asynchronous write, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-194">В платформе .NET Framework 4 и более ранних версий для реализации операций асинхронного ввода-вывода необходимо использовать такие методы, как <xref:System.IO.Stream.BeginWrite%2A> и <xref:System.IO.Stream.EndWrite%2A> .</span><span class="sxs-lookup"><span data-stu-id="2f525-194">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="2f525-195">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.Stream.FlushAsync%2A>, упрощают реализацию асинхронных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-195">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="2f525-196">Реализация `BeginWrite` по умолчанию в потоке <xref:System.IO.Stream.Write%2A> вызывает метод синхронно, то есть `Write` может блокировать некоторые потоки.</span><span class="sxs-lookup"><span data-stu-id="2f525-196">The default implementation of `BeginWrite` on a stream calls the <xref:System.IO.Stream.Write%2A> method synchronously, which means that `Write` might block on some streams.</span></span> <span data-ttu-id="2f525-197">Однако экземпляры классов, такие как `FileStream` и `NetworkStream` , полностью поддерживают асинхронные операции, если экземпляры были открыты асинхронно.</span><span class="sxs-lookup"><span data-stu-id="2f525-197">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="2f525-198">Таким образом, вызовы `BeginWrite` не будут блокироваться в этих потоках.</span><span class="sxs-lookup"><span data-stu-id="2f525-198">Therefore, calls to `BeginWrite` will not block on those streams.</span></span> <span data-ttu-id="2f525-199">Можно переопределить `BeginWrite` (например, с помощью асинхронных делегатов), чтобы обеспечить асинхронное поведение.</span><span class="sxs-lookup"><span data-stu-id="2f525-199">You can override `BeginWrite` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="2f525-200"><xref:System.IO.Stream.EndWrite%2A> Передайте `IAsyncResult` возвращенное текущим методом значение, чтобы убедиться, что запись завершается и освобождает ресурсы соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="2f525-200">Pass the `IAsyncResult` returned by the current method to <xref:System.IO.Stream.EndWrite%2A> to ensure that the write completes and frees resources appropriately.</span></span> <span data-ttu-id="2f525-201"><xref:System.IO.Stream.EndWrite%2A>должен вызываться один раз для каждого вызова <xref:System.IO.Stream.BeginWrite%2A>метода.</span><span class="sxs-lookup"><span data-stu-id="2f525-201"><xref:System.IO.Stream.EndWrite%2A> must be called once for every call to <xref:System.IO.Stream.BeginWrite%2A>.</span></span> <span data-ttu-id="2f525-202">Это можно сделать с помощью того же кода, который вызвал `BeginWrite` или в обратном вызове, переданном в. `BeginWrite`</span><span class="sxs-lookup"><span data-stu-id="2f525-202">You can do this either by using the same code that called `BeginWrite` or in a callback passed to `BeginWrite`.</span></span> <span data-ttu-id="2f525-203">Если во время асинхронной записи возникает ошибка, то исключение не будет вызываться до `EndWrite` вызова метода `IAsyncResult` с возвращаемым этим методом.</span><span class="sxs-lookup"><span data-stu-id="2f525-203">If an error occurs during an asynchronous write, an exception will not be thrown until `EndWrite` is called with the `IAsyncResult` returned by this method.</span></span>  
  
 <span data-ttu-id="2f525-204">Если поток доступен для записи, запись в конце потока расширяет поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-204">If a stream is writable, writing at the end of the stream expands the stream.</span></span>  
  
 <span data-ttu-id="2f525-205">Текущая позицией в потоке обновляется при выдаче асинхронного чтения или записи, а не после завершения операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-205">The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.</span></span> <span data-ttu-id="2f525-206">Несколько одновременных асинхронных запросов отрабатывают порядок выполнения запроса неопределенным образом.</span><span class="sxs-lookup"><span data-stu-id="2f525-206">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="2f525-207">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-207">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="2f525-208">Если поток закрыт или передан недопустимый аргумент, исключения немедленно создаются из `BeginWrite`.</span><span class="sxs-lookup"><span data-stu-id="2f525-208">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginWrite`.</span></span> <span data-ttu-id="2f525-209">Ошибки, возникающие при асинхронном запросе записи, такие как сбой диска во время запроса ввода-вывода, происходят в потоке пула потоков и вызывают исключения при вызове метода `EndWrite`.</span><span class="sxs-lookup"><span data-stu-id="2f525-209">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-210">Попытка выполнить запись в асинхронном режиме за пределами конца потока или ошибка диска.</span><span class="sxs-lookup"><span data-stu-id="2f525-210">Attempted an asynchronous write past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-211">Один или несколько аргументов являются недопустимыми.</span><span class="sxs-lookup"><span data-stu-id="2f525-211">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-212">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-212">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-213">Текущая реализация класса <see langword="Stream" /> не поддерживает операцию записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-213">The current <see langword="Stream" /> implementation does not support the write operation.</span></span></exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-214">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-214">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-215">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-215">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-216">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-216">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="2f525-217">Асинхронный файловый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-217">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-218">При переопределении в производном классе возвращает значение, показывающее, поддерживает ли текущий поток возможность чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-218">When overridden in a derived class, gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="2f525-219">Значение <see langword="true" />, если поток поддерживает чтение; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-219"><see langword="true" /> if the stream supports reading; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-220">Если класс, производный <xref:System.IO.Stream> от <xref:System.IO.Stream.Read%2A>, не поддерживает чтение, вызовы методов, <xref:System.IO.Stream.ReadByte%2A>и <xref:System.IO.Stream.BeginRead%2A> создают исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="2f525-220">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, and <xref:System.IO.Stream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2f525-221">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="2f525-221">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-222">Ниже приведен пример использования `CanRead` свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-222">The following is an example of using the `CanRead` property.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-223">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-223">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-224">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-224">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-225">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-225">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-226">При переопределении в производном классе возвращает значение, которое показывает, поддерживается ли в текущем потоке возможность поиска.</span><span class="sxs-lookup"><span data-stu-id="2f525-226">When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="2f525-227">Значение <see langword="true" />, если поток поддерживает поиск; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-227"><see langword="true" /> if the stream supports seeking; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-228">Если класс, производный <xref:System.IO.Stream> от <xref:System.IO.Stream.Length%2A>, не поддерживает поиск, вызовы, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>и <xref:System.IO.Stream.Seek%2A> вызывают исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="2f525-228">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, and <xref:System.IO.Stream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="2f525-229">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="2f525-229">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-230">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-230">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-231">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-231">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-232">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-232">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-233">Получает значение, которое показывает, может ли для данного потока истечь время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-233">Gets a value that determines whether the current stream can time out.</span></span></summary>
        <value><span data-ttu-id="2f525-234">Значение, которое показывает, может ли для данного потока истечь время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-234">A value that determines whether the current stream can time out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-235">Свойство <xref:System.IO.Stream.CanTimeout%2A> всегда возвращает значение `false`.</span><span class="sxs-lookup"><span data-stu-id="2f525-235">The <xref:System.IO.Stream.CanTimeout%2A> property always returns `false`.</span></span> <span data-ttu-id="2f525-236">Для <xref:System.Net.Sockets.NetworkStream>некоторых реализаций потока требуется другое поведение, например, время ожидания в случае прерывания или потери сетевого подключения.</span><span class="sxs-lookup"><span data-stu-id="2f525-236">Some stream implementations require different behavior, such as <xref:System.Net.Sockets.NetworkStream>, which times out if network connectivity is interrupted or lost.</span></span> <span data-ttu-id="2f525-237">При реализации потока, который должен иметь возможность истечения времени ожидания, это свойство должно быть переопределено для `true`возврата.</span><span class="sxs-lookup"><span data-stu-id="2f525-237">If you are implementing a stream that must be able to time out, this property should be overridden to return `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-238">При переопределении в производном классе возвращает значение, которое показывает, поддерживает ли текущий поток возможность записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-238">When overridden in a derived class, gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="2f525-239">Значение <see langword="true" />, если поток поддерживает запись; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-239"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-240">Если класс, производный <xref:System.IO.Stream> от <xref:System.IO.Stream.Write%2A> <xref:System.IO.Stream.BeginWrite%2A> ,не<xref:System.IO.Stream.WriteByte%2A> поддерживает запись, вызов, или создает исключение. <xref:System.NotSupportedException></span><span class="sxs-lookup"><span data-stu-id="2f525-240">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="2f525-241">В таких случаях, <xref:System.IO.Stream.Flush%2A> как правило, реализуется как пустой метод для обеспечения полной совместимости с <xref:System.IO.Stream> другими типами, так как он является допустимым для очистки потока, доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-241">In such cases, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>
  
 <span data-ttu-id="2f525-242">Если поток закрыт, это свойство возвращает `false`значение.</span><span class="sxs-lookup"><span data-stu-id="2f525-242">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-243">Ниже приведен пример использования `CanWrite` свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-243">The following is an example of using the `CanWrite` property.</span></span>  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-244">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-244">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-245">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-246">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-247">Закрывает текущий поток и отключает все ресурсы (например, сокеты и файловые дескрипторы), связанные с текущим потоком.</span><span class="sxs-lookup"><span data-stu-id="2f525-247">Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</span></span> <span data-ttu-id="2f525-248">Вместо вызова данного метода, убедитесь в том, что поток надлежащим образом ликвидирован.</span><span class="sxs-lookup"><span data-stu-id="2f525-248">Instead of calling this method, ensure that the stream is properly disposed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-249">Этот метод вызывает <xref:System.IO.Stream.Dispose%2A>, задавая `true` для освобождения всех ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2f525-249">This method calls <xref:System.IO.Stream.Dispose%2A>, specifying `true` to release all resources.</span></span> <span data-ttu-id="2f525-250">Нет необходимости в специальном вызове <xref:System.IO.Stream.Close%2A> метода.</span><span class="sxs-lookup"><span data-stu-id="2f525-250">You do not have to specifically call the <xref:System.IO.Stream.Close%2A> method.</span></span> <span data-ttu-id="2f525-251">Вместо этого убедитесь, что <xref:System.IO.Stream> каждый объект удален правильно.</span><span class="sxs-lookup"><span data-stu-id="2f525-251">Instead, ensure that every <xref:System.IO.Stream> object is properly disposed.</span></span> <span data-ttu-id="2f525-252">Можно объявить <xref:System.IO.Stream> `using` объекты в блоке (или `Using` блоке в Visual Basic), чтобы убедиться, что поток и все его ресурсы удалены, или можно явно вызвать <xref:System.IO.Stream.Dispose%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="2f525-252">You can declare <xref:System.IO.Stream> objects within a `using` block (or `Using` block in Visual Basic) to ensure that the stream and all of its resources are disposed, or you can explicitly call the <xref:System.IO.Stream.Dispose%2A> method.</span></span>  
  
 <span data-ttu-id="2f525-253">При сбросе потока его базовый кодировщик не очищается, пока не будет явно вызвана <xref:System.IO.Stream.Flush%2A> реализация `Close`или.</span><span class="sxs-lookup"><span data-stu-id="2f525-253">Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of <xref:System.IO.Stream.Flush%2A> or `Close`.</span></span> <span data-ttu-id="2f525-254">Значение <xref:System.IO.StreamWriter.AutoFlush%2A> указывает, что данные будут сброшены из буфера в поток, но состояние кодировщика не будет сбрасываться. `true`</span><span class="sxs-lookup"><span data-stu-id="2f525-254">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="2f525-255">Это позволяет кодировщику оставаться в состоянии (частичные символы), чтобы он мог правильно кодировать следующий блок символов.</span><span class="sxs-lookup"><span data-stu-id="2f525-255">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="2f525-256">Этот сценарий влияет на UTF8 и UTF7, где определенные символы могут быть закодированы только после того, как кодировщик получит смежный символ или символы.</span><span class="sxs-lookup"><span data-stu-id="2f525-256">This scenario affects UTF8 and UTF7 where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="2f525-257">Попытки управления потоком после закрытия потока могут вызвать <xref:System.ObjectDisposedException>исключение.</span><span class="sxs-lookup"><span data-stu-id="2f525-257">Attempts to manipulate the stream after the stream has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-258">В производных классах не переопределяйте <see cref="M:System.IO.Stream.Close" /> метод, вместо этого следует разместить всю <see langword="Stream" /> логику очистки в <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> методе.</span><span class="sxs-lookup"><span data-stu-id="2f525-258">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the <see langword="Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="2f525-259">Дополнительные сведения см. [в разделе Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-259">For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-260">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-260">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-261">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-261">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-262">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-262">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-263">Считывает байты из текущего потока и записывает их в другой поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-263">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-264">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-264">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="2f525-265">Считывает байты из текущего потока и записывает их в другой поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-265">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-266">Копирование начинается с текущей позиции в текущем потоке и не сбрасывает расположение целевого потока после завершения операции копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-266">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-267">В следующем примере показано копирование содержимого <xref:System.IO.FileStream> <xref:System.IO.MemoryStream>в.</span><span class="sxs-lookup"><span data-stu-id="2f525-267">The following example copies the contents of a <xref:System.IO.FileStream> to a <xref:System.IO.MemoryStream>.</span></span>  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-268">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-268"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-269">Текущий поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-269">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="2f525-270">-или-</span><span class="sxs-lookup"><span data-stu-id="2f525-270">-or-</span></span> 
 <span data-ttu-id="2f525-271">Параметр <paramref name="destination" /> не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-271"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-272">Текущий поток или параметр <paramref name="destination" /> был закрыт до вызова метода <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-272">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-273">Ошибка ввода/вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-273">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.IO.Stream * int -&gt; unit&#xA;override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-274">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-274">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="2f525-275">Размер буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-275">The size of the buffer.</span></span> <span data-ttu-id="2f525-276">Это значение должно быть больше нуля.</span><span class="sxs-lookup"><span data-stu-id="2f525-276">This value must be greater than zero.</span></span> <span data-ttu-id="2f525-277">Размер по умолчанию — 81920.</span><span class="sxs-lookup"><span data-stu-id="2f525-277">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="2f525-278">Считывает байты из текущего потока и записывает их в другой поток, используя указанный размер буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-278">Reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-279">Копирование начинается с текущей позиции в текущем потоке и не сбрасывает расположение целевого потока после завершения операции копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-279">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-280"><paramref name="destination" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-280"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-281">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.</span><span class="sxs-lookup"><span data-stu-id="2f525-281"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-282">Текущий поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-282">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="2f525-283">- или -</span><span class="sxs-lookup"><span data-stu-id="2f525-283">-or-</span></span> 
 <span data-ttu-id="2f525-284">Параметр <paramref name="destination" /> не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-284"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-285">Текущий поток или параметр <paramref name="destination" /> был закрыт до вызова метода <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-285">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-286">Ошибка ввода/вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-286">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-287">Асинхронно считывает байты из текущего потока и записывает их в другой поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-287">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-288">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-288">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="2f525-289">Асинхронно считывает байты из текущего потока и записывает их в другой поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-289">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <returns><span data-ttu-id="2f525-290">Задача, представляющая асинхронную операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-290">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-291"><xref:System.IO.Stream.CopyToAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-291">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-292">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-292">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-293">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-293">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-294">Копирование начинается с текущей позиции в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-294">Copying begins at the current position in the current stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-295">В следующем примере показано, как использовать два <xref:System.IO.FileStream> объекта для асинхронного копирования файлов из одного каталога в другой.</span><span class="sxs-lookup"><span data-stu-id="2f525-295">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another.</span></span> <span data-ttu-id="2f525-296">Класс <xref:System.IO.FileStream> является производным от класса <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="2f525-296">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span>  <span data-ttu-id="2f525-297">Обратите внимание <xref:System.Web.UI.WebControls.Button.Click> , что обработчик событий <xref:System.Windows.Controls.Button> для элемента управления помечается с помощью модификатора, `async` так как он вызывает асинхронный метод.</span><span class="sxs-lookup"><span data-stu-id="2f525-297">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-298">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-298"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-299">Текущий поток или поток назначения удаляется.</span><span class="sxs-lookup"><span data-stu-id="2f525-299">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-300">Текущий поток не поддерживает чтение или поток назначения не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-300">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-301">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-301">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="2f525-302">Размер (в байтах) буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-302">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="2f525-303">Это значение должно быть больше нуля.</span><span class="sxs-lookup"><span data-stu-id="2f525-303">This value must be greater than zero.</span></span> <span data-ttu-id="2f525-304">Размер по умолчанию — 81920.</span><span class="sxs-lookup"><span data-stu-id="2f525-304">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="2f525-305">Асинхронно считывает байты из текущего потока и записывает их в другой поток, используя указанный размер буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-305">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <returns><span data-ttu-id="2f525-306">Задача, представляющая асинхронную операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-306">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-307"><xref:System.IO.Stream.CopyToAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-307">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-308">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-308">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-309">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-309">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-310">Копирование начинается с текущей позиции в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-310">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="2f525-311">Пример копирования между двумя потоками см. в <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-311">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-312">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-312"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-313">Параметр <paramref name="buffersize" /> имеет отрицательное значение или равен нулю.</span><span class="sxs-lookup"><span data-stu-id="2f525-313"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-314">Текущий поток или поток назначения удаляется.</span><span class="sxs-lookup"><span data-stu-id="2f525-314">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-315">Текущий поток не поддерживает чтение или поток назначения не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-315">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-316">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-316">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-317">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-317">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-318">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-318">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-319">Асинхронно считывает байты из текущего потока и записывает их в другой поток, используя указанный токен отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-319">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="2f525-320">Задача, представляющая асинхронную операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-320">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-321"><xref:System.IO.Stream.CopyToAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-321">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-322">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-322">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-323">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-323">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-324">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-324">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-325">Копирование начинается с текущей позиции в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-325">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="2f525-326">Пример копирования между двумя потоками см. в <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-326">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="2f525-327">Поток, в который будет скопировано содержимое текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-327">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="2f525-328">Размер (в байтах) буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-328">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="2f525-329">Это значение должно быть больше нуля.</span><span class="sxs-lookup"><span data-stu-id="2f525-329">This value must be greater than zero.</span></span> <span data-ttu-id="2f525-330">Размер по умолчанию — 81920.</span><span class="sxs-lookup"><span data-stu-id="2f525-330">The default size is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-331">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-331">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-332">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-332">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-333">Асинхронно считывает байты из текущего потока и записывает их в другой поток, используя указанный размер буфера и токен отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-333">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="2f525-334">Задача, представляющая асинхронную операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="2f525-334">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-335"><xref:System.IO.Stream.CopyToAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-335">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-336">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-336">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-337">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-337">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-338">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-338">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-339">Копирование начинается с текущей позиции в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-339">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="2f525-340">Пример копирования между двумя потоками см. в <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-340">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-341"><paramref name="destination" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-341"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-342">Параметр <paramref name="buffersize" /> имеет отрицательное значение или равен нулю.</span><span class="sxs-lookup"><span data-stu-id="2f525-342"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-343">Текущий поток или поток назначения удаляется.</span><span class="sxs-lookup"><span data-stu-id="2f525-343">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-344">Текущий поток не поддерживает чтение или поток назначения не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-344">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-345">Размещает объект <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-345">Allocates a <see cref="T:System.Threading.WaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="2f525-346">Ссылка на выделенный объект <see langword="WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-346">A reference to the allocated <see langword="WaitHandle" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-347">При первом вызове текущий метод создает `WaitHandle` объект и возвращает его.</span><span class="sxs-lookup"><span data-stu-id="2f525-347">When called for the first time, the current method creates a `WaitHandle` object and returns it.</span></span> <span data-ttu-id="2f525-348">При последующих вызовах `CreateWaitHandle` функция возвращает ссылку на новый маркер ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-348">On subsequent calls, `CreateWaitHandle` returns a reference to a new wait handle.</span></span>  
  
 <span data-ttu-id="2f525-349">Используйте этот метод, если реализуется асинхронный метод и требуется способ блокировки в <xref:System.IO.Stream.EndRead%2A> или <xref:System.IO.Stream.EndWrite%2A> до завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="2f525-349">Use this method if you implement the asynchronous methods and require a way of blocking in <xref:System.IO.Stream.EndRead%2A> or <xref:System.IO.Stream.EndWrite%2A> until the asynchronous operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-350">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-350">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-351">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-351">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-352">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-352">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-353">Освобождает все ресурсы, используемые объектом <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-353">Releases all resources used by the <see cref="T:System.IO.Stream" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-354">Освобождает все ресурсы, занятые модулем <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-354">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-355">Этот метод уничтожает поток, записывая изменения в резервное хранилище и закрывая поток для освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2f525-355">This method disposes the stream, by writing any changes to the backing store and closing the stream to release resources.</span></span>  
  
 <span data-ttu-id="2f525-356">Вызов `Dispose` позволяет перераспределить ресурсы, используемые <xref:System.IO.Stream> в, для других целей.</span><span class="sxs-lookup"><span data-stu-id="2f525-356">Calling `Dispose` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="2f525-357">Дополнительные сведения о `Dispose`см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-357">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-358">Поместите всю логику очистки для объекта Stream в <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-358">Place all cleanup logic for your stream object in <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span> <span data-ttu-id="2f525-359">Не переопределяйте <see cref="M:System.IO.Stream.Close" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-359">Do not override <see cref="M:System.IO.Stream.Close" />.</span></span>  
  
<span data-ttu-id="2f525-360">Обратите внимание, что из-за требований к обратной совместимости реализация этого метода отличается от рекомендованных рекомендаций для шаблона удаления.</span><span class="sxs-lookup"><span data-stu-id="2f525-360">Note that because of backward compatibility requirements, this method's implementation differs from the recommended guidance for the Dispose pattern.</span></span>  <span data-ttu-id="2f525-361">Этот метод вызывает <see cref="M:System.IO.Stream.Close" />, который затем вызывает <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-361">This method calls <see cref="M:System.IO.Stream.Close" />, which then calls <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="2f525-362">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="2f525-362"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="2f525-363">Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.IO.Stream" />, а при необходимости освобождает также управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="2f525-363">Releases the unmanaged resources used by the <see cref="T:System.IO.Stream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-364">Необходимо освободить все ресурсы, указав `true` для. `disposing`</span><span class="sxs-lookup"><span data-stu-id="2f525-364">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="2f525-365">Если `disposing` имеет `true`значение, поток также может гарантировать, что данные будут сброшены в базовый буфер, и получить доступ к другим объектам, которые можно финализировать.</span><span class="sxs-lookup"><span data-stu-id="2f525-365">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span>  <span data-ttu-id="2f525-366">Это может быть невозможно при вызове из метода завершения из-за отсутствия упорядочения среди методов завершения.</span><span class="sxs-lookup"><span data-stu-id="2f525-366">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>  
  
 <span data-ttu-id="2f525-367">Если поток использует обработчик операционной системы для связи с источником, рассмотрите возможность использования подкласса <xref:System.Runtime.InteropServices.SafeHandle> для этой цели.</span><span class="sxs-lookup"><span data-stu-id="2f525-367">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>  
  
 <span data-ttu-id="2f525-368">Этот метод вызывается открытым <xref:System.ComponentModel.Component.Dispose%2A> методом <xref:System.Object.Finalize%2A> и методом.</span><span class="sxs-lookup"><span data-stu-id="2f525-368">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="2f525-369"><xref:System.ComponentModel.Component.Dispose%2A>вызывает защищенный <xref:System.IO.Stream.Dispose%2A> метод с параметром `disposing` , для `true`которого задано значение.</span><span class="sxs-lookup"><span data-stu-id="2f525-369"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Stream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="2f525-370"><xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. <xref:System.IO.Stream.Dispose%2A></span><span class="sxs-lookup"><span data-stu-id="2f525-370"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Stream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-371">В производных классах не переопределяйте <see cref="M:System.IO.Stream.Close" /> метод, вместо этого следует разместить всю логику очистки потока <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> в методе.</span><span class="sxs-lookup"><span data-stu-id="2f525-371">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the Stream cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="2f525-372">Метод <see cref="M:System.ComponentModel.Component.Dispose" /> может вызываться несколько раз другими объектами.</span><span class="sxs-lookup"><span data-stu-id="2f525-372"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="2f525-373">При переопределении метода <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see cref="M:System.ComponentModel.Component.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-373">When overriding <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="2f525-374">Дополнительные сведения о реализации <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-374">For more information about how to implement <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="2f525-375">Дополнительные сведения о <see cref="M:System.ComponentModel.Component.Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе Очистка неуправляемых [ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-375">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="stream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-376">Асинхронно освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-376">Asynchronously releases the unmanaged resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <returns><span data-ttu-id="2f525-377">Задача, представляющая асинхронную операцию закрытия.</span><span class="sxs-lookup"><span data-stu-id="2f525-377">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-378"><xref:System.IO.Stream.DisposeAsync%2A> Метод позволяет выполнять ресурсоемкие операции удаления без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-378">The <xref:System.IO.Stream.DisposeAsync%2A> method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="2f525-379">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-379">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-380">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-380">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span> 
 
 <span data-ttu-id="2f525-381">Этот метод уничтожает поток, записывая изменения в резервное хранилище и закрывая поток для освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="2f525-381">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>   
  
 <span data-ttu-id="2f525-382">Вызов `DisposeAsync` позволяет перераспределить ресурсы, используемые <xref:System.IO.Stream> в, для других целей.</span><span class="sxs-lookup"><span data-stu-id="2f525-382">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="2f525-383">Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="2f525-383">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="2f525-384">Ссылка на отложенный асинхронный запрос, который необходимо завершить.</span><span class="sxs-lookup"><span data-stu-id="2f525-384">The reference to the pending asynchronous request to finish.</span></span></param>
        <summary><span data-ttu-id="2f525-385">Ожидает завершения отложенного асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-385">Waits for the pending asynchronous read to complete.</span></span> <span data-ttu-id="2f525-386">(Рекомендуется использовать <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="2f525-386">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="2f525-387">Количество байтов, считанных из потока, от нуля (0) до количества запрошенных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-387">The number of bytes read from the stream, between zero (0) and the number of bytes you requested.</span></span> <span data-ttu-id="2f525-388">Потоки возвращают нуль (0) только в конце. В противном случае они должны блокироваться до тех пор, пока доступен хотя бы один байт.</span><span class="sxs-lookup"><span data-stu-id="2f525-388">Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-389">В платформе .NET Framework 4 и более ранних версий для реализации операций асинхронного ввода-вывода необходимо использовать такие методы, как <xref:System.IO.Stream.BeginRead%2A> и <xref:System.IO.Stream.EndRead%2A> .</span><span class="sxs-lookup"><span data-stu-id="2f525-389">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="2f525-390">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.Stream.FlushAsync%2A>, упрощают реализацию асинхронных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-390">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="2f525-391">Вызовите метод `EndRead` , чтобы определить, сколько байтов было считано из потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-391">Call `EndRead` to determine how many bytes were read from the stream.</span></span>  
  
 <span data-ttu-id="2f525-392">`EndRead`может вызываться один раз для <xref:System.IAsyncResult> каждого <xref:System.IO.Stream.BeginRead%2A>из.</span><span class="sxs-lookup"><span data-stu-id="2f525-392">`EndRead` can be called once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="2f525-393">Этот метод блокируется до завершения операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-393">This method blocks until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-394">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-394"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-395">Обработчик отложенной операции считывания не доступен.</span><span class="sxs-lookup"><span data-stu-id="2f525-395">A handle to the pending read operation is not available.</span></span>  
  
 <span data-ttu-id="2f525-396">-или-</span><span class="sxs-lookup"><span data-stu-id="2f525-396">-or-</span></span>  
  
 <span data-ttu-id="2f525-397">Ожидающая операция не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-397">The pending operation does not support reading.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-398"><paramref name="asyncResult" /> не происходит из метода <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-398"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-399">Поток закрыт, или произошла внутренняя ошибка.</span><span class="sxs-lookup"><span data-stu-id="2f525-399">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-400">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-400">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-401">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-401">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-402">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-402">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="2f525-403">Асинхронный файловый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-403">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="2f525-404">Ссылка на невыполненный асинхронный запрос ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-404">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="2f525-405">Заканчивает операцию асинхронной записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-405">Ends an asynchronous write operation.</span></span> <span data-ttu-id="2f525-406">(Рекомендуется использовать <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="2f525-406">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-407">В платформе .NET Framework 4 и более ранних версий для реализации операций асинхронного ввода-вывода необходимо использовать такие методы, как <xref:System.IO.Stream.BeginWrite%2A> и <xref:System.IO.Stream.EndWrite%2A> .</span><span class="sxs-lookup"><span data-stu-id="2f525-407">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="2f525-408">Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода, однако новые асинхронные методы, такие как <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.Stream.FlushAsync%2A>, упрощают реализацию асинхронных операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-408">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="2f525-409">`EndWrite`метод должен вызываться только один раз <xref:System.IAsyncResult> для <xref:System.IO.Stream.BeginWrite%2A>каждого из.</span><span class="sxs-lookup"><span data-stu-id="2f525-409">`EndWrite` must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="2f525-410">Этот метод блокируется до завершения операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-410">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="2f525-411">Ошибки, возникающие во время запроса асинхронной записи, такие как сбой диска во время запроса ввода-вывода, происходят в потоке пула потоков и становятся видимыми при вызове `EndWrite`.</span><span class="sxs-lookup"><span data-stu-id="2f525-411">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and become visible upon a call to `EndWrite`.</span></span> <span data-ttu-id="2f525-412">Исключения, вызываемые потоком пула потоков, не будут видны `EndWrite`при вызове.</span><span class="sxs-lookup"><span data-stu-id="2f525-412">Exceptions thrown by the thread pool thread will not be visible when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-413"><paramref name="asyncResult" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-413"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-414">Обработчик отложенной операции записи не доступен.</span><span class="sxs-lookup"><span data-stu-id="2f525-414">A handle to the pending write operation is not available.</span></span>  
  
 <span data-ttu-id="2f525-415">- или -</span><span class="sxs-lookup"><span data-stu-id="2f525-415">-or-</span></span>  
  
 <span data-ttu-id="2f525-416">Ожидающая операция не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-416">The pending operation does not support writing.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-417">Параметр <paramref name="asyncResult" /> не был порожден методом <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-417"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-418">Поток закрыт, или произошла внутренняя ошибка.</span><span class="sxs-lookup"><span data-stu-id="2f525-418">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-419">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-419">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-420">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-420">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-421">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-421">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="2f525-422">Асинхронный файловый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-422">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-423">При переопределении в производном классе очищает все буферы данного потока и вызывает запись данных буферов в базовое устройство.</span><span class="sxs-lookup"><span data-stu-id="2f525-423">When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-424">Переопределение `Flush` для потоков, реализующих буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-424">Override `Flush` on streams that implement a buffer.</span></span> <span data-ttu-id="2f525-425">Этот метод используется для перемещения любых данных из базового буфера в место назначения, очистки буфера или и того и другого.</span><span class="sxs-lookup"><span data-stu-id="2f525-425">Use this method to move any information from an underlying buffer to its destination, clear the buffer, or both.</span></span> <span data-ttu-id="2f525-426">В зависимости от состояния объекта может потребоваться изменить текущую точку в потоке (например, если базовый поток поддерживает поиск).</span><span class="sxs-lookup"><span data-stu-id="2f525-426">Depending upon the state of the object, you might have to modify the current position within the stream (for example, if the underlying stream supports seeking).</span></span> <span data-ttu-id="2f525-427">Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.</span><span class="sxs-lookup"><span data-stu-id="2f525-427">For additional information see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  

 <span data-ttu-id="2f525-428">В классе, производном <xref:System.IO.Stream> от, который не поддерживает <xref:System.IO.Stream.Flush%2A> запись, обычно реализуется как пустой метод для обеспечения полной совместимости с <xref:System.IO.Stream> другими типами, так как он является допустимым для очистки потока, доступного только для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-428">In a class derived from <xref:System.IO.Stream> that doesn't support writing, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>

 <span data-ttu-id="2f525-429">При использовании <xref:System.IO.StreamWriter> класса или <xref:System.IO.BinaryWriter> не следует сбрасывать базовый <xref:System.IO.Stream> объект.</span><span class="sxs-lookup"><span data-stu-id="2f525-429">When using the <xref:System.IO.StreamWriter> or <xref:System.IO.BinaryWriter> class, do not flush the base <xref:System.IO.Stream> object.</span></span> <span data-ttu-id="2f525-430">Вместо этого следует использовать метод <xref:System.IO.Stream.Flush%2A> или <xref:System.IO.Stream.Close%2A> класса, который гарантирует, что данные сбрасываются в базовый поток, а затем записываются в файл.</span><span class="sxs-lookup"><span data-stu-id="2f525-430">Instead, use the class's <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.Close%2A> method, which makes sure that the data is flushed to the underlying stream first and then written to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-431">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-431">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-432">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-432">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-433">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-433">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-434">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-434">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-435">Асинхронно очищает все буферы для этого потока и вызывает запись всех буферизованных данных в базовое устройство.</span><span class="sxs-lookup"><span data-stu-id="2f525-435">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-436">Асинхронно очищает все буферы для этого потока и вызывает запись всех буферизованных данных в базовое устройство.</span><span class="sxs-lookup"><span data-stu-id="2f525-436">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <returns><span data-ttu-id="2f525-437">Задача, представляющая асинхронную операцию очистки.</span><span class="sxs-lookup"><span data-stu-id="2f525-437">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-438"><xref:System.IO.Compression.DeflateStream> Если производный класс, например или <xref:System.IO.Compression.GZipStream>, не очищает буфер <xref:System.IO.Stream.Flush%2A> в своей реализации метода, <xref:System.IO.Stream.FlushAsync%2A> метод не будет очищать буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-438">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-439">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-439">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="2f525-440">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-440">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-441">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-441">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-442">Асинхронно очищает все буферы данного потока, вызывает запись буферизованных данных в базовое устройство и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-442">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="2f525-443">Задача, представляющая асинхронную операцию очистки.</span><span class="sxs-lookup"><span data-stu-id="2f525-443">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-444">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-444">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-445"><xref:System.IO.Compression.DeflateStream> Если производный класс, например или <xref:System.IO.Compression.GZipStream>, не очищает буфер <xref:System.IO.Stream.Flush%2A> в своей реализации метода, <xref:System.IO.Stream.FlushAsync%2A> метод не будет очищать буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-445">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-446">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-446">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="2f525-447">Отмена</span><span class="sxs-lookup"><span data-stu-id="2f525-447">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-448">При переопределении в производном классе получает длину потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="2f525-448">When overridden in a derived class, gets the length in bytes of the stream.</span></span></summary>
        <value><span data-ttu-id="2f525-449">Длинное значение, представляющее длину потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="2f525-449">A long value representing the length of the stream in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-450">Класс, созданный на основе класса <see langword="Stream" />, не поддерживает возможность поиска.</span><span class="sxs-lookup"><span data-stu-id="2f525-450">A class derived from <see langword="Stream" /> does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-451">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-451">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-452">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-452">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-453">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-453">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-454">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-454">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-455">Объект <see langword="Stream" /> без резервного хранилища.</span><span class="sxs-lookup"><span data-stu-id="2f525-455">A <see langword="Stream" /> with no backing store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-456">Используйте `Null` для перенаправления выходных данных в поток, который не будет потреблять никаких ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="2f525-456">Use `Null` to redirect output to a stream that will not consume any operating system resources.</span></span> <span data-ttu-id="2f525-457">Когда методы `Stream` , предоставляющие запись, вызываются в `Null`, вызов просто возвращает, а данные не записываются.</span><span class="sxs-lookup"><span data-stu-id="2f525-457">When the methods of `Stream` that provide writing are invoked on `Null`, the call simply returns, and no data is written.</span></span> <span data-ttu-id="2f525-458">`Null`также реализует `Read` метод, который возвращает ноль без считывания данных.</span><span class="sxs-lookup"><span data-stu-id="2f525-458">`Null` also implements a `Read` method that returns zero without reading data.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-459">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-459">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-460">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-460">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-461">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-461">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-462">Обеспечивает поддержку для <see cref="T:System.Diagnostics.Contracts.Contract" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-462">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-463">При переопределении в производном классе получает или задает позицию в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-463">When overridden in a derived class, gets or sets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="2f525-464">Текущее положение в потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-464">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-465">Поток должен поддерживать поиск для получения или задания расположения.</span><span class="sxs-lookup"><span data-stu-id="2f525-465">The stream must support seeking to get or set the position.</span></span> <span data-ttu-id="2f525-466">Используйте свойство <xref:System.IO.Stream.CanSeek%2A> , чтобы определить, поддерживает ли поток поиск.</span><span class="sxs-lookup"><span data-stu-id="2f525-466">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the stream supports seeking.</span></span>  
  
 <span data-ttu-id="2f525-467">Поддерживается поиск в любом расположении, превышающем длину потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-467">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="2f525-468">`Position` Свойство не отслеживает количество байтов из потока, которые были потреблены, пропущены или и то, и другое.</span><span class="sxs-lookup"><span data-stu-id="2f525-468">The `Position` property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-469">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-469">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-470">Поток не поддерживает поиск.</span><span class="sxs-lookup"><span data-stu-id="2f525-470">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-471">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-471">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-472">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-472">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-473">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-473">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-474">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-474">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-475">Область памяти.</span><span class="sxs-lookup"><span data-stu-id="2f525-475">A region of memory.</span></span> <span data-ttu-id="2f525-476">При возвращении данного метода содержимое этой области заменяется байтами, считанными из текущего источника.</span><span class="sxs-lookup"><span data-stu-id="2f525-476">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="2f525-477">При переопределении в производном классе считывает последовательность байтов из текущего потока и перемещает позицию в потоке на число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-477">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="2f525-478">Общее количество байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-478">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="2f525-479">Это число может быть меньше количества выделенных в буфере байтов, если столько байтов в настоящее время недоступно, а также равняться нулю (0), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-479">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-480">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-480">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="2f525-481"><xref:System.IO.Stream.ReadAsync%2A> Используйте метод для асинхронного чтения из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-481">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="2f525-482">Реализации этого метода считывают максимум `buffer.Length` байт из текущего потока и сохраняют их в. `buffer`</span><span class="sxs-lookup"><span data-stu-id="2f525-482">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="2f525-483">Текущая координата в потоке увеличивается на число считанных байтов; Однако при возникновении исключения текущее место в потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="2f525-483">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="2f525-484">Реализации возвращают число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-484">Implementations return the number of bytes read.</span></span> <span data-ttu-id="2f525-485">Реализация будет заблокирована до тех пор, пока не будет прочитан хотя бы один байт данных в случае, если данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="2f525-485">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="2f525-486"><xref:System.IO.Stream.Read%2A>Возвращает 0 только в том случае, если в потоке больше нет данных и больше не ожидается (например, закрытый сокет или конец файла).</span><span class="sxs-lookup"><span data-stu-id="2f525-486"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="2f525-487">Реализация может возвращать меньше байтов, чем было запрошено, даже если конец потока не был достигнут.</span><span class="sxs-lookup"><span data-stu-id="2f525-487">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="2f525-488">Используется <xref:System.IO.BinaryReader> для чтения примитивных типов данных.</span><span class="sxs-lookup"><span data-stu-id="2f525-488">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>    
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-489">Массив байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-489">An array of bytes.</span></span> <span data-ttu-id="2f525-490">После завершения выполнения данного метода буфер содержит указанный массив байтов, в котором значения в интервале между <paramref name="offset" /> и (<paramref name="offset" /> + <paramref name="count" /> - 1) заменены байтами, считанными из текущего источника.</span><span class="sxs-lookup"><span data-stu-id="2f525-490">When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-491">Смещение байтов (начиная с нуля) в <paramref name="buffer" />, с которого начинается сохранение данных, считанных из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-491">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-492">Максимальное количество байтов, которое должно быть считано из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-492">The maximum number of bytes to be read from the current stream.</span></span></param>
        <summary><span data-ttu-id="2f525-493">При переопределении в производном классе считывает последовательность байтов из текущего потока и перемещает позицию в потоке на число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-493">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="2f525-494">Общее количество байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-494">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="2f525-495">Это число может быть меньше количества запрошенных байтов, если столько байтов в настоящее время недоступно, а также равняться нулю (0), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-495">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-496">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-496">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="2f525-497"><xref:System.IO.Stream.ReadAsync%2A> Используйте метод для асинхронного чтения из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-497">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="2f525-498">Реализации этого метода считывают максимум `count` байтов из текущего потока и сохраняют их в `buffer` начале `offset`.</span><span class="sxs-lookup"><span data-stu-id="2f525-498">Implementations of this method read a maximum of `count` bytes from the current stream and store them in `buffer` beginning at `offset`.</span></span> <span data-ttu-id="2f525-499">Текущая координата в потоке увеличивается на число считанных байтов; Однако при возникновении исключения текущее место в потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="2f525-499">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="2f525-500">Реализации возвращают число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-500">Implementations return the number of bytes read.</span></span> <span data-ttu-id="2f525-501">Реализация будет заблокирована до тех пор, пока не будет прочитан хотя бы один байт данных в случае, если данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="2f525-501">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="2f525-502"><xref:System.IO.Stream.Read%2A>Возвращает 0 только в том случае, если в потоке больше нет данных и больше не ожидается (например, закрытый сокет или конец файла).</span><span class="sxs-lookup"><span data-stu-id="2f525-502"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="2f525-503">Реализация может возвращать меньше байтов, чем было запрошено, даже если конец потока не был достигнут.</span><span class="sxs-lookup"><span data-stu-id="2f525-503">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="2f525-504">Используется <xref:System.IO.BinaryReader> для чтения примитивных типов данных.</span><span class="sxs-lookup"><span data-stu-id="2f525-504">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-505">В следующем примере показано, как использовать <xref:System.IO.Stream.Read%2A> для чтения блока данных.</span><span class="sxs-lookup"><span data-stu-id="2f525-505">The following example shows how to use <xref:System.IO.Stream.Read%2A> to read a block of data.</span></span>  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-506">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-506">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-507"><paramref name="buffer" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-507"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-508"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="2f525-508"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-509">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-509">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-510">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-510">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-511">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-511">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-512">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-512">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-513">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-514">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-515">Асинхронно считывает последовательность байтов из текущего потока и перемещает позицию внутри потока на число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-515">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-516">Область памяти, в которую будут записываться данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-516">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-517">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-517">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-518">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-518">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-519">Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию в потоке на число считанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-519">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="2f525-520">Задача, представляющая асинхронную операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-520">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="2f525-521">Значение свойства <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> содержит общее число байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-521">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="2f525-522">Итоговое значение может быть меньше количества выделенных в буфере байтов, если столько байтов в настоящее время недоступно, или оно может равняться нулю (0), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-522">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-523"><xref:System.IO.Stream.ReadAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-523">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-524">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-524">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-525">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-525">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-526">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-526">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="2f525-527">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> значение <xref:System.Threading.Tasks.Task.Status> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-527">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  
  
 <span data-ttu-id="2f525-528">Пример см. в <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-528">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-529">Буфер, в который записываются данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-529">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-530">Смещение байтов в <paramref name="buffer" />, с которого начинается запись данных из потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-530">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-531">Максимальное число байтов, предназначенных для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-531">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="2f525-532">Асинхронно считывает последовательность байтов из текущего потока и перемещает позицию внутри потока на число считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-532">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="2f525-533">Задача, представляющая асинхронную операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-533">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="2f525-534">Значение параметра <paramref name="TResult" /> содержит общее число байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-534">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="2f525-535">Значение результата может быть меньше запрошенного числа байтов, если число доступных в данный момент байтов меньше запрошенного числа, или результат может быть равен 0 (нулю), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-535">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-536"><xref:System.IO.Stream.ReadAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-536">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-537">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-537">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-538">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-538">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-539">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-539">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-540">В следующем примере показано асинхронное чтение из файла.</span><span class="sxs-lookup"><span data-stu-id="2f525-540">The following example shows how to read from a file asynchronously.</span></span> <span data-ttu-id="2f525-541">В примере используется <xref:System.IO.FileStream> класс, производный <xref:System.IO.Stream> от класса.</span><span class="sxs-lookup"><span data-stu-id="2f525-541">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-542">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-542"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-543"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="2f525-543"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-544">Сумма значений параметров <paramref name="offset" /> и <paramref name="count" /> больше длины буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-544">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-545">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-545">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-546">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-546">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-547">Поток в настоящее время используется предыдущей операцией чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-547">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-548">Буфер, в который записываются данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-548">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-549">Смещение байтов в <paramref name="buffer" />, с которого начинается запись данных из потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-549">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-550">Максимальное число байтов, предназначенных для чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-550">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-551">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-551">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-552">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-552">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-553">Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию в потоке на число считанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-553">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="2f525-554">Задача, представляющая асинхронную операцию чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-554">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="2f525-555">Значение параметра <paramref name="TResult" /> содержит общее число байтов, считанных в буфер.</span><span class="sxs-lookup"><span data-stu-id="2f525-555">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="2f525-556">Значение результата может быть меньше запрошенного числа байтов, если число доступных в данный момент байтов меньше запрошенного числа, или результат может быть равен 0 (нулю), если был достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-556">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-557"><xref:System.IO.Stream.ReadAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-557">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-558">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-558">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-559">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-559">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-560">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-560">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="2f525-561">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-561">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-562">Пример см. в <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-562">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-563">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-563"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-564"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="2f525-564"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-565">Сумма значений параметров <paramref name="offset" /> и <paramref name="count" /> больше длины буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-565">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-566">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-566">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-567">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-567">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-568">Поток в настоящее время используется предыдущей операцией чтения.</span><span class="sxs-lookup"><span data-stu-id="2f525-568">The stream is currently in use by a previous read operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="2f525-569">Отмена</span><span class="sxs-lookup"><span data-stu-id="2f525-569">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-570">Считывает байт из потока и перемещает позицию в потоке на один байт или возвращает -1, если достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-570">Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="2f525-571">Байт без знака, приведенный к <see langword="Int32" />, или значение -1, если достигнут конец потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-571">The unsigned byte cast to an <see langword="Int32" />, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-572">Используйте свойство <xref:System.IO.Stream.CanRead%2A> , чтобы определить, поддерживает ли текущий экземпляр чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-572">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="2f525-573">Попытки управления потоком после закрытия потока могут вызвать <xref:System.ObjectDisposedException>исключение.</span><span class="sxs-lookup"><span data-stu-id="2f525-573">Attempts to manipulate the stream after the stream has been closed could throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-574">Поток не поддерживает чтение.</span><span class="sxs-lookup"><span data-stu-id="2f525-574">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-575">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-575">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-576">Реализация по умолчанию <see langword="Stream" /> для создает новый однобайтовый массив, а затем <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />вызывает.</span><span class="sxs-lookup"><span data-stu-id="2f525-576">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="2f525-577">Хотя это формально верно, это неэффективно.</span><span class="sxs-lookup"><span data-stu-id="2f525-577">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="2f525-578">Любой поток с внутренним буфером должен переопределить этот метод и предоставить гораздо более эффективную версию, которая считывает буфер напрямую, избегая дополнительного выделения массива при каждом вызове.</span><span class="sxs-lookup"><span data-stu-id="2f525-578">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-579">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-579">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-580">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-580">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-581">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-581">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-582">Возвращает или задает значение в миллисекундах, определяющее период, в течение которого поток будет пытаться выполнить операцию чтения, прежде чем истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-582">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></summary>
        <value><span data-ttu-id="2f525-583">Значение в миллисекундах, определяющее период, в течение которого поток будет пытаться выполнить операцию чтения, прежде чем истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-583">A value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-584">Метод <see cref="P:System.IO.Stream.ReadTimeout" /> всегда создает исключение <see cref="T:System.InvalidOperationException" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-584">The <see cref="P:System.IO.Stream.ReadTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-585"><see cref="P:System.IO.Stream.ReadTimeout" /> Свойство должно быть переопределено, чтобы обеспечить соответствующее поведение для потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-585">The <see cref="P:System.IO.Stream.ReadTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="2f525-586">Если поток не поддерживает время ожидания, это свойство должно вызывать исключение <see cref="T:System.InvalidOperationException" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-586">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="2f525-587">Смещение в байтах относительно параметра <paramref name="origin" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-587">A byte offset relative to the <paramref name="origin" /> parameter.</span></span></param>
        <param name="origin"><span data-ttu-id="2f525-588">Значение типа <see cref="T:System.IO.SeekOrigin" /> определяет точку ссылки, которая используется для получения новой позиции.</span><span class="sxs-lookup"><span data-stu-id="2f525-588">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="2f525-589">При переопределении в производном классе задает позицию в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-589">When overridden in a derived class, sets the position within the current stream.</span></span></summary>
        <returns><span data-ttu-id="2f525-590">Новая позиция в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="2f525-590">The new position within the current stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-591">Используйте свойство <xref:System.IO.Stream.CanSeek%2A> , чтобы определить, поддерживает ли текущий экземпляр поиск.</span><span class="sxs-lookup"><span data-stu-id="2f525-591">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the current instance supports seeking.</span></span>  
  
 <span data-ttu-id="2f525-592">Если `offset` параметр имеет отрицательное значение, Новая единица должна предшествовать положению, `origin` заданному параметром, равным `offset`количеству байтов, заданному параметром.</span><span class="sxs-lookup"><span data-stu-id="2f525-592">If `offset` is negative, the new position is required to precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="2f525-593">Если `offset` значение равно нулю (0), то новое значение должно быть позицией, указанной в параметре `origin`.</span><span class="sxs-lookup"><span data-stu-id="2f525-593">If `offset` is zero (0), the new position is required to be the position specified by `origin`.</span></span> <span data-ttu-id="2f525-594">Если `offset` является положительным, Новая единица должна следовать за позицией, `origin` заданной параметром, на число байтов, `offset`заданное параметром.</span><span class="sxs-lookup"><span data-stu-id="2f525-594">If `offset` is positive, the new position is required to follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="2f525-595">Классы, производные от `Stream` , которые поддерживают поиск, должны переопределять этот метод для предоставления описанных выше функций.</span><span class="sxs-lookup"><span data-stu-id="2f525-595">Classes derived from `Stream` that support seeking must override this method to provide the functionality described above.</span></span>  
  
 <span data-ttu-id="2f525-596">Поддерживается поиск в любом расположении, превышающем длину потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-596">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-597">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-597">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-598">Поток не поддерживает поиск, если поток создан на основе канала или вывода консоли.</span><span class="sxs-lookup"><span data-stu-id="2f525-598">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-599">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-599">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-600">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-600">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-601">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-601">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-602">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-602">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2f525-603">Необходимая длина текущего потока в байтах.</span><span class="sxs-lookup"><span data-stu-id="2f525-603">The desired length of the current stream in bytes.</span></span></param>
        <summary><span data-ttu-id="2f525-604">При переопределении в производном классе задает длину текущего потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-604">When overridden in a derived class, sets the length of the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-605">Если указанное значение меньше текущей длины потока, поток усекается.</span><span class="sxs-lookup"><span data-stu-id="2f525-605">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="2f525-606">Если указанное значение больше текущей длины потока, поток расширяется.</span><span class="sxs-lookup"><span data-stu-id="2f525-606">If the specified value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="2f525-607">Если поток развернут, содержимое потока между старой и новой длиной не определено.</span><span class="sxs-lookup"><span data-stu-id="2f525-607">If the stream is expanded, the contents of the stream between the old and the new length are not defined.</span></span>  
  
 <span data-ttu-id="2f525-608">Поток должен поддерживать как запись, так и поиск `SetLength` для работы.</span><span class="sxs-lookup"><span data-stu-id="2f525-608">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 <span data-ttu-id="2f525-609">Используйте свойство, чтобы определить, поддерживает ли текущий экземпляр запись, <xref:System.IO.Stream.CanSeek%2A> и свойство, чтобы определить, поддерживается ли поиск. <xref:System.IO.Stream.CanWrite%2A></span><span class="sxs-lookup"><span data-stu-id="2f525-609">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.Stream.CanSeek%2A> property to determine whether seeking is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-610">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-610">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-611">Поток не поддерживает ни поиск, ни запись, например, если поток создан на основе канала или вывода консоли.</span><span class="sxs-lookup"><span data-stu-id="2f525-611">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-612">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-612">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-613">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-613">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-614">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-614">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-615">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-615">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="2f525-616">Синхронизируемый объект <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-616">The <see cref="T:System.IO.Stream" /> object to synchronize.</span></span></param>
        <summary><span data-ttu-id="2f525-617">Создает потокобезопасную (синхронизированную) оболочку для заданного объекта <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-617">Creates a thread-safe (synchronized) wrapper around the specified <see cref="T:System.IO.Stream" /> object.</span></span></summary>
        <returns><span data-ttu-id="2f525-618">Потокобезопасный объект <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-618">A thread-safe <see cref="T:System.IO.Stream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-619">Этот метод возвращает класс, который заключает в оболочку <xref:System.IO.Stream> указанный объект и разрешает доступ к нему из нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="2f525-619">This method returns a class that wraps the specified <xref:System.IO.Stream> object and restricts access to it from multiple threads.</span></span> <span data-ttu-id="2f525-620">Все доступ <xref:System.IO.Stream> к объекту будет потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="2f525-620">All access to the <xref:System.IO.Stream> object will be thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-621">Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-621"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2f525-622">Освобождает все ресурсы, занятые модулем <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-622">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="2f525-623">Этот член представляет собой явную реализацию члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="2f525-623">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="2f525-624">Он может использоваться, только если экземпляр <xref:System.IO.Stream> приведен к типу интерфейса <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="2f525-624">It can be used only when the <xref:System.IO.Stream> instance is cast to an <xref:System.IDisposable> interface.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-625">Область памяти.</span><span class="sxs-lookup"><span data-stu-id="2f525-625">A region of memory.</span></span> <span data-ttu-id="2f525-626">Этот метод копирует содержимое данной области в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-626">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="2f525-627">При переопределении в производном классе записывает последовательность байтов в текущий поток и перемещает текущую позицию в нем вперед на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-627">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-628">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-628">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="2f525-629"><xref:System.IO.Stream.WriteAsync%2A> Используйте метод для асинхронной записи в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-629">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="2f525-630">Если операция записи выполнена успешно, то позицию в потоке увеличивается на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-630">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="2f525-631">При возникновении исключения расположение в потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="2f525-631">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-632">Массив байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-632">An array of bytes.</span></span> <span data-ttu-id="2f525-633">Этот метод копирует байты <paramref name="count" /> из <paramref name="buffer" /> в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-633">This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-634">Отсчитываемое от нуля смещение байтов в буфере <paramref name="buffer" />, с которого начинается копирование байтов в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-634">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-635">Количество байтов, которое необходимо записать в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-635">The number of bytes to be written to the current stream.</span></span></param>
        <summary><span data-ttu-id="2f525-636">При переопределении в производном классе записывает последовательность байтов в текущий поток и перемещает текущую позицию в нем вперед на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-636">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-637">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-637">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="2f525-638"><xref:System.IO.Stream.WriteAsync%2A> Используйте метод для асинхронной записи в текущий поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-638">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="2f525-639">Если операция записи выполнена успешно, то позицию в потоке увеличивается на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-639">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="2f525-640">При возникновении исключения расположение в потоке остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="2f525-640">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-641">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-641">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-642">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-642"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-643">Значение параметра <paramref name="offset" /> или <paramref name="count" /> является отрицательным.</span><span class="sxs-lookup"><span data-stu-id="2f525-643"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-644">Произошла ошибка ввода-вывода, например связанная с тем, что не удается найти указанный файл.</span><span class="sxs-lookup"><span data-stu-id="2f525-644">An I/O error occurred, such as the specified file cannot be found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-645">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-645">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-646">Метод <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> был вызван после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-646"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> was called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-647">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-647">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-648">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-648">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-649">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-649">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2f525-650">Асинхронно записывает последовательность байтов в текущий поток и перемещает текущую позицию внутри потока на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-650">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-651">Область памяти, из которой будут записываться данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-651">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-652">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-652">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-653">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-653">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-654">Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-654">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="2f525-655">Задача, представляющая асинхронную операцию записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-655">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-656"><xref:System.IO.Stream.WriteAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-656">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-657">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-657">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-658">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-658">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-659">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-659">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="2f525-660">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-660">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-661">Пример см. в <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-661">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-662">Буфер, из которого записываются данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-662">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-663">Смещение байтов (начиная с нуля) в <paramref name="buffer" />, с которого начинается копирование байтов в поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-663">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-664">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-664">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="2f525-665">Асинхронно записывает последовательность байтов в текущий поток и перемещает текущую позицию внутри потока на число записанных байтов.</span><span class="sxs-lookup"><span data-stu-id="2f525-665">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <returns><span data-ttu-id="2f525-666">Задача, представляющая асинхронную операцию записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-666">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-667"><xref:System.IO.Stream.WriteAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-667">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-668">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-668">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-669">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-669">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-670">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-670">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2f525-671">В следующем примере показано, как асинхронно выполнять запись в файл.</span><span class="sxs-lookup"><span data-stu-id="2f525-671">The following example shows how to write asynchronously to a file.</span></span> <span data-ttu-id="2f525-672">В примере используется <xref:System.IO.FileStream> класс, производный <xref:System.IO.Stream> от класса.</span><span class="sxs-lookup"><span data-stu-id="2f525-672">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-673">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-673"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-674"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="2f525-674"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-675">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-675">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-676">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-676">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-677">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-677">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-678">Поток в настоящее время используется предыдущей операцией записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-678">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="2f525-679">Буфер, из которого записываются данные.</span><span class="sxs-lookup"><span data-stu-id="2f525-679">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="2f525-680">Смещение байтов (начиная с нуля) в <paramref name="buffer" />, с которого начинается копирование байтов в поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-680">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="2f525-681">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-681">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="2f525-682">Токен для отслеживания запросов отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-682">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="2f525-683">Значение по умолчанию — <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-683">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="2f525-684">Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены.</span><span class="sxs-lookup"><span data-stu-id="2f525-684">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="2f525-685">Задача, представляющая асинхронную операцию записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-685">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-686"><xref:System.IO.Stream.WriteAsync%2A> Метод позволяет выполнять ресурсоемкие операции ввода-вывода без блокировки основного потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-686">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="2f525-687">Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] , где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает.</span><span class="sxs-lookup"><span data-stu-id="2f525-687">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="2f525-688">Асинхронные методы используются в сочетании с `async` ключевыми словами и `await` в Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="2f525-688">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="2f525-689">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-689">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="2f525-690">Если операция отменяется до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> для свойства.</span><span class="sxs-lookup"><span data-stu-id="2f525-690">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="2f525-691">Пример см. в <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> описании перегрузки.</span><span class="sxs-lookup"><span data-stu-id="2f525-691">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="2f525-692">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-692"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="2f525-693"><paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="2f525-693"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="2f525-694">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</span><span class="sxs-lookup"><span data-stu-id="2f525-694">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-695">Поток не поддерживает запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-695">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-696">Поток был удален.</span><span class="sxs-lookup"><span data-stu-id="2f525-696">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-697">Поток в настоящее время используется предыдущей операцией записи.</span><span class="sxs-lookup"><span data-stu-id="2f525-697">The stream is currently in use by a previous write operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="2f525-698">Отмена</span><span class="sxs-lookup"><span data-stu-id="2f525-698">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="2f525-699">Байт, записываемый в поток.</span><span class="sxs-lookup"><span data-stu-id="2f525-699">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="2f525-700">Записывает байт в текущее положение в потоке и перемещает позицию в потоке вперед на один байт.</span><span class="sxs-lookup"><span data-stu-id="2f525-700">Writes a byte to the current position in the stream and advances the position within the stream by one byte.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2f525-701">Используйте свойство <xref:System.IO.Stream.CanWrite%2A> , чтобы определить, поддерживает ли текущий экземпляр запись.</span><span class="sxs-lookup"><span data-stu-id="2f525-701">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="2f525-702">Ошибка ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="2f525-702">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2f525-703">Поток не поддерживает запись или был закрыт до начала операции.</span><span class="sxs-lookup"><span data-stu-id="2f525-703">The stream does not support writing, or the stream is already closed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="2f525-704">Методы были вызваны после закрытия потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-704">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-705">Реализация по умолчанию <see langword="Stream" /> для создает новый однобайтовый массив, а затем <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />вызывает.</span><span class="sxs-lookup"><span data-stu-id="2f525-705">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="2f525-706">Хотя это формально верно, это неэффективно.</span><span class="sxs-lookup"><span data-stu-id="2f525-706">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="2f525-707">Любой поток с внутренним буфером должен переопределять этот метод и предоставлять гораздо более эффективную версию, которая непосредственно записывает данные в буфер, избегая дополнительного выделения массива при каждом вызове.</span><span class="sxs-lookup"><span data-stu-id="2f525-707">Any stream with an internal buffer should override this method and provide a much more efficient version that writes to the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="2f525-708">Файловый и потоковый ввод-вывод</span><span class="sxs-lookup"><span data-stu-id="2f525-708">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="2f525-709">Практическое руководство. Считывание текста из файла</span><span class="sxs-lookup"><span data-stu-id="2f525-709">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="2f525-710">Практическое руководство. Запись текста в файл</span><span class="sxs-lookup"><span data-stu-id="2f525-710">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2f525-711">Возвращает или задает значение в миллисекундах, определяющее период, в течение которого поток будет пытаться выполнить операцию записи, прежде чем истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-711">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></summary>
        <value><span data-ttu-id="2f525-712">Значение в миллисекундах, определяющее период, в течение которого поток будет пытаться выполнить операцию записи, прежде чем истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="2f525-712">A value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="2f525-713">Метод <see cref="P:System.IO.Stream.WriteTimeout" /> всегда создает исключение <see cref="T:System.InvalidOperationException" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-713">The <see cref="P:System.IO.Stream.WriteTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="2f525-714"><see cref="P:System.IO.Stream.WriteTimeout" /> Свойство должно быть переопределено, чтобы обеспечить соответствующее поведение для потока.</span><span class="sxs-lookup"><span data-stu-id="2f525-714">The <see cref="P:System.IO.Stream.WriteTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="2f525-715">Если поток не поддерживает время ожидания, это свойство должно вызывать исключение <see cref="T:System.InvalidOperationException" />.</span><span class="sxs-lookup"><span data-stu-id="2f525-715">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>
