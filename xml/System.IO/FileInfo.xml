<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f0871ad56e65c7446fdadb36852f9d2b0d1ff066" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75132300" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type FileInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет свойства и методы экземпляра для создания, копирования, удаления, перемещения и открытия файлов, а также позволяет создавать объекты <see cref="T:System.IO.FileStream" />. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте класс <xref:System.IO.FileInfo> для выполнения типичных операций, таких как копирование, перемещение, переименование, создание, открытие, удаление и добавление в файлы.  
  
 Если вы выполняете несколько операций над одним и тем же файлом, более эффективно использовать <xref:System.IO.FileInfo> методы экземпляра вместо соответствующих статических методов класса <xref:System.IO.File>, поскольку проверка безопасности не всегда будет требоваться.  
  
 Многие из <xref:System.IO.FileInfo> методов возвращают другие типы ввода-вывода при создании или открытии файлов. Эти другие типы можно использовать для дальнейшего управления файлом. Дополнительные сведения см. в разделе определенные <xref:System.IO.FileInfo> члены, такие как <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>или <xref:System.IO.FileInfo.Create%2A>.  
  
 По умолчанию всем пользователям предоставляется полный доступ на чтение и запись к новым файлам.  
  
 В следующей таблице описаны перечисления, используемые для настройки поведения различных методов <xref:System.IO.FileInfo>.  
  
|Перечисление|Описание|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Указывает доступ к файлу для чтения и записи.|  
|<xref:System.IO.FileShare>|Указывает уровень доступа, разрешенный для уже используемого файла.|  
|<xref:System.IO.FileMode>|Указывает, будет ли содержимое существующего файла сохранено или перезаписано, и должны ли запросы на создание существующего файла вызывать исключение.|  
  
> [!NOTE]
>  В членах, принимающих путь в качестве входной строки, этот путь должен иметь правильный формат или возникнет исключение. Например, если путь является полным, но начинается с пробела, путь не усекается в методах класса. Поэтому путь имеет неправильный формат и возникает исключение. Аналогично, путь или сочетание путей не могут быть полными и дважды. Например, "c:\temp c:\Windows" также вызывает исключение в большинстве случаев. При использовании методов, принимающих строку пути, убедитесь, что пути имеют правильный формат.  
  
 В членах, принимающих путь, путь может ссылаться на файл или только на каталог. Указанный путь может также ссылаться на относительный путь или путь в формате UNC для имени сервера и общего ресурса. Например, все следующие допустимые пути:  
  
-   "c:\\\Мидир\\\Мифиле.ткст" in C#или "к:\мидир\мифиле.ткст" в Visual Basic.  
  
-   "c:\\\Мидир" in C#или "к:\мидир" в Visual Basic.  
  
-   "MyDir\\\Мисубдир" in C#или "мидир\мисубдир" в Visual Basic.  
  
-   "\\\\\\\Мисервер\\\Мишаре" in C#или "\\\MyServer\MyShare" в Visual Basic.  
  
 Класс <xref:System.IO.FileInfo> предоставляет следующие свойства, позволяющие получить сведения о файле. Пример использования каждого свойства см. в разделе страницы свойств.  
  
-   Свойство <xref:System.IO.FileInfo.Directory%2A> извлекает объект, представляющий родительский каталог файла.  
  
-   Свойство <xref:System.IO.FileInfo.DirectoryName%2A> извлекает полный путь к родительскому каталогу файла.  
  
-   Свойство <xref:System.IO.FileInfo.Exists%2A> проверяет наличие файла перед тем, как он будет запущен.  
  
-   Свойство <xref:System.IO.FileInfo.IsReadOnly%2A> извлекает или задает значение, указывающее, можно ли изменить файл.  
  
-   <xref:System.IO.FileInfo.Length%2A> получает размер файла.  
  
-   <xref:System.IO.FileInfo.Name%2A> извлекает имя файла.  
  
   
  
## Examples  
 В следующем примере показаны некоторые из основных элементов класса `FileInfo`.  
  
 При первом извлечении свойств <xref:System.IO.FileInfo> вызывает метод <xref:System.IO.FileSystemInfo.Refresh%2A> и кэширует сведения о файле. При последующих вызовах необходимо вызвать <xref:System.IO.FileSystemInfo.Refresh%2A>, чтобы получить последнюю копию информации.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 В этом примере создаются выходные данные, аналогичные приведенным ниже.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
    <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.IO.FileInfo : string -&gt; System.IO.FileInfo" Usage="new System.IO.FileInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Полное имя нового файла или относительное имя файла. Путь не должен заканчиваться символом разделителя каталогов.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.IO.FileInfo" />, который служит оболочкой для пути файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать полное или относительное имя файла, но проверка безопасности получает полное имя.  
  
   
  
## Examples  
 В следующем примере этот конструктор используется для создания двух файлов, которые затем записываются в, считываются, копируются и удаляются.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 В следующем примере открывается существующий файл или создается файл, добавляется текст в файл и выводятся результаты.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="fileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.ArgumentException">Имя файла является пустой строкой, содержит только пробелы или недопустимые символы.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Отказано в доступе к <paramref name="fileName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="fileName" /> содержит двоеточие (:) в середине строки.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberSignature Language="F#" Value="member this.AppendText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.AppendText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.IO.StreamWriter" />, который добавляет текст в файл, представленный этим экземпляром <see cref="T:System.IO.FileInfo" />.</summary>
        <returns>Новый объект <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере текст добавляется в файл и считывается из файла.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 Следующий пример демонстрирует добавление текста в конец файла, а также отображение результата операции добавления в консоль. При первом вызове этой подпрограммы файл создается, если он не существует. После этого указанный текст добавляется к файлу.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует существующий файл в новый файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Имя нового файла, в который будет выполняться копирование.</param>
        <summary>Копирует существующий файл в новый файл и запрещает перезапись существующего файла.</summary>
        <returns>Новый файл с полным именем.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.IO.FileInfo.CopyTo(System.String,System.Boolean)>, чтобы разрешить перезапись существующего файла.  
  
> [!CAUTION]
>  Везде, где это возможно, Избегайте использования коротких имен файлов (например, XXXXXX ~ 1. XXX) с этим методом. Если два файла имеют эквивалентные короткие имена файлов, этот метод может завершиться ошибкой и (или) привести к нежелательному поведению.  
  
   
  
## Examples  
 В следующем примере показаны обе перегрузки метода `CopyTo`.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 В следующем примере демонстрируется копирование одного файла в другой, что вызывает исключение, если целевой файл уже существует.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> является пустой строкой, содержит только пробелы или недопустимые символы.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка, или файл назначения уже существует.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Передан путь к каталогу, или файл перемещен на другой диск.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, указанный в <paramref name="destFileName" />, не существует.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" /> содержит двоеточие (:) в строке, но не указывает том.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">Имя нового файла, в который будет выполняться копирование.</param>
        <param name="overwrite">Значение <see langword="true" /> позволяет разрешить перезапись существующего файла; в противном случае — значение <see langword="false" />.</param>
        <summary>Копирует существующий файл в новый файл и разрешает перезапись существующего файла.</summary>
        <returns>Новый файл или перезапись существующего файла, если для параметра <paramref name="overwrite" /> задано значение <see langword="true" />. Если файл существует и для параметра <paramref name="overwrite" /> задано значение <see langword="false" />, создается исключение <see cref="T:System.IO.IOException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы разрешить или запретить перезапись существующего файла. Используйте метод <xref:System.IO.FileInfo.CopyTo(System.String)>, чтобы предотвратить перезапись существующего файла по умолчанию.  
  
> [!CAUTION]
>  Везде, где это возможно, Избегайте использования коротких имен файлов (например, XXXXXX ~ 1. XXX) с этим методом. Если два файла имеют эквивалентные короткие имена файлов, этот метод может завершиться ошибкой и (или) привести к нежелательному поведению.  
  
   
  
## Examples  
 В следующем примере показаны обе перегрузки метода `CopyTo`.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 В следующем примере показано, как скопировать один файл в другой файл, указав, следует ли перезаписывать уже существующий файл.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> является пустой строкой, содержит только пробелы или недопустимые символы.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка, или файл назначения уже существует, а <paramref name="overwrite" /> имеет значение <see langword="false" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, указанный в <paramref name="destFileName" />, не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Передан путь к каталогу, или файл перемещен на другой диск.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" /> содержит двоеточие (:) в середине строки.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; System.IO.FileStream" Usage="fileInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает файл.</summary>
        <returns>Новый файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию всем пользователям предоставляется полный доступ на чтение и запись к новым файлам.  
  
 Этот метод является оболочкой для функциональных возможностей, предоставляемых <xref:System.IO.File.Create%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере создается ссылка на файл, а затем файл создается на диске с помощью `FileInfo.Create()`.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 В следующем примере создается файл, в него добавляется текст и считывается из файла.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberSignature Language="F#" Value="member this.CreateText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.CreateText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.IO.StreamWriter" />, который записывает новый текстовый файл.</summary>
        <returns>Новый объект <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию всем пользователям предоставляется полный доступ на чтение и запись к новым файлам.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод `CreateText`.  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Имя файла является каталогом.</exception>
        <exception cref="T:System.IO.IOException">Диск доступен только для чтения.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberSignature Language="F#" Value="member this.Decrypt : unit -&gt; unit" Usage="fileInfo.Decrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Расшифровывает файл, зашифрованный текущей учетной записью с помощью метода <see cref="M:System.IO.FileInfo.Encrypt" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.Decrypt%2A> позволяет расшифровать файл, который был зашифрован с помощью метода <xref:System.IO.FileInfo.Encrypt%2A>.  Метод <xref:System.IO.FileInfo.Decrypt%2A> может расшифровывать только те файлы, которые были зашифрованы с использованием текущей учетной записи пользователя.  
  
 Как метод <xref:System.IO.FileInfo.Encrypt%2A>, так и метод <xref:System.IO.FileInfo.Decrypt%2A> используют поставщик служб шифрования (CSP), установленный на компьютере, и ключи шифрования файлов процесса, вызывающего метод.  
  
 Текущая файловая система должна иметь формат NTFS, а текущая операционная система должна быть установлена на компьютере под управлением Microsoft Windows NT или более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.IO.FileInfo.Encrypt%2A> и метод <xref:System.IO.FileInfo.Decrypt%2A> для шифрования и последующей расшифровки файла.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Указан недопустимый диск.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии файла возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Файловая система не является системой NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />, доступен только для чтения.  
  
-или- 
Эта операция не поддерживается на текущей платформе.  
  
-или- 
У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Действие по обеспечению безопасности: Demand.  
  
Разрешение на чтение и запись в файл, описываемый текущим объектом <see cref="T:System.IO.FileInfo" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="fileInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет файл без возможности восстановления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файл не существует, этот метод не выполняет никаких действий.  
  
   
  
## Examples  
 В следующем примере демонстрируется метод `Delete`.  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 В следующем примере создается, закрывается и удаляется файл.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Целевой файл открыт или сопоставлен в памяти на компьютере под управлением Microsoft Windows NT.  
  
-или- 
Для файла имеется открытый дескриптор, а операционной системой является Windows XP или более ранней версии. Этот открытый дескриптор может быть результатом перечисления каталогов и файлов. Дополнительные сведения см. в разделе [Практическое руководство. Перечисление каталогов и файлов](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Путь является каталогом.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Directory : System.IO.DirectoryInfo" Usage="System.IO.FileInfo.Directory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр родительского каталога.</summary>
        <value>Объект <see cref="T:System.IO.DirectoryInfo" />, представляющий родительский каталог данного файла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить родительский каталог в виде строки, используйте свойство <xref:System.IO.FileInfo.DirectoryName%2A>.  
  
   
  
## Examples  
 Следующий пример открывает или создает файл, определяет его полный путь, а также определяет и отображает все содержимое каталога.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryName : string" Usage="System.IO.FileInfo.DirectoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строку, представляющую полный путь к каталогу.</summary>
        <value>Строка, представляющая полный путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить родительский каталог в качестве объекта <xref:System.IO.DirectoryInfo>, используйте свойство <xref:System.IO.FileInfo.Directory%2A>.  
  
 При первом вызове <xref:System.IO.FileInfo> вызывает <xref:System.IO.FileSystemInfo.Refresh%2A> и кэширует сведения о файле. При последующих вызовах необходимо вызвать <xref:System.IO.FileSystemInfo.Refresh%2A>, чтобы получить последнюю копию информации.  
  
   
  
## Examples  
 В следующем примере извлекается полный путь к указанному файлу.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <see langword="null" /> было передано в качестве имени каталога.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина имени полного пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberSignature Language="F#" Value="member this.Encrypt : unit -&gt; unit" Usage="fileInfo.Encrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Шифрует файл таким образом, чтобы его можно было расшифровать только с помощью учетной записи, которая использовалась для шифрования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.Encrypt%2A> позволяет зашифровать файл, чтобы только учетная запись, используемая для вызова этого метода, могла его расшифровать.  Используйте метод <xref:System.IO.FileInfo.Decrypt%2A> для расшифровки файла, зашифрованного методом <xref:System.IO.FileInfo.Encrypt%2A>.  
  
 Как метод <xref:System.IO.FileInfo.Encrypt%2A>, так и метод <xref:System.IO.FileInfo.Decrypt%2A> используют поставщик служб шифрования (CSP), установленный на компьютере, и ключи шифрования файлов процесса, вызывающего метод.  
  
 Текущая файловая система должна иметь формат NTFS, а текущая операционная система должна быть установлена на компьютере под управлением Microsoft Windows NT или более поздней версии.  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.IO.FileInfo.Encrypt%2A> и метод <xref:System.IO.FileInfo.Decrypt%2A> для шифрования файла и последующего его расшифровки.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Указан недопустимый диск.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии файла возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Файловая система не является системой NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />, доступен только для чтения.  
  
-или- 
Эта операция не поддерживается на текущей платформе.  
  
-или- 
У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Действие по обеспечению безопасности: Demand.  
  
Разрешение на чтение и запись в файл, описываемый текущим объектом <see cref="T:System.IO.FileInfo" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.FileInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, существует ли файл.</summary>
        <value>Значение <see langword="true" />, если файл существует; значение <see langword="false" />, если файл не существует или если это каталог.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При первом вызове <xref:System.IO.FileInfo> вызывает <xref:System.IO.FileSystemInfo.Refresh%2A> и кэширует сведения о файле. При последующих вызовах необходимо вызвать <xref:System.IO.FileSystemInfo.Refresh%2A>, чтобы получить последнюю копию информации.  
  
 Свойство <xref:System.IO.FileInfo.Exists%2A> возвращает `false` при возникновении любой ошибки при попытке определить, существует ли указанный файл. Это может произойти в ситуациях, когда вызываются такие исключения, как передача имени файла с недопустимыми символами или слишком много символов, неудачный или отсутствующий диск или если вызывающий объект не имеет разрешения на чтение файла.  
  
   
  
## Examples  
 В следующем примере кода используется свойство <xref:System.IO.FileInfo.Exists%2A> для проверки существования файла перед его открытием.  Этот метод можно использовать для создания пользовательского исключения, если файл не найден.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Security.AccessControl.FileSecurity" />, который инкапсулирует записи списка управления доступом (ACL) для файла, описываемого текущим объектом <see cref="T:System.IO.FileInfo" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.FileInfo.GetAccessControl%2A> методы для получения записей списка управления доступом (ACL) для текущего файла.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Security.AccessControl.FileSecurity" />, который инкапсулирует записи списка управления доступом (ACL) для файла, описываемого текущим объектом <see cref="T:System.IO.FileInfo" />.</summary>
        <returns><see cref="T:System.Security.AccessControl.FileSecurity" />, инкапсулирующий правила управления доступом к текущему файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.IO.FileInfo.GetAccessControl%2A>, чтобы получить записи списка управления доступом (ACL) для текущего файла.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.IO.FileInfo.GetAccessControl%2A> и метод <xref:System.IO.FileInfo.SetAccessControl%2A> для добавления и удаления записи списка управления доступом (ACL) из файла.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При открытии файла возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows 2000 или более поздней версией Windows.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Текущая системная учетная запись не имеет прав администратора.</exception>
        <exception cref="T:System.SystemException">Не удалось найти файл.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Эта операция не поддерживается на текущей платформе.  
  
 -или-  
  
 У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Demand.  
  
разрешение на чтение списка управления доступом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Одно из значений <see cref="T:System.Security.AccessControl.AccessControlSections" />, которое указывает, какую группу записей списка ACL необходимо извлечь.</param>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.FileSecurity" />, который инкапсулирует заданный тип записей списка управления доступом для файла, описываемого текущим объектом <see cref="T:System.IO.FileInfo" />.</summary>
        <returns><see cref="T:System.Security.AccessControl.FileSecurity" />, инкапсулирующий правила управления доступом к текущему файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.IO.FileInfo.GetAccessControl%2A>, чтобы получить записи списка управления доступом (ACL) для текущего файла.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При открытии файла возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows 2000 или более поздней версией Windows.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Текущая системная учетная запись не имеет прав администратора.</exception>
        <exception cref="T:System.SystemException">Не удалось найти файл.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Эта операция не поддерживается на текущей платформе.  
  
 -или-  
  
 У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Demand.  
  
разрешение на чтение списка управления доступом.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.IO.FileInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, позволяющее определить, является ли текущий файл доступным только для чтения.</summary>
        <value>Значение<see langword="true" /> , если текущий файл доступен только для чтения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.IO.FileInfo.IsReadOnly%2A>, чтобы быстро определить, доступен ли текущий файл только для чтения.  
  
 При первом вызове <xref:System.IO.FileInfo> вызывает <xref:System.IO.FileSystemInfo.Refresh%2A> и кэширует сведения о файле. При последующих вызовах необходимо вызвать <xref:System.IO.FileSystemInfo.Refresh%2A>, чтобы получить последнюю копию информации.  
  
   
  
## Examples  
 В следующем примере свойство <xref:System.IO.FileInfo.IsReadOnly%2A> используется, чтобы пометить файл как доступный только для чтения, а затем пометить его как доступный для чтения и записи.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии файла возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Эта операция не поддерживается на текущей платформе.  
  
 -или-  
  
 У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.ArgumentException">Пользователь не имеет разрешения на запись, но пытается задать для этого свойства значение <see langword="false" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Действие по обеспечению безопасности: Demand.  
  
Разрешение на чтение и запись в файл, описываемый текущим объектом <see cref="T:System.IO.FileInfo" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileInfo.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер текущего файла в байтах.</summary>
        <value>Размер текущего файла в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.IO.FileInfo.Length%2A> предварительно кэшировано, если текущий экземпляр объекта <xref:System.IO.FileInfo> был возвращен из любого из следующих методов <xref:System.IO.DirectoryInfo>:  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 Чтобы получить Последнее значение, вызовите метод <xref:System.IO.FileSystemInfo.Refresh%2A>.  
  
   
  
## Examples  
 В следующем примере показан размер указанных файлов.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><see cref="M:System.IO.FileSystemInfo.Refresh" /> не удалось обновить состояние файла или каталога.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.  
  
-или- 
Свойство <see langword="Length" /> вызывается для каталога.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="fileInfo.MoveTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Путь, указывающий на местоположение, в которое необходимо переместить файл; в этом же пути можно задать и другое имя файла.</param>
        <summary>Перемещает заданный файл в новое местоположение и разрешает переименование файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод работает на дисковых томах. Например, файл c:\MyFile.txt можно переместить в д:\публик и переименовать NewFile. txt.

Этот метод не перезаписывает файл назначения, если он уже существует. Для этой цели следует вызвать <xref:System.IO.FileInfo.MoveTo(System.String,System.Boolean)>.

## Examples

В следующем примере показано перемещение файла в другое расположение и переименование файла.

[!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
[!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода, например, конечный файл уже существует или устройство назначения не готово.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> является пустой строкой, содержит только пробелы или недопустимые символы.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destFileName" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" /> содержит двоеточие (:) в середине строки.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string * bool -&gt; unit" Usage="fileInfo.MoveTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destFileName">Путь, указывающий на местоположение, в которое необходимо переместить файл; в этом же пути можно задать и другое имя файла.</param>
        <param name="overwrite"><see langword="true" /> для перезаписи конечного файла, если он уже существует; в противном случае — <see langword="false" />.</param>
        <summary>Перемещает указанный файл в новое расположение, предоставляя параметры для указания нового имени файла и перезаписи конечного файла, если он уже существует.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Этот метод работает на дисковых томах. Например, файл c:\MyFile.txt можно переместить в д:\публик и переименовать NewFile. txt.

## Examples

В следующем примере показано перемещение файла в другое расположение и переименование файла.

[!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
[!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например целевое устройство не готово.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> является пустой строкой, содержит только пробелы или недопустимые символы.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destFileName" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" /> содержит двоеточие (:) в середине строки.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя файла.</summary>
        <value>Имя файла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При первом вызове <xref:System.IO.FileInfo> вызывает <xref:System.IO.FileSystemInfo.Refresh%2A> и кэширует сведения о файле. При последующих вызовах необходимо вызвать <xref:System.IO.FileSystemInfo.Refresh%2A>, чтобы получить последнюю копию информации.  
  
 Имя файла включает в себя расширение файла.  
  
   
  
## Examples  
 В следующем примере свойство `Name` используется для вывода имен файлов в текущем каталоге.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает файл с различными правами на чтение и запись и привилегиями для совместной работы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode -&gt; System.IO.FileStream" Usage="fileInfo.Open mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Константа <see cref="T:System.IO.FileMode" /> задает режим (например <see langword="Open" /> или <see langword="Append" />), в котором необходимо открыть файл.</param>
        <summary>Открывает файл в заданном режиме.</summary>
        <returns>Файл открыт в заданном режиме с доступом для чтения и записи и без предоставления общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере открывается файл, добавляются сведения в файл и считывается файл.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Файл доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">Файл уже открыт.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи и чтения файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Константа <see cref="T:System.IO.FileMode" /> задает режим (например <see langword="Open" /> или <see langword="Append" />), в котором необходимо открыть файл.</param>
        <param name="access">Константа <see cref="T:System.IO.FileAccess" /> задает доступ к открываемому файлу: <see langword="Read" />, <see langword="Write" /> или <see langword="ReadWrite" />.</param>
        <summary>Открывает файл в заданном режиме с доступом для чтения или записи, или и для чтения, и для записи.</summary>
        <returns>Объект <see cref="T:System.IO.FileStream" /> открыт в заданном режиме, с заданными правами и без предоставления общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере файл открывается с правами только для чтения и считывается из файла.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">Файл уже открыт.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи и чтения файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> является пустой строкой или содержит только пробелы.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">Константа <see cref="T:System.IO.FileMode" /> задает режим (например <see langword="Open" /> или <see langword="Append" />), в котором необходимо открыть файл.</param>
        <param name="access">Константа <see cref="T:System.IO.FileAccess" /> задает доступ к открываемому файлу: <see langword="Read" />, <see langword="Write" /> или <see langword="ReadWrite" />.</param>
        <param name="share">Константа <see cref="T:System.IO.FileShare" /> задает тип доступа к файлу для других объектов <see langword="FileStream" />.</param>
        <summary>Открывает файл в заданном режиме с доступом для чтения, записи или и для чтения, и для записи и с заданным параметром совместного доступа.</summary>
        <returns>Объект <see cref="T:System.IO.FileStream" /> открыт в заданном режиме, с заданными правами и параметром общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется открытие файла для чтения и записи, но запрещается доступ к другим пользователям или процессам.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">Файл уже открыт.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> является пустой строкой или содержит только пробелы.</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько аргументов имеют значение NULL.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи и чтения файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberSignature Language="F#" Value="member this.OpenRead : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает доступный только для чтения поток <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Новый объект <see cref="T:System.IO.FileStream" />, доступный только для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает объект <xref:System.IO.FileStream>, доступного только для чтения, с режимом <xref:System.IO.FileShare>, для которого задано значение <xref:System.IO.FileShare.Read>.  
  
   
  
## Examples  
 В следующем примере файл открывается только для чтения и считывается из него.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">Файл уже открыт.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberSignature Language="F#" Value="member this.OpenText : unit -&gt; System.IO.StreamReader" Usage="fileInfo.OpenText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает поток <see cref="T:System.IO.StreamReader" /> с кодировкой UTF-8, который считывает данные из существующего текстового файла.</summary>
        <returns>Новый объект <see langword="StreamReader" /> с кодировкой UTF8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример считывает текст из файла.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего кода отсутствуют необходимые разрешения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberSignature Language="F#" Value="member this.OpenWrite : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenWrite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает доступный только для чтения поток <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Объект <see cref="T:System.IO.FileStream" />, доступный только для записи, не предназначенный для совместного использования и служащий для нового или существующего файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.OpenWrite%2A> открывает файл, если он уже существует для пути к файлу, или создает новый файл, если он не существует. Для существующего файла он не добавляет новый текст к существующему тексту. Вместо этого существующие символы перезаписываются новыми символами. Если перезаписать более длинную строку (например, "это тест метода OpenWrite") с более короткой строкой (например, "второй запуск"), файл будет содержать сочетание строк ("второй рунтест метода OpenWrite").  
  
   
  
## Examples  
 В следующем примере открывается файл для записи, а затем выполняется чтение из файла.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Путь, указанный при создании экземпляра объекта <see cref="T:System.IO.FileInfo" />, доступен только для чтения или является каталогом.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Путь, указанный при создании экземпляра объекта <see cref="T:System.IO.FileInfo" />, является недопустимым, например находится на несопоставленном диске.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Заменяет содержимое заданного файла на содержимое файла, которое описано в текущем объекте <see cref="T:System.IO.FileInfo" />, удаляет исходный файл и создает резервную копию замененного файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.FileInfo.Replace%2A> методы, если необходимо быстро заменить файл содержимым файла, описываемого текущим объектом <xref:System.IO.FileInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Имя файла, который необходимо заменить текущим файлом.</param>
        <param name="destinationBackupFileName">Имя файла, с которым необходимо создать резервную копию файла, описанного параметром <paramref name="destFileName" />.</param>
        <summary>Заменяет содержимое заданного файла на содержимое файла, которое описано в текущем объекте <see cref="T:System.IO.FileInfo" />, удаляет исходный файл и создает резервную копию замененного файла.</summary>
        <returns>Объект <see cref="T:System.IO.FileInfo" />, который инкапсулирует сведения о файле, описанные параметром <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.Replace%2A> заменяет содержимое указанного файла содержимым файла, описываемого текущим объектом <xref:System.IO.FileInfo>.  Он также создает резервную копию файла, который был заменен.  Наконец, он возвращает новый объект <xref:System.IO.FileInfo>, описывающий перезаписанный файл.  
  
> [!CAUTION]
>  Этот метод будет выполнен в средах Windows 2000, если `destFileName` доступен только для чтения и не будет вызывать исключение. Используйте свойство <xref:System.IO.FileInfo.IsReadOnly%2A>, чтобы проверить, доступен ли целевой файл только для чтения, прежде чем пытаться его заменить.  
  
 Передайте `null` в параметр `destBackupFileName`, если не нужно создавать резервную копию заменяемого файла.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.IO.File.Replace%2A> для замены файла другим файлом и создания резервной копии замененного файла.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь, описываемый параметром <paramref name="destFileName" />, имел недопустимую форму.  
  
-или- 
Путь, описываемый параметром <paramref name="destBackupFileName" />, имел недопустимую форму.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destFileName" /> содержит значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />.  
  
-или- 
Файл, описываемый параметром <paramref name="destinationFileName" />, не найден.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
Действие по обеспечению безопасности: Demand.  
  
разрешение на запись в файл, описываемый параметром <paramref name="destBackupFileName" />, если он указан.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Имя файла, который необходимо заменить текущим файлом.</param>
        <param name="destinationBackupFileName">Имя файла, с которым необходимо создать резервную копию файла, описанного параметром <paramref name="destFileName" />.</param>
        <param name="ignoreMetadataErrors">Значение <see langword="true" /> позволяет игнорировать ошибки слияния (например атрибуты и списки ACL), исходящие из заменяемого файла в заменяющий; в противном случае — значение <see langword="false" />.</param>
        <summary>Заменяет содержимое заданного файла на содержимое файла, которое описано в текущем объекте <see cref="T:System.IO.FileInfo" />, удаляет исходный файл и создает резервную копию замененного файла.  Также позволяет определить, нужно ли игнорировать ошибки слияния.</summary>
        <returns>Объект <see cref="T:System.IO.FileInfo" />, который инкапсулирует сведения о файле, описанные параметром <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.Replace%2A> заменяет содержимое указанного файла содержимым файла, описываемого текущим объектом <xref:System.IO.FileInfo>.  Он также создает резервную копию файла, который был заменен.  Наконец, он возвращает новый объект <xref:System.IO.FileInfo>, описывающий перезаписанный файл.  
  
> [!CAUTION]
>  Этот метод будет выполнен в средах Windows 2000, если `destFileName` доступен только для чтения и не будет вызывать исключение. Используйте свойство <xref:System.IO.FileInfo.IsReadOnly%2A>, чтобы проверить, доступен ли целевой файл только для чтения, прежде чем пытаться его заменить.  
  
 Передайте `null` в параметр `destBackupFileName`, если не нужно создавать резервную копию заменяемого файла.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.IO.File.Replace%2A> для замены файла другим файлом и создания резервной копии замененного файла.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь, описываемый параметром <paramref name="destFileName" />, имел недопустимую форму.  
  
-или- 
Путь, описываемый параметром <paramref name="destBackupFileName" />, имел недопустимую форму.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destFileName" /> содержит значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти файл, описанный текущим объектом <see cref="T:System.IO.FileInfo" />.  
  
-или- 
Файл, описываемый параметром <paramref name="destinationFileName" />, не найден.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
Действие по обеспечению безопасности: Demand.  
  
разрешение на запись в файл, описываемый параметром <paramref name="destBackupFileName" />, если он указан.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileInfo.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Объект <see cref="T:System.Security.AccessControl.FileSecurity" />, описывающий запись списка управления доступом (ACL), которую необходимо применить к текущему файлу.</param>
        <summary>Применяет записи списка управления доступом (ACL), описанные объектом <see cref="T:System.Security.AccessControl.FileSecurity" />, к файлу, который описывается текущим объектом <see cref="T:System.IO.FileInfo" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.IO.FileInfo.SetAccessControl%2A> применяет записи списка управления доступом (ACL) к текущему файлу, который представляет неунаследованный список ACL.  
  
 Используйте метод <xref:System.IO.FileInfo.SetAccessControl%2A> каждый раз, когда необходимо добавить или удалить записи ACL из файла.  
  
> [!CAUTION]
>  Список управления доступом, указанный для параметра `fileSecurity`, заменяет существующий список ACL для файла. Чтобы добавить разрешения для нового пользователя, используйте метод <xref:System.IO.Directory.GetAccessControl%2A> для получения существующего списка ACL, измените его, а затем используйте <xref:System.IO.FileInfo.SetAccessControl%2A>, чтобы применить его к файлу.  
  
 Список ACL описывает пользователей и (или) группы, которые имеют или не имеют прав на определенные действия с заданным файлом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Метод <xref:System.IO.FileInfo.SetAccessControl%2A> сохраняет только объекты <xref:System.Security.AccessControl.FileSecurity>, которые были изменены после создания объекта.  Если объект <xref:System.Security.AccessControl.FileSecurity> не был изменен, он не будет сохранен в файл.  Таким образом, невозможно получить объект <xref:System.Security.AccessControl.FileSecurity> из одного файла и повторно применить тот же объект к другому файлу.  
  
 Чтобы скопировать данные ACL из одного файла в другой:  
  
1.  Используйте метод <xref:System.IO.FileInfo.GetAccessControl%2A> для получения объекта <xref:System.Security.AccessControl.FileSecurity> из исходного файла.  
  
2.  Создайте новый объект <xref:System.Security.AccessControl.FileSecurity> для целевого файла.  
  
3.  Используйте метод <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> объекта <xref:System.Security.AccessControl.FileSecurity> источника для получения сведений ACL.  
  
4.  Используйте метод <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>, чтобы скопировать данные, полученные на шаге 3, в целевой <xref:System.Security.AccessControl.FileSecurity> объект.  
  
5.  Установите целевой объект <xref:System.Security.AccessControl.FileSecurity> в конечный файл с помощью метода <xref:System.IO.FileInfo.SetAccessControl%2A>.  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.IO.FileInfo.GetAccessControl%2A> и метод <xref:System.IO.FileInfo.SetAccessControl%2A> для добавления и удаления записи ACL из файла.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="fileSecurity" /> содержит значение <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Не удалось найти или изменить файл.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий процесс не может открыть файл из-за отсутствия соответствующих прав доступа.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows 2000 или более поздней версией Windows.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" />  
  
Действие по обеспечению безопасности: Demand 
разрешение на доступ к файлу.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="fileInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает путь в виде строки. Используйте свойство <see cref="P:System.IO.FileInfo.Name" /> для полного пути.</summary>
        <returns>Строка, содержащая путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> Строка, возвращаемая методом <xref:System.IO.FileInfo.ToString%2A>, представляет путь, который был передан конструктору <xref:System.IO.FileInfo>. Вместо вызова метода `ToString` необходимо получить значение любого из следующих свойств в зависимости от цели.
> - <xref:System.IO.FileInfo.Name>, чтобы получить имя файла без сведений о родительском пути.
> - [FullName](xref:System.IO.FileSystemInfo.FullName)для получения полного пути к файлу.
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
  </Members>
</Type>
