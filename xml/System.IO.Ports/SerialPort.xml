<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3825fde78adc15a4414e3102f40f7d589914d705" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70333597" /></Metadata><TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет ресурс последовательного порта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот класс для управления файловым ресурсом последовательного порта. Этот класс обеспечивает синхронный и управляемый событиями ввод-вывод, доступ к состояниям ПИН-кода и прерываний, а также доступ к свойствам последовательного драйвера. Кроме того, функциональные возможности этого класса могут быть заключены во внутренний <xref:System.IO.Stream> объект, доступны <xref:System.IO.Ports.SerialPort.BaseStream%2A> через свойство и переданы в классы, которые переносятся в оболочку или используют потоки.  
  
 <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding> <xref:System.Text.UTF32Encoding>Класс поддерживает следующие кодировки: <xref:System.Text.ASCIIEncoding>,,, и любую кодировку, определенную в mscorlib. dll, где кодовая страница меньше 50000 или кодовая страница 54936. <xref:System.IO.Ports.SerialPort>  Можно использовать альтернативные кодировки, но необходимо использовать <xref:System.IO.Ports.SerialPort.ReadByte%2A> метод или <xref:System.IO.Ports.SerialPort.Write%2A> и выполнить кодирование самостоятельно.  
  
 <xref:System.IO.Ports.SerialPort.GetPortNames%2A> Метод используется для получения допустимых портов для текущего компьютера.  
  
 <xref:System.IO.Ports.SerialPort> Если объект блокируется во время операции чтения, не прерывайте поток. Вместо этого закройте базовый поток или <xref:System.IO.Ports.SerialPort> удалите объект.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Для обеспечения полной функциональности этого примера оба компьютера должны выполнять программу.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор использует значения свойств по умолчанию, если ни одно из них не указано. Например, <xref:System.IO.Ports.SerialPort.DataBits%2A> свойство по умолчанию равно 8 <xref:System.IO.Ports.SerialPort.Parity%2A> , `None` свойство по умолчанию имеет значение перечисления, <xref:System.IO.Ports.SerialPort.StopBits%2A> свойство по умолчанию равно 1 и имя порта COM1 по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Интерфейс к контейнеру.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанный объект <see cref="T:System.ComponentModel.IContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор использует значения свойств по умолчанию, если ни одно из них не указано. Например, <xref:System.IO.Ports.SerialPort.DataBits%2A> свойство по умолчанию равно 8 <xref:System.IO.Ports.SerialPort.Parity%2A> , `None` свойство по умолчанию имеет значение перечисления, <xref:System.IO.Ports.SerialPort.StopBits%2A> свойство по умолчанию равно 1 и имя порта COM1 по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Порт для использования (например, COM1).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанное имя порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для создания нового экземпляра класса, <xref:System.IO.Ports.SerialPort> если необходимо указать имя порта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Порт для использования (например, COM1).</param>
        <param name="baudRate">Скорость в бодах.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанное имя порта и скорость передачи в бодах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для создания нового экземпляра <xref:System.IO.Ports.SerialPort> класса, если необходимо указать имя порта и скорость передачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Порт для использования (например, COM1).</param>
        <param name="baudRate">Скорость в бодах.</param>
        <param name="parity">Одно из значений перечисления <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанное имя порта, скорость передачи в бодах и бит четности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для создания нового экземпляра <xref:System.IO.Ports.SerialPort> класса, если необходимо указать имя порта, скорость передачи данных и бит четности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Порт для использования (например, COM1).</param>
        <param name="baudRate">Скорость в бодах.</param>
        <param name="parity">Одно из значений перечисления <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Число битов данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанное имя порта, скорость передачи в бодах, бит четности и биты данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для создания нового экземпляра <xref:System.IO.Ports.SerialPort> класса, если необходимо указать имя порта, скорость передачи, бит четности и биты данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Порт для использования (например, COM1).</param>
        <param name="baudRate">Скорость в бодах.</param>
        <param name="parity">Одно из значений перечисления <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Число битов данных.</param>
        <param name="stopBits">Одно из значений перечисления <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Ports.SerialPort" />, используя указанное имя порта, скорость передачи в бодах, бит четности, биты данных и стоп-бит.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для создания нового экземпляра <xref:System.IO.Ports.SerialPort> класса, если необходимо указать имя порта, скорость передачи, бит четности, биты данных и бит окончания.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удается найти или открыть указанный порт.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый объект <see cref="T:System.IO.Stream" /> для объекта <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для явных асинхронных операций ввода-вывода или для передачи <xref:System.IO.Ports.SerialPort> объекта в класс <xref:System.IO.Stream> -оболочку, <xref:System.IO.StreamWriter>например.  
  
 <xref:System.IO.Ports.SerialPort.BaseStream%2A> Любое свойство открытого последовательного порта возвращает объект, производный от абстрактного <xref:System.IO.Stream> класса, и реализует методы чтения и записи, используя <xref:System.IO.Stream> прототипы, унаследованные от класса <xref:System.IO.Stream.BeginRead%2A>: <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>и .<xref:System.IO.Stream.WriteByte%2A> Эти методы могут быть полезны при передаче упакованного последовательного ресурса <xref:System.IO.Stream> в класс-оболочку.  
  
 Из-за недоступности <xref:System.IO.Stream.Length%2A> обработчика упакованных файлов свойства и <xref:System.IO.Stream.Position%2A> не поддерживаются, а <xref:System.IO.Stream.Seek%2A> методы и <xref:System.IO.Stream.SetLength%2A> не поддерживаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
        <exception cref="T:System.NotSupportedException">Поток находится в приложении .NET Compact Framework и был вызван один из следующих методов: 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
В .NET Compact Framework не поддерживается асинхронная модель с базовыми потоками.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает скорость передачи для последовательного порта (в бодах).</summary>
        <value>Скорость в бодах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Скорость передачи должна поддерживаться последовательным драйвером пользователя. Значение по умолчанию — 9600 бит в секунду (бит/с).  
  
   
  
## Examples  
 В следующем примере показано, как задать <xref:System.IO.Ports.SerialPort.BaudRate%2A> для `9600`свойства значение.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 В следующем примере показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли обмениваться сообщениями между двумя отдельными компьютерами, подключенными нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанная скорость меньше или равна нулю, или больше максимальной допустимой скорости передачи для устройства.</exception>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает состояние сигнала разрыва.</summary>
        <value><see langword="true" />, если порт находится в состоянии разрыва, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Состояние сигнала прерывания возникает, когда передача приостанавливается и строка переводится в состояние останова (все младшие, без остановки) до выпуска. Чтобы войти в состояние останова, присвойте этому `true`свойству значение. Если порт уже находится в состоянии Break, установка этого свойства в значение не приводит `true` к исключению. Невозможно выполнить запись в <xref:System.IO.Ports.SerialPort> объект, пока <xref:System.IO.Ports.SerialPort.BreakState%2A> имеет значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число байтов данных, находящихся в буфере приема.</summary>
        <value>Число байтов данных, находящихся в буфере приема.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Буфер приема включает в себя буфер получения последовательного драйвера, а также внутреннюю буферизацию в <xref:System.IO.Ports.SerialPort> самом объекте.  
  
 Поскольку свойство представляет <xref:System.IO.Ports.SerialPort> буфер и буфер, созданный системой Windows, он может возвращать большее значение, чем <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> свойство, которое представляет только буфер, созданный системой Windows. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Порт не открыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число байтов данных, находящихся в буфере отправки.</summary>
        <value>Число байтов данных, находящихся в буфере отправки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Буфер отправки содержит буфер отправки последовательного драйвера, а также внутреннюю буферизацию в <xref:System.IO.Ports.SerialPort> самом объекте.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает состояние линии обнаружения несущей для порта.</summary>
        <value>Значение <see langword="true" />, если несущая обнаружена, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для отслеживания состояния строки обнаружения несущей для порта. Отсутствие несущей частоты не означает, что получатель зависла и перевозчик был удален.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает соединение порта, присваивает свойству <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> значение <see langword="false" /> и уничтожает внутренний объект <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода закрывает <xref:System.IO.Ports.SerialPort> объект и очищает буферы приема и передачи. Этот метод вызывает <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> метод, который вызывает защищенный <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> метод с `disposing` параметром, для `true`которого задано значение.  
  
 Для любого приложения рекомендуется подождать некоторое время после вызова <xref:System.IO.Ports.SerialPort.Close%2A> метода, прежде чем пытаться <xref:System.IO.Ports.SerialPort.Open%2A> вызвать метод, так как порт не может быть закрыт мгновенно.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает состояние линии готовности к приему.</summary>
        <value>Значение <see langword="true" />, если сигнал готовности к приему обнаружен, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Линия CTS (Clear-To-Send) используется в запросе на отправку или очистку для отправки (RTS/CTS) подтверждения оборудования. Перед отправкой данных Линия CTS запрашивается через порт.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает стандартное число битов данных в байте.</summary>
        <value>Число битов данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диапазон значений этого свойства — от 5 до 8. Значение по умолчанию — 8.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Число битов данных меньше 5 или больше 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event DataReceived As SerialDataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что данные были получены через порт, представленный объектом <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События данных могут быть вызваны любыми элементами <xref:System.IO.Ports.SerialData> перечисления. Поскольку операционная система определяет, следует ли вызывать это событие или нет, может быть сообщено не все ошибки четности.  
  
 Событие также вызывается при получении символа EOF, независимо от числа байтов во внутреннем входном буфере и значения <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> свойства. <xref:System.IO.Ports.SerialPort.DataReceived>  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>события <xref:System.IO.Ports.SerialPort.DataReceived>, и <xref:System.IO.Ports.SerialPort.ErrorReceived> могут вызываться не по порядку, и может возникнуть небольшая задержка между тем, когда базовый поток сообщает об ошибке и о выполнении обработчика событий. В каждый момент времени может выполняться только один обработчик событий.  
  
 <xref:System.IO.Ports.SerialPort.DataReceived> Событие не гарантируется для каждого полученного байта. <xref:System.IO.Ports.SerialPort.BytesToRead%2A> Используйте свойство, чтобы определить, сколько данных осталось прочитать в буфере.  
  
 Событие возникает во вторичном потоке при получении данных <xref:System.IO.Ports.SerialPort> от объекта. <xref:System.IO.Ports.SerialPort.DataReceived> Поскольку это событие возникает во вторичном потоке, а не в основном потоке, попытка изменить некоторые элементы в основном потоке, например в элементах пользовательского интерфейса, может вызвать исключение потоковой обработки. Если необходимо изменить элементы в основном <xref:System.Windows.Forms.Form> или <xref:System.Windows.Forms.Control>, выполните запросы на изменение обратно с помощью <xref:System.Windows.Forms.Control.Invoke%2A>, что сделает работу в правильном потоке.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В этом примере <xref:System.IO.Ports.SerialDataReceivedEventHandler> добавляется <xref:System.IO.Ports.SerialPort.DataReceived> в для чтения всех доступных данных, полученных через порт COM1. Обратите внимание, что для проверки этого кода необходимо, чтобы оборудование подключено к порту COM1, который будет передавать данные.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет данные из буфера приема последовательного драйвера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен следующему коду Visual Basic: `MSComm1.InBufferCount = 0`. Он очищает буфер приема, но не влияет на буфер передачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, игнорируются ли пустые байты (NULL), передаваемые между портом и буфером приема.</summary>
        <value><see langword="true" />, если байты NULL игнорируются, в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно это значение должно быть установлено в `false`, особенно для двоичных передач.  Присвоение этому свойству `true` значения может привести к непредвиденным результатам для байтов в кодировке UTF32-и UTF16-Encoded.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет данные из буфера передачи последовательного драйвера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен следующему коду Visual Basic: `MSComm1.OutBufferCount = 0`. Он очищает буфер передачи, но не влияет на приемный буфер.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.IO.Ports.SerialPort" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым <xref:System.ComponentModel.Component.Dispose%2A> методом <xref:System.Object.Finalize%2A> и методом. <xref:System.ComponentModel.Component.Dispose%2A>вызывает защищенный <xref:System.IO.Ports.SerialPort.Dispose%2A> метод с параметром `disposing` , для `true`которого задано значение. <xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. <xref:System.IO.Ports.SerialPort.Dispose%2A>  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.IO.Ports.SerialPort>. Этот метод вызывает метод <xref:System.ComponentModel.Component.Dispose%2A> каждого объекта, на который есть ссылка.  
  
 Этот метод очищает и закрывает объект потока в <xref:System.IO.Ports.SerialPort.BaseStream%2A> свойстве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <block subset="none" type="overrides"><para>Метод 
            <see cref="M:System.ComponentModel.Component.Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see cref="M:System.ComponentModel.Component.Dispose" />. Дополнительные сведения о реализации <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see cref="M:System.ComponentModel.Component.Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе Очистка неуправляемых [ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает состояние сигнала готовности данных (DSR).</summary>
        <value>Значение <see langword="true" />, если сигнал готовности данных отправлен в порт, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется для подтверждения готовности набора данных и готовности терминала (DSR/DTR). Сигнал готовности набора данных (DSR) обычно отправляется через модем в порт, чтобы указать, что он готов к передаче данных или получению данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Поток закрыт. Это может произойти, если метод <see cref="M:System.IO.Ports.SerialPort.Open" /> не был вызван или же, напротив, вызван метод <see cref="M:System.IO.Ports.SerialPort.Close" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, включающее поддержку сигнала готовности терминала (DTR) в сеансе последовательной связи.</summary>
        <value><see langword="true" /> для включения сигнала готовности терминала (DTR), в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поддержка терминала данных (DTR) обычно включена при подтверждении программного обеспечения XON/XOFF и запросе на отправку и очистку для отправки (RTS/CTS) аппаратного подтверждения связи и модемного взаимодействия.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку байтов для преобразования текста до и после передачи.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />. Значение по умолчанию — <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Для свойства <see cref="P:System.IO.Ports.SerialPort.Encoding" /> задано значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">В качестве свойства <see cref="P:System.IO.Ports.SerialPort.Encoding" /> задана кодировка, отличная от <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" /> и любых однобайтовых и двухбайтовых кодировок Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorReceived As SerialErrorReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что произошла ошибка с портом, представленным объектом <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События ошибок могут быть вызваны любыми элементами <xref:System.IO.Ports.SerialError> перечисления. Поскольку операционная система определяет, следует ли вызывать это событие или нет, может быть сообщено не все ошибки четности.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>события <xref:System.IO.Ports.SerialPort.DataReceived>, и <xref:System.IO.Ports.SerialPort.ErrorReceived> могут вызываться не по порядку, и может возникнуть небольшая задержка между моментом, когда базовый поток сообщает об ошибке, а также о том, когда обработчик событий может выполнить код. В каждый момент времени может выполняться только один обработчик событий.  
  
 Если в завершающем байте потока возникает ошибка четности, дополнительный байт будет добавлен в входной буфер со значением 126.  
  
 Событие возникает во вторичном потоке при получении ошибки <xref:System.IO.Ports.SerialPort> от объекта. <xref:System.IO.Ports.SerialPort.ErrorReceived> Поскольку это событие возникает во вторичном потоке, а не в основном потоке, попытка изменить некоторые элементы в основном потоке, например в элементах пользовательского интерфейса, может вызвать исключение потоковой обработки. Если необходимо изменить элементы в основном <xref:System.Windows.Forms.Form> или <xref:System.Windows.Forms.Control>, выполните запросы на изменение обратно с помощью <xref:System.Windows.Forms.Control.Invoke%2A>, что сделает работу в правильном потоке.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает массив имен последовательных портов для текущего компьютера.</summary>
        <returns>Массив имен последовательных портов для текущего компьютера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок имен портов, возвращенных из <xref:System.IO.Ports.SerialPort.GetPortNames%2A> , не указан.  
  
 <xref:System.IO.Ports.SerialPort.GetPortNames%2A> Используйте метод для запроса к текущему компьютеру списка допустимых имен последовательных портов. Например, с помощью этого метода можно определить, являются ли COM1 и COM2 допустимыми последовательными портами для текущего компьютера.  
  
 Имена портов извлекаются из системного реестра (например, HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). Если реестр содержит устаревшие или иным образом неправильные данные <xref:System.IO.Ports.SerialPort.GetPortNames%2A> , метод возвратит неверные данные.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.IO.Ports.SerialPort.GetPortNames%2A> метод для вывода имен последовательных портов на консоль.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось выполнить запрос имен последовательных портов.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает протокол установления связи для передачи данных через последовательный порт с использованием значения <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.IO.Ports.Handshake" />. Значение по умолчанию — <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании подтверждения устройство, подключенное к <xref:System.IO.Ports.SerialPort> объекту, получает указание о том, что отправка данных прекращается, если в буфере находится по меньшей мере (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) байт. Устройство дает указание начать отправку данных, если в буфере 1024 или меньше байтов. Если устройство отправляет данные в блоки размером более 1024 байт, это может привести к переполнению буфера.  
  
 Если свойство имеет <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> значение и <xref:System.IO.Ports.SerialPort.CtsHolding%2A> имеет значение `false`, то символ XOFF не будет отправляться. <xref:System.IO.Ports.SerialPort.Handshake%2A> Если <xref:System.IO.Ports.SerialPort.CtsHolding%2A> параметр имеет `true`значение, то перед отправкой символа XOFF необходимо отправить больше данных.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Переданное значение не является допустимым значением перечисления <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Указывает, что отсчет времени ожидания не производится.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение используется со <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> свойствами и. <xref:System.IO.Ports.SerialPort.WriteTimeout%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее открытое или закрытое состояние объекта <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Значение <see langword="true" />, если последовательный порт открыт, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.IsOpen%2A> Свойство отслеживает, открыт ли порт для использования вызывающим объектом, а не указывает, открыт ли порт каким-либо приложением на компьютере.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Переданное значение <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Переданное значение <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> является пустой строкой ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, используемое для интерпретации окончания вызова методов <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> и <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Значение, представляющее конец строки. По умолчанию используется символ перевода строки ("\n" C# в <see cref="F:Microsoft.VisualBasic.Constants.vbLf" /> или в Visual Basic).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство определяет, какое значение (Byte) определяет конец строки для <xref:System.IO.Ports.SerialPort.ReadLine%2A> методов и. <xref:System.IO.Ports.SerialPort.WriteLine%2A> По умолчанию значением конца строки является символ перевода строки (`\n` C# <xref:Microsoft.VisualBasic.Constants.vbLf?displayProperty=nameWithType> в Visual Basic). Вы измените это значение на другое, если конкретное последовательное устройство, с которым вы работаете, использует другое значение для той же цели.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение свойства не указано.</exception>
        <exception cref="T:System.ArgumentNullException">Значение свойства — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает новое соединение последовательного порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого <xref:System.IO.Ports.SerialPort> объекта может существовать только одно открытое соединение.  
  
 Для любого приложения рекомендуется подождать некоторое время после вызова <xref:System.IO.Ports.SerialPort.Close%2A> метода, прежде чем пытаться <xref:System.IO.Ports.SerialPort.Open%2A> вызвать метод, так как порт не может быть закрыт мгновенно.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Отказ в доступе к порту.  
  
-или- 
Для текущего процесса или другого процесса в системе уже открыт заданный порт COM — экземпляром <see cref="T:System.IO.Ports.SerialPort" /> или в неуправляемом коде.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Одно или несколько свойств этого экземпляра недопустимы. Например, свойство <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> или <see cref="P:System.IO.Ports.SerialPort.Handshake" /> имеет недопустимое значение, значение <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> меньше или равно нулю, значение <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> или <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> меньше нуля и отлично от <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">Имя порта не начинается с "COM".  
  
- или -
  
 Тип файла порта не поддерживается.</exception>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Заданный порт текущего экземпляра объекта <see cref="T:System.IO.Ports.SerialPort" /> уже открыт.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />Действие по обеспечению безопасности:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает протокол контроля четности.</summary>
        <value>Одно из значений перечисления, представляющее протокол контроля четности. Значение по умолчанию — <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Четность — это процедура проверки ошибок, при которой количество единиц должно всегда быть одинаковым или четным для каждой группы битов, передаваемых без ошибок. При обмене данными между модемами часто используется один из параметров, которые должны быть согласованы перед отправкой и получением сторон, прежде чем может быть выполнена передача.  
  
 Если в завершающем байте потока возникает ошибка четности, дополнительный байт будет добавлен в входной буфер со значением 126.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Переданное значение <see cref="P:System.IO.Ports.SerialPort.Parity" /> не является допустимым значением перечисления <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает байт, которым заменяются недопустимые байты потока данных при обнаружении ошибок четности.</summary>
        <value>Байт для замены недопустимых байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задано значение null, замена четности отключается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event PinChanged As SerialPinChangedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для порта, представленного объектом <see cref="T:System.IO.Ports.SerialPort" />, возникло событие сигнала, не связанного с данными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События изменения последовательного ПИН-кода могут быть вызваны любыми <xref:System.IO.Ports.SerialPinChange> элементами перечисления. Поскольку операционная система определяет, следует ли вызывать это событие или нет, может быть сообщено не все ошибки четности. В рамках этого события задается новое значение ПИН-кода.  
  
 Событие возникает <xref:System.IO.Ports.SerialPort.BreakState%2A>при входе <xref:System.IO.Ports.SerialPort.BreakState%2A>объекта в, но не при выходе порта из. <xref:System.IO.Ports.SerialPort> <xref:System.IO.Ports.SerialPort.PinChanged> Это поведение не применяется к другим значениям в <xref:System.IO.Ports.SerialPinChange> перечислении.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>события <xref:System.IO.Ports.SerialPort.DataReceived>, и <xref:System.IO.Ports.SerialPort.ErrorReceived> могут вызываться не по порядку, и может возникнуть небольшая задержка между тем, когда базовый поток сообщает об ошибке и о выполнении обработчика событий. В каждый момент времени может выполняться только один обработчик событий.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged> Событие возникает во вторичном потоке. Поскольку это событие возникает во вторичном потоке, а не в основном потоке, попытка изменить некоторые элементы в основном потоке, например в элементах пользовательского интерфейса, может вызвать исключение потоковой обработки. Если необходимо изменить элементы в основном <xref:System.Windows.Forms.Form> или <xref:System.Windows.Forms.Control>, выполните запросы на изменение обратно с помощью <xref:System.Windows.Forms.Control.Invoke%2A>, что сделает работу в правильном потоке.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает последовательный порт, в частности, любой из доступных портов COM.</summary>
        <value>COM-порт. По умолчанию используется порт COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список допустимых имен портов можно получить с помощью <xref:System.IO.Ports.SerialPort.GetPortNames%2A> метода.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойству <see cref="P:System.IO.Ports.SerialPort.PortName" /> присвоено значение нулевой длины.  
  
- или - 
Свойству <see cref="P:System.IO.Ports.SerialPort.PortName" /> присвоено значение, начинающееся с "\\\\".  
  
- или - 
Недопустимое имя порта.</exception>
        <exception cref="T:System.ArgumentNullException">Для свойства <see cref="P:System.IO.Ports.SerialPort.PortName" /> задано значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт открыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет чтение из входного буфера <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив байтов, в который записываются входные данные.</param>
        <param name="offset">Смещение в <paramref name="buffer" />, с которым следует записывать байты.</param>
        <param name="count">Максимальное число байтов, предназначенных для чтения. Считывается меньшее число байтов, если <paramref name="count" /> больше числа байтов во входном буфере.</param>
        <summary>Считывает из входного буфера <see cref="T:System.IO.Ports.SerialPort" /> определенное число байтов и записывает их в байтовый массив, начиная с указанной позиции.</summary>
        <returns>Количество прочитанных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
 <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с тем, сколько байтов доступно для чтения.  Свойство может означать, что есть байты для чтения, но эти байты могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 Метод не блокирует другие операции, когда число считанных байтов равно `count` , но в последовательном порте остаются непрочитанные байты. <xref:System.IO.Ports.SerialPort.Read%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Буфер для записи задан значением <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> или <paramref name="count" /> выходит за пределы указанного массива <paramref name="buffer" />. Значение параметра <paramref name="offset" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> плюс <paramref name="count" /> превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Отсутствуют байты, доступные для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив символов, в который записываются входные данные.</param>
        <param name="offset">Смещение в <paramref name="buffer" />, с которым следует записывать знаки.</param>
        <param name="count">Максимальное число считываемых символов. Считывается меньшее число знаков, если <paramref name="count" /> больше числа знаков во входном буфере.</param>
        <summary>Считывает из входного буфера <see cref="T:System.IO.Ports.SerialPort" /> определенное число символов и записывает их в символьный массив, начиная с указанной позиции.</summary>
        <returns>Число прочитанных знаков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения символов из последовательного порта.  
  
 Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
 <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с количеством доступных для чтения символов.  Свойство может указывать на то, что для чтения есть символы, но эти символы могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 Метод не блокирует другие операции, когда число считанных байтов равно `count` , но в последовательном порте остаются непрочитанные байты. <xref:System.IO.Ports.SerialPort.Read%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> плюс <paramref name="count" /> превышает длину буфера.  
  
- или - 
 <paramref name="count" /> равно 1 и в буфере имеется символ-суррогат.</exception>
        <exception cref="T:System.ArgumentNullException">В качестве <paramref name="buffer" /> передано <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> или <paramref name="count" /> выходит за пределы указанного массива <paramref name="buffer" />. Значение параметра <paramref name="offset" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.TimeoutException">Отсутствуют символы, доступные для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер входного буфера <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Размер буфера в байтах. Значение по умолчанию равно 4096; максимальное значение является положительным int или 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> Свойство пропускает любое значение меньше 4096.  
  
 Поскольку свойство представляет только буфер, созданный системой Windows, он может вернуть меньшее значение, <xref:System.IO.Ports.SerialPort.BytesToRead%2A> чем свойство <xref:System.IO.Ports.SerialPort> , которое представляет буфер и буфер, созданный системой Windows. <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Задаваемое значение <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> меньше или равно нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> было установлено при открытом потоке.</exception>
        <exception cref="T:System.IO.IOException">Свойству <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> присвоено нечетное значение.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает из входного буфера <see cref="T:System.IO.Ports.SerialPort" /> один байт в синхронном режиме.</summary>
        <returns>Байт, приведенный к типу <see cref="T:System.Int32" />, или -1, если достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает один байт.  
  
 Будьте внимательны при <xref:System.IO.Ports.SerialPort.ReadByte%2A> использовании <xref:System.IO.Ports.SerialPort.ReadChar%2A> и вместе. Переключение между чтением и чтением символов может привести к тому, что дополнительные данные будут считываться и (или) другое непреднамеренное поведение. Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
> [!NOTE]
>  <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с тем, сколько байтов доступно для чтения.  Свойство может означать, что есть байты для чтения, но эти байты могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Операция не была завершена до истечения срока ожидания.  
  
- или -
  
 Не считано ни одного байта.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает из входного буфера <see cref="T:System.IO.Ports.SerialPort" /> один символ в синхронном режиме.</summary>
        <returns>Прочитанный символ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает один полный символ на основе кодировки.  
  
 Будьте внимательны при <xref:System.IO.Ports.SerialPort.ReadByte%2A> использовании <xref:System.IO.Ports.SerialPort.ReadChar%2A> и вместе. Переключение между чтением и чтением символов может привести к тому, что дополнительные данные будут считываться и (или) другое непреднамеренное поведение. Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
> [!NOTE]
>  <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с тем, сколько байтов доступно для чтения.  Свойство может означать, что есть байты для чтения, но эти байты могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Операция не была завершена до истечения срока ожидания.  
  
- или -
  
 В течение отведенного срока ожидания не было доступно ни одного символа.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает все непосредственно доступные байты в соответствии с кодировкой из потока и из входного буфера объекта <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Содержимое потока и входного буфера объекта <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает содержимое потока и внутренний буфер <xref:System.IO.Ports.SerialPort> объекта в виде строки. Этот метод не использует время ожидания. Обратите внимание, что этот метод может оставить конечные старшие байты во внутреннем <xref:System.IO.Ports.SerialPort.BytesToRead%2A> буфере, что делает значение больше нуля.  
  
 Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
> [!NOTE]
>  Класс помещает данные в буфер, но объект потока, содержащийся <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> в свойстве, — нет. <xref:System.IO.Ports.SerialPort> Таким образом, <xref:System.IO.Ports.SerialPort> объект и объект потока могут отличаться от числа байтов, доступных для чтения. Если байты буферизованы <xref:System.IO.Ports.SerialPort> в объект <xref:System.IO.Ports.SerialPort.BytesToRead%2A> , свойство включает эти байты в свое значение, однако эти байты могут быть недоступны для потока <xref:System.IO.Ports.SerialPort.BaseStream%2A> , содержащегося в свойстве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает данные из входного буфера до значения <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</summary>
        <returns>Содержимое входного буфера до первого появления значения <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что хотя этот метод не <xref:System.IO.Ports.SerialPort.NewLine%2A> возвращает значение <xref:System.IO.Ports.SerialPort.NewLine%2A> , значение удаляется из входного буфера.  
  
 По умолчанию <xref:System.IO.Ports.SerialPort.ReadLine%2A> метод будет блокироваться до получения строки. Если такое поведение нежелательно, присвойте <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> свойству любое ненулевое значение, чтобы <xref:System.IO.Ports.SerialPort.ReadLine%2A> метод вызывал исключение, <xref:System.TimeoutException> если линия недоступна в порте.  
  
 Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
> [!NOTE]
>  <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с тем, сколько байтов доступно для чтения.  Свойство может означать, что есть байты для чтения, но эти байты могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.TimeoutException">Операция не была завершена до истечения срока ожидания.  
  
- или -
  
 Не считано ни одного байта.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает срок ожидания в миллисекундах для завершения операции чтения.</summary>
        <value>Срок ожидания в миллисекундах для завершения операции чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение времени ожидания чтения было изначально установлено в 500 миллисекунд в API связи Win32. Это свойство позволяет задать это значение. Для параметра время ожидания можно задать любое значение больше нуля или значение <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, в этом случае время ожидания не истекает. Тип <xref:System.IO.Ports.SerialPort.InfiniteTimeout> используется по умолчанию.  
  
> [!NOTE]
>  Пользователи неуправляемой `COMMTIMEOUTS` структуры могут ожидать, что значение времени ожидания будет равно нулю, чтобы подавить время ожидания. Однако для подавления истечения <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> времени ожидания со свойством необходимо указать <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Это свойство не влияет <xref:System.IO.Stream.BeginRead%2A> на метод потока, возвращаемого <xref:System.IO.Ports.SerialPort.BaseStream%2A> свойством.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Срок ожидания чтения меньше нуля и отличен от <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение, указывающее место прекращения операции чтения.</param>
        <summary>Считывает из входного буфера строку до указанного значения <paramref name="value" />.</summary>
        <returns>Содержимое входного буфера до указанного <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает строку вплоть до указанного `value`. Хотя возвращаемая строка не включает `value` `value` , удаляется из входного буфера.  
  
 Если необходимо переключаться между чтением текста и считыванием двоичных данных из потока, выберите протокол, который аккуратно определяет границу между текстовыми и двоичными данными, например чтение вручную байтов и декодирование данных.  
  
> [!NOTE]
>  <xref:System.IO.Ports.SerialPort.BaseStream%2A> Так как <xref:System.IO.Ports.SerialPort> класс помещает данные в буфер, а поток, содержащийся в свойстве, не имеет значения, два могут конфликтовать с тем, сколько байтов доступно для чтения.  Свойство может означать, что есть байты для чтения, но эти байты могут быть недоступны для потока, содержащегося <xref:System.IO.Ports.SerialPort.BaseStream%2A> в свойстве, так как они <xref:System.IO.Ports.SerialPort> были помещены в буфер класса. <xref:System.IO.Ports.SerialPort.BytesToRead%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="value" /> равна 0.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.TimeoutException">Операция не была завершена до истечения срока ожидания.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает число байтов во внутреннем входном буфере до возникновения события <see cref="E:System.IO.Ports.SerialPort.DataReceived" />.</summary>
        <value>Число байтов во внутреннем входном буфере до возникновения события <see cref="E:System.IO.Ports.SerialPort.DataReceived" />. Значение по умолчанию — 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие также вызывается <xref:System.IO.Ports.SerialData.Eof> при получении символа независимо от числа байтов во внутреннем входном буфере <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> и значения свойства. <xref:System.IO.Ports.SerialPort.DataReceived>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> меньше или равно нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, включен ли сигнал запроса передачи (RTS) в сеансе последовательной связи.</summary>
        <value><see langword="true" /> для включения запроса передачи (RTS), в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сигнал запроса передачи (RTS) обычно используется в запросе на отправку или очистку для отправки (RTS/CTS) аппаратного подтверждения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> устанавливается или извлекается, в то время как свойству <see cref="P:System.IO.Ports.SerialPort.Handshake" /> присваивается значение <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> или <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стандартное число стоповых битов в байте.</summary>
        <value>Одно из значений <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию для объекта <xref:System.IO.Ports.SerialPort.StopBits%2A> установлено значение <xref:System.IO.Ports.StopBits.One>.  
  
 Значение <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> не поддерживается.  
  
   
  
## Examples  
 В следующем примере показано, как задать <xref:System.IO.Ports.SerialPort.StopBits%2A> для `One`свойства значение.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 В следующем примере показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли обмениваться сообщениями между двумя отдельными компьютерами, подключенными нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью большого примера, <xref:System.IO.Ports.SerialPort> приведенного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.IO.Ports.SerialPort.StopBits" /> равно <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
-или- 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает данные в выходной буфер последовательного порта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write text" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Строка для вывода.</param>
        <param name="str">To be added.</param>
        <summary>Записывает указанную строку в последовательный порт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если требуется записать строку в качестве выходных данных в последовательный порт.  
  
 Если в выходном <xref:System.IO.Ports.SerialPort.Handshake%2A> буфере слишком много байтов и для <xref:System.IO.Ports.Handshake.XOnXOff> <xref:System.IO.Ports.SerialPort> него задано значение, то объект может вызвать <xref:System.ServiceProcess.TimeoutException> некоторое время, пока устройство будет готово к приему данных.  
  
 По умолчанию <xref:System.IO.Ports.SerialPort> использует <xref:System.Text.ASCIIEncoding> для кодирования символов. <xref:System.Text.ASCIIEncoding>кодирует все символы, превышающие 127, как (char) 63 или "?". Для поддержки дополнительных символов в этом диапазоне задайте значение <xref:System.IO.Ports.SerialPort.Encoding%2A> <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>или <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="text" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Операция не была завершена до истечения срока ожидания.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив байтов, данные из которого записываются в порт.</param>
        <param name="offset">Отсчитываемое от нуля смещение в массиве <paramref name="buffer" /> (в байтах), с которого начинается копирование байтов в порт.</param>
        <param name="count">Количество записываемых байтов.</param>
        <summary>Записывает указанное число байтов в последовательный порт, используя данные из буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если требуется записать в буфер байтов для создания выходных данных в последовательный порт.  
  
 Если в выходном <xref:System.IO.Ports.SerialPort.Handshake%2A> буфере слишком много байтов и для <xref:System.IO.Ports.Handshake.XOnXOff> <xref:System.IO.Ports.SerialPort> него задано значение, то объект может вызвать <xref:System.ServiceProcess.TimeoutException> некоторое время, пока устройство будет готово к приему данных.  
  
 По умолчанию <xref:System.IO.Ports.SerialPort> использует <xref:System.Text.ASCIIEncoding> для кодирования символов. <xref:System.Text.ASCIIEncoding>кодирует все символы, превышающие 127, как (char) 63 или "?". Для поддержки дополнительных символов в этом диапазоне задайте значение <xref:System.IO.Ports.SerialPort.Encoding%2A> <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>или <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В качестве <paramref name="buffer" /> передано <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> или <paramref name="count" /> выходит за пределы указанного массива <paramref name="buffer" />. Значение параметра <paramref name="offset" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> плюс <paramref name="count" /> превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Операция не была завершена до истечения срока ожидания.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив символов, данные из которого записываются в порт.</param>
        <param name="offset">Отсчитываемое от нуля смещение в массиве <paramref name="buffer" /> (в байтах), с которого начинается копирование байтов в порт.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает указанное число символов в последовательный порт, используя данные из буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если требуется записать в символьный буфер для создания выходных данных в последовательный порт.  
  
 Если в выходном <xref:System.IO.Ports.SerialPort.Handshake%2A> буфере слишком много байтов и для <xref:System.IO.Ports.Handshake.XOnXOff> <xref:System.IO.Ports.SerialPort> него задано значение, то объект может вызвать <xref:System.ServiceProcess.TimeoutException> некоторое время, пока устройство будет готово к приему данных.  
  
 По умолчанию <xref:System.IO.Ports.SerialPort> использует <xref:System.Text.ASCIIEncoding> для кодирования символов. <xref:System.Text.ASCIIEncoding>кодирует все символы, превышающие 127, как (char) 63 или "?". Для поддержки дополнительных символов в этом диапазоне задайте значение <xref:System.IO.Ports.SerialPort.Encoding%2A> <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>или <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В качестве <paramref name="buffer" /> передано <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> или <paramref name="count" /> выходит за пределы указанного массива <paramref name="buffer" />. Значение параметра <paramref name="offset" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> плюс <paramref name="count" /> превышает длину массива <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Операция не была завершена до истечения срока ожидания.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер выходного буфера последовательного порта.</summary>
        <value>Размер выходного буфера. Значение по умолчанию — 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> Свойство пропускает любое значение меньше 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> меньше или равно нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> было установлено при открытом потоке.</exception>
        <exception cref="T:System.IO.IOException">Свойству <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> присвоено нечетное значение.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine text" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Строка для записи в выходной буфер.</param>
        <param name="str">To be added.</param>
        <summary>Записывает указанную строку и значение <see cref="P:System.IO.Ports.SerialPort.NewLine" /> в выходной буфер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в входном <xref:System.IO.Ports.SerialPort.Handshake%2A> буфере слишком много байтов и для <xref:System.IO.Ports.Handshake.XOnXOff> <xref:System.IO.Ports.SerialPort> него задано значение, то объект может вызвать <xref:System.ServiceProcess.TimeoutException> , пока устройство не будет готово к приему данных.  
  
 Записанный выход включает <xref:System.IO.Ports.SerialPort.NewLine%2A> строку.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="text" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный порт не открыт.</exception>
        <exception cref="T:System.TimeoutException">Метод <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> не выполнил запись в поток.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает срок ожидания в миллисекундах для завершения операции записи.</summary>
        <value>Количество миллисекунд до истечения времени ожидания. Значение по умолчанию — <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение времени ожидания записи было изначально установлено в 500 миллисекунд в API обмена данными Win32. Это свойство позволяет задать это значение. Для параметра время ожидания можно задать любое значение больше нуля или значение <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, в этом случае время ожидания не истекает. Тип <xref:System.IO.Ports.SerialPort.InfiniteTimeout> используется по умолчанию.  
  
> [!NOTE]
>  Пользователи неуправляемой `COMMTIMEOUTS` структуры могут ожидать, что значение времени ожидания будет равно нулю, чтобы подавить время ожидания. Однако для подавления истечения <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> времени ожидания со свойством необходимо указать <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Это свойство не влияет <xref:System.IO.Stream.BeginWrite%2A> на метод потока, возвращаемого <xref:System.IO.Ports.SerialPort.BaseStream%2A> свойством.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.IO.Ports.SerialPort> класса, чтобы два пользователя могли общаться с двух отдельных компьютеров, Соединенных нуль-модемным кабелем. В этом примере пользователям предлагается ввести параметры порта и имя пользователя перед разговором. Этот пример кода является частью более крупного примера кода, <xref:System.IO.Ports.SerialPort> предоставленного для класса.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Порт находится в недействительном состоянии.  
  
- или - 
Попытка задать состояние базового порта завершилась неудачей. Например, вследствие недопустимости переданных этим объектом <see cref="T:System.IO.Ports.SerialPort" /> параметров.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> меньше нуля и отлично от <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
