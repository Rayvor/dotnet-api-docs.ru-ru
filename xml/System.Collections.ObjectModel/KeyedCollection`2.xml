<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f674f9e621e530f6ee1b3c61278c7bc6009ee991" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63907825" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
    <typeparam name="TItem">Тип элементов в коллекции.</typeparam>
    <summary>Предоставляет абстрактный базовый класс для коллекции, ключи которой внедрены в значения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Класс предоставляет оба O(1) индексированное извлечение и ключом которого является получение которого приближается к заданному O(1). Это абстрактный тип, или точнее бесконечное множество абстрактных типов, так как каждый из его сконструированных универсальных типов — это абстрактный базовый класс. Чтобы использовать <xref:System.Collections.ObjectModel.KeyedCollection%602>, производные от соответствующего типа сконструированного типа коллекции.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Класс — это гибрид коллекции на основе <xref:System.Collections.Generic.IList%601> универсального интерфейса и коллекции на основе <xref:System.Collections.Generic.IDictionary%602> универсальный интерфейс. На основе коллекций, такие как <xref:System.Collections.Generic.IList%601> универсальный интерфейс <xref:System.Collections.ObjectModel.KeyedCollection%602> — индексированных список элементов. На основе коллекций, такие как <xref:System.Collections.Generic.IDictionary%602> универсальный интерфейс <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет ключ, связанный с каждым элементом.  
  
 В отличие от словарей, элемент <xref:System.Collections.ObjectModel.KeyedCollection%602> не пару ключ значение; вместо этого весь элемент значение и ключ внедряется в значении.  Например, элемента коллекции, производного от `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` в Visual Basic) может быть «John Doe мл.» где значение — «John Doe мл.» а ключ — «Doe»; или коллекцию записей сотрудников, содержащих целочисленные ключи могут быть производными от `KeyedCollection\<int,Employee>`. Абстрактный <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод извлекает ключ из элемента.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который можно получить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> свойство.  При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекается один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить, указав порог создания словаря, при создании <xref:System.Collections.ObjectModel.KeyedCollection%602>. Словарь поиска создается в первый раз, количество элементов превышает пороговое значение.  Если указать значение -1 в качестве порогового значения, словарь поиска никогда не создается.  
  
> [!NOTE]
>  Если используется внутренний словарь поиска, он содержит ссылки на все элементы в коллекции, если `TItem` является ссылочным типом, или копирует всех элементов в коллекции, если `TItem` является типом значения. Таким образом, используя словарь поиска может не подойти Если `TItem` является типом значения.  
  
 Элемент по его индексу или ключу доступны посредством <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> свойство. Можно добавить элементы без ключа, но эти элементы впоследствии может осуществляться только по индексу.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. Первый пример показывает минимальный код, необходимый для являются производными от <xref:System.Collections.ObjectModel.KeyedCollection%602>и демонстрируется ряд унаследованные методы. Во втором примере показано, как в Переопределите защищенный методы <xref:System.Collections.ObjectModel.KeyedCollection%602> чтобы обеспечить пользовательское поведение.  
  
 **Пример 1**  
  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется компаратор по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Collections.ObjectModel.KeyedCollection%602> созданных с помощью данной конструктор использует универсальный компаратор по умолчанию для типа ключа, полученный из <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Чтобы указать другой универсальный компаратор, используйте <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> конструктор или <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекается один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
> [!NOTE]
>  Так как <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), должны наследоваться от него для использования. В конструкторе для вашего производного типа, вызовите соответствующий <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор проверки на равенство или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
   
  
## Examples  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется заданный компаратор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекается один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
> [!NOTE]
>  Так как <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), должны наследоваться от него для использования. В конструкторе для вашего производного типа, вызовите соответствующий <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор проверки на равенство или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Количество элементов, которое может содержать коллекция без создания словаря поиска (при значении 0 словарь поиска создается при добавлении первого элемента), или –1, чтобы словарь поиска не создавался никогда.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, который использует заданный компаратор и создает словарь поиска при превышении заданного порога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекается один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Этот конструктор позволяет переопределить это поведение. Укажите 0, чтобы создать словарь при добавлении первого элемента, 1, чтобы создать словарь при добавлении второго элемента и т. д. Если указать значение -1 в качестве порогового значения, словарь поиска никогда не создается.  
  
 Для очень маленьких коллекций повышение скорости получения данных, предоставляемые словарь поиска может не стоит дополнительную память, необходимую для словаря. Задание порога позволяет определить, когда такой компромисс.  
  
> [!NOTE]
>  Так как <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), должны наследоваться от него для использования. В конструкторе для вашего производного типа, вызовите соответствующий <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор проверки на равенство или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода используется <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор с пороговым значением 0, чтобы внутренний словарь создается в первый раз объект добавляется в коллекцию.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="dictionaryCreationThreshold" /> меньше -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, ключ которого требуется изменить.</param>
        <param name="newKey">Новый ключ для <paramref name="item" />.</param>
        <summary>Изменяет ключ, связанный с указанным элементом в словаре поиска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не изменяет ключ, внедренных в `item`; он просто заменяет ключ, сохраненный в словаре поиска.  Таким образом Если `newKey` отличается от ключа, которое внедрено в `item`, при отсутствии доступа к `item` с помощью ключа, возвращаемого функцией <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Этот метод не выполняет никаких действий при <xref:System.Collections.ObjectModel.KeyedCollection%602> не поддерживает словарь поиска.  
  
 Каждый ключ в <xref:System.Collections.ObjectModel.KeyedCollection%602> должно быть уникальным. Ключ не может быть `null`.  
  
 Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Прежде чем изменения ключа, встроенного в элемент, необходимо вызвать этот метод, чтобы обновить ключ в словаре поиска. Если порог создания словаря равно -1, вызов этого метода не требуется.  
  
 Не предоставляйте <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метода в качестве открытого метода производного класса. Неправильное использование этого метода помещает словарь поиска не синхронизировано с ключами элементов. Например, если ключ `null` и задав другое значение добавляет несколько ключей для элемента в словаре поиска. Предоставляйте этот метод, чтобы разрешить изменяемые ключи элементов: При изменении ключа для элемента, этот метод используется для изменения ключа в словаре поиска.  
  
   
  
## Examples  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> — <see langword="null" />.  
  
-или- 
 <paramref name="key" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> не найден.  
  
-или- 
 Указанный параметр <paramref name="key" /> уже существует в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если словарь поиска, этот метод очищает его, но не удаляет его.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использовать словарь поиска, несмотря на то, что количество элементов снова станет ниже порогового значения.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> метод, унаследованный от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода для очистки базовой коллекции и словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> метод, чтобы обеспечить пользовательское поведение для очистки всех объектов из коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает универсальный компаратор, используемый для определения равенства ключей в коллекции.</summary>
        <value>Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, используемого для определения равенства ключей в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Определяет, содержится ли в коллекции элемент с указанным ключом.</summary>
        <returns><see langword="true" />, если <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> содержит элемент с указанным ключом, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска `key` используется для поиска словаря. Если отсутствует словарь поиска, ключ каждого элемента, извлеченное с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод и сравнивается с указанным ключом.  
  
 Этот метод является операцией O(1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска; в противном случае он является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает словарь поиска <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Словарь поиска коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, если он существует; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекается один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, из которого нужно извлечь ключ.</param>
        <summary>При реализации в производном классе извлекает ключ из указанного элемента.</summary>
        <returns>Ключ для указанного элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ в словаре поиска отличается от ключа, внедренного в `item`, при отсутствии доступа к `item` с помощью ключа, возвращаемого функцией <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Можно реализовать этот метод для возврата `null` для коллекции, содержащей элементы без ключей, в этом случае элементы может осуществляться только по индексу. Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Необходимо переопределить этот метод для предоставления словаря способ извлечения ключей из элементов в словаре.  
  
 Этот метод вызывается внутренним образом. Необязательно для него должен быть общедоступным.  
  
   
  
## Examples  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить элемент <paramref name="item" />.</param>
        <param name="item">Вставляемый объект.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `index` равен <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` добавляется в конец <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> вызывается <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> методы.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> методы, унаследованные от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода для вставки элемента в базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод, чтобы обеспечить пользовательское поведение для добавления или вставка объектов в коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
-или- 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется получить.</param>
        <summary>Получает элемент с указанным ключом.</summary>
        <value>Элемент с указанным ключом. Если элемент с указанным ключом не найден, выдается исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет возможность доступа к определенному элементу в коллекции, используя следующий синтаксис: `myCollection[key]` (`myCollection(key)` в Visual Basic).  
  
> [!NOTE]
>  Это свойство отличается от наследуемого <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство, которое получает и задает элементы по числовому индексу. Тем не менее если `TKey` имеет тип <xref:System.Int32>, это свойство маскирует унаследованное свойство. В этом случае можно получить доступ к унаследованное свойство путем приведения <xref:System.Collections.ObjectModel.KeyedCollection%602> со своим базовым типом. Например `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` в Visual Basic, `KeyedCollection<int, MyType^>` в C++) может быть приведен к `Collection<MyType>` (`Collection(Of MyType)` в Visual Basic, `Collection<MyType^>` в C++).  
  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска `key` используется для извлечения элемента из словаря.  Если отсутствует словарь поиска, ключ каждого элемента, извлеченное с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод и сравнивается с указанным ключом.  
  
 В языке C# ключевое слово используется для определения индексаторов вместо реализации <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> свойство. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>, предоставляющее те же возможности индексирования.  
  
 Получение значения этого свойства является операцией o(1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска; в противном случае он является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 Пример кода вызывает и <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения и получает по ключу, и <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство, которое можно задать и извлекает по индексу. Показано, как получить доступ к последнему свойству, если для объектов в производная коллекция целочисленных ключей, не отличается от целых чисел, используемый для получения элементов по индексу.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Элемент с указанным ключом отсутствует в коллекции.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется удалить.</param>
        <summary>Удаляет элемент с указанным ключом из <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>Значение <see langword="true" />, если элемент успешно удален; в противном случае — значение <see langword="false" />.  Этот метод также возвращает <see langword="false" />, если элемент <paramref name="key" /> не найден в коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента, также удаляется из словаря поиска.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использовать словарь поиска, несмотря на то, что количество элементов снова станет ниже порогового значения.  
  
> [!NOTE]
>  Для настройки поведения этого метода Переопределите <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> метод.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Данный пример кода показан минимальный код, необходимо создать производный класс коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> с указанием открытый конструктор, который выполняет делегирование конструктор базового класса. В примере также показано многие свойства и методы, наследуемые от <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 В примере демонстрируется <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> метод наследуется от <xref:System.Collections.ObjectModel.KeyedCollection%602>, который удаляет элемент с указанным ключом, а также <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> методами, унаследованными от <xref:System.Collections.ObjectModel.Collection%601>, удаляющие объектом и индексу соответственно.  
  
 `SimpleOrder` Класс является очень простой заявки список, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который должен быть удален.</param>
        <summary>Удаляет элемент по указанному индексу из коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента, также удаляется из словаря поиска.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использовать словарь поиска, несмотря на то, что количество элементов снова станет ниже порогового значения.  
  
 Этот метод является операцией O (`n`) операции, где `n` является <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> методы, унаследованные от <xref:System.Collections.ObjectModel.Collection%601> универсальный класс и <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> метод.  
  
 Вызовите реализацию базового класса этого метода для удаления элемента из базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> метод, чтобы обеспечить пользовательское поведение для удаления объектов из коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) заменяемого элемента.</param>
        <param name="item">Новый элемент.</param>
        <summary>Заменяет элемент по заданному индексу указанным элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словарь поиска обновляется соответствующим образом. То есть ключ элемента, который требуется заменить удаляется из словаря поиска и добавлении ключа нового элемента.  
  
 Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение параметра <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство унаследовано от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
> [!NOTE]
>  Этот метод не влияет на поведение <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения.  
  
 Вызовите реализацию базового класса этого метода, чтобы задать элемент в базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> метод, чтобы обеспечить пользовательское поведение для параметра <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методов, а также для параметр по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (индексатор в C#). Пользовательское поведение в этом примере является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и является упрощенной формой. Форма заказа `OrderItem` объектов, представляющих элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление, чтобы определить тип изменения.  
  
 В примере кода показано настраиваемое поведение путем вызова свойства и методы производного класса, в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, использующего изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как в Переопределите защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> поддерживают изменяемые ключи, а также как в Переопределите защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа в свойстве установщик свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. Если Да, создается исключение, и значение свойства не изменяется.  
  
 Для поддержания связи между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Это поле поддерживается защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Поле устанавливается в том случае, когда элемент добавляется в коллекцию и очищается, когда элемент удаляется.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>