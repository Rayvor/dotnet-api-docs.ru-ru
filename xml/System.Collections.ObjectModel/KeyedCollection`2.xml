<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c89d98e367a7205fcd37ba9360776f3ba0c420eb" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/06/2019" /><Meta Name="ms.locfileid" Value="74154493" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
    <typeparam name="TItem">Тип элементов в коллекции.</typeparam>
    <summary>Предоставляет абстрактный базовый класс для коллекции, ключи которой внедрены в значения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Collections.ObjectModel.KeyedCollection%602> предоставляет как O (1) индексированное извлечение, так и получение по ключу, которые подходет к O (1). Это абстрактный тип, или точнее неограниченный набор абстрактных типов, поскольку каждый из сконструированных универсальных типов является абстрактным базовым классом. Чтобы использовать <xref:System.Collections.ObjectModel.KeyedCollection%602>, необходимо получить тип коллекции из соответствующего сконструированного типа.  
  
 Класс <xref:System.Collections.ObjectModel.KeyedCollection%602> является гибридным между коллекцией на основе <xref:System.Collections.Generic.IList%601> универсального интерфейса и коллекции, основанной на <xref:System.Collections.Generic.IDictionary%602> универсальном интерфейсе. Как и коллекции, основанные на <xref:System.Collections.Generic.IList%601> универсальном интерфейсе, <xref:System.Collections.ObjectModel.KeyedCollection%602> является индексированным списком элементов. Как и коллекции, основанные на <xref:System.Collections.Generic.IDictionary%602> универсальном интерфейсе, <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет ключ, связанный с каждым элементом.  
  
 В отличие от словарей элемент <xref:System.Collections.ObjectModel.KeyedCollection%602> не является парой «ключ-значение». Вместо этого весь элемент — это значение, а ключ внедряется в значение.  Например, элемент коллекции, производный от `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` в Visual Basic), может иметь значение «Джон Петров Jr». где значение равно «Джон Петров Jr». а ключ — «Петров»; или коллекция записей сотрудников, содержащих целочисленные ключи, может быть получена из `KeyedCollection\<int,Employee>`. Абстрактный <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод извлекает ключ из элемента.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который можно получить с помощью свойства <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A>.  При добавлении элемента в <xref:System.Collections.ObjectModel.KeyedCollection%602>ключ элемента извлекается один раз и сохраняется в словаре поиска для ускорения поиска. Это поведение переопределяется путем указания порогового значения создания словаря при создании <xref:System.Collections.ObjectModel.KeyedCollection%602>. Словарь уточняющего запроса создается при первом превышении этого порога числом элементов.  Если задать для порога значение-1, словарь поиска никогда не будет создан.  
  
> [!NOTE]
>  При использовании внутреннего словаря поиска он содержит ссылки на все элементы в коллекции, если `TItem` является ссылочным типом, или копирует все элементы в коллекции, если `TItem` является типом значения. Таким образом, использование словаря поиска может быть неуместным, если `TItem` является типом значения.  
  
 Доступ к элементу по его индексу или ключу можно получить с помощью свойства <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>. Можно добавлять элементы без ключа, но впоследствии доступ к этим элементам можно получить только по индексу.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показан минимальный код, необходимый для наследования от <xref:System.Collections.ObjectModel.KeyedCollection%602>, и демонстрируется множество унаследованных методов. Во втором примере показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602>, чтобы обеспечить пользовательское поведение.  
  
 **Пример 1**  
  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется компаратор по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602>, созданная с помощью этого конструктора, использует универсальный компаратор по умолчанию для типа ключа, полученного из <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Чтобы указать другую универсальную функцию сравнения на равенство, используйте конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> или конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29>.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента в <xref:System.Collections.ObjectModel.KeyedCollection%602>ключ элемента извлекается один раз и сохраняется в словаре поиска для ускорения поиска. Это поведение можно переопределить с помощью конструктора <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> и указать пороговое значение создания словаря.  
  
> [!NOTE]
>  Поскольку класс <xref:System.Collections.ObjectModel.KeyedCollection%602> является абстрактным (`MustInherit` в Visual Basic), для его использования необходимо наследовать от него. В конструкторе для производного типа вызовите соответствующий конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602>. Нет необходимости предоставлять такие функциональные возможности, как компаратор проверки на равенство или пороговое значение создания словаря в конструкторах.  
  
 Этот конструктор является операцией O (1).  
  
   
  
## Examples  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется заданный компаратор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента в <xref:System.Collections.ObjectModel.KeyedCollection%602>ключ элемента извлекается один раз и сохраняется в словаре поиска для ускорения поиска. Это поведение можно переопределить с помощью конструктора <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> и указать пороговое значение создания словаря.  
  
> [!NOTE]
>  Поскольку класс <xref:System.Collections.ObjectModel.KeyedCollection%602> является абстрактным (`MustInherit` в Visual Basic), для его использования необходимо наследовать от него. В конструкторе для производного типа вызовите соответствующий конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602>. Нет необходимости предоставлять такие функциональные возможности, как компаратор проверки на равенство или пороговое значение создания словаря в конструкторах.  
  
 Этот конструктор является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Количество элементов, которое может содержать коллекция без создания словаря поиска (при значении 0 словарь поиска создается при добавлении первого элемента), или –1, чтобы словарь поиска не создавался никогда.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, который использует заданный компаратор и создает словарь поиска при превышении заданного порога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента в <xref:System.Collections.ObjectModel.KeyedCollection%602>ключ элемента извлекается один раз и сохраняется в словаре поиска для ускорения поиска. Этот конструктор позволяет переопределить это поведение. Укажите 0, чтобы создать словарь при добавлении первого элемента, 1 для создания словаря при добавлении второго элемента и т. д. Если задать для порога значение-1, словарь поиска никогда не будет создан.  
  
 Для очень мелких коллекций улучшение скорости получения, обеспечиваемой словарем поиска, может не быть полезно для дополнительного объема памяти, требуемого для словаря. Установка порогового значения позволяет решить, когда следует использовать этот компромисс.  
  
> [!NOTE]
>  Поскольку класс <xref:System.Collections.ObjectModel.KeyedCollection%602> является абстрактным (`MustInherit` в Visual Basic), для его использования необходимо наследовать от него. В конструкторе для производного типа вызовите соответствующий конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602>. Нет необходимости предоставлять такие функциональные возможности, как компаратор проверки на равенство или пороговое значение создания словаря в конструкторах.  
  
 Этот конструктор является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода используется конструктор <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> с пороговым значением 0, чтобы внутренний словарь создавался при первом добавлении объекта в коллекцию.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="dictionaryCreationThreshold" /> меньше -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, ключ которого требуется изменить.</param>
        <param name="newKey">Новый ключ для <paramref name="item" />.</param>
        <summary>Изменяет ключ, связанный с указанным элементом в словаре поиска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не изменяет ключ, внедренный в `item`; Он просто заменяет ключ, сохраненный в словаре поиска.  Таким образом, если `newKey` отличается от ключа, внедренного в `item`, получить доступ к `item` с помощью ключа, возвращаемого <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>, невозможно.  
  
 Этот метод не выполняет никаких действий, если <xref:System.Collections.ObjectModel.KeyedCollection%602> не имеет словаря поиска.  
  
 Каждый ключ в <xref:System.Collections.ObjectModel.KeyedCollection%602> должен быть уникальным. Ключ не может быть `null`.  
  
 Этот метод является операцией O (1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Перед изменением ключа, внедренного в элемент, необходимо вызвать этот метод, чтобы обновить ключ в словаре поиска. Если пороговое значение создания словаря равно-1, вызов этого метода не требуется.  
  
 Не предоставляйте метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> как открытый метод производного класса. Неправильное использование этого метода приводит к несинхронизированному словарю поиска с ключами элементов. Например, если задать для ключа `null`, а затем задать для него другое значение, добавляет несколько ключей для элемента в словарь поиска. Сделать этот метод внутренним, чтобы разрешить использование изменяемых ключей элементов: при изменении ключа элемента этот метод используется для изменения ключа в словаре поиска.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="item" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> не найден.  
  
- или - 
 Указанный параметр <paramref name="key" /> уже существует в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При наличии словаря поиска этот метод очищает его, но не удаляет его.  
  
 Если число элементов превысило пороговое значение создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> использует словарь поиска, он будет по-прежнему использовать словарь поиска, даже если число элементов еще не превышает пороговое значение.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы обеспечить настраиваемое поведение для метода <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, унаследованного от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода, чтобы очистить базовую коллекцию и очистить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующих переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> для предоставления пользовательского поведения для удаления всех объектов из коллекции. В первом примере добавляется пользовательское событие уведомления, а во втором — поддержка коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает универсальный компаратор, используемый для определения равенства ключей в коллекции.</summary>
        <value>Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, используемого для определения равенства ключей в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Определяет, содержится ли в коллекции элемент с указанным ключом.</summary>
        <returns><see langword="true" />, если <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> содержит элемент с указанным ключом, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска, для поиска по словарю используется `key`. Если словарь поиска отсутствует, ключ каждого элемента извлекается с помощью метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и сравнивается с указанным ключом.  
  
 Этот метод является операцией O (1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска; в противном случае это операция O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает словарь поиска <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Словарь поиска коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, если он существует; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента в <xref:System.Collections.ObjectModel.KeyedCollection%602>ключ элемента извлекается один раз и сохраняется в словаре поиска для ускорения поиска. Это поведение можно переопределить с помощью конструктора <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> и указать пороговое значение создания словаря.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, из которого нужно извлечь ключ.</param>
        <summary>При реализации в производном классе извлекает ключ из указанного элемента.</summary>
        <returns>Ключ для указанного элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ в словаре поиска отличается от ключа, внедренного в `item`, доступ к `item` с помощью ключа, возвращенного <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>, невозможен.  
  
 Этот метод можно реализовать для возврата `null` коллекции, содержащей элементы без ключей. в этом случае доступ к элементам можно получить только по индексу. Этот метод является операцией O (1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Этот метод необходимо переопределить, чтобы предоставить словарю способ извлечения ключей из элементов в словаре.  
  
 Этот метод вызывается внутренним образом. Он не обязательно должен быть общедоступным.  
  
   
  
## Examples  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить элемент <paramref name="item" />.</param>
        <param name="item">Вставляемый объект.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `index` равно <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` добавляется в конец <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> вызывается методами <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы обеспечить настраиваемое поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A>, унаследованных от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода, чтобы вставить элемент в базовую коллекцию и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующих переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> для предоставления пользовательского поведения при добавлении или вставке объектов в коллекцию. В первом примере добавляется пользовательское событие уведомления, а во втором — поддержка коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется получить.</param>
        <summary>Получает элемент с указанным ключом.</summary>
        <value>Элемент с указанным ключом. Если элемент с указанным ключом не найден, выдается исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет возможность доступа к определенному элементу в коллекции с помощью следующего синтаксиса: `myCollection[key]` (`myCollection(key)` в Visual Basic).  
  
> [!NOTE]
>  Это свойство отличается от унаследованного свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>, которое получает и задает элементы по числовому индексу. Однако если `TKey` имеет тип <xref:System.Int32>, это свойство маскирует унаследованное свойство. В этом случае можно получить доступ к унаследованному свойству путем приведения <xref:System.Collections.ObjectModel.KeyedCollection%602> к его базовому типу. Например, `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` в Visual Basic, `KeyedCollection<int, MyType^>` в C++) можно привести к `Collection<MyType>` (`Collection(Of MyType)` в Visual Basic, `Collection<MyType^>` в C++).  
  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска, для получения элемента из словаря используется `key`.  Если словарь поиска отсутствует, ключ каждого элемента извлекается с помощью метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и сравнивается с указанным ключом.  
  
 Язык использует ключевое слово this для определения индексаторов вместо реализации свойства <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>. [](~/docs/csharp/language-reference/keywords/this.md) C# Visual Basic реализует <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> как [свойство по умолчанию](~/docs/visual-basic/language-reference/modifiers/default.md), которое предоставляет те же функции индексирования.  
  
 Получение значения этого свойства является операцией O (1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска. в противном случае это операция O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.

## Examples  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 В примере кода вызывается свойство <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>, которое доступно только для чтения и извлекается по ключу, и свойство <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>, которое устанавливается и извлекается по индексу. В нем показано, как получить доступ к последнему свойству, если объекты в производной коллекции имеют целочисленные ключи, отличающиеся от целых чисел, используемых для индексированного извлечения.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Элемент с указанным ключом отсутствует в коллекции.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется удалить.</param>
        <summary>Удаляет элемент с указанным ключом из объекта <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>Значение <see langword="true" />, если элемент успешно удален; в противном случае — значение <see langword="false" />.  Этот метод также возвращает <see langword="false" />, если элемент <paramref name="key" /> не найден в коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента также удаляется из словаря поиска.  
  
 Если число элементов превысило пороговое значение создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> использует словарь поиска, он будет по-прежнему использовать словарь поиска, даже если число элементов еще не превышает пороговое значение.  
  
> [!NOTE]
>  Чтобы настроить поведение этого метода, переопределите метод <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 В этом примере кода показан минимальный код, необходимый для получения класса коллекции из <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> и предоставление открытого конструктора, который делегирует конструктору базового класса. В примере кода также демонстрируется множество свойств и методов, унаследованных от классов <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601>.  
  
 В примере демонстрируется <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> метод, унаследованный от <xref:System.Collections.ObjectModel.KeyedCollection%602>, который удаляет элемент с указанным ключом, а также методы <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A>, унаследованные от <xref:System.Collections.ObjectModel.Collection%601>, которые удаляются по объектам и по индексу соответственно.  
  
 Класс `SimpleOrder` — это очень простой список заявок, содержащий объекты `OrderItem`, каждый из которых представляет элемент строки в заказе. Ключ `OrderItem` является неизменяемым, важно помнить о классах, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который должен быть удален.</param>
        <summary>Удаляет элемент по указанному индексу из коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента также удаляется из словаря поиска.  
  
 Если число элементов превысило пороговое значение создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> использует словарь поиска, он будет по-прежнему использовать словарь поиска, даже если число элементов еще не превышает пороговое значение.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы обеспечить настраиваемое поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29>, унаследованных от <xref:System.Collections.ObjectModel.Collection%601> универсального класса и метода <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29>.  
  
 Вызовите реализацию базового класса этого метода, чтобы удалить элемент из базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующих переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> для предоставления пользовательского поведения при удалении объектов из коллекции. В первом примере добавляется пользовательское событие уведомления, а во втором — поддержка коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) заменяемого элемента.</param>
        <param name="item">Новый элемент.</param>
        <summary>Заменяет элемент по заданному индексу указанным элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словарь уточняющих запросов обновляется соответствующим образом. То есть ключ заменяемого элемента удаляется из словаря поиска и добавляется ключ нового элемента.  
  
 Этот метод является операцией O (1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы обеспечить настраиваемое поведение для установки свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A>, унаследованного от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
> [!NOTE]
>  Этот метод не влияет на поведение свойства <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType>, которое доступно только для чтения.  
  
 Вызовите реализацию базового класса этого метода, чтобы задать элемент в базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующих переопределение метода <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для предоставления настраиваемого поведения для установки свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType>. В первом примере добавляется пользовательское событие уведомления, а во втором — поддержка коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A>, чтобы обеспечить пользовательское поведение для методов <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A>, а также для задания свойства <xref:System.Collections.ObjectModel.Collection%601.Item%2A> по умолчанию (индексатор в C#). Пользовательское поведение, представленное в этом примере, представляет собой событие уведомления с именем `Changed`, которое создается в конце каждого переопределенного метода.  
  
 В примере кода создается класс `SimpleOrder`, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет собой простую форму заказа. Форма заказа содержит `OrderItem` объекты, представляющие заказанные элементы. В примере кода также создается класс `SimpleOrderChangedEventArgs`, в котором содержатся сведения о событии, и перечисление для обнаружения типа изменения.  
  
 В примере кода демонстрируется пользовательское поведение путем вызова свойств и методов производного класса в методе `Main` класса `Demo`.  
  
 В этом примере кода используются объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи, см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный метод <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> для поддержки изменяемых ключей и как переопределить защищенные методы <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> для поддержания целостности ключей и коллекции.  
  
 В примере кода создается коллекция `MutableKeys`, которая является производной от <xref:System.Collections.ObjectModel.KeyedCollection%602>и класса `MutableKey`. Класс `MutableKey` имеет настраиваемое свойство `Key`. Когда свойству присваивается новый ключ, метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` коллекции, чтобы проверить, конфликтует ли новый ключ с существующим ключом. Если это так, создается исключение и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между объектом `MutableKey` и коллекцией `MutableKeys` и предотвратить вставку объекта в две коллекции, класс `MutableKey` содержит `internal` (`Friend` в Visual Basic) `Collection`. Это поле поддерживается защищенными методами, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, например метода <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>. Это поле задается, когда элемент добавляется в коллекцию и удаляется при удалении элемента.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key * 'Item -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента для поиска в коллекции.</param>
        <param name="item">Когда этот метод возвращает значение <see langword="true" />, содержит элемент из коллекции, соответствующий указанному ключу; когда этот метод возвращает значение <see langword="false" />, содержит значение <see langword="default" /> для типа коллекции.</param>
        <summary>Пытается получить элемент из коллекции, используя указанный ключ.</summary>
        <returns>Значение <see langword="true" />, если элемент для заданного ключа был найден в коллекции; в противном случае значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
