<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eca9de4ba3e7db5769488f672b1fa19608582f9b" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014795" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет системный идентификатор типа XAML для членов типов XAML. Идентификатор используется средствами чтения XAML и записи XAML во время обработки узлов членов (когда средство чтения XAML находится на <see cref="F:System.Xaml.XamlNodeType.StartMember" />) а также для общей логики системы типов XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> можно использовать три методологии для возврата сведений о члене XAML: стандартные общие отражения среды CLR (CLR); флаги для API-интерфейсы, использовать оптимизированные для бита ссылки — только для отражения способ вызова внутреннего; или переопределениям виртуального вызова `Lookup*` API, предоставляемые возможности <xref:System.Xaml.XamlMember> подклассы. Для большинства задач API-интерфейсов служб XAML .NET Framework и <xref:System.Xaml.XamlMember> API, используйте контекст схемы XAML по умолчанию. Контекст схемы XAML по умолчанию для служб XAML .NET Framework использует для системы типов среды CLR. Это позволяет XAML модули чтения и записи XAML для работы с любой тип или член, который определен в, или в противном случае для, среда CLR и его методами отражения.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>API-интерфейсы поиска * и XamlMember производные классы  
 <xref:System.Xaml.XamlMember> определяет несколько виртуальных членов, которые производные классы могут переопределить. Эти члены имеют имена, которые всегда начинаются со строки `Lookup`. В оставшейся части API имя затем ссылки на свойство, которое влияет виртуальный метод. Например <xref:System.Xaml.XamlMember> производный класс может переопределить <xref:System.Xaml.XamlMember.LookupTargetType%2A> влияет на какие свойства определяемых базы <xref:System.Xaml.XamlMember.TargetType%2A> возвращает в производном классе. Можно предсказать возвращаемые значения таких свойств в <xref:System.Xaml.XamlMember> или существующих производных классов см. в документации по соответствующему `Lookup*` методы.  
  
 Цель `Lookup*` методы — предоставить метод расширения XAML тип системы, включающий <xref:System.Xaml.XamlMember> базового класса. Путем наследования от <xref:System.Xaml.XamlMember> и переопределение `Lookup` виртуальные члены можно определить концепцию члена XAML для схемы XAML в системе типов XAML без привязки к особенностям системой резервных типов или технологии. Можно также использовать предоставленный контекст схемы XAML в этой схеме и по-прежнему возвращать нужные результаты.  
  
 Например, рассмотрим <xref:System.Xaml.XamlMember> свойство <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Это свойство информирует вызывающие объекты этой операции, такие как с помощью <xref:System.Xaml.XamlWriter> для сериализации можно записать значение для этого элемента в целевом объекте. В реализации по умолчанию выполняется определение, является ли элемент для записи, используя методы отражения для резервный CLR <xref:System.Type> и его членах ( <xref:System.Reflection.MemberInfo>). Таким образом по умолчанию система типов XAML зависит от системы типов среды CLR. Тем не менее, можно удалить эту зависимость для XAML тип системы создания отчетов из <xref:System.Xaml.XamlMember.IsWritePublic%2A> путем переопределения API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. В рамках переопределения, можно использовать другие определения, например метаданные, относящиеся к технологии, главная таблица подстановки, оптимизированный для основного словаря XAML или ряд других стратегий для определения ли член XAML доступен для записи в вашей Словарь XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Создав XamlMember без контекста схемы XAML  
 Большинство конструкторов <xref:System.Xaml.XamlMember> требуют <xref:System.Xaml.XamlSchemaContext> как часть их инициализации. <xref:System.Xaml.XamlSchemaContext> Также необходим для многих внутренних <xref:System.Xaml.XamlSchemaContext> операций, таких как получение сведения, которые пересылаются из резервного типа. При работе с <xref:System.Xaml.XamlMember> API, как правило, достаточно <xref:System.Xaml.XamlSchemaContext> , такие как доступные из окружающей конструкции <xref:System.Xaml.XamlWriter>. В этом случае вы можете передать <xref:System.Xaml.XamlSchemaContext> ссылаются через на любые вызовы системы типов XAML, которые требуется контекст схемы XAML.  
  
 Один определенный конструктор <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, не требует <xref:System.Xaml.XamlSchemaContext>. Тем не менее <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, такой элемент не удается записать в граф объекта. С помощью реализации служб XAML .NET Framework, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> , имеет значение `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение. Например один или несколько из следующих может быть верно для реализации:  
  
-   Контекст схемы XAML доступен в более поздней версии.  
  
-   Можно использовать шаблон вызова члена.  
  
-   Вы намеренно переопределить <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательский модуль записи XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Общее представление о понятиях и структурах потока узлов XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Системы типов среды CLR <see cref="T:System.Reflection.EventInfo" /> , представляющий член события.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса системы типов среды CLR <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет событие (свойство точки подключения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Системы типов среды CLR <see cref="T:System.Reflection.PropertyInfo" /> , представляющий член свойства.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса системы типов среды CLR <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется в том случае, если член представляет свойство (и специально не является соединением обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Системы типов среды CLR <see cref="T:System.Reflection.EventInfo" /> , представляющий член события.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Реализация, которая обрабатывает отражения среды выполнения вызывает от <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса системы типов среды CLR <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" />, в том числе <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> сведения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет событие (или свойство точки подключения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Системы типов среды CLR <see cref="T:System.Reflection.PropertyInfo" /> , представляющий член свойства.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Реализация, которая обрабатывает вызов среды выполнения вызывает от <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса с помощью отражения <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" />, в том числе <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> сведения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется только в том случае, если элемент представляет свойство, и если он не является соединением обработчика событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> обработчика <see langword="Add" /> метод присоединяемого члена в резервном реализации.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса для <see cref="T:System.Xaml.XamlMember" /> , представляющего присоединяемое событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Строковое имя члена.</param>
        <param name="declaringType"><see cref="T:System.Xaml.XamlType" /> Сведения для объявляющего типа.</param>
        <param name="isAttachable"><see langword="true" /> Чтобы указать, что член может быть присоединен; в противном случае <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса, используя строковое имя и объявление <see cref="T:System.Xaml.XamlType" /> сведения. Объект <see cref="T:System.Xaml.XamlMember" />, созданный с данной сигнатурой, имеет значительные ограничения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, такой элемент не удается записать в граф объекта. С помощью реализации служб XAML .NET Framework, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> с <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение. Например один или несколько из следующих может быть верно для реализации:  
  
-   Контекст схемы XAML доступен в более поздней версии.  
  
-   Можно использовать шаблон вызова члена.  
  
-   Вы намеренно переопределить <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательский модуль записи XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> или <paramref name="declaringType" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> для <see langword="get" /> доступа присоединяемого члена в резервном реализации.</param>
        <param name="setter">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> для <see langword="set" /> доступа присоединяемого члена в резервном реализации.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса для <see cref="T:System.Xaml.XamlMember" /> , представляющего присоединяемое свойство.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет присоединяемое свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> обработчика <see langword="Add" /> метод присоединяемого члена в резервном реализации.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Реализация, которая обрабатывает вызов среды выполнения вызывает от <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса для <see cref="T:System.Xaml.XamlMember" /> , представляющего присоединяемое событие, включая <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> сведения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> для <see langword="get" /> доступа присоединяемого члена в резервном реализации.</param>
        <param name="setter">Системы типов среды CLR <see cref="T:System.Reflection.MethodInfo" /> для <see langword="set" /> доступа присоединяемого члена в резервном реализации.</param>
        <param name="schemaContext"><see cref="T:System.Xaml.XamlSchemaContext" /> Контекста, определяющий член.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Реализация, которая обрабатывает вызов среды выполнения вызывает от <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> класса для <see cref="T:System.Xaml.XamlMember" /> , представляющего присоединяемое свойство, включая <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> сведения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор используется, если элемент представляет элемент вложенного свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.XamlType" /> для типа, который объявляет член, связанный с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Для типа, который объявляет член, связанный с данным <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение обычно устанавливается во время инициализации и обычно не `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> данные могут передаваться в конструкторами для инициализации. Обращаясь напрямую базовые конструкторы, инициализации для <xref:System.Xaml.XamlMember> производных классов может пропускать некоторые проверки значения, которые вносятся в базовом классе. Таким образом производная инициализация можно изменить сведения о связях сообщаемые члена типа элемента XAML, таким образом, чтобы он больше не соответствуют ожидаемым образом информации о системе типов из его базового объявления CLR. Для объявления информации о типах проверок с точки зрения безопасности используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> объектов, объявленных объект, который используется для отложенной загрузки XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Xaml.XamlDeferringLoader" /> ограничения для универсального.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.DeferringLoader%2A> вызывает <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> или конкретного переопределения этого метода. Это происходит в случаях, где логика начального внутреннего отражения не уже настроен.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список объектов <see cref="T:System.Xaml.XamlMember" />. Они сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Список объектов <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.DependsOn%2A> вызывает <xref:System.Xaml.XamlMember.LookupDependsOn%2A> или конкретного переопределения этого метода. Это происходит в случаях, где логика начального внутреннего отражения не уже настроен.  
  
 `DependsOn` Модель может применяться к вариантам модели объекта, которые намеренно противоречат правило XAML. Общее правило XAML — это члены типа, которые передаются как текст инициализации (или методом фабрики в XAML 2009) должен уметь назначаться в любом порядке. Применяя `DependsOn` узор на член, можно указать модули записи XAML всегда обработать указанный член перед этим членом. Можно применить этот шаблон в ситуациях, где значение текущего элемента требует контекста или другие сведения, которые доступны только после установки другого элемента.  
  
 `DependsOn` Шаблон должен применен внимательно и зарезервирован для сценариев свойств, где он служит архитектурной цели. Большое количество зависимостей могут замедлить обработку XAML. Кроме того имеется возможность создать циклические зависимости, в этом случае поведение обработки XAML не определено.  
  
 Пример `DependsOn` сценарии из WPF включают некоторые свойства на <xref:System.Windows.Controls.ControlTemplate> и <xref:System.Windows.DataTemplate>на <xref:System.Windows.Trigger>, а затем на <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, равен ли текущий объект другому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, сравниваемый с данным объектом.</param>
        <summary>Указывает, равен ли текущий объект другому объекту.</summary>
        <returns><see langword="true" />, если текущий объект эквивалентен параметру <paramref name="obj" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Указывает, эквивалентен ли текущий объект другому объекту того же типа.</summary>
        <returns><see langword="true" />, если текущий объект эквивалентен параметру <paramref name="other" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этого объекта.</summary>
        <returns>Целочисленный хэш-код.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список пространств имен XAML, в которых может существовать этот член XAML.</summary>
        <returns>Список идентификаторов пространства имен XAML в виде строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> результат из вызова <xref:System.Xaml.XamlMember.DeclaringType%2A> , связанного с данным <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> реализации, который связан с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Реализации, который связан с данным <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Шаблон — это сложная и расширение системы типов XAML. `Invoker` Шаблон предоставляет способ вставки поведение сопоставления типов другую схему, при этом используя определения системы типов XAML из служб XAML .NET Framework.  
  
 Если <xref:System.Xaml.XamlMember.LookupInvoker%2A> переопределить возвращает `null`, или реализация по умолчанию возвращает `null` так, как у него нет <xref:System.Xaml.XamlMember.UnderlyingMember%2A> для данного <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlMember.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 Значение по умолчанию — <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>. Это верно для большинства операций, которые используют служб XAML .NET Framework и контекст схемы XAML по умолчанию, и где переопределить конкретные `Invoker` шаблоны передаются для создания сущностей системы типов XAML.  
  
 Вызов <xref:System.Xaml.XamlMember.Invoker%2A> вызывает <xref:System.Xaml.XamlMember.LookupInvoker%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> сообщается как внешнее свойство.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> выводятся как внешнее свойство; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsAmbient%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> или конкретного переопределения этого метода. Это происходит в реализациях, где логика начального внутреннего отражения не уже настроен.  
  
 Проверка внешних свойств обычно являются частью логики обработки XAML, чтобы убедиться в том, что объекты и значения, которые зависят от использования окружения для уточнения типа может работать неправильно. API-интерфейсы служб XAML .NET Framework и контекст схемы XAML по умолчанию заполняет значение в зависимости от однозначного соответствия примитивов с <xref:System.Windows.Markup.AmbientAttribute>. Реализация по умолчанию <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> использует этот существующие <xref:System.Windows.Markup.AmbientAttribute> прием и она вернет `true` Если <xref:System.Windows.Markup.AmbientAttribute> существует в объявлении члена.  
  
 <xref:System.Windows.Markup.AmbientAttribute> имеет место на элементы из нескольких типов WPF, в том числе <xref:System.Windows.Application>, <xref:System.Windows.Setter>, и <xref:System.Windows.Style>. Также его обнаружении на <xref:System.Windows.ResourceDictionary> тип, который описывающая, что на любой член, который использует <xref:System.Windows.ResourceDictionary> как его тип должен считаться окружающим даже, если элемент не помечается с помощью специально.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> является присоединяемым членом.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> является присоединяемым членом; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAttachable%2A> Значение инициализируется в зависимости от того, какой конструктор использовался для создания <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> является директивой XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> является XAML; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsDirective%2A> Значение инициализируется в зависимости от того, какой конструктор использовался для создания <xref:System.Xaml.XamlMember>. Базовый <xref:System.Xaml.XamlMember> конструкторы выполняют инициализацию, чтобы <xref:System.Xaml.XamlMember.IsDirective%2A> является `false`. Тем не менее <xref:System.Xaml.XamlDirective> класс ( <xref:System.Xaml.XamlMember> производного класса) инициализирует таким образом, чтобы <xref:System.Xaml.XamlMember.IsDirective%2A> является `true`.  
  
 Если необходимо получить отчет <xref:System.Xaml.XamlMember.IsDirective%2A> как `true` вызывающим объектам пользовательского класса схемы XAML для элементов XAML, убедитесь, что вы наследуете от <xref:System.Xaml.XamlDirective> потому что это единственный способ включить это поведение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> представляет член события.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsEvent%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsEvent%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее ли это <see cref="T:System.Xaml.XamlMember" /> инициализируется с действующей <see langword="xamlName" /> строку в качестве его <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> инициализируется с действующей <see langword="xamlName" /> строка; в противном случае <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsReadOnly%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> представляет член с доступным для вызова открытым <see langword="get" /> метода доступа.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет доступным для вызова открытым <see langword="get" /> метод доступа; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> Ли значение проверки <xref:System.Xaml.XamlMember.DeclaringType%2A> является открытым. Если <xref:System.Xaml.XamlMember.DeclaringType%2A> является закрытым, `get` метод доступа не может вызываться удобный, и <xref:System.Xaml.XamlMember.IsReadPublic%2A> возвращает `false`.  
  
 Вызов <xref:System.Xaml.XamlMember.IsReadPublic%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> или конкретного переопределения этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли элемент не неразрешимым в базовой системе, используется для разрешения типов и членов.</summary>
        <value><see langword="true" /> Если элемент не может быть разрешена; <see langword="false" /> Если разрешить член.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный с <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> сигнатура возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlMember> с `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> не может быть записан в граф объекта. В реализации по умолчанию в API служб XAML .NET Framework <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не следует создавать <xref:System.Xaml.XamlMember> , имеет значение `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A> Если ваша реализация может обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение.  
  
 Вызов <xref:System.Xaml.XamlMember.IsUnknown%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.IsWriteOnly%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий доступным для вызова открытым <see langword="set" /> метода доступа.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет доступным для вызова открытым <see langword="set" /> метод доступа; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> Считает, что значение ли <xref:System.Xaml.XamlMember.DeclaringType%2A> является общим как часть определения. Если <xref:System.Xaml.XamlMember.DeclaringType%2A> является закрытым, `set` метод доступа не может вызываться удобный, и <xref:System.Xaml.XamlMember.IsWritePublic%2A> возвращает `false`.  
  
 Вызов <xref:System.Xaml.XamlMember.IsWritePublic%2A> вызывает <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> или конкретного переопределения этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе возвращает <see cref="T:System.Reflection.ICustomAttributeProvider" /> реализации.</summary>
        <returns>Реализация <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите этот метод для предоставления внутреннее отражение альтернативный способ получения значений атрибутов CLR. В отсутствие переопределения, внутренний объект, отражающий использует типичные логику отражения среды CLR, такие как вызовы <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Реализация по умолчанию возвращает значение `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> объектов, объявленных объект, который используется для отложенной загрузки XAML.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Xaml.XamlDeferringLoader" /> ограничения для универсального.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.DeferringLoader%2A> свойство. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.DeferringLoader%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализация по умолчанию возвращает объект, либо путем чтения <xref:System.Windows.Markup.XamlDeferLoadAttribute> или с помощью <xref:System.Xaml.XamlDeferringLoader> от объявляющего типа. Если ни один из объектов доступна, этот метод может возвращать `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список <see cref="T:System.Xaml.XamlMember" /> объектов. Элементы списка сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Список объектов <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.DependsOn%2A> свойство. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.DependsOn%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализации WPF XAML чтения и записи атрибута этот случай с <xref:System.Windows.Markup.DependsOnAttribute>. Реализация по умолчанию использует этот существующий <xref:System.Windows.Markup.DependsOnAttribute> методика.  
  
 Переопределите этот метод, если вы не используете <xref:System.Windows.Markup.DependsOnAttribute> для этой цели и не собираетесь заменить этот прием для указания порядка обработки свойств собственной методикой. Если вы не собираетесь поддерживать порядок обработки свойства, можно использовать реализация по умолчанию, поскольку он не возвращает результатов, который подходит.  
  
 Список доступен только для чтения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> , связанного с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> Сведения для этого <see cref="T:System.Xaml.XamlMember" />; или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается при вызове <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Реализация по умолчанию не требует <xref:System.Xaml.XamlMember> создаваться с помощью одного из конструкторов, которые передают первоначальный <xref:System.Xaml.Schema.XamlMemberInvoker>. Тем не менее <xref:System.Xaml.XamlMember.UnderlyingMember%2A> значение должно существовать для <xref:System.Xaml.XamlMember>; в противном случае реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы наследуете от <xref:System.Xaml.Schema.XamlMemberInvoker> и должны возвращать производного класса. Если возвращается `null`, <xref:System.Xaml.XamlMember.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> вызывающим объектам.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> сообщается как внешнее свойство.</summary>
        <returns><see langword="true" /> необходимо объявить этот <see cref="T:System.Xaml.XamlMember" /> внешним свойством; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутренних вызовов, которые проверяют данные свойства окружения XAML. Поведение внешнее свойство учитывается в поведении открытого API средства чтения XAML и записи XAML. Эти внутренние вызовы, которые ссылаются на <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> обычно являются частью логики обработки XAML, чтобы убедиться в том, что объекты и значения, которые зависят от использования окружения для уточнения типа может работать неправильно. Реализация служб XAML .NET Framework по умолчанию использует CLR с атрибутами для получения этих сведений из отражения резервных типов. В частности, реализация по умолчанию проверяет наличие <xref:System.Windows.Markup.AmbientAttribute> и возвращает `true` для <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Если <xref:System.Windows.Markup.AmbientAttribute> существует для определения члена.  
  
 Переопределите этот метод, если вы не используете <xref:System.Windows.Markup.AmbientAttribute> для этой цели и не собираетесь заменить этот прием для указания внешние свойства XAML с помощью собственного метода.  
  
 Пример API-интерфейсы WPF, атрибут с <xref:System.Windows.Markup.AmbientAttribute> являются <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> и <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет событие.</summary>
        <returns><see langword="true" /> отчет, <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация проверок по умолчанию ли <xref:System.Xaml.XamlMember.UnderlyingMember%2A> имеет тип <xref:System.Reflection.EventInfo>и если это так, возвращает `true`.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsEvent%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданные, можно интерпретировать для определения XAML тип представления систем для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет требуемое свойство только для чтения.</summary>
        <returns><see langword="true" /> необходимо объявить этот <see cref="T:System.Xaml.XamlMember" /> как требуемое свойство, доступное только для чтения; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` Если <xref:System.Xaml.XamlMember.UnderlyingMember%2A> существует, но открытый `set` метод доступа не существует, что определяется внутреннего отражения.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданные, можно интерпретировать для определения XAML тип представления систем для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет свойство, имеющее открытый <see langword="get" /> метода доступа.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет свойство, имеющее открытый <see langword="get" /> метод доступа; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты, либо на основе внутреннего отражения либо отрицание <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, обработку в указанном порядке.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Возвращает, является ли сам элемент открытым; он возвращает `true` для на открытый член nonpublic, объявляющий тип. Используйте <xref:System.Xaml.XamlMember.IsReadPublic%2A> вместо этого, если вы хотите, чтобы учел видимость объявляющего типа.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, не может быть разрешен в базовой системе, которая используется для разрешения типов и членов.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет Неразрешимый член; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsUnknown%2A>. Реализация по умолчанию возвращает результаты, которые находятся в зависимости от любого внутреннего отражения или для проверки `null` значение <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, обработку в указанном порядке.  
  
 Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый <see langword="set" /> метод доступа, но не имеющий открытого <see langword="get" /> метода доступа.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` Если <xref:System.Xaml.XamlMember.UnderlyingMember%2A> существует, имеющий открытый `set` метода доступа и закрытого `get` метод доступа, что определяется внутреннего отражения.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ли это <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый <see langword="set" /> метода доступа.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный для записи; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты на основе внутреннего отражения или отрицанием <xref:System.Xaml.XamlMember.IsReadOnly%2A>, обработку в указанном порядке.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (намеренно или иным способом) данные доступа члена XAML таким образом, чтобы он больше не соответствуют ожидаемым образом доступа к информации о системе типов из его базового объявления CLR. Для проверок с точки зрения безопасности уровни доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <returns>Коллекция, содержащая символы открывающих и закрывающих скобок.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.XamlType" /> типа где <see cref="T:System.Xaml.XamlMember" /> может существовать.</summary>
        <returns>Тип где <see cref="T:System.Xaml.XamlMember" /> может существовать.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию проводится различие между присоединяемого и не присоединяемых членов. Не присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> всегда возвращает <xref:System.Xaml.XamlMember.DeclaringType%2A>. Присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат на основе анализа <xref:System.Xaml.XamlMember.UnderlyingMember%2A> тип параметра метода доступа и интерпретирует, что тип исходя из контекста схемы XAML.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.TargetType%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.XamlType" /> типа, который используется данным членом.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> Типа, который используется данным членом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlMember.Type%2A> возвращать значение, отличное от значения, которое включено по умолчанию внутреннего отражения, и если вы также предоставляете пользовательский <xref:System.Xaml.Schema.XamlMemberInvoker> сведения.  
  
 Реализация по умолчанию использует разных путей кода и концептуальные значения для возвращенного <xref:System.Xaml.XamlType> , основанный на ли это <xref:System.Xaml.XamlMember> представляет свойство, метод или событие.  
  
-   Для свойства, возвращенного <xref:System.Xaml.XamlType> — тип, который задает свойство или возвращаемое свойство.  
  
-   Для события, возвращенного <xref:System.Xaml.XamlType> — это тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> является возвращаемым типом.  
  
 В каждом случае контекст схемы XAML используется для определения типа XAML с базовым системным типом.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию преобразователя типов, связанный с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с экземпляром <see cref="T:System.ComponentModel.TypeConverter" /> ограничение; или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если с атрибутами существует на уровне элементов (<xref:System.ComponentModel.TypeConverterAttribute>), сведения об атрибутах используется для вызова <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> в контексте схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь типов, который связан с типом.  
  
-   Если элемент является событием, возвращается преобразователь типов связанных с событием.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.TypeConverter%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see langword="get" /> метод доступа, который связан с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> Для связанного <see langword="get" /> метод доступа; или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию интерпретирует <xref:System.Xaml.XamlMember.UnderlyingMember%2A> свойство как <xref:System.Reflection.PropertyInfo> и возвращает значение <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (с параметром, имеющим `true`), что означает, что возвращаемый метод может быть закрытым. Это поведение может привести `null` некоторых случаях. включая случаи, когда связанный метод доступа не существует или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> свойства в связанном <xref:System.Xaml.Schema.XamlMemberInvoker>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает системы типов среды CLR <see cref="T:System.Reflection.MemberInfo" /> , связанного с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Системы типов среды CLR <see cref="T:System.Reflection.MemberInfo" /> объект, связанный с данным <see cref="T:System.Xaml.XamlMember" />; или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает базовые сведения о члене, основанное на построение. Если <xref:System.Reflection.MemberInfo> объект создан с сигнатурой, которая не предоставляет достаточно сведений для установки базового элемента, этот метод возвращает `null`.  
  
 Если базовый член был задан во время построения, нет необходимости вызывать этот метод.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see langword="set" /> метод доступа, который связан с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> Для связанного <see langword="set" /> метод доступа; или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию интерпретирует <xref:System.Xaml.XamlMember.UnderlyingMember%2A> как <xref:System.Reflection.PropertyInfo> и возвращает значение <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (с параметром, имеющим `true`), что означает, что возвращаемый метод может быть закрытым. Это может привести `null` для некоторых случаев, включая случаи, когда такой метод доступа отсутствует, или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> в связанном <xref:System.Xaml.Schema.XamlMemberInvoker>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая. Убедитесь, что <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> таким образом, чтобы все они возвращают коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию сериализатора значений, связанный с данным <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с экземпляром <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничение, или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если с атрибутами существует на уровне элементов (<xref:System.Windows.Markup.ValueSerializerAttribute>), сведения об атрибутах используется для вызова <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> в контексте схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь значений, который связан с типом.  
  
-   Если предыдущие условия не применяются, `null` возвращается.  
  
 Этот метод вызывается, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Переопределите этот метод, если вы хотите сообщить о результатах универсальный код для всего <xref:System.Xaml.XamlMember> производного класса, или если специализированные метаданными, доступными определение для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <value>Коллекция, содержащая символы открывающих и закрывающих скобок.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see langword="xamlName" /> , объявляющий это строковое представление имени <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see langword="xamlName" /> , Объявляющий это строковое представление имени <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение всегда имеет значение во время построения. Конструкторы, которые реализуются <xref:System.Xaml.XamlMember> обычно создают исключение, если начальное имя не указано; таким образом, непредвиденным образом это свойство имело `null` или является пустой строкой, при использовании служб XAML .NET Framework по умолчанию в реализации.  
  
 [Грамматика XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) и правилам именования для членов и типов CLR не образуют точного пересечения. Это можно объявить имя элемента, которое является допустимым в среде CLR, но не является допустимым в области имен XAML. По возможности следует избегать такой ситуации.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlMember1" /> совпадает со значением <paramref name="xamlMember2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see langword="true" /> Если значение <paramref name="xamlMember1" /> отличается от значения <paramref name="xamlMember2" />; в противном случае <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает одно пространство имен XAML URI, определяющий первичное пространство имен XAML для данного <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Идентификатор первичного пространства имен XAML для данного <see cref="T:System.Xaml.XamlMember" />, как строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Свойство предоставляет то же значение, что и вызов метода <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> и затем получение первой строки значение из возвращенного списка. Предпочтительный пространства имен XAML можно использовать при написании элемента к текст или другие представления, которые сохраняют сведения о пространстве имен XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> значение, которое указывает, как визуальный конструктор должен обрабатывать этот член.</summary>
        <value>Значение <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> перечисления. Значение по умолчанию — <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.XamlType" /> типа где <see cref="T:System.Xaml.XamlMember" /> может существовать.</summary>
        <value>Тип где <see cref="T:System.Xaml.XamlMember" /> может существовать.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение отличается для присоединяемого и не присоединяемых членов. Не присоединяемых членов <xref:System.Xaml.XamlMember.TargetType%2A> возвращает <xref:System.Xaml.XamlMember.DeclaringType%2A>. Присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат, основанный на эту логику:  
  
-   Если отражение не может разрешить резервирование (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), этот метод возвращает внутреннюю константу, представляющую тип универсального объекта.  
  
-   Если предыдущее условие не применяется, <xref:System.Xaml.XamlMember.LookupTargetType%2A> вызывается. Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> , основанный на изучение методов, реализующих `get` и `set` методы доступа. Класс может переопределить <xref:System.Xaml.XamlMember.LookupTargetType%2A> для использования другого поведения, такие, как другие метаданные форм может сообщить о целевых типов присоединяемых членов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.XamlType" /> типа, который используется данным членом.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Типа, который используется данным членом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.Type%2A> вызывает <xref:System.Xaml.XamlMember.LookupType%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Поведение по умолчанию (не <xref:System.Xaml.XamlMember.LookupType%2A> переопределить), возвращенного <xref:System.Xaml.XamlType> может иметь разные общие значения. Применяемое значение зависит от того это <xref:System.Xaml.XamlMember> представляет свойство, метод или событие, как показано в следующем списке:  
  
-   Для свойства, возвращенного <xref:System.Xaml.XamlType> — тип, который задает свойство или возвращаемое свойство.  
  
-   Для события, возвращенного <xref:System.Xaml.XamlType> — это тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> является тип возвращаемого значения этот метод, который может быть `null`.  
  
 В каждом случае контекст схемы XAML используется для определения типа XAML из резервного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> объект, который может использоваться для создания конструкции преобразователя типов объектов, объявленных XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> значение, с помощью <see cref="T:System.ComponentModel.TypeConverter" /> ограничения для универсального.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.TypeConverter%2A> вызывает <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Реализации, которые возвращают свойство отличное от null значение для <xref:System.Xaml.XamlMember.TypeConverter%2A> не обязательно являются рабочее <xref:System.ComponentModel.TypeConverter>. Ниже приведен список возможных возвращаемых значений от null для <xref:System.Xaml.XamlMember.TypeConverter%2A> и возможных значений:  
  
-   Возвращаемое значение сообщает преобразователь типов, помечается с членом, или более общем смысле конечный тип преобразователя. Такое поведение обычно какие большинство системы типов XAML и искать процессоры XAML для создания экземпляра преобразователя типов и вызова его методов.  
  
-   Возвращаемое значение сообщает преобразователь встроенных значений. Эти преобразователи существовать для некоторых внутренних операций, выполняемых модулем записи XAML. В частности эти встроенные преобразователи значений преобразования строковых значений атрибута строки примитивы языка XAML. Для реализации служб XAML .NET Framework эти встроенные преобразования типа часто пересылают в преобразователь типов, который определен в сборке System. Например, преобразование для <xref:System.Int32> значение встроен перенаправленных преобразования и, следовательно, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> значение ссылки <xref:System.ComponentModel.Int32Converter>.  
  
-   Возвращаемое значение сообщает особого случая неограниченной объектной модели; то есть <xref:System.Xaml.XamlMember> имеет <xref:System.Xaml.XamlMember.Type%2A> значение <xref:System.Object>. В этом случае <xref:System.Xaml.Schema.XamlValueConverter%601> сообщает, что <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> — {`Object}`. Тем не менее <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> является `null` , так как не фактический тип или экземпляр, для выполнения этого преобразования. Вместо этого поведение модели объекта невозможно определить до времени выполнения, когда среда выполнения определенной технологии определяет обработку его графа объектов.  
  
 Если можно получить доступ к рабочей <xref:System.ComponentModel.TypeConverter> из <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, можно вызывать его методы преобразования. Тем не менее многие методы преобразования зависит от контекста службы. Если у вас же контекст службы, доступные ожидает что преобразователь типов для стандартной роли записи объектов для графов объектов, методы преобразователя можно вызывать исключения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает системы типов среды CLR <see cref="T:System.Reflection.MemberInfo" /> доступный для члена, который создается с помощью <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" />, или <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Системы типов среды CLR <see cref="T:System.Reflection.MemberInfo" /> сведения, преобразованные из исходных параметров конструктора. Объект <see cref="T:System.Xaml.XamlMember" /> , созданный с <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> сигнатура возвращает <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.UnderlyingMember%2A> вызывает <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> или конкретного переопределения этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> объект, который используется для сериализации значений объектов, объявленных XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничения для универсального.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Xaml.XamlMember.ValueSerializer%2A> вызывает <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> или конкретного переопределения этого метода. Это происходит, когда логика начального внутреннего отражения не уже настроен.  
  
 Не все варианты, которые возвращают свойство отличное от null значение для <xref:System.Xaml.XamlMember.ValueSerializer%2A> обязательно являются рабочее <xref:System.Windows.Markup.ValueSerializer>. См. в разделе <xref:System.Xaml.XamlMember.TypeConverter%2A>; эти же рекомендации будут применимы к <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>