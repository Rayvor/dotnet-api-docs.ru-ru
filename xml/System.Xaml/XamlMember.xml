<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eca9de4ba3e7db5769488f672b1fa19608582f9b" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014795" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет системный идентификатор типа языка XAML для членов типов XAML. Этот идентификатор используется средствами чтения и записи XAML во время обработки узлов членов (когда средство чтения XAML находится в поле <see cref="F:System.Xaml.XamlNodeType.StartMember" />). Кроме того, он используется для общей логики системы типов XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember>может использовать три методологии для возврата сведений о члене XAML: стандартное отражение среды CLR; метод отражения только для ссылок, вызывающий внутренние интерфейсы API, использующие оптимизированные битовые флаги; или вызов виртуальных переопределений `Lookup*` API, предоставляемых возможными <xref:System.Xaml.XamlMember> подклассами. Для большинства случаев использования API-интерфейсов служб .NET Framework <xref:System.Xaml.XamlMember> XAML и API используется контекст схемы XAML по умолчанию. Контекст схемы XAML по умолчанию для служб .NET Framework XAML использует резервное копирование CLR для системы типов. Это позволяет средствам чтения и записи XAML работать с любым типом или членом, который определен в среде CLR и ее методах отражения или иным образом доступен.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>API Lookup * и производные классы Ксамлмембер  
 <xref:System.Xaml.XamlMember>определяет несколько виртуальных членов, которые могут быть переопределены производными классами. Эти члены имеют имена, которые всегда начинаются со строки `Lookup`. Оставшаяся часть имени API ссылается на свойство, которое влияет на виртуальный метод. Например, <xref:System.Xaml.XamlMember> производный класс может переопределять <xref:System.Xaml.XamlMember.LookupTargetType%2A> , чтобы влиять на то, что базовое свойство <xref:System.Xaml.XamlMember.TargetType%2A> возвращает в производном классе. Вы можете предсказать возвращаемые значения для таких свойств <xref:System.Xaml.XamlMember> в или существующих производных классах, прочитав документацию по соответствующим `Lookup*` методам.  
  
 Назначение `Lookup*` методов заключается в том, чтобы предоставить метод расширения системы типов XAML, включающий <xref:System.Xaml.XamlMember> базовый класс. При наследовании от <xref:System.Xaml.XamlMember> и `Lookup` переопределении виртуальных членов можно определить концепцию элемента XAML для схемы XAML в системе типов XAML без привязки к конкретным системам резервного типа или технологии. Можно также использовать предоставленный контекст схемы XAML в этой схеме и по-прежнему возвращать нужные результаты.  
  
 В качестве примера рассмотрим <xref:System.Xaml.XamlMember> свойство. <xref:System.Xaml.XamlMember.IsWritePublic%2A> Это свойство информирует вызывающие объекты о том, что операции, такие <xref:System.Xaml.XamlWriter> как использование для сериализации, могут записывать значение для этого элемента в целевом объекте. В реализации по умолчанию определение, является ли член доступным для записи, с помощью методик отражения для резервной среды CLR <xref:System.Type> и ее членов <xref:System.Reflection.MemberInfo>(). Таким образом, по умолчанию система типов XAML зависит от системы типов CLR. Однако эту зависимость можно удалить для отчетов <xref:System.Xaml.XamlMember.IsWritePublic%2A> системы типов XAML, переопределив API. <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> В рамках переопределения можно использовать другие определения, например метаданные, характерные для вашей технологии, главную таблицу уточняющих запросов, оптимизированную для фиксированного словаря XAML, или разнообразные другие стратегии определения того, доступен ли член XAML для записи в Словарь XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Создание Ксамлмембер без контекста схемы XAML  
 Для <xref:System.Xaml.XamlMember> большинства конструкторов <xref:System.Xaml.XamlSchemaContext> требуется как часть их инициализации. Компонент также необходим для многих внутренних <xref:System.Xaml.XamlSchemaContext> операций, например для получения сведений, пересылаемых из резервного типа. <xref:System.Xaml.XamlSchemaContext> При работе с <xref:System.Xaml.XamlMember> API обычно имеется объект <xref:System.Xaml.XamlSchemaContext> , доступный из <xref:System.Xaml.XamlWriter>окружающей конструкции, такой как. В этом случае можно передать <xref:System.Xaml.XamlSchemaContext> ссылку на все системные вызовы типов XAML, для которых требуется контекст схемы XAML.  
  
 <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> Для<xref:System.Xaml.XamlSchemaContext>одного конкретного конструктора,, не требуется. Однако, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> `true` который создается с сигнатурой, возвращает для <xref:System.Xaml.XamlMember.IsUnknown%2A>. <xref:System.Xaml.XamlMember>  
  
 Для пути загрузки, включающего <xref:System.Xaml.XamlObjectWriter>в себя, такой элемент не может быть записан в граф объектов. Используя .NET Framework реализацию служб XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызов создает исключение, <xref:System.Xaml.XamlObjectWriterException> когда соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 <xref:System.Xaml.XamlMember> Не следует создавать объект, имеющий `true` значение для <xref:System.Xaml.XamlMember.IsUnknown%2A> , если только ваша реализация не может выполнять обработку исключений <xref:System.Xaml.XamlObjectWriter>из или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведения. Например, для реализации может потребоваться одно или несколько из следующих условий:  
  
-   Контекст схемы XAML доступен позже.  
  
-   Используется шаблон вызова члена.  
  
-   Намеренно переопределяется <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательском модуле записи XAML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Общее представление о понятиях и структурах потока узлов XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Объект <see cref="T:System.Reflection.EventInfo" /> системы типов среды CLR, представляющий член события.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет событие (свойство точки соединения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Объект <see cref="T:System.Reflection.PropertyInfo" /> системы типов среды CLR, представляющий член свойства.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет свойство (и в частности не является соединением обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Объект <see cref="T:System.Reflection.EventInfo" /> системы типов среды CLR, представляющий член события.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы отражения во время выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.EventInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> системы типов среды CLR, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет событие (или свойство точки соединения обработчика событий).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Объект <see cref="T:System.Reflection.PropertyInfo" /> системы типов среды CLR, представляющий член свойства.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> объектами <see cref="T:System.Reflection.PropertyInfo" /> и <see cref="T:System.Xaml.XamlSchemaContext" /> отражения, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, только если элемент представляет свойство и не является соединением обработчика событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода <see langword="Add" /> обработчика базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет присоединяемый член события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Строковое имя члена.</param>
        <param name="declaringType">Сведения <see cref="T:System.Xaml.XamlType" /> для объявляемого типа.</param>
        <param name="isAttachable">Значение <see langword="true" />, если необходимо указать, что член является присоединяемым; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" />, используя строковое имя и сведения об объявляющем типе <see cref="T:System.Xaml.XamlType" />. Объект <see cref="T:System.Xaml.XamlMember" />, созданный с данной сигнатурой, имеет значительные ограничения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> с сигнатурой, возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, включающего <xref:System.Xaml.XamlObjectWriter>в себя, такой элемент не может быть записан в граф объектов. Используя .NET Framework реализацию служб XAML, <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> вызов создает исключение, <xref:System.Xaml.XamlObjectWriterException> когда соответствующие <xref:System.Xaml.XamlMember> отчеты `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Не <xref:System.Xaml.XamlMember> следует создавать с помощью, <xref:System.Xaml.XamlMember.IsUnknown%2A> если ваша реализация не может обменять <xref:System.Xaml.XamlObjectWriter> `true` исключения из или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведения. Например, для реализации может потребоваться одно или несколько из следующих условий:  
  
-   Контекст схемы XAML доступен позже.  
  
-   Используется шаблон вызова члена.  
  
-   Намеренно переопределяется <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> в пользовательском модуле записи XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> или <paramref name="declaringType" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="get" /> базовой реализации присоединяемого члена.</param>
        <param name="setter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="set" /> базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое свойство.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет присоединяемое свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Строковое имя присоединяемого события.</param>
        <param name="adder">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода <see langword="Add" /> обработчика базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое событие, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет присоединяемый член события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Строковое имя присоединяемого свойства.</param>
        <param name="getter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="get" /> базовой реализации присоединяемого члена.</param>
        <param name="setter">Объект <see cref="T:System.Reflection.MethodInfo" /> системы типов среды CLR для метода доступа <see langword="set" /> базовой реализации присоединяемого члена.</param>
        <param name="schemaContext">Контекст <see cref="T:System.Xaml.XamlSchemaContext" />, определяющий член.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, которая обрабатывает вызовы времени выполнения, адресованные объекту <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlMember" /> для объекта <see cref="T:System.Xaml.XamlMember" />, представляющего присоединяемое свойство, включая сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор, если элемент представляет член присоединяемого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> для типа, который объявляет член, связанный с этим объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа, который объявляет член, связанный с этим объектом <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение обычно задается во время инициализации и обычно `null`не является.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A>сведения могут передаваться конструкторами для инициализации. При вызове напрямую в базовые конструкторы инициализация <xref:System.Xaml.XamlMember> производных классов может опускать некоторые проверки значений, сделанные в базовом классе. Таким образом, производная инициализация может изменить сообщаемую информацию о связях типа-члена для члена XAML, чтобы он больше не совпадал с данными системы типов базового объявления CLR. Для всех проверок, критических с точки зрения безопасности, для объявления сведений о типах следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для отложенной загрузки объектов, объявленных в языке XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.DeferringLoader%2A> Вызов<xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> Invoke или переопределение этого метода. Такое поведение возникает в случаях, когда начальная логика внутреннего отражения еще не установила информацию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список объектов <see cref="T:System.Xaml.XamlMember" />. Эти объекты сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Список объектов <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.DependsOn%2A> Вызов<xref:System.Xaml.XamlMember.LookupDependsOn%2A> Invoke или переопределение этого метода. Такое поведение возникает в случаях, когда начальная логика внутреннего отражения еще не установила информацию.  
  
 `DependsOn` Шаблон можно применить к вариантам объектной модели, которые намеренно противоречат общему правилу XAML. Общее правило XAML заключается в том, что члены типа, которые не передаются как текст инициализации (или методом фабрики в XAML 2009), должны быть способны назначаться в любом порядке. Применив `DependsOn` шаблон к элементу, можно указать средствам записи XAML всегда обрабатывать ссылочный элемент до этого элемента. Этот шаблон можно применить в ситуациях, когда значение текущего члена требует контекста или других сведений, доступных только после установки другого элемента.  
  
 `DependsOn` Шаблон следует применять внимательно и зарезервировано для сценариев свойств, где он служит целью архитектуры. Большое количество зависимостей может замедлить обработку XAML. Кроме того, можно создать циклические зависимости. в этом случае поведение обработки XAML не определено.  
  
 Примеры `DependsOn` сценариев из WPF включают определенные свойства в <xref:System.Windows.Controls.ControlTemplate> и <xref:System.Windows.DataTemplate>, в <xref:System.Windows.Trigger>и в <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
        <returns><see langword="true" />, если текущий объект равен параметру <paramref name="obj" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
        <returns><see langword="true" />, если текущий объект равен параметру <paramref name="other" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этого объекта.</summary>
        <returns>Целочисленный хэш-код.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список пространств имен XAML, в которых может существовать этот член XAML.</summary>
        <returns>Список идентификаторов пространства имен XAML в виде строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> результат вызова <xref:System.Xaml.XamlMember.DeclaringType%2A> из, связанного с этим <xref:System.Xaml.XamlMember>объектом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает реализацию объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанную с данным типом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Реализация объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанная с данным типом <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker` Шаблон является расширенной методикой расширения системы типов XAML. `Invoker` Шаблон позволяет внедрить поведение сопоставления типов схем, не используя определения системы типов XAML из .NET Framework служб XAML.  
  
 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> `null` <xref:System.Xaml.XamlMember.Invoker%2A> <xref:System.Xaml.XamlMember> <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>Если переопределение возвращает `null`или, если реализация по умолчанию возвращает, поскольку для этого свойства отсутствует, свойство возвращает значение. <xref:System.Xaml.XamlMember.LookupInvoker%2A>  
  
 Тип <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> используется по умолчанию. Это справедливо для большинства операций, использующих .NET Framework служб XAML и контекст схемы XAML по умолчанию и где не передаются специальные шаблоны переопределения `Invoker` для создания системных сущностей типов XAML.  
  
 <xref:System.Xaml.XamlMember.Invoker%2A> Вызов<xref:System.Xaml.XamlMember.LookupInvoker%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли этот объект <see cref="T:System.Xaml.XamlMember" /> внешнее свойство.</summary>
        <value>Значение <see langword="true" />, если об объекте <see cref="T:System.Xaml.XamlMember" /> сообщается, что он является внешним свойством; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAmbient%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Invoke или переопределение этого метода. Это поведение возникает в реализациях, где начальная внутренняя логика отражения еще не установила информацию.  
  
 Проверка внешних свойств обычно является частью логики обработки XAML, чтобы убедиться, что объекты и значения, зависящие от использования окружающей среды для квалификации типов, могут работать правильно. .NET Framework API-интерфейсы служб XAML и контекст схемы XAML по умолчанию заполняет это значение на основе атрибутов с <xref:System.Windows.Markup.AmbientAttribute>. Реализация <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> по умолчанию использует этот существующий <xref:System.Windows.Markup.AmbientAttribute> метод и возвращает `true` , если <xref:System.Windows.Markup.AmbientAttribute> существует в объявлении элемента.  
  
 <xref:System.Windows.Markup.AmbientAttribute>находится на членах нескольких типов WPF, которые включают <xref:System.Windows.Application>, <xref:System.Windows.Setter>и <xref:System.Windows.Style>. Он также находится в <xref:System.Windows.ResourceDictionary> типе, который показывает, что любой член, который использует <xref:System.Windows.ResourceDictionary> в качестве его типа, должен рассматриваться как окружение, даже если элемент не имеет специально атрибутов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот объект <see cref="T:System.Xaml.XamlMember" /> присоединяемым членом.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> является присоединяемым членом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение инициализируется в зависимости от того <xref:System.Xaml.XamlMember>, какой конструктор использовался для создания. <xref:System.Xaml.XamlMember.IsAttachable%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот объект <see cref="T:System.Xaml.XamlMember" /> директивой XAML.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Xaml.XamlMember" /> является директивой XAML; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение инициализируется в зависимости от того <xref:System.Xaml.XamlMember>, какой конструктор использовался для создания. <xref:System.Xaml.XamlMember.IsDirective%2A> Базовые <xref:System.Xaml.XamlMember> конструкторы инициализируются так, <xref:System.Xaml.XamlMember.IsDirective%2A> что `false`имеет значение. Однако класс (производный класс) инициализируется так, что <xref:System.Xaml.XamlMember.IsDirective%2A> имеет значение `true`. <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlDirective>  
  
 Если вы хотите сообщить о <xref:System.Xaml.XamlMember.IsDirective%2A> `true` вызовах для членов XAML классом пользовательского класса схемы XAML, убедитесь, что вы наследуете от <xref:System.Xaml.XamlDirective> , так как это единственный способ включить это поведение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член события.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsEvent%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsEvent%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, инициализирован ли этот объект <see cref="T:System.Xaml.XamlMember" /> допустимой строкой <see langword="xamlName" /> в качестве значения его свойства <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> инициализирован допустимой строкой <see langword="xamlName" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для чтения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadOnly%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> член с доступным для вызова открытым методом доступа <see langword="get" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет доступный для вызова открытый метод доступа <see langword="get" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение проверяет, является ли <xref:System.Xaml.XamlMember.DeclaringType%2A> объект общедоступным. <xref:System.Xaml.XamlMember.IsReadPublic%2A> Если <xref:System.Xaml.XamlMember.DeclaringType%2A> не является общедоступным `get` , метод доступа не может вызываться по-разному <xref:System.Xaml.XamlMember.IsReadPublic%2A> и `false`возвращает.  
  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Invoke или переопределение этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и, следовательно, может быть переопределен. Переопределение может быть изменено (вредоносным или иным образом) сообщаемыми сведениями о доступе элемента XAML, чтобы он больше не совпадал с данными о доступе к системе типов его базовой декларации CLR. Для всех проверок уровня доступа, критически важных для безопасности, используйте базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот член неразрешимым в базовой системе, используемой для разрешения типов и членов.</summary>
        <value>Значение <see langword="true" />, если этот член невозможно разрешить; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xaml.XamlMember> , созданный <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> с сигнатурой, возвращает `true` для <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Для пути загрузки, включающего <xref:System.Xaml.XamlObjectWriter>в себя <xref:System.Xaml.XamlMember> , `true` объект <xref:System.Xaml.XamlMember.IsUnknown%2A> с для не может быть записан в граф объектов. В реализациях по умолчанию в .NET Framework API-интерфейсах <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> служб XAML вызов <xref:System.Xaml.XamlObjectWriterException> создает исключение, <xref:System.Xaml.XamlMember> когда `true` соответствующие <xref:System.Xaml.XamlMember.IsUnknown%2A>отчеты для.  
  
 <xref:System.Xaml.XamlMember> Не следует создавать объект, имеющий `true` значение для <xref:System.Xaml.XamlMember.IsUnknown%2A> , если только ваша реализация не может выполнять обработку исключений <xref:System.Xaml.XamlObjectWriter>из или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведения.  
  
 <xref:System.Xaml.XamlMember.IsUnknown%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsUnknown%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWriteOnly%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> член с доступным для вызова открытым методом доступа <see langword="set" />.</summary>
        <value>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет доступный для вызова открытый метод доступа <see langword="set" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение определяет, является ли <xref:System.Xaml.XamlMember.DeclaringType%2A> объект общедоступным как часть определения. <xref:System.Xaml.XamlMember.IsWritePublic%2A> Если <xref:System.Xaml.XamlMember.DeclaringType%2A> не является общедоступным `set` , метод доступа не может вызываться по-разному <xref:System.Xaml.XamlMember.IsWritePublic%2A> и `false`возвращает.  
  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A> Вызов<xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Invoke или переопределение этого метода.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и, следовательно, может быть переопределен. Переопределение может быть изменено (вредоносным или иным образом) сообщаемыми сведениями о доступе элемента XAML, чтобы он больше не совпадал с данными о доступе к системе типов его базовой декларации CLR. Для всех проверок уровня доступа, критически важных для безопасности, используйте базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе возвращает реализацию класса <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Реализация <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите этот метод, чтобы обеспечить внутреннее отражение альтернативным способом получения значений атрибута CLR. При отсутствии переопределения внутренний отражатель использует обычную логику отражения среды CLR, например вызовы <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Реализация по умолчанию возвращает значение `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для отложенной загрузки объектов, объявленных в XAML.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" /> на универсальный класс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.DeferringLoader%2A> свойства. Переопределите этот метод, если <xref:System.Xaml.XamlMember.DeferringLoader%2A> требуется возвратить значение, которое отличается от значения, включенного внутренним отражением по умолчанию, а также при предоставлении <xref:System.Xaml.Schema.XamlMemberInvoker> пользовательских сведений.  
  
 Реализация по умолчанию возвращает объект путем чтения <xref:System.Windows.Markup.XamlDeferLoadAttribute> или <xref:System.Xaml.XamlDeferringLoader> использования из объявляющего типа. Если ни один из объектов недоступен, этот `null`метод может вернуть значение.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список объектов <see cref="T:System.Xaml.XamlMember" />. Элементы списка сообщают о членах, в которых существуют отношения зависимости для порядка инициализации относительно данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Список объектов <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.DependsOn%2A> свойства. Переопределите этот метод, если <xref:System.Xaml.XamlMember.DependsOn%2A> требуется возвратить значение, которое отличается от значения, включенного внутренним отражением по умолчанию, а также при предоставлении <xref:System.Xaml.Schema.XamlMemberInvoker> пользовательских сведений.  
  
 Реализация средства чтения и записи XAML WPF в этом случае имеет <xref:System.Windows.Markup.DependsOnAttribute>атрибут. Реализация по умолчанию использует этот <xref:System.Windows.Markup.DependsOnAttribute> существующий метод.  
  
 Переопределите этот метод, если вы не <xref:System.Windows.Markup.DependsOnAttribute> используете для этой цели и планируете заменить этот метод для указания порядка обработки свойств на собственный метод. Если не требуется поддерживать порядок обработки свойств, можно использовать реализацию по умолчанию, так как она не возвращает результатов, что является соответствующим.  
  
 Список доступен только для чтения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />, связанный с данным типом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Сведения объекта <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> для этого объекта <see cref="T:System.Xaml.XamlMember" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается вызовами <xref:System.Xaml.XamlMember.Invoker%2A>метода.  
  
 Реализация по умолчанию не требует, чтобы <xref:System.Xaml.XamlMember> объект создавался с помощью одного из конструкторов, которые передают <xref:System.Xaml.Schema.XamlMemberInvoker>начальное значение. Однако значение должно существовать <xref:System.Xaml.XamlMember>для; в противном случае реализация по умолчанию возвращает `null`. <xref:System.Xaml.XamlMember.UnderlyingMember%2A>  
  
 Переопределите этот метод, если вы также наследуете от <xref:System.Xaml.Schema.XamlMemberInvoker> и хотите вернуть производный класс. При возврате `null` <xref:System.Xaml.XamlMember.Invoker%2A> возвращается<xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> к вызывающим объектам.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, рассматривается ли данный объект <see cref="T:System.Xaml.XamlMember" /> как внешнее свойство.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить этот объект <see cref="T:System.Xaml.XamlMember" /> внешним свойством; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутренними вызовами, которые проверяют сведения о внешнем свойстве XAML. Поведение свойства окружения учитывается в поведении открытого API для средств чтения и записи XAML. Внутренние вызовы, которые ссылаются <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> на эту ссылку, обычно являются частью логики обработки XAML, чтобы убедиться, что объекты и значения, зависящие от использования окружающей среды для квалификации типов, могут работать правильно. По умолчанию .NET Framework реализация служб XAML использует атрибуты CLR для получения этих сведений из отражения по резервным типам. В частности, реализация по умолчанию <xref:System.Windows.Markup.AmbientAttribute> проверяет и `true` возвращает <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> для <xref:System.Windows.Markup.AmbientAttribute> , если существует в определении элемента.  
  
 Переопределите этот метод, если вы не <xref:System.Windows.Markup.AmbientAttribute> используете для этой цели и планируете заменить этот метод для указания внешних свойств XAML собственной методикой.  
  
 Примеры API-интерфейсов из WPF <xref:System.Windows.Markup.AmbientAttribute> этот <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> атрибут <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>имеет атрибуты и.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный объект <see cref="T:System.Xaml.XamlMember" /> событие.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить, что этот объект <see cref="T:System.Xaml.XamlMember" /> представляет событие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию проверяет <xref:System.Xaml.XamlMember.UnderlyingMember%2A> , имеет ли <xref:System.Reflection.EventInfo>тип значение, и, если это `true`так, возвращает.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsEvent%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные, которые можно интерпретировать для определения представлений системы типов XAML для каждого варианта.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> требуемое свойство только для чтения.</summary>
        <returns>Значение <see langword="true" />, если необходимо объявить, что этот объект <see cref="T:System.Xaml.XamlMember" /> представляет ожидаемое свойство, доступное только для чтения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию `true` возвращает <xref:System.Xaml.XamlMember.UnderlyingMember%2A> , если существует, но `set` открытый метод доступа для него не существует, как определено внутренним отражением.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные, которые можно интерпретировать для определения представлений системы типов XAML для каждого варианта.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли объект <see cref="T:System.Xaml.XamlMember" /> свойство, имеющее открытый метод доступа <see langword="get" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет свойство, имеющее открытый метод доступа <see langword="get" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты на основе внутреннего отражения или отрицания <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, обрабатываемого в указанном порядке.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>Возвращает значение, указывающее, является ли сам член открытым; Он возвращает `true` для открытого члена в неоткрытом объявляем типе. Вместо <xref:System.Xaml.XamlMember.IsReadPublic%2A> этого следует использовать, если также необходимо рассмотреть видимость объявляющего типа.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Метод является виртуальным и, следовательно, может быть переопределен. Переопределение может быть изменено (вредоносным или иным образом) сообщаемыми сведениями о доступе элемента XAML, чтобы он больше не совпадал с данными о доступе к системе типов его базовой декларации CLR. Для всех проверок уровня доступа, критически важных для безопасности, используйте базовый тип CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный объект <see cref="T:System.Xaml.XamlMember" /> член, который не может быть разрешен в базовой системе, используемой для разрешения типов и членов.</summary>
        <returns>Значение <see langword="true" />, если данный объект <see cref="T:System.Xaml.XamlMember" /> представляет неразрешимый член; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsUnknown%2A>. Реализация по умолчанию возвращает результаты, которые основаны либо на внутреннем отражении `null` , либо <xref:System.Xaml.XamlMember.UnderlyingMember%2A>на проверке значения, обрабатываемого в указанном порядке.  
  
 Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый метод доступа <see langword="set" />, но не имеющий открытого метода доступа <see langword="get" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный только для записи; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию `true` возвращает, <xref:System.Xaml.XamlMember.UnderlyingMember%2A> если существует, имеющий `set` открытый метод доступа и неоткрытый `get` метод доступа, как определено внутренним отражением.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, действительно ли этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, имеющий открытый метод доступа <see langword="set" />.</summary>
        <returns>Значение <see langword="true" />, если этот объект <see cref="T:System.Xaml.XamlMember" /> представляет член, доступный для записи; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает результаты на основе внутреннего отражения или отрицания <xref:System.Xaml.XamlMember.IsReadOnly%2A>, обрабатываемого в указанном порядке.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Метод является виртуальным и, следовательно, может быть переопределен. Переопределение может быть изменено (вредоносным или иным образом) сообщаемыми сведениями о доступе элемента XAML, чтобы он больше не совпадал с данными о доступе к системе типов его базовой декларации CLR. Для всех проверок уровня доступа, критически важных для безопасности, используйте базовый тип CLR.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <returns>Коллекция, содержащая символы открывающих и закрывающих скобок.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.XamlType" /> того типа, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Тип, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию различает присоединяемые и не присоединяемые члены. Для членов, не являющихся присоединяемыми <xref:System.Xaml.XamlMember.DeclaringType%2A>, <xref:System.Xaml.XamlMember.LookupTargetType%2A> всегда возвращает. Для присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат на основе проверки <xref:System.Xaml.XamlMember.UnderlyingMember%2A> типа параметра доступа и интерпретирует этот тип на основе контекста схемы XAML.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.TargetType%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если <xref:System.Xaml.XamlMember.Type%2A> требуется возвратить значение, которое отличается от значения, включенного внутренним отражением по умолчанию, а также при предоставлении <xref:System.Xaml.Schema.XamlMemberInvoker> пользовательских сведений.  
  
 Реализация по умолчанию использует разные пути кода и концептуальные значения для возвращаемого <xref:System.Xaml.XamlType> значения, основанного на том, представляет ли это <xref:System.Xaml.XamlMember> свойство, метод или событие.  
  
-   Для свойства возвращается <xref:System.Xaml.XamlType> тип, который задает свойство или возвращается свойством.  
  
-   Для события возвращаемым <xref:System.Xaml.XamlType> является обязательный тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> является типом возвращаемого значения.  
  
 В каждом случае контекст схемы XAML используется для вычисления типа XAML из базового системного типа.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.Type%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию преобразователя типов, связанного с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Экземпляр <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если атрибуты существуют на уровне члена (<xref:System.ComponentModel.TypeConverterAttribute>), сведения об атрибуте используются для вызова к <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> контексту схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь типов, связанный с типом.  
  
-   Если член является событием, возвращается преобразователь типов, специфичный для события.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.TypeConverter%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метод доступа <see langword="get" />, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MethodInfo" /> для связанного метода доступа <see langword="get" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация <xref:System.Xaml.XamlMember.UnderlyingMember%2A> по умолчанию интерпретирует свойство как <xref:System.Reflection.PropertyInfo> <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> и возвращает значение (с параметром `true`, имеющим значение), что означает, что возвращаемый метод может быть неоткрытым. Это может привести `null` к определенным ситуациям. включая случаи, когда связанный метод доступа не существует или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> свойства связанного <xref:System.Xaml.Schema.XamlMemberInvoker>объекта. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая. Обязательно реализуйте <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> так, чтобы они возвращали коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает сведения о базовом элементе, которые основаны на построении. Если объект создан с сигнатурой, которая не предоставляет достаточно сведений для установки базового члена, этот метод возвращает `null`значение. <xref:System.Reflection.MemberInfo>  
  
 Если базовый элемент был задан во время создания, не нужно вызывать этот метод.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая. Обязательно реализуйте <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> так, чтобы они возвращали коррелированные результаты.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метод доступа <see langword="set" />, связанный с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.MethodInfo" /> для связанного метода доступа <see langword="set" /> или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию интерпретирует <xref:System.Xaml.XamlMember.UnderlyingMember%2A> <xref:System.Reflection.PropertyInfo> <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> и возвращает значение (с параметром, имеющим значение `true`), что означает, что возвращаемый метод может быть неоткрытым. Это может привести `null` к некоторым случаям, включая случаи отсутствия такого метода доступа, или член не является свойством.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> связанного <xref:System.Xaml.Schema.XamlMemberInvoker>объекта. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая. Обязательно реализуйте <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>и <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> так, чтобы они возвращали коррелированные результаты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает реализацию сериализатора значений, связанную с данным объектом <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Экземпляр <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" /> или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию использует следующую логику и порядок обработки:  
  
-   Если атрибуты существуют на уровне члена (<xref:System.Windows.Markup.ValueSerializerAttribute>), сведения об атрибуте используются для вызова к <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> контексту схемы XAML.  
  
-   Если <xref:System.Xaml.XamlMember.Type%2A> является допустимым, возвращается преобразователь значений, связанный с типом.  
  
-   Если предыдущие условия не применяются, `null` возвращается значение.  
  
 Этот метод вызывается, когда вызывающий объект получает значение из <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Переопределите этот метод, если требуется сообщать единообразные результаты для <xref:System.Xaml.XamlMember> всего производного класса или если имеются специализированные метаданные для определения этого варианта для каждого случая.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет символы открывающей и закрывающей скобок для расширения разметки.</summary>
        <value>Коллекция, содержащая символы открывающих и закрывающих скобок.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое представление имени <see langword="xamlName" />, объявляющего этот объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Строковое представление имени <see langword="xamlName" />, объявляющего этот объект <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение всегда задается во время создания. Конструкторы, реализованные с помощью <xref:System.Xaml.XamlMember> , обычно создают исключение, если начальное имя не задано, поэтому не следует предполагать, что это свойство `null` является или пустой строкой, если используется .NET Framework служб XAML по умолчанию реализации.  
  
 [Грамматика имяxaml](~/docs/framework/xaml-services/xamlname-grammar.md) и правила именования для типа CLR и членов не являются строго пересекающимися. Можно объявить имя члена, которое является допустимым в среде CLR, но недопустимо при именовании XAML. Эту ситуацию следует избегать по возможности.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlMember1" /> совпадает со значением <paramref name="xamlMember2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> или <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных объектов <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlMember1" /> отличается от значения параметра <paramref name="xamlMember2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает URI одного пространства имен XAML, определяющий первичное пространство имен XAML для этого объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Идентификатор первичного пространства имен XAML для этого объекта <see cref="T:System.Xaml.XamlMember" /> в виде строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство предоставляет то же значение, что и <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> вызов, а затем получает строку первого значения из возвращенного списка. <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Предпочтительное пространство имен XAML следует использовать при записи элемента обратно в текст или других представлениях, сохраняющих сведения о пространстве имен XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />, указывающее, как визуальный конструктор должен обрабатывать этот член.</summary>
        <value>Значение перечисления <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. Значение по умолчанию — <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> того типа, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Тип, в котором может существовать объект <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение отличается для присоединяемых и не присоединяемых членов. Для членов, не являющихся присоединяемыми, <xref:System.Xaml.XamlMember.TargetType%2A> возвращает. <xref:System.Xaml.XamlMember.DeclaringType%2A> Для присоединяемых членов <xref:System.Xaml.XamlMember.LookupTargetType%2A> возвращает результат, основанный на этой логике:  
  
-   Если отражение не может разрешить резервное копирование<xref:System.Xaml.XamlMember.IsUnknown%2A> ( `true`), этот метод возвращает внутреннюю константу, представляющую универсальный тип объекта.  
  
-   Если предыдущее условие не применяется, <xref:System.Xaml.XamlMember.LookupTargetType%2A> вызывается метод. Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> объект, основанный на проверке методов, `get` реализующих методы доступа `set` и. Класс может переопределяться <xref:System.Xaml.XamlMember.LookupTargetType%2A> для использования другого поведения, такого как другие формы метаданных, которые могут сообщать о целевых типах для присоединяемых членов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Строковое представление данного объекта <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> того типа, который используется данным членом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.Type%2A> Вызов<xref:System.Xaml.XamlMember.LookupType%2A> Invoke или переопределение этого метода. Это происходит, когда начальная логика внутреннего отражения еще не установила информацию.  
  
 В поведении по умолчанию <xref:System.Xaml.XamlMember.LookupType%2A> (без переопределения) возвращаемое <xref:System.Xaml.XamlType> значение может иметь различные концептуальные значения. Это значение зависит от того, представляет <xref:System.Xaml.XamlMember> ли это свойство, метод или событие, как показано в следующем списке.  
  
-   Для свойства возвращается <xref:System.Xaml.XamlType> тип, который задает свойство или возвращается свойством.  
  
-   Для события возвращаемым <xref:System.Xaml.XamlType> является обязательный тип обработчика событий (делегат в реализации CLR).  
  
-   Для метода <xref:System.Xaml.XamlType> — это возвращаемый тип этого метода, который может иметь `null`значение.  
  
 В каждом случае контекст схемы XAML используется для вычисления типа XAML из резервного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, который может использоваться для создания конструкции преобразователя типов для объектов, объявленных в языке XAML.</summary>
        <value>Значение <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.TypeConverter%2A> Вызов<xref:System.Xaml.XamlMember.LookupTypeConverter%2A> Invoke или переопределение этого метода. Такое поведение возникает, когда начальная логика внутреннего отражения еще не установила информацию.  
  
 Реализации, возвращающие значение <xref:System.Xaml.XamlMember.TypeConverter%2A> свойства, отличное от NULL, не обязательно являются рабочими. <xref:System.ComponentModel.TypeConverter> Ниже приведен список возможных возвращаемых значений, отличных от NULL, <xref:System.Xaml.XamlMember.TypeConverter%2A> для и значений, которые они представляют.  
  
-   Возвращаемое значение сообщает преобразователь типов, который в частности относится к этому элементу или более обычно к целевому типу преобразователя. Обычно это поведение большинства систем типов XAML и обработчиков XAML для создания экземпляра преобразователя типов и вызова его методов.  
  
-   Возвращаемое значение сообщает о встроенном преобразователе значений. Эти конвертеры существуют для определенных внутренних операций, выполняемых модулем записи XAML. В частности, эти встроенные преобразователи значений преобразуют необработанные строковые значения атрибута в примитивы уровня языка XAML. Для .NET Framework реализации служб XAML эти встроенные преобразования типов часто пересылаются в преобразователь типов, определенный в системной сборке. Например, преобразование <xref:System.Int32> значения имеет встроенное перенаправленное преобразование, поэтому <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> значение ссылается на <xref:System.ComponentModel.Int32Converter>.  
  
-   Возвращаемое значение сообщает об особом случае неограниченной объектной модели. то есть, <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlMember.Type%2A> имеет значение <xref:System.Object>. В этом случае <xref:System.Xaml.Schema.XamlValueConverter%601> отчет <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> имеет значение {`Object}`. Однако это <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> `null` связано с тем, что для выполнения этого преобразования не существует фактического типа или экземпляра. Вместо этого поведение объектной модели не может быть определено до времени выполнения, когда среда выполнения конкретной технологии определяет обработку графа объекта.  
  
 Если у вас есть доступ к <xref:System.ComponentModel.TypeConverter> работе <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>из, можно вызвать его методы преобразования. Однако многие методы преобразования зависят от контекста службы. Если у вас нет того же контекста службы, который преобразователь типов ожидает для своей обычной роли при записи объектов для графов объектов, то методы преобразователя могут создавать исключения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, доступный для члена, который создан объектом <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> или <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Сведения объекта <see cref="T:System.Reflection.MemberInfo" /> системы типов среды CLR, преобразованные из исходных параметров конструктора. Объект <see cref="T:System.Xaml.XamlMember" />, созданный с сигнатурой <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />, возвращает значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Вызов<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> Invoke или переопределение этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для сериализации значений объектов, объявленных в языке XAML.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" /> для универсального класса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.ValueSerializer%2A> Вызов<xref:System.Xaml.XamlMember.LookupValueSerializer%2A> Invoke или переопределение этого метода. Такое поведение возникает, когда начальная логика внутреннего отражения еще не установила информацию.  
  
 Не все случаи, в которых возвращается значение <xref:System.Xaml.XamlMember.ValueSerializer%2A> свойства, отличное от NULL, обязательно являются рабочими. <xref:System.Windows.Markup.ValueSerializer> См <xref:System.Xaml.XamlMember.TypeConverter%2A>. также те же рекомендации, <xref:System.Xaml.XamlMember.ValueSerializer%2A>что и для.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>