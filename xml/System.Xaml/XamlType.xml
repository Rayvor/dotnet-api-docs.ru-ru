<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfd91f69d569a06e754734f5e72c44b4d3283e86" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72397148" /></Metadata><TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сообщает сведения о типах языка XAML в составе общей системы языка XAML, реализованной в службах XAML платформы .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие API в классе <xref:System.Xaml.XamlType> предоставляют сведения о типах XAML, где концепция, в которой они сообщают, аналогична определенным разделам спецификации XAML [MS-XAML].  
  
 <xref:System.Xaml.XamlType> широко используется в API-интерфейсе .NET Framework служб XAML для отправки сведений о типе XAML. <xref:System.Xaml.XamlType> сообщает сведения, которые могут потребоваться знать о типе XAML, чтобы работать с экземпляром или получить доступ к его членам из потока узлов XAML или аналогичного представления XAML. Его отчеты похожи на то, как <xref:System.Type> в системе типов CLR, а также классы отражения, такие как <xref:System.Reflection.MemberInfo>, предоставляют сведения о типе CLR и его использовании.  
  
 Чтобы расширить систему типов XAML, можно наследовать от <xref:System.Xaml.XamlType>. Чтобы сделать это эффективно, также может потребоваться реализовать <xref:System.Xaml.Schema.XamlTypeInvoker>. @No__t-0 позволяет обобщенной системе типов XAML работать с резервной системой типов, которая указывается как часть поведения вызова. Конкретный пользовательский <xref:System.Xaml.Schema.XamlTypeInvoker> позволяет уменьшить зависимости от системы типов CLR, которые используются поведением по умолчанию <xref:System.Xaml.XamlType>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Базовый тип среды CLR <see cref="T:System.Type" /> для создаваемого типа XAML.</param>
        <param name="schemaContext">Контекст схемы XAML для средств чтения и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> на основе сведений о базовом типе среды CLR.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Одно или несколько значений <paramref name="underlyingType" /> или <paramref name="schemaContext" /> равны <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя создаваемого типа.</param>
        <param name="typeArguments">Аргументы типа для объекта <see cref="T:System.Xaml.XamlType" />, представляющего универсальный тип. Может (нередко) иметь значение <see langword="null" />, указывающее, что представленный тип не является универсальным.</param>
        <param name="schemaContext">Контекст схемы XAML для средств чтения и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> на основе строки имени для типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор является защищенным. Не существует текущих открытых производных классов, которые используют этот конкретный путь для создания. В качестве потребителя существующего <xref:System.Xaml.XamlType> необходимо использовать другие сигнатуры конструктора (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29> или <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) для инициализации объекта <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Одно или несколько значений <paramref name="typeName" /> или <paramref name="schemaContext" /> равны <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Базовый тип для создаваемого типа языка XAML.</param>
        <param name="schemaContext">Контекст схемы XAML для средства чтения XAML.</param>
        <param name="invoker">Реализация <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />, которая обрабатывает вызовы отражения во время выполнения, адресованные объекту <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> на основе сведений о базовом типе и реализации <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Одно или несколько значений <paramref name="underlyingType" /> или <paramref name="schemaContext" /> равны <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Пространство имен XAML для типа в виде строки.</param>
        <param name="unknownTypeName">Имя типа в предоставленном пространстве имен XAML <paramref name="unknownTypeNamespace" />.</param>
        <param name="typeArguments">Аргументы типа для объекта <see cref="T:System.Xaml.XamlType" />, представляющего универсальный тип. Может (нередко) иметь значение <see langword="null" />, указывающее, что представленный тип не является универсальным.</param>
        <param name="schemaContext">Контекст схемы XAML для средств чтения и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> на основе пространства имен XAML и строки имени для типа. Этот конструктор предназначен исключительно для анализа и записи в узлы XAML использований типов, о которых известно, что они не зарезервированы в базовой системе типов и контексте схемы XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор только для типов "Unknown", в которых тип XAML, сопоставляемый с базовой системой типов, недоступен. Этот конструктор может не дать результата, где <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> равно `true`. Вместо этого логика отражения по умолчанию сообщает базовый тип как <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Однако это поведение может измениться из-за переопределения @no__t – 0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Одно или несколько значений <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" /> или <paramref name="schemaContext" /> равны <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию только для чтения, содержащую типы, которые могут использоваться в качестве значения свойства <see cref="P:System.Xaml.XamlType.ContentProperty" /> для этого класса <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Доступная только для чтения коллекция возможных типов содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типы, которые могут быть назначены определенному типу содержимого (например, могут быть назначены базовому типу, который является допустимым типом содержимого), не считаются несколькими типами в целях <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML. Определение этого значения основано на базовом типе данного типа <see cref="T:System.Xaml.XamlType" /> и контексте схемы.</summary>
        <value>Тип <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupBaseType%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupBaseType%2A> для этого типа. По умолчанию <xref:System.Xaml.XamlType.BaseType%2A> возвращает внутреннюю константу, которая представляет <xref:System.Object>, если <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых типов данных о типе XAML, чтобы он больше не совпадал с данными системы типов базового типа CLR. Для всех проверок, критических для системы безопасности операций присваивания и доступа, следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Тип, который надо сравнить с текущим типом <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Возвращает значение, указывающее, содержит ли экземпляр данного типа <see cref="T:System.Xaml.XamlType" /> заданный тип <see cref="T:System.Xaml.XamlType" /> в своем списке присваиваемых типов.</summary>
        <returns>Значение <see langword="true" />, если тип <paramref name="xamlType" /> содержится в списке присваиваемых типов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хотя назначаемый тип не имеет всех возможностей ссылочного типа, его можно использовать для назначения. Например, можно использовать назначение, чтобы сделать тип равным для значений свойства. Концепция назначаемых типов в XAML аналогична концепции приведения вверх в системе типов CLR. Например, в системе типов CLR каждый тип имеет <xref:System.Object> в списке присваиваемых типов.  
  
 Если одно из двух экземпляров <xref:System.Xaml.XamlType>, используемых для сравнения, <xref:System.Xaml.XamlType.IsUnknown%2A> равно `true`, этот метод имеет специальный Неизвестный режим, который возвращает значение `true`, если два экземпляра <xref:System.Xaml.XamlType> эквивалентны.  
  
 Реализация по умолчанию использует CLR <xref:System.Type> из <xref:System.Xaml.XamlType.UnderlyingType%2A> для этого <xref:System.Xaml.XamlType> и входных данных <xref:System.Xaml.XamlType>, а также вызывает <xref:System.Type.IsAssignableFrom%2A>. Переопределите этот метод, если требуется другое определение назначаемых типов.  
  
 Передача значения NULL `xamlType` не приводит к созданию исключения и всегда возвращает `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и в других случаях) для изменения способа присваивания типа XAML, чтобы он больше не совпадал в ожидаемом виде с поведением приведения типа к базовому типу CLR. Для всех проверок, критических для системы безопасности операций присваивания и доступа, следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, должен ли данный тип <see cref="T:System.Xaml.XamlType" /> иметь аргументы (универсальные ограничения с использованием <see langword="x:TypeArguments" />, текста инициализации или других технологии языка XAML) для создания допустимого экземпляра этого типа.</summary>
        <value>Значение <see langword="true" />, если для создания экземпляра требуется некоторое значение аргумента; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сведения <see cref="T:System.Xaml.XamlMember" /> для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Сведения <see cref="T:System.Xaml.XamlMember" /> для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />. Может принимать значение <see langword="null" />, если свойство содержимого отсутствует.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании привязки или резервного копирования системы типов CLR свойство содержимого XAML может быть задано для типа путем применения <xref:System.Windows.Markup.ContentPropertyAttribute> к определению типа.  
  
 Это свойство соответствует информационному элементу `[content property]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupContentProperty%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupContentProperty%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает типы, используемые для создания оболочки свойства содержимого, если оно не удовлетворяет требованию строгого соответствия типов, например строки в строго типизированной коллекции <see langword="Collection&lt;T&gt;" />.</summary>
        <value>Доступная только для чтения коллекция возможных типов оболочки содержимого или значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если нет оболочек для защиты от ослабления соответствия типов, это свойство имеет значение `null`.  
  
 Типы, которые оцениваются как <xref:System.Xaml.XamlType.CanAssignTo%2A> для определенного типа содержимого, не считаются несколькими типами в целях <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 В привязке CLR для <xref:System.Xaml> и <xref:System.Xaml.XamlType> тип оболочки содержимого XAML можно указать в типе как <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupContentWrappers%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupContentWrappers%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, представляющий поведение преобразования отложенной загрузки для этого типа.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" />, представляющим поведение отложенной загрузки для данного типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение шаблона XAML в WPF является примером поведения отложенной загрузки.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Позволяет определить, равен ли текущий объект другому объекту.</summary>
        <returns><see langword="true" />, если текущий объект равен параметру <paramref name="obj" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
        <returns><see langword="true" />, если текущий объект эквивалентен параметру <paramref name="other" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Директива, для которой требуется найти член с псевдонимом.</param>
        <summary>Возвращает элемент XAML, который связан псевдонимом с директивой XAML посредством данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Член с псевдонимом, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не использовать метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого метода могут вызвать переопределение <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> для производных классов <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, содержащую все присоединяемые свойства, предоставляемые этим классом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Коллекция, содержащая ноль или более значений <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый <xref:System.Xaml.XamlMember> в возвращаемой коллекции должен содержать значения, которые поддерживают концепцию, которую <xref:System.Xaml.XamlMember> является присоединяемым элементом. Например, члены должны возвращать `true` для <xref:System.Xaml.XamlMember.IsAttachable%2A>, тип для <xref:System.Xaml.XamlMember.TargetType%2A> и т. д.  
  
 Если не использовать метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого метода могут вызвать переопределение <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> для производных классов <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, содержащую все члены, предоставляемые данным объектом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Коллекция, содержащая ноль или более значений <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовы этого метода могут вызвать переопределения <xref:System.Xaml.XamlType.LookupAllMembers%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя присоединяемого элемента в следующем формате: <c>ownerTypeName.MemberName</c>.</param>
        <summary>Возвращает элемент <see cref="T:System.Xaml.XamlMember" />, который представляет определенный именованный присоединяемый элемент <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlMember" /> для запрошенного присоединяемого элемента или значение <see langword="null" />, если присоединяемого элемента с таким именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовы этого метода могут вызвать переопределения <xref:System.Xaml.XamlType.LookupAttachableMember%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых элементов типа XAML, чтобы они больше не выдавались ожидаемым образом с <xref:System.ComponentModel.TypeDescriptor> `Get*` сведениями о базовом типе CLR. Для всех проверок, критических с точки зрения безопасности, для отчетов о членах следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этого объекта.</summary>
        <returns>Целочисленный хэш-код.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя (в виде строки) члена, который требуется получить.</param>
        <summary>Возвращает член <see cref="T:System.Xaml.XamlMember" /> для определенного именованного члена из данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Сведения <see cref="T:System.Xaml.XamlMember" /> для члена, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `name` должно быть неполным. Имена с квалификаторами типа, которые указывают, что присоединенный член должен отправляться <xref:System.Xaml.XamlType.GetAttachableMember%2A>. Имена элементов с префиксом не должны использоваться; Префикс является ситуацией использования, и система типов XAML не может понять контекст такого использования и способ сопоставления префикса.  
  
 Вызовы этого метода могут вызвать переопределения <xref:System.Xaml.XamlType.LookupMember%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых элементов типа XAML, чтобы они больше не выдавались ожидаемым образом с <xref:System.ComponentModel.TypeDescriptor> `Get*` сведениями о базовом типе CLR. Для всех проверок, критических с точки зрения безопасности, для отчетов о членах следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Количество (арность) определенного режима синтаксиса или конструктора, о котором требуется получить сведения.</param>
        <summary>Для типов расширения разметки возвращает типы позиционных параметров, поддерживаемых в конкретном употреблении расширения разметки для данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список значений <see cref="T:System.Xaml.XamlType" />, где каждый объект <see cref="T:System.Xaml.XamlType" /> является типом для этой позиции в синтаксисе. При передаче входных данных разметки в расширение разметки необходимо задавать типы в том же порядке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот API важен только в том случае, если этот <xref:System.Xaml.XamlType> представляет расширение разметки (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> — `true`).  
  
 Входные `parameterCount` не запрашивают тип конкретного позиционированного параметра. Он предназначен для указания арности использования расширения разметки. Использование расширения разметки часто имеет несколько "сигнатур" и использует разные значения арности параметров (количество) для различения параметров. Однако можно настроить контекст схемы, чтобы разрешить дублирование аритиес и использовать типы позиционированных параметров для различения. Для получения дополнительной информации см. <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Для определенной арности (Count) позиции и типы параметров могут различаться. Чтобы получить определяющий тип использования расширения разметки определенной арности, сначала необходимо вызвать <xref:System.Xaml.XamlType.GetPositionalParameters%2A>, указав число арностей. Затем получите элемент в этой позиции из возвращенной коллекции.  
  
 Вызовы этого метода могут вызвать переопределения <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список строковых идентификаторов для пространств имен языка XAML, в которые входит этот тип.</summary>
        <returns>Список строковых значений, в котором каждая строка является URI-идентификатором для пространства имен языка XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичные идентификаторы пространства имен XAML — это строки в форме URI.  
  
 Реализация по умолчанию проверяет следующее по порядку: пространство имен XAML, которое предоставляется в конструкции (только для сигнатуры <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>); и пространства имен, доступные из контекста схемы. Если это все `null`, создается новый список, содержащий одну пустую строку. Этот метод можно переопределить, чтобы изменить методологию поиска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает реализацию объекта <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />, связанную с данным типом <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Реализация объекта <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />, связанная с данным типом <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для <xref:System.Xaml.XamlType> не используется метод внутренней среды CLR по умолчанию, вызов <xref:System.Xaml.XamlType.Invoker%2A> может вызвать либо <xref:System.Xaml.XamlType.LookupInvoker%2A>, либо конкретное переопределение этого метода. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupInvoker%2A> для этого типа.  
  
 Если переопределение <xref:System.Xaml.XamlType.LookupInvoker%2A> возвращает `null` или реализация по умолчанию возвращает `null` по причине отсутствия <xref:System.Xaml.XamlType.UnderlyingType%2A> для этого <xref:System.Xaml.XamlType>, то <xref:System.Xaml.XamlType.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> внешний тип в соответствии с определением языка XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет внешний тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsAmbient%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsAmbient%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> массив.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет массив; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> коллекцию.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет коллекцию; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> конструируемый тип в соответствии с определением языка XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует информационному элементу `[is default constructible]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsConstructible%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsConstructible%2A> для этого типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> словарь в соответствии с определением языка XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет словарь; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует информационному элементу `[is dictionary]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли этот данный тип <see cref="T:System.Xaml.XamlType" /> универсальный тип.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет универсальный тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является вспомогательным, которое проверяет значение null, равное <xref:System.Xaml.XamlType.TypeArguments%2A>. Нет конкретного метода `Lookup`, связанного с <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> расширение разметки.</summary>
        <value>Значение <see langword="true" />, если этот класс <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В терминах спецификации XAML этот тип должен быть назначен для `x:MarkupExtension`, чтобы возвратить `true` для <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> область имен XAML в соответствии с определением языка XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область имен XAML обеспечивает уникальность имени свойства или свойств, используемых для `x:Name` @ no__t-1 @ no__t-2. Если <xref:System.Xaml.XamlType.IsNameScope%2A> равно `true`, должен существовать механизм обеспечения уникальности, который должен оцениваться от перспективы этого типа, владеющего областью имен XAML. Область имен XAML затем расширяется до содержимого типа до тех пор, пока не встретится другой тип области видимости имен XAML.  
  
 Это свойство соответствует информационному элементу `[is name scope]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsNameScope%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, инициализирован ли данный тип <see cref="T:System.Xaml.XamlType" /> с использованием допустимой строки <see langword="xamlName" /> в качестве его свойства <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> инициализирован с использованием допустимой строки <see langword="xamlName" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> тип, допускающий значение null, в соответствии с определением языка XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет тип, допускающий значение null; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует информационному элементу `[is nullable]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsNullable%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> открытый тип в соответствующей системе типов.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет открытый тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsPublic%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и в других случаях) для изменения сведений о доступе к типу XAML, чтобы он больше не совпадал с системой типов и сведениями о доступе к базовому типу CLR. Для всех проверок, критических для системы безопасности операций присваивания и доступа, следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> тип, который не может быть разрешен в базовой системе типов.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет неразрешимый тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsUnknown%2A> для классов, производных от <xref:System.Xaml.XamlType>.  
  
 Для пути загрузки, включающего <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlType> с `true` для <xref:System.Xaml.XamlType.IsUnknown%2A> не может быть записан в граф объектов. В реализациях по умолчанию в <xref:System.Xaml> вызов <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> создает исключение <xref:System.Xaml.XamlObjectWriterException>, если соответствующие отчеты <xref:System.Xaml.XamlType> `true` для <xref:System.Xaml.XamlType.IsUnknown%2A>. Не следует передавать <xref:System.Xaml.XamlType> с <xref:System.Xaml.XamlType.IsUnknown%2A> как `true`, если вы не готовы обрабатывать исключения из <xref:System.Xaml.XamlObjectWriter> или у вас есть другие способы настройки поведения <xref:System.Xaml.XamlObjectWriter> или потока узлов XAML перед записью графа объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое показывает, выполняется ли построение данного типа <see cref="T:System.Xaml.XamlType" /> сверху вниз во время инициализации XAML.</summary>
        <value>Значение <see langword="true" />, если этот класс <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "Сверху вниз" — это метафора, которая приблизительно соответствует поведению процессора XAML при создании графа объектов. При построении сверху вниз создается экземпляр типа, прикрепляется к родительскому элементу, а затем задаются его свойства. Построение сверху вниз позволяет избежать многократного вызова обработчиков, изменяющих свойства. Такая обработка настраивает граф объектов и, следовательно, устраняет несколько вызовов обработчика и обеспечивает оптимизацию производительности для запуска графа объекта.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> для этого типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> коллекцию значащих символов пробелов в соответствии с определением XML.</summary>
        <value>Значение <see langword="true" />, если этот тип <see cref="T:System.Xaml.XamlType" /> представляет коллекцию значащих символов пробелов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> XML-<see langword="XDATA" /> в соответствии с определением XAML.</summary>
        <value>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет <see langword="XDATA" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует информационному элементу `[is xdata]` в спецификации [MS-XAML].  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsXData%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsXData%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе для свойства <see langword="Items" /> данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа элементов в коллекции или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет коллекцию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, только если этот <xref:System.Xaml.XamlType> представляет коллекцию (<xref:System.Xaml.XamlType.IsCollection%2A> — `true`). Свойство `Items` — это любое свойство, содержащее элементы в этом типе коллекции или массива.  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupItemType%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupItemType%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе для свойства ключа данного типа <see cref="T:System.Xaml.XamlType" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет словарь.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа ключа для использования словаря или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет словарь.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство уместно, только если этот <xref:System.Xaml.XamlType> представляет словарь (<xref:System.Xaml.XamlType.IsDictionary%2A> — `true`).  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupKeyType%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupKeyType%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Директива, для которой требуется найти член с псевдонимом.</param>
        <summary>Возвращает элемент XAML, который связан псевдонимом с директивой XAML посредством данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Член с псевдонимом, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 Реализация по умолчанию может возвращать результаты для следующих директив XAML: `Key`; `Name`; `Uid`; и `xml:lang`. Значения для этих параметров зависят от базового отражения и по-прежнему могут возвращать `null`, если не найдено свойство Alias.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемый набор, содержащий все присоединяемые свойства, которые предоставляются данным классом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Перечисляемый набор, содержащий ноль или более значений <see cref="T:System.Xaml.XamlMember" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Хотя <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> возвращает универсальную коллекцию, этот метод `Lookup` возвращает универсальный перечислимый набор.  
  
 Реализация по умолчанию использует внутреннее отражение CLR. Если <xref:System.Xaml.XamlType.UnderlyingType%2A> равно `null`, реализация по умолчанию может использовать <xref:System.Xaml.XamlType.BaseType%2A>, если она доступна. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> рекурсивно, чтобы попытаться найти допустимый базовый тип, и возвращает значение `null`, если допустимый базовый тип не существует.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа. Возвращаемое значение null должно быть зарезервировано для случаев, когда сведения не могут быть определены из-за отсутствия поддержки системы типов или отражения. Если тип является допустимым, а отражение или другие методы доступны, но тип не имеет присоединяемых членов, вместо этого следует возвращать пустой набор <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемый набор, содержащий все члены, предоставляемые данным классом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Перечисляемый набор, содержащий ноль или более значений <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Хотя <xref:System.Xaml.XamlType.GetAllMembers%2A> возвращает универсальную коллекцию, этот метод `Lookup` возвращает универсальный перечислимый набор.  
  
 Реализация по умолчанию использует внутреннее отражение CLR. В случаях, когда <xref:System.Xaml.XamlType.UnderlyingType%2A> имеет значение `null`, реализация по умолчанию может использовать <xref:System.Xaml.XamlType.BaseType%2A>, если она доступна. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAllMembers%2A> рекурсивно, чтобы попытаться найти допустимый базовый тип, и возвращает значение `null`, если допустимый базовый тип не существует.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа. Возвращаемое значение null должно быть зарезервировано для случаев, когда сведения не могут быть определены из-за отсутствия поддержки системы типов или отражения. Если тип является допустимым, становятся доступны отражение или другие методы. Если у типа нет членов, вместо него следует возвращать пустой набор <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Возвращаемые значения для <xref:System.Xaml.XamlType.LookupAllMembers%2A> и <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> должны быть взаимоисключающими. Если у вас есть ситуация, когда свойство системы резервного типа может поддерживать стандартное использование экземпляра, а также присоединяемое использование, этот элемент должен быть передан как два разных значения <xref:System.Xaml.XamlMember>, причем одно значение появляется в присоединяемом списке, а другое — в элементе список стандартных членов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список типов, которые могут использоваться в качестве значения <see cref="P:System.Xaml.XamlType.ContentProperty" /> для данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список возможных типов содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Типы, которые оцениваются как <xref:System.Xaml.XamlType.CanAssignTo%2A> для определенного типа содержимого, не считаются несколькими типами в целях <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Реализация по умолчанию может использовать другие свойства <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A> или <xref:System.Xaml.XamlType.ItemType%2A>) для получения результата. В этом определении также можно вызвать переопределения `Lookup` для предыдущего списка свойств.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя присоединяемого элемента в следующем формате: <c>ownerTypeName.MemberName</c>.</param>
        <summary>Возвращает <see cref="T:System.Xaml.XamlMember" /> для конкретного именованного присоединяемого элемента из этого <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlMember" /> для запрошенного присоединяемого элемента или значение <see langword="null" />, если присоединяемого элемента с таким именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 Реализация по умолчанию использует внутреннее отражение CLR. Если <xref:System.Xaml.XamlType.UnderlyingType%2A> равно `null`, реализация по умолчанию может использовать <xref:System.Xaml.XamlType.BaseType%2A>, если она доступна. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAttachableMember%2A> рекурсивно, чтобы попытаться найти допустимый базовый тип, и возвращает значение `null`, если допустимый базовый тип не существует.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых элементов типа XAML, чтобы они больше не выдавались ожидаемым образом с <xref:System.ComponentModel.TypeDescriptor> `Get*` сведениями о базовом типе CLR. Для всех проверок, критических с точки зрения безопасности, для отчетов о членах следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML. Определение этого значения основано на базовом типе данного типа <see cref="T:System.Xaml.XamlType" /> и контексте схемы.</summary>
        <returns>Тип <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 Реализация по умолчанию может возвращать внутреннюю константу, представляющую <xref:System.Object>, если <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых типов данных о типе XAML, чтобы он больше не совпадал с данными системы типов базового типа CLR. Для всех проверок, критических для системы безопасности операций присваивания и доступа, следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение перечисления <see cref="T:System.Xaml.Schema.XamlCollectionKind" />, объявляющее, какой конкретный тип коллекции используется этим типом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Значение перечисления <see cref="T:System.Xaml.Schema.XamlCollectionKind" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутренним закрытым методом (в <xref:System.Xaml.XamlType> не существует общедоступного `CollectionKind` или `GetCollectionKind` API).  
  
 Реализация по умолчанию использует внутреннее отражение CLR. В случаях, когда <xref:System.Xaml.XamlType.UnderlyingType%2A> имеет значение `null`, реализация по умолчанию может использовать <xref:System.Xaml.XamlType.BaseType%2A>, если она доступна. Это поведение косвенно вызывает <xref:System.Xaml.XamlType.LookupCollectionKind%2A> рекурсивно, чтобы попытаться найти допустимый базовый тип. Он возвращает <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>, если допустимый базовый тип не существует. Как правило, реализация по умолчанию пытается найти метод `Add` базового типа путем отражения. Если объект найден, <xref:System.Reflection.MethodInfo> метода `Add` представляет собой достаточно информации, чтобы определить, какое значение <xref:System.Xaml.Schema.XamlCollectionKind> должно возвращаться. В противном случае она возвращает <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, должен ли этот класс <see cref="T:System.Xaml.XamlType" /> иметь аргументы (универсальные ограничения с помощью <see langword="x:TypeArguments" />, текст инициализации или другие технологии языка XAML) для создания допустимого экземпляра этого типа.</summary>
        <returns>Значение <see langword="true" />, если для создания экземпляра требуется некоторое значение аргумента; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 Реализация по умолчанию возвращает `false` для типов, которые считаются типами значений в системе типов CLR. Для других типов значений используется отражение CLR <xref:System.Reflection.ConstructorInfo>, чтобы определить, существует ли конструктор без параметров.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сведения <see cref="T:System.Xaml.XamlMember" /> для свойства содержимого этого класса <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Сведения <see cref="T:System.Xaml.XamlMember" /> для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />. Может иметь значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 Реализация по умолчанию проверяет наличие <xref:System.Windows.Markup.ContentPropertyAttribute> в определении типа. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если эти проверки не обнаруживают тип содержимого, реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы не полагаетесь на внутреннее отражение CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведениях о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает список значений <see cref="T:System.Xaml.XamlType" />, представляющих оболочки содержимого для этого класса <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список значений <see cref="T:System.Xaml.XamlType" />, представляющих оболочки содержимого для этого класса <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оболочка содержимого — это класс, представляющий тип коллекции содержимого, если типы, используемые в этой коллекции, не являются непрерывными для системы типов. Типы элементов сбора для оболочки содержимого должны быть ограничены по сравнению с <xref:System.Object> или эквивалентом нейтрального объекта. Однако это ограничение применяется только при проектировании или назначении свойств, использующих этот тип, а не системы типов. Для типа может существовать более одной оболочки содержимого.  
  
 Пример класса и сценарий из реализации XAML в WPF см. в разделе <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе возвращает реализацию класса <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Реализация <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите этот метод, чтобы обеспечить внутреннее отражение альтернативным способом получения значений атрибута CLR. При отсутствии переопределения внутренний отражатель использует обычную логику отражения CLR.  
  
 Реализация по умолчанию возвращает значение `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, используемый для отложенной загрузки объектов, объявленных в языке XAML.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Xaml.XamlDeferringLoader" /> на универсальный класс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван, когда вызывающий объект получает значение из <xref:System.Xaml.XamlType.DeferringLoader%2A>. Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.DeferringLoader%2A> возвращал другое значение, чем включено внутренним отражением по умолчанию, а также предоставляет пользовательские данные <xref:System.Xaml.Schema.XamlTypeInvoker>.  
  
 Реализация по умолчанию возвращает объект на основе чтения <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, этот метод возвращает `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />, связанный с данным типом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Сведения <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> для данного типа <see cref="T:System.Xaml.XamlType" />; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 Реализация по умолчанию не требует, чтобы <xref:System.Xaml.XamlType> создавался с помощью одного из конструкторов, которые передают начальный <xref:System.Xaml.Schema.XamlTypeInvoker>. Однако для <xref:System.Xaml.XamlType> должно присутствовать значение <xref:System.Xaml.XamlType.UnderlyingType%2A>; в противном случае реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы также создаете производный класс из <xref:System.Xaml.Schema.XamlTypeInvoker> и планируете возвращать производный класс. Если возвращается `null`, <xref:System.Xaml.XamlType.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> в вызывающие объекты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> внешний тип в соответствии с определением языка XAML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет внешний тип; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 Реализация по умолчанию использует отражение CLR для <xref:System.Xaml.XamlType.UnderlyingType%2A> и может проверять базовые типы. Эта реализация проверяет наличие <xref:System.Windows.Markup.AmbientAttribute>, которая применяется к определению соответствующего типа на уровне класса и возвращает `true` в этом случае. Все остальные варианты возвращают `false`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsAmbient%2A> возвращал другое значение, чем включено внутренним отражением по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> конструируемый тип в соответствии с определением языка XAML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 Реализация по умолчанию использует отражение CLR для <xref:System.Xaml.XamlType.UnderlyingType%2A>. Тип должен быть конкретным, не вложенным и закрытым. Реализация по умолчанию проверяет, является ли тип типом значения, и возвращается <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Для значения NULL <xref:System.Xaml.XamlType.UnderlyingType%2A> этот метод возвращает `true`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsConstructible%2A> возвращал другое значение, чем включено внутренним отражением по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли этот класс <see cref="T:System.Xaml.XamlType" /> расширение разметки.</summary>
        <returns>Значение <see langword="true" />, если этот класс <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Реализация по умолчанию состоит только из этого вызова:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsMarkupExtension%2A> использовала другую логику.  
  
 В терминах спецификации XAML этот тип должен быть назначен для `x:MarkupExtension`, чтобы возвратить `true` для <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> область имен XAML в соответствии с определением языка XAML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 Реализация по умолчанию делает вызов <xref:System.Xaml.XamlType.CanAssignTo%2A> косвенно на тип <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> — это интерфейс, определенный в сборке WindowsBase. dll. Этот метод для идентификации области имен XAML используется в реализациях WPF и Windows Workflow Foundation XAML.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsNameScope%2A> использовала другую логику.  
  
 Область имен XAML обеспечивает уникальность имени свойства или свойств, используемых для `x:Name` @ no__t-1 @ no__t-2. Если <xref:System.Xaml.XamlType.IsNameScope%2A> равно `true`, то должен существовать механизм обеспечения уникальности, который должен оцениваться от перспективы этого типа, владеющего областью имен XAML. Затем область имен XAML расширяется до содержимого типа до тех пор, пока не встретится другой тип владельца области видимости имен XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> тип, допускающий значение null, в соответствии с определением языка XAML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет тип, допускающий значение null; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 Реализация по умолчанию выполняет определение на основе концепции CLR базовой библиотеки, которая проверяется на соответствие <xref:System.Xaml.XamlType.UnderlyingType%2A>. Для значения NULL <xref:System.Xaml.XamlType.UnderlyingType%2A> возвращается значение `true`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsNullable%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> открытый тип в соответствующей системе типов.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет открытый тип; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 Реализация по умолчанию использует отражение CLR для <xref:System.Xaml.XamlType.UnderlyingType%2A>, отличного от NULL. Для значения NULL <xref:System.Xaml.XamlType.UnderlyingType%2A> возвращается значение `true`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsPublic%2A> использовала другую логику.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и в других случаях) для изменения сведений о доступе к типу XAML, чтобы он больше не был правильно согласован с системой типов или сведениями о доступе к базовому типу CLR. Для всех проверок, критических для системы безопасности операций присваивания и доступа, следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> тип, который не может быть разрешен в базовой системе типов.</summary>
        <returns>Значение <see langword="true" />, если этот тип <see cref="T:System.Xaml.XamlType" /> представляет неразрешимый тип; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 Реализация по умолчанию может использовать отражение CLR. Для значения NULL <xref:System.Xaml.XamlType.UnderlyingType%2A> возвращается значение `true`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsUnknown%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли этот тип <see cref="T:System.Xaml.XamlType" /> коллекцию, в которой учитываются символы пробелов, в соответствии с определением XML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет коллекцию, в которой учитываются символы пробелов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Он также может проверить значение <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `false`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли данный тип <see cref="T:System.Xaml.XamlType" /> XML-<see langword="XDATA" /> в соответствии с определением языка XAML.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> представляет <see langword="XDATA" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 Реализация по умолчанию делает вызов <xref:System.Xaml.XamlType.CanAssignTo%2A> косвенно на тип <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsXData%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе для свойства <see langword="Items" /> данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> для типа членов в коллекции или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет коллекцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 Реализация по умолчанию может использовать концепции отражения CLR, например проверку метода `Add` с помощью <xref:System.Reflection.MethodInfo> и <xref:System.Reflection.ParameterInfo>; Проверка <xref:System.Xaml.XamlType.IsArray%2A>; и проверка <xref:System.Xaml.XamlType.BaseType%2A> и попытайтесь выполнить ту же логику там.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.ItemType%2A> использовала другую логику. Случаи, когда <xref:System.Xaml.XamlType.LookupCollectionKind%2A> возвращает значение <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>, должно возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе для свойства ключа этого класса <see cref="T:System.Xaml.XamlType" />, если этот класс <see cref="T:System.Xaml.XamlType" /> представляет словарь.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> для типа ключа для использования словаря или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет словарь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 Реализация по умолчанию может использовать концепции отражения CLR, например проверку метода `Add` с помощью <xref:System.Reflection.MethodInfo> и <xref:System.Reflection.ParameterInfo>; и проверка <xref:System.Xaml.XamlType.BaseType%2A> и попытайтесь выполнить ту же логику там.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.KeyType%2A> использовала другую логику. Случаи, когда <xref:System.Xaml.XamlType.LookupCollectionKind%2A> не возвращаются <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType>, должны возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе для возвращенного <see langword="ProvideValue" /> данного типа <see cref="T:System.Xaml.XamlType" />, если он представляет расширение разметки.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> для возвращаемого типа для использования расширения разметки или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет расширение разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> на основе чтения <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `null`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Имя (в виде строки) члена, который требуется получить.</param>
        <param name="skipReadOnlyCheck">Значение <see langword="true" />, если необходимо возвратить член, даже если в этом члене задано значение <see langword="true" /> для свойства <see cref="P:System.Xaml.XamlMember.IsReadOnly" />. Значение <see langword="false" />, чтобы не возвращать член <see cref="P:System.Xaml.XamlMember.IsReadOnly" />. Значение по умолчанию — <see langword="false" />.</param>
        <summary>Возвращает член <see cref="T:System.Xaml.XamlMember" /> для определенного именованного члена из данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Сведения <see cref="T:System.Xaml.XamlMember" /> для члена, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> на основе внутреннего отражения CLR и вычисления с контекстом схемы.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.GetMember%2A> использовала другую логику.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> является виртуальным и, следовательно, может быть переопределен. Переопределение имеет потенциал (как для вредоносных целей, так и других) для изменения сообщаемых элементов типа XAML, чтобы они больше не выдавались ожидаемым образом с <xref:System.ComponentModel.TypeDescriptor> `Get*` сведениями о базовом типе CLR. Для всех проверок, критических с точки зрения безопасности, для отчетов о членах следует использовать базовый тип CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Количество (арность) определенного режима синтаксиса или конструктора, о котором требуется получить сведения.</param>
        <summary>Для типов расширения разметки возвращает типы позиционных параметров, поддерживаемых в конкретном употреблении расширения разметки для данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список значений <see cref="T:System.Xaml.XamlType" />, где каждый такой тип <see cref="T:System.Xaml.XamlType" /> является типом для этой позиции в синтаксисе. При передаче входных данных разметки в расширение разметки необходимо задавать эти типы в том же порядке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 Реализация по умолчанию использует сведения о внутреннем отражении на основе поиска конструкторов и проверки арности. Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.GetPositionalParameters%2A> использовала другую логику.  
  
 Этот API важен только в том случае, если этот <xref:System.Xaml.XamlType> представляет расширение разметки (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> — `true`).  
  
 Входные `parameterCount` не запрашивают тип конкретного позиционированного параметра. Он предназначен для указания арности использования расширения разметки. Использование расширения разметки часто имеет несколько сигнатур и использует разную арность параметров (число) для различения параметров. Однако можно настроить контекст схемы, чтобы разрешить дублирование аритиес и использовать типы позиционированных параметров для различения. Для получения дополнительной информации см. <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Для конкретного счетчика арности позиции и типы параметров могут различаться. Чтобы получить требуемый тип использования расширения разметки определенной арности, сначала необходимо вызвать <xref:System.Xaml.XamlType.GetPositionalParameters%2A> с числом арности. Затем получите элемент в этой позиции из возвращенной коллекции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает обратный вызов обработчика, который нужно использовать для операций установки расширений разметки.</summary>
        <returns>Обратный вызов обработчика, который нужно использовать для операций установки расширения разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает обработчик, используемый для вариантов установки преобразователя типов.</summary>
        <returns>Обработчик, используемый для вариантов установки преобразователя типов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, следует ли сериализовать данный <see cref="T:System.Xaml.XamlType" /> с использованием режима, удаляющего окружающие пробелы.</summary>
        <returns>Значение <see langword="true" />, если данный тип <see cref="T:System.Xaml.XamlType" /> следует сериализовать в режиме, удаляющем окружающие пробелы; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" />, представляющим поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" />, представляющий поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.ComponentModel.TypeConverterAttribute>. Реализация по умолчанию также может проверять <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Он также включает специальную логику для преобразования по умолчанию перечислений, общих типов значений и универсальных шаблонов. Если значение недоступно, оно возвращает `null`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.TypeConverter%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает среду CLR <see cref="T:System.Type" />, которая является базовой для типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Среда CLR <see cref="T:System.Type" />, которая является базовой для типа <see cref="T:System.Xaml.XamlType" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 Реализация по умолчанию возвращает внутреннее поле. Это поле обычно инициализируется во время создания, и его значение основано на том, какой конструктор был вызван, и предоставленной информации.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.UnderlyingType%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, которое показывает, выполняется ли построение этого класса <see cref="T:System.Xaml.XamlType" /> сверху вниз при инициализации языка XAML.</summary>
        <returns>Значение <see langword="true" />, если этот класс <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "Сверху вниз" — это метафора, которая приблизительно соответствует поведению процессора XAML при создании графа объекта. При построении сверху вниз создается экземпляр типа, который прикрепляется к родительскому элементу и задается его свойства. Построение сверху вниз позволяет избежать многократного вызова обработчиков, изменяющих свойства. Такая обработка настраивает граф объектов и, следовательно, устраняет несколько вызовов обработчика и обеспечивает оптимизацию производительности для запуска графа объекта.  
  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Если значение недоступно, оно возвращает `false`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" />, представляющим поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" />, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызвать с помощью вызовов <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтении <xref:System.Windows.Markup.ValueSerializerAttribute>. Он также может проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если в непосредственный базовый тип не найден ни один атрибут. Он также включает специальную логику сериализации по умолчанию для перечислений, общих типов значений или универсальных шаблонов. Если значение недоступно, оно возвращает `null`.  
  
 Переопределите этот метод, если требуется, чтобы <xref:System.Xaml.XamlType.ValueSerializer%2A> использовала другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе для возвращенного значения <see langword="ProvideValue" /> данного типа <see cref="T:System.Xaml.XamlType" />, если он представляет расширение разметки.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для возвращаемого типа для использования расширения разметки или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет расширение разметки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, только если этот <xref:System.Xaml.XamlType> представляет расширение разметки (`x:MarkupExtension` находится в списке назначаемых типов).  
  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое имя типа, представляемого данным типом <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Строковое представление имени этого типа XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно получает имя, сформированное схемой (для подписи <xref:System.Xaml.XamlType.%23ctor%2A>), или имя <xref:System.Type>, если оно создается с помощью подданного конструктора системы типов CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlType1" /> совпадает со значением <paramref name="xamlType2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных объектов <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Значение <see langword="true" />, если значение <paramref name="xamlType1" /> отличается от значения <paramref name="xamlType2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает одно пространство имен XAML, являющееся первичным пространством имен XAML для данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Идентификатор первичного пространства имен XAML для данного типа XAML в виде строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация предоставляет то же значение, что и вызов <xref:System.Xaml.XamlType.GetXamlNamespaces%2A>, а затем получение первой строки значения из возвращенного перечислимого набора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает активный контекст <see cref="T:System.Xaml.XamlSchemaContext" /> для обработки этого класса <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Активный контекст <see cref="T:System.Xaml.XamlSchemaContext" /> для обработки этого класса <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> является обязательной записью параметра при создании <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление данного объекта <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Строковое представление данного объекта <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация <xref:System.Xaml.XamlType> <xref:System.Object.ToString%2A> возвращает свойство <xref:System.Xaml.XamlType.Name%2A> объекта <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли данный тип <see cref="T:System.Xaml.XamlType" /> поведение обработки пробелов для сериализации, выполняющее удаление окружающих пробелов из его содержимого.</summary>
        <value>Значение <see langword="true" />, если этот класс <see cref="T:System.Xaml.XamlType" /> представляет тип, в котором используется удаление пробелов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список типов аргументов для случаев, в которых данный тип <see cref="T:System.Xaml.XamlType" /> представляет универсальный тип.</summary>
        <value>Список типов аргументов или значение <see langword="null" />, если данный тип <see cref="T:System.Xaml.XamlType" /> не представляет универсальный тип.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существуют определенные сценарии для <xref:System.Xaml.XamlType>, где вызов параметра <xref:System.Xaml.XamlType.TypeArguments%2A> возвращает список, в котором типы по-прежнему открыты. В этом случае одно или несколько возвращенных значений <xref:System.Xaml.XamlType> будут иметь значения заполнителей для <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, например `T`, чтобы представить, что универсальный объект все еще открыт. Этот сценарий может возникать, если вы получаете <xref:System.Xaml.XamlType> из вызова <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, а не из реализации средства чтения XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" />, представляющий поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.ComponentModel.TypeConverter" />, представляющий поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupTypeConverter%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupTypeConverter%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает среду CLR <see cref="T:System.Type" />, которая является базовой для типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Среда CLR <see cref="T:System.Type" />, являющаяся базовой для данного типа <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" />, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с ограничением <see cref="T:System.Windows.Markup.ValueSerializer" />, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />, или значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не используете метод внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого свойства могут вызвать переопределение <xref:System.Xaml.XamlType.LookupValueSerializer%2A> для классов, производных от <xref:System.Xaml.XamlType>. Дополнительные сведения о возвращаемых значениях и других поведении см. в документации по <xref:System.Xaml.XamlType.LookupValueSerializer%2A> для этого типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
