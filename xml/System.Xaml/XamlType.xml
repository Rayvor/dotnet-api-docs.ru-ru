<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3faba62692ba6139b45fa826eb8db90e5cf230d2" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014723" /></Metadata><TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сообщает сведения о типах XAML как часть общей системы XAML, реализованной в службах XAML .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие API в <xref:System.Xaml.XamlType> предоставляют сведения о типах XAML, где концепция, они сообщают об аналогична к отдельным частям спецификации XAML [MS-XAML].  
  
 <xref:System.Xaml.XamlType> широко используется в API служб XAML платформы .NET Framework для создания отчетов о типе XAML. <xref:System.Xaml.XamlType> Предоставляет сведения, которые могут потребоваться знать о типе XAML для работы с экземпляром или для доступа к его членам поток узлов XAML или представлением, сходным с XAML. Его отчетов аналогичен тому, как <xref:System.Type> в среде CLR тип системы, вместе с классами отражения, например <xref:System.Reflection.MemberInfo>, содержат сведения о типом CLR и их использование.  
  
 Для расширения системы типов XAML, можно получить из <xref:System.Xaml.XamlType>. Чтобы сделать таким образом, может также потребоваться реализовать <xref:System.Xaml.Schema.XamlTypeInvoker>. <xref:System.Xaml.Schema.XamlTypeInvoker> Позволяет системе универсального типа XAML для работы с системой типов, резервном указываются как часть поведения вызова. Определенные пользовательские <xref:System.Xaml.Schema.XamlTypeInvoker> предоставляет способ уменьшения зависимостей на системе типов CLR, которые используются по умолчанию <xref:System.Xaml.XamlType> поведение.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Базовый CLR <see cref="T:System.Type" /> для создаваемого типа XAML.</param>
        <param name="schemaContext">Контекст схемы XAML для средств чтения XAML и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> класса на основании сведений о базовом типе среды CLR.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько из <paramref name="underlyingType" /> или <paramref name="schemaContext" /> являются <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя создаваемого типа.</param>
        <param name="typeArguments">Аргументы типа для <see cref="T:System.Xaml.XamlType" /> , представляющий универсальный тип. Может быть (и часто является) <see langword="null" />, который указывает, что представленный тип не является универсальным типом.</param>
        <param name="schemaContext">Контекст схемы XAML для средства чтения XAML и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> класс на основе строки имени для типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный конструктор. Нет текущих открытых производных классов существуют, использующих этот конкретный путь для построения. В качестве получателя существующего <xref:System.Xaml.XamlType>, необходимо использовать другие сигнатур конструкторов (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, или <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) для инициализации <xref:System.Xaml.XamlType> объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько из <paramref name="typeName" /> или <paramref name="schemaContext" /> являются <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Базовый тип для создаваемого типа XAML.</param>
        <param name="schemaContext">Контекст схемы XAML для средства чтения XAML.</param>
        <param name="invoker"><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Реализация, которая обрабатывает отражения среды выполнения вызывает от <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> класса на основании сведений о базовом типе и <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> реализации.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько из <paramref name="underlyingType" /> или <paramref name="schemaContext" /> являются <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Пространство имен XAML для типа, в виде строки.</param>
        <param name="unknownTypeName">Имя типа в предоставленном <paramref name="unknownTypeNamespace" /> пространства имен XAML.</param>
        <param name="typeArguments">Аргументы типа для <see cref="T:System.Xaml.XamlType" /> , представляющий универсальный тип. Может быть (и часто является) <see langword="null" />, который указывает, что представленный тип не является универсальным типом.</param>
        <param name="schemaContext">Контекст схемы XAML для средств чтения XAML и записи XAML.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xaml.XamlType" /> класс на основе пространства имен XAML и строки имени для типа. Этот конструктор предназначен исключительно для анализа и записи в узлы XAML использований типов, которые заведомо не зарезервированы в базовой системе типов и контекст схемы XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор только для типов «unknown», где недоступен тип XAML, который сопоставляется с базовой системе типов. Этот конструктор не может выдавать результат где <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> является `true`. Вместо этого логика по умолчанию reflector сообщает базовый тип, что <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Тем не менее, это поведение может измениться из-за <xref:System.Xaml.XamlType.LookupIsUnknown%2A> переопределить.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Один или несколько из <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" />, или <paramref name="schemaContext" /> являются <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию типов, которые могут использоваться в качестве <see cref="P:System.Xaml.XamlType.ContentProperty" /> значение для данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Только для чтения коллекция возможных типов содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типы, которые можно назначить конкретный тип содержимого (например, может быть назначен для базового типа, который имеет допустимый тип содержимого) не считаются несколько типов для целей <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML. Определение этого значения основан на базовом типе данного типа <see cref="T:System.Xaml.XamlType" /> и контекст схемы.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> Для непосредственного базового типа данного типа XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupBaseType%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupBaseType%2A> для данного типа. По умолчанию <xref:System.Xaml.XamlType.BaseType%2A> возвращает внутренней константа, которая представляет <xref:System.Object> Если <xref:System.Xaml.XamlType.UnderlyingType%2A> является `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) чтобы изменить сведения о типе сообщаемые о типе XAML таким образом, чтобы он больше не соответствуют ожидаемым образом информации о системе типов из его базового типа CLR. Для проверок с точки зрения безопасности операции присваивания и доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Тип, который необходимо проверить на соответствие текущим <see cref="T:System.Xaml.XamlType" /> .</param>
        <summary>Возвращает значение, указывающее, является ли экземпляр этого <see cref="T:System.Xaml.XamlType" /> имеет заданное <see cref="T:System.Xaml.XamlType" /> в своем списке присваиваемых типов.</summary>
        <returns><see langword="true" /> Если <paramref name="xamlType" /> находится в списке присваиваемых типов; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что может быть назначен тип не имеет все возможности ссылочного типа, его можно использовать для назначения. Например можно использовать назначение, чтобы установить соответствия типов для значений свойства. Понятие присваиваемых типов в XAML аналогичен понятие приведения с повышением в системе типов CLR. Например, в разделе системы типов среды CLR, каждый тип имеет <xref:System.Object> в своем списке присваиваемых типов.  
  
 Если один из двух <xref:System.Xaml.XamlType> экземпляров, которые используются для сравнения имеет <xref:System.Xaml.XamlType.IsUnknown%2A> равным `true`, этот метод имеет специальный Неизвестный режим, который возвращает `true` Если два <xref:System.Xaml.XamlType> экземпляра эквивалентны.  
  
 Реализация по умолчанию использует CLR <xref:System.Type> из <xref:System.Xaml.XamlType.UnderlyingType%2A> для данного <xref:System.Xaml.XamlType> входных данных и <xref:System.Xaml.XamlType>и вызывает метод <xref:System.Type.IsAssignableFrom%2A>. Переопределите этот метод, если требуется другой определение присваиваемых типов.  
  
 Передача пустого `xamlType` не выдает исключение и всегда возвращает `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) чтобы изменить возможности назначения типа XAML таким образом, чтобы он больше не соответствуют ожидаемым образом поведение приведения типа базового типа CLR. Для проверок с точки зрения безопасности операции присваивания и доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее ли это <see cref="T:System.Xaml.XamlType" /> должны иметь аргументы (универсальные ограничения с помощью <see langword="x:TypeArguments" />, текста инициализации или другие функции XAML) для создания допустимого экземпляра типа.</summary>
        <value><see langword="true" /> Если для создания экземпляра требуется некоторое значение аргумента; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.XamlMember" /> сведения для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value><see cref="T:System.Xaml.XamlMember" /> сведения для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />. Может быть <see langword="null" /> Если свойство содержимого отсутствует.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если с использованием привязки или резервном системы типов среды CLR, свойство содержимого XAML можно указать в типе, применив <xref:System.Windows.Markup.ContentPropertyAttribute> к определению типа.  
  
 Это свойство соответствует `[content property]` информационный элемент в спецификации [MS-XAML].  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupContentProperty%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupContentProperty%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает типы, которые используются для создания оболочки свойства содержимого, когда она не соответствует строгого типа, например строки в строго типизированный <see langword="Collection&lt;T&gt;" />.</summary>
        <value>Только для чтения коллекция возможных типов оболочки содержимого; в противном случае <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если нет оболочек, с учетом ослаблении соответствия типов, это свойство является `null`.  
  
 Типы, которые интерпретируются как <xref:System.Xaml.XamlType.CanAssignTo%2A> для определенного типа содержимого не учитываются несколько типов для целей <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 В привязке CLR для <xref:System.Xaml> и <xref:System.Xaml.XamlType>, типов оболочки содержимого XAML может быть указан для типа в качестве <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupContentWrappers%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupContentWrappers%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> , представляющий отложенной загрузке поведение преобразования для этого типа.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> С <see cref="T:System.Xaml.XamlDeferringLoader" /> ограничение, которое представляет поведение отложенной загрузки для этого типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение шаблона XAML в WPF является примером поведения отложенной загрузки.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, равен ли текущий объект другому объекту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, сравниваемый с данным объектом.</param>
        <summary>Указывает, равен ли текущий объект другому объекту.</summary>
        <returns><see langword="true" />, если текущий объект эквивалентен параметру <paramref name="obj" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        <summary>Указывает, эквивалентен ли текущий объект другому объекту того же типа.</summary>
        <returns><see langword="true" />, если текущий объект эквивалентен параметру <paramref name="other" />, в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Директива, для которого необходимо найти член с псевдонимом.</param>
        <summary>Возвращает элемент XAML, который связан псевдонимом с директивой XAML в данном <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Член с псевдонимом, если найден; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, содержащую все присоединяемые свойства, предоставляемые этим <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Коллекция, содержащая ноль или более <see cref="T:System.Xaml.XamlMember" /> значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый <xref:System.Xaml.XamlMember> в возвращаемой коллекции должен содержать значения, которые поддерживают концепцию, <xref:System.Xaml.XamlMember> является присоединяемым членом. Например, члены должны возвращать `true` для <xref:System.Xaml.XamlMember.IsAttachable%2A>, тип для <xref:System.Xaml.XamlMember.TargetType%2A>, и т. д.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, содержащую все члены, предоставляемые данным объектом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Коллекция, содержащая ноль или более <see cref="T:System.Xaml.XamlMember" /> значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupAllMembers%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя присоединяемого элемента в следующем формате: <c>ownerTypeName.MemberName</c>.</param>
        <summary>Возвращает элемент <see cref="T:System.Xaml.XamlMember" />, который представляет определенный именованный присоединяемый элемент <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlMember" /> для запрошенного присоединяемого элемента или значение <see langword="null" />, если присоединяемого элемента с таким именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupAttachableMember%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) изменить сообщаемые члены типа XAML, чтобы они больше не согласовывались с ожидаемым образом <xref:System.ComponentModel.TypeDescriptor> `Get*` сведения о базовый тип среды CLR. Для проверок с точки зрения безопасности элементов отчетов используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для этого объекта.</summary>
        <returns>Целочисленный хэш-код.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя члена, который требуется получить (в виде строки).</param>
        <summary>Возвращает <see cref="T:System.Xaml.XamlMember" /> для определенного именованного члена из данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> Сведения для члена, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение для `name` должен иметь неточных имен. Имена с указанием типа, указывающие присоединенного члена, которые передаются <xref:System.Xaml.XamlType.GetAttachableMember%2A> вместо этого. Префикс член, к которому не следует использовать имена; префикс зависит от конкретной ситуации использования и системе типов XAML не может знать контекст такого использования и способ сопоставления префикса.  
  
 Вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupMember%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) изменить сообщаемые члены типа XAML, чтобы они больше не согласовывались с ожидаемым образом <xref:System.ComponentModel.TypeDescriptor> `Get*` сведения о базовый тип среды CLR. Для проверок с точки зрения безопасности элементов отчетов используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Количество (арность) определенного режима синтаксиса или конструктора, который вам нужны сведения о.</param>
        <summary>Для типов расширения разметки возвращает типы позиционных параметров, которые поддерживаются в конкретном употреблении расширения разметки для данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список <see cref="T:System.Xaml.XamlType" /> значения, где каждый <see cref="T:System.Xaml.XamlType" /> является типом для этой позиции в синтаксисе. Необходимо указать типы в том же порядке, при передаче входных данных для расширения разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот API применяется, только если это <xref:System.Xaml.XamlType> представляет расширение разметки (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> — `true`).  
  
 Входные данные `parameterCount` не запрашивает тип конкретного позиционного параметра. Он предназначен для указания арности использования расширения разметки. Использование расширения разметки часто имеет несколько «сигнатур» и использует для различения разных арность (количество) позиционных параметров. Тем не менее можно настроить контекст схемы, чтобы разрешить дублирование арностей и использовать для дифференциации типы позиционных параметров. Дополнительные сведения см. в разделе <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Для конкретной арности (количества) позиции и типы параметров могут различаться. Чтобы получить позиционные тип использования расширения разметки конкретной арности, сначала вызовите <xref:System.Xaml.XamlType.GetPositionalParameters%2A> Указание количества арности. Затем получите элемент в этой позиции из возвращенной коллекции.  
  
 Вызовы этого метода можно вызвать <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список строковых идентификаторов для пространств имен XAML, которые входит этот тип.</summary>
        <returns>Список строковых значений, где каждая строка представляет идентификатор URI для пространства имен XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичный идентификаторов пространства имен XAML — это строки в форме URI.  
  
 Реализация по умолчанию проверяет в следующем порядке: пространство имен XAML, которое предоставляется в конструкции (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> только подпись); и пространства имен, которые доступны из контекста схемы. Если все элементы данного `null`, создается новый список, который содержит одну пустую строку. Можно переопределить этот метод, чтобы изменить методологию подстановки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> реализации, который связан с данным <see cref="T:System.Xaml.XamlType" />.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Реализации, который связан с данным <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызов <xref:System.Xaml.XamlType.Invoker%2A> можно вызвать либо <xref:System.Xaml.XamlType.LookupInvoker%2A> или конкретного переопределения этого метода. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupInvoker%2A> для данного типа.  
  
 Если <xref:System.Xaml.XamlType.LookupInvoker%2A> переопределить возвращает `null`, или реализация по умолчанию возвращает `null` из-за недостатка <xref:System.Xaml.XamlType.UnderlyingType%2A> для данного <xref:System.Xaml.XamlType>, затем <xref:System.Xaml.XamlType.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет внешний тип в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет внешний тип; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsAmbient%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsAmbient%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет массив.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет массив; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupCollectionKind%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет коллекцию.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет коллекцию; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupCollectionKind%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует `[is default constructible]` информационный элемент в спецификации [MS-XAML].  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsConstructible%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsConstructible%2A> для данного типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет словарь, в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет словарь; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует `[is dictionary]` информационный элемент в спецификации [MS-XAML].  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupCollectionKind%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupCollectionKind%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет универсальный тип.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет универсальный тип; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является вспомогательное свойство, которое проверяет наличие значения null <xref:System.Xaml.XamlType.TypeArguments%2A>. Есть конкретные `Lookup` метод связанные с <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В терминах спецификации XAML, этот тип должен быть назначен `x:MarkupExtension` для возвращения `true` для <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область видимости имен XAML обеспечивает уникальность имени свойства или свойств, используемых для `x:Name`  /  `[name property]`. Если <xref:System.Xaml.XamlType.IsNameScope%2A> является `true`, должна существовать какой-либо механизм для обеспечения уникальности и необходимо оценить с точки зрения этого типа, которой принадлежит области видимости имен XAML. Область видимости имен XAML затем распространяется на содержимое типа, пока не будет обнаружен другой тип-владелец области видимости имен XAML.  
  
 Это свойство соответствует `[is name scope]` информационный элемент в спецификации [MS-XAML].  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsNameScope%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> инициализируется с использованием допустимой <see langword="xamlName" /> строку в качестве его <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> инициализируется с использованием допустимой <see langword="xamlName" /> строка; в противном случае <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет допускающее значение NULL тип в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет тип, допускающий значение NULL; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует `[is nullable]` информационный элемент в спецификации [MS-XAML].  
  
 Если вы не используете отражения методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsNullable%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет открытый тип в соответствующей системе типов.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет открытый тип; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsPublic%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) для изменения доступа сведений о типе XAML, таким образом, чтобы он больше не соответствуют ожидаемым образом системы и доступа к информации о типе его базовый тип среды CLR. Для проверок с точки зрения безопасности операции присваивания и доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет тип, который не может быть разрешен в базовой системе типов.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет Неразрешимый тип; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsUnknown%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов.  
  
 Для пути загрузки, который включает в себя <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlType> с `true` для <xref:System.Xaml.XamlType.IsUnknown%2A> не может быть записан в граф объекта. В реализации по умолчанию в <xref:System.Xaml> , <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> вызова вызывает <xref:System.Xaml.XamlObjectWriterException> при соответствующие <xref:System.Xaml.XamlType> отчеты `true` для <xref:System.Xaml.XamlType.IsUnknown%2A>. Не следует передавать <xref:System.Xaml.XamlType> с <xref:System.Xaml.XamlType.IsUnknown%2A> как `true` Если вы не готовы для обработки исключений из <xref:System.Xaml.XamlObjectWriter>, или у вас есть другие способы настройки <xref:System.Xaml.XamlObjectWriter> поведение или поток узлов XAML перед записью объекта граф.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сверху вниз — метафора, приблизительно моделирует поведение обработчика XAML при создании графа объекта. При построении сверху вниз, создается экземпляр типа, прикрепленная к родительскому объекту, а затем настраиваются его свойства. Построение сверху вниз позволяет избежать вызова обработчики property-changed несколько раз. Такая обработка приведет к нарушению графа объектов и таким образом, исключает несколько вызовов обработчика и поддерживает оптимизировать производительность при запуске графа объектов.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> для данного типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет коллекцию значащих символов пробелов, в соответствии с определением XML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет коллекцию значащих символов пробелов; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет XML <see langword="XDATA" />, в соответствии с определением XAML.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет <see langword="XDATA" />; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует `[is xdata]` информационный элемент в спецификации [MS-XAML].  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsXData%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsXData%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе <see langword="Items" /> свойства данного объекта <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа элементов в коллекции; в противном случае <see langword="null" />, если данный <see cref="T:System.Xaml.XamlType" /> представляет коллекцию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство применяется, только если это <xref:System.Xaml.XamlType> представляет коллекцию (<xref:System.Xaml.XamlType.IsCollection%2A> — `true`). `Items` Свойство является любое свойство содержит элементы в этом типе коллекции или массива.  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupItemType%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupItemType%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе для свойства ключа этого <see cref="T:System.Xaml.XamlType" />, если <see cref="T:System.Xaml.XamlType" /> представляет словарь.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> для типа ключа для использования словаря, в противном случае — <see langword="null" />, если данный <see cref="T:System.Xaml.XamlType" /> не представляет словарь.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство применяется, только если это <xref:System.Xaml.XamlType> представляет словарь (<xref:System.Xaml.XamlType.IsDictionary%2A> — `true`).  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupKeyType%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupKeyType%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Директива, для которого необходимо найти член с псевдонимом.</param>
        <summary>Возвращает элемент XAML, который связан псевдонимом с директивой XAML в данном <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Член с псевдонимом, если найден; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 Реализация по умолчанию может возвращать результаты для следующих директив XAML: `Key`; `Name`; `Uid`; и `xml:lang`. Значения для этих зависят от базового отражения и по-прежнему могут возвращать `null` если связанное свойство не найден.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемый набор, содержащий все присоединяемые свойства, предоставляемые этим объектом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Перечисляемый набор, содержащий ноль или более <see cref="T:System.Xaml.XamlMember" /> значения; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Несмотря на то что <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> возвращает универсальную коллекцию, это `Lookup` метод возвращает универсальный перечисляемого набора.  
  
 Реализация по умолчанию использует внутреннее отражение среды CLR. Когда <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`, реализация по умолчанию можно использовать <xref:System.Xaml.XamlType.BaseType%2A>, если он доступен. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> рекурсивно, чтобы попытаться найти является допустимым базовым типом и возвращает `null` Если допустимый базового типа не существует.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа. Возвращаемое значение null необходимо зарезервировать для случаев, где сведения невозможно определить из-за отсутствия поддержки системы или отражения типа. Если тип является допустимым и доступны отражения или другие функции, но тип не имеет присоединяемых членов, вместо этого следует возвращать пустой <xref:System.Collections.Generic.IEnumerable%601> значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисляемый набор, содержащий все члены, предоставляемые данным объектом <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Перечисляемый набор, содержащий ноль или более <see cref="T:System.Xaml.XamlMember" /> значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Несмотря на то что <xref:System.Xaml.XamlType.GetAllMembers%2A> возвращает универсальную коллекцию, это `Lookup` метод возвращает универсальный перечисляемого набора.  
  
 Реализация по умолчанию использует внутреннее отражение среды CLR. Для случаев, где <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`, реализация по умолчанию можно использовать <xref:System.Xaml.XamlType.BaseType%2A>, если он доступен. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAllMembers%2A> рекурсивно, чтобы попытаться найти является допустимым базовым типом и возвращает `null` Если допустимый базового типа не существует.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа. Возвращаемое значение null необходимо зарезервировать для случаев, где сведения невозможно определить из-за отсутствия поддержки системы или отражения типа. Если тип является допустимым, доступны отражения или другие методы; Если тип не содержит члены, вместо этого следует возвращать пустой <xref:System.Collections.Generic.IEnumerable%601> значение.  
  
 Возвращаемые значения для <xref:System.Xaml.XamlType.LookupAllMembers%2A> и <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> должны быть взаимоисключающими. При наличии ситуации, где тип системного свойства резервного может поддерживать использование стандартного экземпляра, а также использование присоединяемого члена должны сопровождаться двумя разными <xref:System.Xaml.XamlMember> значений с одним значением, появляются в списке присоединяемого, а другой в Список стандартных элементов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает список типов, которые могут использоваться в качестве <see cref="P:System.Xaml.XamlType.ContentProperty" /> значение для данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список возможных типов содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Типы, которые интерпретируются как <xref:System.Xaml.XamlType.CanAssignTo%2A> для определенного типа содержимого не учитываются несколько типов для целей <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Реализация по умолчанию можно использовать другие свойства <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, или <xref:System.Xaml.XamlType.ItemType%2A>) для получения результата. `Lookup` Переопределяет для вышеуказанных свойство также может вызываться в этом определении.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя присоединяемого элемента в следующем формате: <c>ownerTypeName.MemberName</c>.</param>
        <summary>Возвращает <see cref="T:System.Xaml.XamlMember" /> для конкретного именованного присоединяемого элемента из этого <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlMember" /> для запрошенного присоединяемого элемента или значение <see langword="null" />, если присоединяемого элемента с таким именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 Реализация по умолчанию использует внутреннее отражение среды CLR. Когда <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`, реализация по умолчанию можно использовать <xref:System.Xaml.XamlType.BaseType%2A>, если он доступен. Это поведение вызывает <xref:System.Xaml.XamlType.LookupAttachableMember%2A> рекурсивно, чтобы попытаться найти является допустимым базовым типом и возвращает `null` Если допустимый базового типа не существует.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) изменить сообщаемые члены типа XAML, чтобы они больше не согласовывались с ожидаемым образом <xref:System.ComponentModel.TypeDescriptor> `Get*` сведения о базовый тип среды CLR. Для проверок с точки зрения безопасности элементов отчетов используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.XamlType" /> для непосредственного базового типа данного типа XAML. Определение этого значения основан на базовом типе данного типа <see cref="T:System.Xaml.XamlType" /> и контекст схемы.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> Для непосредственного базового типа данного типа XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 Реализация по умолчанию может возвращать Внутренняя константа, которая представляет <xref:System.Object> Если <xref:System.Xaml.XamlType.UnderlyingType%2A> является `null`.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) чтобы изменить сведения о типе сообщаемые о типе XAML таким образом, чтобы он больше не соответствуют ожидаемым образом информации о системе типов из его базового типа CLR. Для проверок с точки зрения безопасности операции присваивания и доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> тип перечисления, который объявляет какие определенной коллекции, это <see cref="T:System.Xaml.XamlType" /> использует.</summary>
        <returns>Значение <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутреннего частного метода (без общего `CollectionKind` или `GetCollectionKind` API существует на <xref:System.Xaml.XamlType>).  
  
 Реализация по умолчанию использует внутреннее отражение среды CLR. Для случаев, где <xref:System.Xaml.XamlType.UnderlyingType%2A> — `null`, реализация по умолчанию можно использовать <xref:System.Xaml.XamlType.BaseType%2A>, если он доступен. Это поведение косвенно вызывает <xref:System.Xaml.XamlType.LookupCollectionKind%2A> рекурсивно, чтобы попытаться найти является допустимым базовым типом; он возвращает <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> Если допустимый базового типа не существует. Как правило, реализация по умолчанию пытается найти `Add` метод базового типа путем отражения. Если найден, <xref:System.Reflection.MethodInfo> из `Add` метод является достаточно информации, чтобы определить, какие <xref:System.Xaml.Schema.XamlCollectionKind> должно возвращаться значение. В противном случае она возвращает <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее ли это <see cref="T:System.Xaml.XamlType" /> должны иметь аргументы (универсальные ограничения с помощью <see langword="x:TypeArguments" />, текста инициализации или другие функции XAML) для создания допустимого экземпляра типа.</summary>
        <returns><see langword="true" /> Если для создания экземпляра требуется некоторое значение аргумента; в противном случае — значение false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 Реализация по умолчанию возвращает `false` система типов для типов, которые считаются значения типов данных CLR. Для строки, отличный от типов значений, отражение среды CLR <xref:System.Reflection.ConstructorInfo> позволяет определить, существует ли конструктор по умолчанию.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.XamlMember" /> сведения для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> сведения для свойства содержимого данного типа <see cref="T:System.Xaml.XamlType" />. Может иметь значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 Реализация по умолчанию проверяет наличие <xref:System.Windows.Markup.ContentPropertyAttribute> в определении типа. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если эти проверки не позволяют обнаруживать типом содержимого, реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы не полагаться на внутреннее отражение среды CLR по умолчанию и используете метаданные или другие методы для создания отчетов о системе типов XAML или сведения о схеме типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает список <see cref="T:System.Xaml.XamlType" /> значений, представляющих оболочки содержимого для этого <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список <see cref="T:System.Xaml.XamlType" /> значений, представляющих оболочки содержимого для этого <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оболочка содержимого — это класс, который представляет тип содержимого коллекции, типы, используемые в этой коллекции не являются смежными в систему типов. Типы элементов коллекции для содержимого оболочки должны быть ограничены определенным образом помимо <xref:System.Object> или нейтральным эквивалентом объекта. Тем не менее это ограничение применяется только намеренно или в целях свойств, использующих этот тип, а не в систему типов. Более чем одной оболочки содержимого могут существовать в типе.  
  
 Пример класса и сценарий из реализации WPF XAML, см. в разделе <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При реализации в производном классе возвращает <see cref="T:System.Reflection.ICustomAttributeProvider" /> реализации.</summary>
        <returns>Реализация <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите этот метод для предоставления внутреннее отражение альтернативный способ получения значений атрибутов CLR. В отсутствие переопределения внутренний объект, отражающий использует типичные логику отражения среды CLR.  
  
 Реализация по умолчанию возвращает значение `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> объект, который используется для отложенной загрузки объектов, объявленных в XAML.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Xaml.XamlDeferringLoader" /> ограничения для универсального.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться, когда вызывающий объект возвращает значение из <xref:System.Xaml.XamlType.DeferringLoader%2A>. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.DeferringLoader%2A> для возвращают другое значение не включено по умолчанию внутреннего отражения и, также предоставляют пользовательские <xref:System.Xaml.Schema.XamlTypeInvoker> сведения.  
  
 Реализация по умолчанию возвращает объект, на основании чтения <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение недоступно, этот метод возвращает `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> , связанного с данным <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> Сведения для этого <see cref="T:System.Xaml.XamlType" />; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 Реализация по умолчанию не требует <xref:System.Xaml.XamlType> создаваться с помощью одного из конструкторов, которые передают первоначальный <xref:System.Xaml.Schema.XamlTypeInvoker>. Тем не менее <xref:System.Xaml.XamlType.UnderlyingType%2A> значение должно существовать для <xref:System.Xaml.XamlType>; в противном случае реализация по умолчанию возвращает `null`.  
  
 Переопределите этот метод, если вы также создать класс, производный от <xref:System.Xaml.Schema.XamlTypeInvoker> и должны возвращать производного класса. Если возвращается `null`, <xref:System.Xaml.XamlType.Invoker%2A> возвращает <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> вызывающим объектам.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет внешний тип в соответствии с определением XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет внешний тип; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 Реализация по умолчанию использует отражение среды CLR на <xref:System.Xaml.XamlType.UnderlyingType%2A> и может проверить базовые типы. Эта реализация проверяет <xref:System.Windows.Markup.AmbientAttribute> , применяемый к определению соответствующего типа на уровне класса и возвращающий `true` в данном случае. Во всех остальных случаях возвращают `false`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsAmbient%2A> для возвращают другое значение, не включена по умолчанию внутреннего отражения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип в соответствии с определением XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет конструируемый тип; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 Реализация по умолчанию использует отражение среды CLR на <xref:System.Xaml.XamlType.UnderlyingType%2A>. Тип должен быть конкретные, невложенными и закрыт. Реализация по умолчанию проверяет, является ли тип типом значения и возвращение <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Значение NULL, <xref:System.Xaml.XamlType.UnderlyingType%2A>, этот метод возвращает `true`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsConstructible%2A> для возвращают другое значение, не включена по умолчанию внутреннего отражения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет расширение разметки; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Реализация по умолчанию состоит только из этого вызова.  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsMarkupExtension%2A> использовать другую логику.  
  
 В терминах спецификации XAML, этот тип должен быть назначен `x:MarkupExtension` для возвращения `true` для <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML в соответствии с определением XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет область имен XAML; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 Реализация по умолчанию создает <xref:System.Xaml.XamlType.CanAssignTo%2A> косвенно вызывать по типу <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> представляет собой интерфейс, который определен в сборке WindowsBase.dll. Этот метод для идентификации области видимости имен XAML используется одновременно реализации XAML WPF и Windows Workflow Foundation.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsNameScope%2A> использовать другую логику.  
  
 Область видимости имен XAML обеспечивает уникальность имени свойства или свойств, используемых для `x:Name`  /  `[name property]`. Если <xref:System.Xaml.XamlType.IsNameScope%2A> — `true`, то какой-либо механизм для обеспечения уникальности должна существовать и необходимо оценить с точки зрения этого типа, которой принадлежит области видимости имен XAML. Область видимости имен XAML затем распространяется на содержимое типа, пока не будет обнаружен другой тип-владелец области видимости имен XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет допускающее значение NULL тип в соответствии с определением XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет тип, допускающий значение NULL; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 Реализация по умолчанию создает определение, в зависимости от среды CLR core библиотека допускает значения NULL понятия, проверяются на соответствие <xref:System.Xaml.XamlType.UnderlyingType%2A>. Значение NULL, <xref:System.Xaml.XamlType.UnderlyingType%2A>, он возвращает `true`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsNullable%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет открытый тип в соответствующей системе типов.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет открытый тип; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 Реализация по умолчанию использует отражение среды CLR для ненулевой <xref:System.Xaml.XamlType.UnderlyingType%2A>. Значение NULL, <xref:System.Xaml.XamlType.UnderlyingType%2A>, он возвращает `true`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsPublic%2A> использовать другую логику.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) для изменения доступа сведений о типе XAML, таким образом, чтобы он больше не соответствуют ожидаемым образом системы или доступа к информации о типе его базовый тип среды CLR. Для проверок с точки зрения безопасности операции присваивания и доступа используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет тип, который не может быть разрешен в базовой системе типов.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет Неразрешимый тип; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 Реализация по умолчанию можно использовать отражение среды CLR. Значение NULL, <xref:System.Xaml.XamlType.UnderlyingType%2A>, он возвращает `true`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsUnknown%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет коллекцию значащих символов пробелов, в соответствии с определением XML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет коллекцию значительных пробелов; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение не доступен, он возвращает `false`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> представляет XML <see langword="XDATA" />, в соответствии с определением XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет <see langword="XDATA" />; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 Реализация по умолчанию создает <xref:System.Xaml.XamlType.CanAssignTo%2A> косвенно вызывать по типу <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsXData%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе <see langword="Items" /> свойства данного объекта <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> для типа элементов в коллекции; в противном случае <see langword="null" /> Если <see cref="T:System.Xaml.XamlType" /> представляет коллекцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 Реализация по умолчанию можно использовать концепций отражения среды CLR, такие как проверка `Add` метод, с помощью <xref:System.Reflection.MethodInfo> и с помощью <xref:System.Reflection.ParameterInfo>; проверки <xref:System.Xaml.XamlType.IsArray%2A>; и проверка <xref:System.Xaml.XamlType.BaseType%2A> и ту же логику.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.ItemType%2A> использовать другую логику. Ситуации, когда <xref:System.Xaml.XamlType.LookupCollectionKind%2A> возвращает <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> должен возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе для свойства ключа этого <see cref="T:System.Xaml.XamlType" />, если <see cref="T:System.Xaml.XamlType" /> представляет словарь.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> для типа ключа для использования словаря или <see langword="null" /> Если <see cref="T:System.Xaml.XamlType" /> не представляет словарь,</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 Реализация по умолчанию можно использовать концепций отражения среды CLR, такие как проверка `Add` метод, с помощью <xref:System.Reflection.MethodInfo> и с помощью <xref:System.Reflection.ParameterInfo>; и проверка <xref:System.Xaml.XamlType.BaseType%2A> и ту же логику.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.KeyType%2A> использовать другую логику. Ситуации, когда <xref:System.Xaml.XamlType.LookupCollectionKind%2A> не возвращает <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> должен возвращать `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, предоставляющее сведения о типе для возвращенного <see langword="ProvideValue" /> этого <see cref="T:System.Xaml.XamlType" />, если он представляет расширение разметки.</summary>
        <returns>Объект <see cref="T:System.Xaml.XamlType" /> объект для возвращаемого типа для использования расширения разметки; в противном случае <see langword="null" />, если данный <see cref="T:System.Xaml.XamlType" /> не представляет расширение разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> на основании чтения <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение не доступен, он возвращает `null`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Имя члена, который требуется получить (в виде строки).</param>
        <param name="skipReadOnlyCheck"><see langword="true" /> для возврата элемента, даже если этот элемент имеет <see langword="true" /> значение <see cref="P:System.Xaml.XamlMember.IsReadOnly" />; <see langword="false" /> не будет возвращать <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> член. Значение по умолчанию — <see langword="false" />.</param>
        <summary>Возвращает <see cref="T:System.Xaml.XamlMember" /> для определенного именованного члена из данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" /> Сведения для члена, если он найден; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 Реализация по умолчанию возвращает <xref:System.Xaml.XamlType> на основе внутреннего отражения среды CLR и оценки в контексте схемы.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.GetMember%2A> использовать другую логику.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> является виртуальным и таким образом, может быть переопределен. Переопределение обладает потенциалом (вредоносных целях или иным способом) изменить сообщаемые члены типа XAML, чтобы они больше не согласовывались с ожидаемым образом <xref:System.ComponentModel.TypeDescriptor> `Get*` сведения о базовый тип среды CLR. Для проверок с точки зрения безопасности элементов отчетов используйте базовый тип среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Количество (арность) определенного режима синтаксиса или конструктора, который вам нужны сведения о.</param>
        <summary>Для типов расширения разметки возвращает типы позиционных параметров, которые поддерживаются в конкретном употреблении расширения разметки для данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Список <see cref="T:System.Xaml.XamlType" /> значения, у которых каждый такой <see cref="T:System.Xaml.XamlType" /> является типом для этой позиции в синтаксисе. Необходимо указать эти типы в том же порядке, при передаче входных данных для расширения разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 Реализация по умолчанию использует внутреннее отражение сведения с учетом поиск конструкторов и проверке арности. Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.GetPositionalParameters%2A> использовать другую логику.  
  
 Этот API применяется, только если это <xref:System.Xaml.XamlType> представляет расширение разметки (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> — `true`).  
  
 Входные данные `parameterCount` не запрашивает тип конкретного позиционного параметра. Он предназначен для указания арности использования расширения разметки. Использование расширения разметки часто имеет несколько сигнатур и используется для различения различная арность (количество) позиционных параметров. Тем не менее можно настроить контекст схемы, чтобы разрешить дублирование арностей и использовать для дифференциации типы позиционных параметров. Дополнительные сведения см. в разделе <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Для конкретного количества арности позиции и типы параметров могут различаться. Чтобы получить позиционные тип использования расширения разметки конкретной арности, сначала вызовите <xref:System.Xaml.XamlType.GetPositionalParameters%2A> с количеством арности. Затем получите элемент в этой позиции из возвращенной коллекции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает обратный вызов обработчика для операций установки расширения разметки.</summary>
        <returns>Обработчик обратного вызова для операций установки расширения разметки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение недоступно, возвращается `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает обработчик, используемый для вариантов установки преобразователя типов.</summary>
        <returns>Обработчик, используемый для вариантов установки преобразователя типов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение недоступно, возвращается `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, следует ли сериализовать данный <see cref="T:System.Xaml.XamlType" /> с использованием режима, удаляющего окружающие пробелы.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> должно быть сериализовано в режима, удаляющего окружающие пробелы; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение недоступно, возвращается `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.ComponentModel.TypeConverter" /> ограничение, которое представляет поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.ComponentModel.TypeConverter" /> ограничение, представляющий поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.ComponentModel.TypeConverterAttribute>. Реализация по умолчанию можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Он также включает специальную логику для преобразования по умолчанию перечислений, общих типов значений и универсальных шаблонов. Если значение недоступно, возвращается `null`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.TypeConverter%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает CLR <see cref="T:System.Type" /> , является базовой для типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Среда CLR <see cref="T:System.Type" /> , является базовой для типа <see cref="T:System.Xaml.XamlType" />; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 Реализация по умолчанию возвращает внутреннее поле. Обычно это поле инициализируется во время построения и его значение основано на какой конструктор был вызван и сведения, которые вы указали.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.UnderlyingType%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML.</summary>
        <returns><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> строится сверху вниз в ходе инициализации XAML; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сверху вниз — метафора, приблизительно моделирует поведение обработчика XAML при создании графа объектов. При построении сверху вниз, создается экземпляр типа, прикрепленная к родительскому объекту, и его свойства установки для свойства. Построение сверху вниз позволяет избежать вызова обработчики property-changed несколько раз. Такая обработка приведет к нарушению графа объектов и таким образом, исключает несколько вызовов обработчика и поддерживает оптимизировать производительность при запуске графа объектов.  
  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Если значение недоступно, возвращается `false`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничение, которое представляет поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничение, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />; в противном случае <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может вызываться путем вызова <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 Реализация по умолчанию возвращает значение, основанное на чтения <xref:System.Windows.Markup.ValueSerializerAttribute>. Можно также проверить <xref:System.Xaml.XamlType.BaseType%2A> для атрибута, если атрибут не найден на непосредственного базового типа. Он также включает специальную логику сериализации по умолчанию перечислений, общих типов значений или универсальных шаблонов. Если значение недоступно, возвращается `null`.  
  
 Переопределите этот метод, если вы хотите, чтобы <xref:System.Xaml.XamlType.ValueSerializer%2A> использовать другую логику.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, предоставляющее сведения о типе для возвращенного <see langword="ProvideValue" /> этого <see cref="T:System.Xaml.XamlType" />, если он представляет расширение разметки.</summary>
        <value>Объект <see cref="T:System.Xaml.XamlType" /> объект для возвращаемого типа для использования расширения разметки; в противном случае <see langword="null" />, если данный <see cref="T:System.Xaml.XamlType" /> не представляет расширение разметки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство применяется, только если это <xref:System.Xaml.XamlType> представляет расширение разметки (`x:MarkupExtension` находится в списке присваиваемых типов).  
  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строковое имя типа, это <see cref="T:System.Xaml.XamlType" /> представляет.</summary>
        <value>Строковое имя данного типа XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно это свойство получает имя схемы узла (на <xref:System.Xaml.XamlType.%23ctor%2A> подписи), или имя <xref:System.Type>, если он создан с использованием соответствующих конструктор системы типов среды CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <summary>Определяет, совпадают ли значения двух указанных объектов <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="xamlType1" /> совпадает со значением <paramref name="xamlType2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> или <see langword="null" />.</param>
        <summary>Определяет, различаются ли значения двух указанных объектов <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Значение <see langword="true" />, если значение <paramref name="xamlType1" /> отличается от значения <paramref name="xamlType2" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает одно пространство имен XAML, — это основное пространство имен XAML для данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Идентификатор в виде строки, основного пространства имен XAML для данного типа XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация предоставляет то же значение, что и вызов метода <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> и затем получение первой строки значение из возвращенного перечисляемого набора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает активный <see cref="T:System.Xaml.XamlSchemaContext" /> для обработки данного <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Активный <see cref="T:System.Xaml.XamlSchemaContext" /> для обработки данного <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> является записью обязательный параметр при создании <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление данного объекта <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Строковое представление данного объекта <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlType> Реализация <xref:System.Object.ToString%2A> возвращает <xref:System.Xaml.XamlType.Name%2A> свойство <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли это <see cref="T:System.Xaml.XamlType" /> имеет поведение обработки пробелов для сериализации, выполняющее удаление окружающих пробелов из его содержимого.</summary>
        <value><see langword="true" /> Если этот <see cref="T:System.Xaml.XamlType" /> представляет тип, который использует пробелы удаление; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список аргументов типа для случаев, где это <see cref="T:System.Xaml.XamlType" /> представляет универсальный.</summary>
        <value>Список типов аргументов; в противном случае <see langword="null" />, если данный <see cref="T:System.Xaml.XamlType" /> не представляет универсальный.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существуют некоторые сценарии для <xref:System.Xaml.XamlType> там, где вызов <xref:System.Xaml.XamlType.TypeArguments%2A> параметр Возвращает список, в которой типы будут все еще открыт. В нашем примере это один или несколько возвращаемого <xref:System.Xaml.XamlType> свойство может принимать значения заполнителей <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, такие как `T`, чтобы представить, что универсальный по-прежнему открыт. Этот сценарий может произойти, если вы получаете <xref:System.Xaml.XamlType> из вызова <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, а не из реализации средства чтения XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.ComponentModel.TypeConverter" /> ограничения, что представляет поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.ComponentModel.TypeConverter" /> ограничения, что представляет поведение преобразования типов для значений данного типа <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupTypeConverter%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupTypeConverter%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает среду CLR <see cref="T:System.Type" /> , является базовой для типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Среда CLR <see cref="T:System.Type" /> , является базовой для типа <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничение, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Объект <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> с <see cref="T:System.Windows.Markup.ValueSerializer" /> ограничение, представляющий поведение сериализации значений для значений данного типа <see cref="T:System.Xaml.XamlType" />; в противном случае <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если не выполнить отражение методика внутренней среды CLR по умолчанию для <xref:System.Xaml.XamlType>, вызовы к этому свойству можно вызвать <xref:System.Xaml.XamlType.LookupValueSerializer%2A> переопределяет на <xref:System.Xaml.XamlType> производных классов. Дополнительные сведения о возвращаемых значений и других аспектов поведения, см. в документации для <xref:System.Xaml.XamlType.LookupValueSerializer%2A> для данного типа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>