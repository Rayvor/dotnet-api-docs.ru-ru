<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3b7f9e3db8fdf784f59a76f504fcbc8dc39873d4" /><Meta Name="ms.sourcegitcommit" Value="6e7795ffb53e7cc489d655f9ee4308569b8763b9" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/26/2019" /><Meta Name="ms.locfileid" Value="72961814" /></Metadata><TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Включает свойства и методы для работы с дисками, файлами и каталогами.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведены примеры задач, в которых используется объект `My.Computer.FileSystem`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Чтение из текстового файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из текстового файла с фиксированной шириной|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичных файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Чтение из текстового файла с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Запись в текстовый файл|[Практическое руководство. Запись текста в файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавить в текстовый файл|[Практическое руководство. Дозапись в текстовый файл](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Запись в текстовые файлы в каталоге **MyDocuments**|[Практическое руководство. Запись текста в файлы в каталоге "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Запись в текстовый файл с помощью `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Копирование файлов с помощью определенного шаблона|[Практическое руководство. Копирование файлов по заданному шаблону в каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Копирование файла в тот же каталог|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Копирование файла в другой каталог|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Создание файла|[Практическое руководство. Создание файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Удаление файла|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Поиск файлов по определенному шаблону|[Практическое руководство. Поиск файлов по конкретному шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Переименование файла|[Практическое руководство. Переименование файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Копирование каталога в другой каталог|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Создание каталога|[Практическое руководство. Создание каталога](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Поиск подкаталогов по определенному шаблону|[Практическое руководство. Поиск подкаталогов по шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Получение коллекции файлов в каталоге|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Чтение из каталога **MyDocuments**|[Практическое руководство. Извлечение содержимого каталога "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Этот пример проверяет, существует ли папка `C:\backup\logs` и проверяет ее свойства.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Объекты (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Объекты (Visual Basic)](~/docs/visual-basic/language-reference/objects/index.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CombinePath(string baseDirectory, string relativePath) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" />. Первый путь, который необходимо объединить.</param>
        <param name="relativePath"><see langword="String" />. Второй путь, который необходимо объединить.</param>
        <summary>Объединяет два пути и возвращает правильно отформатированный путь.</summary>
        <returns>Сочетание заданных путей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обрезает лишние символы косой черты для создания правильно отформатированного пути.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CombinePath`.  
  
|Кому|См.|  
|-|-|  
|Объединение пути к каталогу и имени файла|[Практическое руководство. Синтаксический анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере путь к каталогу и имя файла объединяются для создания правильно отформатированного пути.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 В этом примере объединяются два пути для создания правильно отформатированного пути.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Этот пример возвращает `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь <paramref name="baseDirectory" /> или <paramref name="relativePath" /> сформирован неправильно.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он будет создан. Если каталог с таким же именем существует в целевом расположении, содержимое этих двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге могут возникать исключения, вызванные конкретным файлом. При возникновении таких исключений они объединяются в одно исключение, свойство `Data` которого содержит записи в форме <xref:System.Collections.IDictionary>, в которой путь к файлу или каталогу является ключом, а конкретное сообщение об исключении содержится в соответствующем значении. Для перечисления записей используйте `For…Each`.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CopyDirectory`.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Скопируйте каталог в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 В следующем примере содержимое `TestDirectory1` каталога копируется в `TestDirectory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#94)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` на путь и имя каталога, который необходимо скопировать, и расположение, куда вы хотите его скопировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он будет создан. Если каталог с таким же именем существует в целевом расположении, содержимое этих двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге могут возникать исключения, вызванные конкретным файлом. При возникновении таких исключений они объединяются в одно исключение, свойство `Data` которого содержит записи в форме <xref:System.Collections.IDictionary>, в которой путь к файлу или каталогу является ключом, а конкретное сообщение об исключении содержится в соответствующем значении. Для перечисления записей используйте `For…Each`.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CopyDirectory`.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Скопируйте каталог в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, отображая диалоговое окно хода выполнения и любое диалоговое окно ошибки.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#92)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` на путь и имя каталога, который необходимо скопировать, и расположение, куда вы хотите его скопировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он будет создан. Если каталог с таким же именем существует в целевом расположении, содержимое этих двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге могут возникать исключения, вызванные конкретным файлом, например файлом, существующим во время слияния, в то время как `overwrite` имеет значение `False`. При возникновении таких исключений они объединяются в одно исключение, свойство `Data` которого содержит записи в форме <xref:System.Collections.IDictionary>, в которой путь к файлу или каталогу является ключом, а конкретное сообщение об исключении содержится в соответствующем значении. Для перечисления записей используйте `For…Each`.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CopyDirectory`.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Скопируйте каталог в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 В следующем примере содержимое `TestDirectory1` каталога копируется в `TestDirectory2`, переписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` на путь и имя каталога, который необходимо скопировать, и расположение, куда вы хотите его скопировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать содержимое каталога.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует содержимое каталога в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует содержимое исходного каталога в целевой каталог. Если целевой каталог не существует, он будет создан. Если каталог с таким же именем существует в целевом расположении, содержимое этих двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге могут возникать исключения, вызванные конкретным файлом. При возникновении таких исключений они объединяются в одно исключение, свойство `Data` которого содержит записи в форме <xref:System.Collections.IDictionary>, в которой путь к файлу или каталогу является ключом, а конкретное сообщение об исключении содержится в соответствующем значении. Для перечисления записей используйте `For…Each`.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CopyDirectory`.  
  
|Кому|См.|  
|-|-|  
|Копирование каталога|[Практическое руководство. Скопируйте каталог в другой каталог в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует содержимое каталога `TestDirectory1` в `TestDirectory2`, отображая диалоговое окно хода выполнения и любое диалоговое окно ошибки, и не выполняет никаких действий, если пользователь нажимает кнопку **Отмена** во время операции.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#93)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` на путь и имя каталога, который необходимо скопировать, и расположение, куда вы хотите его скопировать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет ACE (записи контроля доступа). Созданный файл наследует элементы ACE по умолчанию из каталога, в котором он создается.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.CopyFile`.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создайте копию файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` и переименовывается `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл в целевом каталоге с тем же именем уже используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет ACE (записи контроля доступа). Созданный файл наследует элементы ACE по умолчанию из каталога, в котором он создается.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.CopyFile`.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создайте копию файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` и переименовывается `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие файлы; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет ACE (записи контроля доступа). Созданный файл наследует элементы ACE по умолчанию из каталога, в котором он создается.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.CopyFile`.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создайте копию файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` и переименовывается `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет ACE (записи контроля доступа). Созданный файл наследует элементы ACE по умолчанию из каталога, в котором он создается.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.CopyFile`.  
  
|Кому|См.|  
|-|-|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создайте копию файла в том же каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другой каталог.|[Практическое руководство. Создание копии файла в другом каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 В этом примере файл `Test.txt` копируется в каталог `TestFiles2` и переименовывается `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам на пути, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDirectory(string directory) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя и местоположение каталога.</param>
        <summary>Создает каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог уже существует, исключение не возникает.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.CreateDirectory`.  
  
|Кому|См.|  
|-|-|  
|Создание каталога|[Практическое руководство. Создание каталога в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 В этом примере создается каталог `NewDirectory`в `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неверное имя каталога. Например, оно содержит недопустимые символы или состоит только из пробелов.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Имя каталога имеет слишком большую длину.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога состоит только из двоеточия (:).</exception>
        <exception cref="T:System.IO.IOException">Родительский каталог создаваемого каталога доступен только для чтения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет разрешения на создание каталога.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий каталог.</summary>
        <value>Текущий каталог для файловых операций ввода-вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` является переменной среды на уровне системы.  
  
   
  
## Examples  
 Этот пример возвращает текущий каталог и отображает его в окне сообщения.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 В этом примере для текущего каталога задается значение `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый путь.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="onDirectoryNotEmpty">Указывает, какие действия должны выполняться, когда удаляемый каталог содержит файлы или каталоги. Значение по умолчанию — <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере каталог удаляется `OldDirectory` только в том случае, если он пуст.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое, запрашивающие пользователя подтвердить удаление, но не отправляющее содержимое в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Этот пример удаляет каталог `OldDirectory` и все его содержимое, отправляя их в **корзину**, но не отображая ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `showUI` и `recycle` не поддерживаются в приложениях, которые не являются интерактивными пользователями, например службами Windows.  
  
   
  
## Examples  
 В этом примере каталог удаляется `OldDirectory` только в том случае, если он пуст.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое, запрашивающие пользователя подтвердить удаление, но не отправляющее содержимое в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Этот пример удаляет каталог `OldDirectory` и все его содержимое, отправляя их в **корзину**, но не отображая ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, следует ли создавать исключение, если пользователь нажимает кнопку **Отмена**.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `showUI`, `recycle`и `onUserCancel` не поддерживаются в приложениях, которые не являются интерактивными пользователями, такими как службы Windows.  
  
   
  
## Examples  
 В этом примере каталог удаляется `OldDirectory` только в том случае, если он пуст.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все его содержимое, запрашивающие пользователя подтвердить удаление, но не отправляющее содержимое в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Этот пример удаляет каталог `OldDirectory` и все его содержимое, отправляя их в **корзину**, но не отображая ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.DeleteFile`.  
  
|Кому|См.|  
|-|-|  
|Удаление файла|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Этот пример удаляет файл `Test.txt` и позволяет пользователю подтвердить удаление файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере файл `Test.txt` удаляется и отправляется в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `showUI` и `recycle` не поддерживаются в приложениях, которые не являются интерактивными пользователями, например службами Windows.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.DeleteFile`.  
  
|Кому|См.|  
|-|-|  
|Удаление файла|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Этот пример удаляет файл `Test.txt` и позволяет пользователю подтвердить удаление файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере файл `Test.txt` удаляется и отправляется в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `showUI`, `recycle`и `onUserCancel` не поддерживаются в приложениях, которые не являются интерактивными пользователями, такими как службы Windows.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.DeleteFile`.  
  
|Кому|См.|  
|-|-|  
|Удаление файла|[Практическое руководство. Удаление файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Этот пример удаляет файл `Test.txt` и позволяет пользователю подтвердить удаление файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере файл `Test.txt` удаляется и отправляется в **корзину**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменил операцию, и для параметра <paramref name="onUserCancel" /> установлено значение <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DirectoryExists(string directory) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный каталог существует.</summary>
        <returns>Значение <see langword="True" />, если каталог существует; в противном случае — значение <see langword="False" />. Этот метод также возвращает <see langword="False" />, если параметр представляет имя и путь файла, а не каталог.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Этот пример определяет, существует ли каталог `C:\backup\logs` и проверяет его свойства.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию имен всех доступных дисков.</summary>
        <value>Доступная только для чтения коллекция всех доступных дисков в виде объектов <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает все логические диски.  
  
   
  
## Examples  
 В этом примере отображаются доступные имена дисков в окне сообщения.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FileExists(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный файл существует.</summary>
        <returns>Возвращает значение <see langword="True" />, если файл существует; в противном случае возвращает значение <see langword="False" />. Этот метод также возвращает <see langword="False" />, если параметр представляет путь к каталогу, а файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если приложение не имеет достаточных разрешений для чтения указанного файла, метод `FileExists` возвращает `False`, независимо от существования пути. метод не создает исключение.  
  
   
  
## Examples  
 В этом примере проверяется наличие файла `Check.txt` существует и предоставляются сведения в окне сообщения.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается обратной косой чертой (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.FindInFiles`.  
  
|Кому|См.|  
|-|-|  
|Поиск файлов, содержащих определенную строку, в каталоге|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере выполняется поиск в каталоге `C:\TestDir` для всех файлов, содержащих строку `"sample string"`, и результаты отображаются в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Для работы проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.FindInFiles`.  
  
|Кому|См.|  
|-|-|  
|Поиск файлов, содержащих определенную строку, в каталоге|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере выполняется поиск в каталоге `C:\TestDir` для всех файлов, содержащих строку `"sample string"`, и результаты отображаются в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Для работы проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.GetDirectories`.  
  
|Кому|См.|  
|-|-|  
|Вывод списка подкаталогов с указанным шаблоном|[Практическое руководство. Поиск подкаталогов по определенному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляются в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому должны соответствовать имена.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для указания определенного шаблона можно использовать параметр `wildcards` . Если требуется включить в поиск содержимое подкаталогов, присвойте параметру `searchType` значение `SearchAllSubDirectories`.  
  
 Если каталоги, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.GetDirectories`.  
  
|Кому|См.|  
|-|-|  
|Вывод списка подкаталогов с указанным шаблоном|[Практическое руководство. Поиск подкаталогов по определенному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляются в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько указанных подстановочных знаков являются <see langword="Nothing" />, пустой строкой или содержат только пробелы.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" />. Путь к каталогу.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</summary>
        <returns>Объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог не существует, исключение не создается до тех пор, пока не будет получен первый доступ к свойству объекта <xref:System.IO.DirectoryInfo>.  
  
   
  
## Examples  
 Этот пример получает объект <xref:System.IO.DirectoryInfo> для каталога `C:\Documents and Settings` и отображает время создания каталога, время последнего доступа и время последней записи.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Диск, который необходимо проверить.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</summary>
        <returns>Объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.IO.DriveInfo> моделирует диск и предоставляет методы и свойства для запроса сведений о диске. Используйте <xref:System.IO.DriveInfo>, чтобы определить доступные диски и типы дисков. Можно также запросить свойство, чтобы определить емкость и доступное свободное место на диске.  
  
   
  
## Examples  
 Этот пример получает объект <xref:System.IO.DriveInfo> для диска C и использует его для вывода сведений о диске.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Сведения о различных типах дисков см. в разделе <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="drive" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileInfo GetFileInfo(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</summary>
        <returns>Объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файл не существует, возникает исключение. Вместо этого он будет создаваться при первом обращении к свойствам объекта.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.GetFileInfo`.  
  
|Кому|См.|  
|-|-|  
|Определение имени и пути к файлу|[Практическое руководство. Синтаксический анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Этот пример извлекает объект <xref:System.IO.FileInfo?displayProperty=nameWithType> для файла `MyLogFile.log` и использует его для сообщения полного имени файла, времени последнего доступа и длины.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя пути Например, оно содержит недопустимые символы или состоит из пробела. В конце имени файла указана косая черта.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.NotSupportedException">Путь содержит двоеточие в середине строки.</exception>
        <exception cref="T:System.IO.PathTooLongException">Слишком длинный путь.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет доступа к списку управления доступом (ACL) файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.GetFiles`.  
  
|Кому|См.|  
|-|-|  
|Получение коллекции файлов в каталоге|[Практическое руководство. Получение коллекции файлов в каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов с указанным шаблоном в каталоге|[Практическое руководство. Поиск файлов по определенному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 Этот пример возвращает все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="directory" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.GetFiles`.  
  
|Кому|См.|  
|-|-|  
|Получение коллекции файлов в каталоге|[Практическое руководство. Получение коллекции файлов в каталоге в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов с указанным шаблоном в каталоге|[Практическое руководство. Поиск файлов по определенному шаблону в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 Этот пример возвращает все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется, чтобы в форме имелся `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(string path) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Обязательный. Путь, синтаксический анализ которого нужно выполнить. <see langword="String" />.</param>
        <summary>Анализирует имя файла без указанного пути.</summary>
        <returns>Имя файла из указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это операция со строками; `FileSystem` не проверяется.  
  
 Метод `GetName` игнорирует знак косой черты в конце пути.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.GetFileName`.  
  
|Кому|См.|  
|-|-|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Синтаксический анализ путей к файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В следующем примере анализируется путь к файлу и возвращается имя файла.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Замените путь `C:\Testdirectory\Testfile` на путь, который нужно проанализировать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetParentPath(string path) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, который необходимо проверить.</param>
        <summary>Возвращает родительский путь предоставленного пути.</summary>
        <returns>Родительский путь для заданного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это операция со строками; файловая система не проверяется.  
  
   
  
## Examples  
 В этом примере возвращается родительский путь для `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь не имеет родительского пути, так как это корневой путь.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает на диске временный пустой файл с уникальным именем и возвращает полный путь этого файла.</summary>
        <returns><see langword="String" />, содержащая полный путь к временному файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания временного файла.  
  
   
  
## Examples  
 В этом примере создается временный файл и возвращается его путь.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке переместить каталог в каталог, который не существует, будет создана целевая структура.  
  
   
  
## Examples  
 В этом примере `Directory1` перемещается в `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Этот пример перемещает `Directory1` в `Directory2`, перезаписывая каталог, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Источник является корневым каталогом, либо исходный путь совпадает с целевым.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке переместить каталог в каталог, который не существует, будет создана целевая структура.  
  
   
  
## Examples  
 В этом примере `Directory1` перемещается в `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Этот пример перемещает `Directory1` в `Directory2`, перезаписывая каталог, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие каталоги; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке переместить каталог в каталог, который не существует, будет создана целевая структура.  
  
   
  
## Examples  
 В этом примере `Directory1` перемещается в `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Этот пример перемещает `Directory1` в `Directory2`, перезаписывая каталог, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке переместить каталог в каталог, который не существует, будет создана целевая структура.  
  
   
  
## Examples  
 В этом примере `Directory1` перемещается в `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Этот пример перемещает `Directory1` в `Directory2`, перезаписывая каталог, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, и подкаталог файла не может быть скопирован.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменяет операцию, или операция не может быть завершена.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, она будет создана.  
  
 Метод `MoveFile` сохраняет ACE (записи контроля доступа) только при перемещении файла в пределах одного тома. Сюда входят унаследованные ACE, которые становятся прямыми записями ACE при перемещении (прямые записи ACE имеют приоритет над унаследованными элементами ACE). Если файл перемещается между томами, записи ACE не будут скопированы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.MoveFile`.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере файл перемещается `Test.txt` из `TestDir1` в `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере файл `Test.txt` перемещается из `TestDir1` в `TestDir2` и переименовывается `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, она будет создана.  
  
 Метод `MoveFile` сохраняет ACE (записи контроля доступа) только при перемещении файла в пределах одного тома. Сюда входят унаследованные ACE, которые становятся прямыми записями ACE при перемещении (прямые записи ACE имеют приоритет над унаследованными элементами ACE). Если файл перемещается между томами, записи ACE не будут скопированы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.MoveFile`.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере файл перемещается `Test.txt` из `TestDir1` в `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере файл `Test.txt` перемещается из `TestDir1` в `TestDir2` и переименовывается `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, она будет создана.  
  
 Метод `MoveFile` сохраняет ACE (записи контроля доступа) только при перемещении файла в пределах одного тома. Сюда входят унаследованные ACE, которые становятся прямыми записями ACE при перемещении (прямые записи ACE имеют приоритет над унаследованными элементами ACE). Если файл перемещается между томами, записи ACE не будут скопированы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.MoveFile`.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере файл перемещается `Test.txt` из `TestDir1` в `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере файл `Test.txt` перемещается из `TestDir1` в `TestDir2` и переименовывается `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевая структура не существует, она будет создана.  
  
 Метод `MoveFile` сохраняет ACE (записи контроля доступа) только при перемещении файла в пределах одного тома. Сюда входят унаследованные ACE, которые становятся прямыми записями ACE при перемещении (прямые записи ACE имеют приоритет над унаследованными элементами ACE). Если файл перемещается между томами, записи ACE не будут скопированы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.MoveFile`.  
  
|Кому|См.|  
|-|-|  
|Перемещение файла|[Практическое руководство. Перемещение файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере файл перемещается `Test.txt` из `TestDir1` в `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере файл `Test.txt` перемещается из `TestDir1` в `TestDir2` и переименовывается `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа ко всем переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, связанными с пользовательскими интерфейсами и буфером обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.OpenTextFieldParser`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из текстового файла с фиксированной шириной|[Практическое руководство. Чтение из текстовых файлов с фиксированной шириной в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов с несколькими форматами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Этот пример открывает `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Значения ширины полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.OpenTextFieldParser`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из текстового файла с фиксированной шириной|[Практическое руководство. Чтение из текстовых файлов с фиксированной шириной в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов с несколькими форматами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Этот пример открывает `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Разделители для полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.OpenTextFieldParser`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из текстового файла с фиксированной шириной|[Практическое руководство. Чтение из текстовых файлов с фиксированной шириной в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов с несколькими форматами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Этот пример открывает `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenTextFileReader(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.IO.StreamReader>можно считывать только текстовые файлы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.OpenTextFileReader`.  
  
|Кому|См.|  
|-|-|  
|Открытие файла с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Этот пример открывает файл `Testfile.txt`, считывает строку из нее и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, используемая для содержимого файла. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.IO.StreamReader>можно считывать только текстовые файлы.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.OpenTextFileReader`.  
  
|Кому|См.|  
|-|-|  
|Открытие файла с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Этот пример открывает файл `Testfile.txt`, считывает строку из нее и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `OpenTextFileWriter` открывает и инициализирует поток для файла, а затем возвращает объект <xref:System.IO.StreamWriter> для этого потока. Можно выполнить запись в Steam столько раз, сколько необходимо, а затем закрыть его по завершении.  
  
> [!NOTE]
>  Необходимо вызвать метод <xref:System.IO.StreamWriter.Close%2A> для объекта <xref:System.IO.StreamWriter>, чтобы убедиться, что все данные правильно записаны в базовый поток.  
  
 Если в файл записывается только несколько строк, возможно, проще использовать метод <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.OpenTextFileWriter`.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл с помощью `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с помощью метода `My.Computer.FileSystem.OpenTextFileWriter` и используется для записи строки в текстовый файл с помощью метода `WriteLine` класса `StreamWriter`.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `OpenTextFileWriter` открывает и инициализирует поток для файла, а затем возвращает объект <xref:System.IO.StreamWriter> для этого потока. Можно выполнить запись в Steam столько раз, сколько необходимо, а затем закрыть его по завершении.  
  
> [!NOTE]
>  Необходимо вызвать метод <xref:System.IO.StreamWriter.Close%2A> для объекта <xref:System.IO.StreamWriter>, чтобы убедиться, что все данные правильно записаны в базовый поток.  
  
 Если в файл записывается только несколько строк, возможно, проще использовать метод <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.OpenTextFileWriter`.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл с помощью `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с методом `My.Computer.FileSystem.OpenTextFileWriter` с `Unicode` кодировкой и используется для записи строки в текстовый файл с помощью метода `WriteLine` класса `StreamWriter`.  
  
 [!code-vb[VbRefFile#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое файла в виде массива байтов.</summary>
        <returns><see langword="Byte" /> массив с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllBytes` объекта `My.Computer.FileSystem` позволяет считывать данные из двоичного файла. Содержимое файла возвращается в виде массива байтов.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.ReadAllBytes`.  
  
|Кому|См.|  
|-|-|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичных файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Этот пример считывает данные из файла `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string file) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns><see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указана, если содержимое файла имеет кодировку, такую как ASCII или UTF-8. При чтении из файла с расширенными символами необходимо указать кодировку файла с помощью другой перегрузки метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A>.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.ReadAllText`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку, а затем отображает его в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку, а затем отображает его в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, которую необходимо использовать при чтении файла. Значением по умолчанию является UTF-8.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns><see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указана, если содержимое файла имеет кодировку, такую как ASCII или UTF-8. При чтении из файла с расширенными символами необходимо указать кодировку файла.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.ReadAllText`.  
  
|Кому|См.|  
|-|-|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку, а затем отображает его в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку, а затем отображает его в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RenameDirectory(string directory, string newName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя каталога, который необходимо переименовать, и путь к нему.</param>
        <param name="newName">Новое имя каталога.</param>
        <summary>Переименование каталога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод нельзя использовать для перемещения каталога. Используйте метод `MoveDirectory` для перемещения и переименования каталога.  
  
   
  
## Examples  
 В этом примере каталог `Test` переименовывается в `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="directory" /> имеет значение <see langword="Nothing" />.  
  
- или - 
 Параметр <paramref name="newName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RenameFile(string file, string newName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо переименовать.</param>
        <param name="newName">Новое имя файла.</param>
        <summary>Переименование файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод нельзя использовать для перемещения файла. Для перемещения и переименования файла используется метод <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A>.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.RenameFile`.  
  
|Кому|См.|  
|-|-|  
|Переименование файла|[Практическое руководство. Переименование файла в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 В этом примере файл `Test.txt` переименовывается в `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Измените "`C:\Test.txt`" на путь и имя файла, который требуется переименовать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> содержит сведения о пути или оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.  
  
- или - 
 Параметр <paramref name="newName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла, в который необходимо выполнить запись, и путь к нему.</param>
        <param name="data">Данные, которые необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает данные в двоичный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указан недопустимый путь, исключая имя файла, будет выдано исключение <xref:System.IO.DirectoryNotFoundException>. Если путь допустим, но файл не существует, файл будет создан.  
  
> [!NOTE]
>  Метод `WriteAllBytes` открывает файл, записывает его, а затем закрывает его. Код, использующий метод `WriteAllBytes`, проще, чем код, использующий объект <xref:System.IO.BinaryWriter>. Однако при добавлении данных в файл с помощью цикла объект <xref:System.IO.BinaryWriter> может обеспечить лучшую производительность, так как достаточно открыть и закрыть файл только один раз.  
  
 В следующей таблице приведен пример задачи, включающей метод `My.Computer.FileSystem.WriteAllBytes`.  
  
|Кому|См.|  
|-|-|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 В этом примере массив данных добавляется `CustomerData` в `CollectedData`файла.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> — <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текст в файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string file, string text, bool append) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка UTF-8 используется для записи в файл. Чтобы указать другую кодировку, используйте другую перегрузку метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A>.  
  
 Если заданный файл не существует, он будет создан.  
  
 Если указанная кодировка не совпадает с существующей кодировкой файла, указанное кодирование игнорируется.  
  
> [!NOTE]
>  Метод `WriteAllText` открывает файл, записывает его, а затем закрывает его. Код, использующий метод `WriteAllText`, проще, чем код, использующий объект <xref:System.IO.StreamWriter>. Однако при добавлении строк в файл с помощью цикла объект <xref:System.IO.StreamWriter> может обеспечить лучшую производительность, так как открывать и закрывать файл нужно только один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.WriteAllText`.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Добавление к текстовым файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Этот пример записывает строку `"This is new text to be added."` в файл `Test.txt`, перезаписывая существующий текст в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере имена файлов в папке `Documents and Settings` записываются в `FileList.txt`и вставляется символ возврата каретки между ними для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append"><see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заданный файл не существует, он будет создан.  
  
 Если указанная кодировка не совпадает с существующей кодировкой файла, указанное кодирование игнорируется.  
  
> [!NOTE]
>  Метод `WriteAllText` открывает файл, записывает его, а затем закрывает его. Код, использующий метод `WriteAllText`, проще, чем код, использующий объект <xref:System.IO.StreamWriter>. Однако при добавлении строк в файл с помощью цикла объект <xref:System.IO.StreamWriter> может обеспечить лучшую производительность, так как открывать и закрывать файл нужно только один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 В следующей таблице приведены примеры задач, в которых используется метод `My.Computer.FileSystem.WriteAllText`.  
  
|Кому|См.|  
|-|-|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Добавление к текстовым файлам в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Этот пример записывает строку `"This is new text to be added."` в файл `Test.txt`, перезаписывая существующий текст в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере имена файлов в папке `Documents and Settings` записываются в `FileList.txt`и вставляется символ возврата каретки между ними для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>
