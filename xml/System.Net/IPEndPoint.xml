<Type Name="IPEndPoint" FullName="System.Net.IPEndPoint">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f400ed24403409be4fa3887b4a424c887f16dc7" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68895913" /></Metadata><TypeSignature Language="C#" Value="public class IPEndPoint : System.Net.EndPoint" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit IPEndPoint extends System.Net.EndPoint" />
  <TypeSignature Language="DocId" Value="T:System.Net.IPEndPoint" />
  <TypeSignature Language="VB.NET" Value="Public Class IPEndPoint&#xA;Inherits EndPoint" />
  <TypeSignature Language="C++ CLI" Value="public ref class IPEndPoint : System::Net::EndPoint" />
  <TypeSignature Language="F#" Value="type IPEndPoint = class&#xA;    inherit EndPoint" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Primitives</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.EndPoint</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет сетевую конечную точка в виде IP-адреса и номера порта.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.IPEndPoint> Класс содержит сведения об узле и локальном или удаленном порте, необходимые приложению для подключения к службе на узле. Объединяя IP-адрес узла и номер порта службы, <xref:System.Net.IPEndPoint> класс формирует точку подключения к службе.  
  
   
  
## Examples  
 [!code-cpp[System.Net.IPEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#1)]
 [!code-csharp[System.Net.IPEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#1)]
 [!code-vb[System.Net.IPEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.IPEndPoint" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPEndPoint (long address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.#ctor(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As Long, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPEndPoint(long address, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.IPEndPoint : int64 * int -&gt; System.Net.IPEndPoint" Usage="new System.Net.IPEndPoint (address, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">IP-адрес узла в Интернете.</param>
        <param name="port">Номер порта, связанный с параметром <paramref name="address" />, или 0 для указания любого доступного порта. <paramref name="port" /> указывается в порядке основного приложения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.IPEndPoint" /> с заданными адресом и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется указанный IP-адрес и номер порта для создания <xref:System.Net.IPEndPoint>.  
  
 [!code-cpp[IPEndPoint_Properties#4](~/samples/snippets/cpp/VS_Snippets_Remoting/IPEndPoint_Properties/CPP/ipendpoint_properties.cpp#4)]
 [!code-csharp[IPEndPoint_Properties#4](~/samples/snippets/csharp/VS_Snippets_Remoting/IPEndPoint_Properties/CS/ipendpoint_properties.cs#4)]
 [!code-vb[IPEndPoint_Properties#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPEndPoint_Properties/VB/ipendpoint_properties.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="port" /> меньше <see cref="F:System.Net.IPEndPoint.MinPort" />.  
  
-или- 
 Значение <paramref name="port" /> больше значения <see cref="F:System.Net.IPEndPoint.MaxPort" />.  
  
- или - 
 <paramref name="address" /> меньше 0 или больше 0x00000000FFFFFFFF.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IPEndPoint (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IPEndPoint(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.IPEndPoint : System.Net.IPAddress * int -&gt; System.Net.IPEndPoint" Usage="new System.Net.IPEndPoint (address, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Net.IPAddress" />.</param>
        <param name="port">Номер порта, связанный с параметром <paramref name="address" />, или 0 для указания любого доступного порта. <paramref name="port" /> указывается в порядке основного приложения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.IPEndPoint" /> с заданными адресом и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Net.IPEndPoint#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#2)]
 [!code-csharp[System.Net.IPEndPoint#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#2)]
 [!code-vb[System.Net.IPEndPoint#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="port" /> меньше значения <see cref="F:System.Net.IPEndPoint.MinPort" />.  
  
- или - 
 Значение <paramref name="port" /> больше значения <see cref="F:System.Net.IPEndPoint.MaxPort" />.  
  
-или- 
 <paramref name="address" /> меньше 0 или больше 0x00000000FFFFFFFF.</exception>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public System.Net.IPAddress Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPAddress Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPEndPoint.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As IPAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPAddress ^ Address { System::Net::IPAddress ^ get(); void set(System::Net::IPAddress ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Address : System.Net.IPAddress with get, set" Usage="System.Net.IPEndPoint.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IPAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает IP-адрес конечной точки.</summary>
        <value>Экземпляр класса <see cref="T:System.Net.IPAddress" />, содержащий IP-адрес конечной точки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.Address%2A> свойство задается <xref:System.Net.IPAddress> с помощью указанного.  
  
 [!code-cpp[System.Net.IPEndPoint#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#3)]
 [!code-csharp[System.Net.IPEndPoint#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#3)]
 [!code-vb[System.Net.IPEndPoint#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public override System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPEndPoint.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.IPEndPoint.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает семейство IP-адресов.</summary>
        <value>Возвращает <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.AddressFamily%2A> свойство используется для <xref:System.Net.Sockets.AddressFamily> возврата <xref:System.Net.IPEndPoint> к, которому принадлежит. В данном случае <xref:System.Net.Sockets.AddressFamily.InterNetwork> <xref:System.Net.Sockets.AddressFamily>это.  
  
 [!code-cpp[System.Net.IPEndPoint#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#3)]
 [!code-csharp[System.Net.IPEndPoint#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#3)]
 [!code-vb[System.Net.IPEndPoint#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public override System.Net.EndPoint Create (System.Net.SocketAddress socketAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.EndPoint Create(class System.Net.SocketAddress socketAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.Create(System.Net.SocketAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::EndPoint ^ Create(System::Net::SocketAddress ^ socketAddress);" />
      <MemberSignature Language="F#" Value="override this.Create : System.Net.SocketAddress -&gt; System.Net.EndPoint" Usage="iPEndPoint.Create socketAddress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketAddress" Type="System.Net.SocketAddress" />
      </Parameters>
      <Docs>
        <param name="socketAddress">Параметр <see cref="T:System.Net.SocketAddress" />, используемый для создания конечной точки.</param>
        <summary>Создает конечную точка по адресу сокета.</summary>
        <returns>Экземпляр класса <see cref="T:System.Net.EndPoint" />, использующий заданный адрес сокета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется указанный <xref:System.Net.SocketAddress> объект для <xref:System.Net.IPEndPoint>создания.  
  
 [!code-cpp[System.Net.IPEndPoint#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#5)]
 [!code-csharp[System.Net.IPEndPoint#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#5)]
 [!code-vb[System.Net.IPEndPoint#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение свойства AddressFamily для <paramref name="socketAddress" /> не равно значению свойства AddressFamily для текущего экземпляра класса.  
  
- или - 
 <paramref name="socketAddress" />.Size &lt; 8.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.SocketAddress" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="iPEndPoint.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Объект <see cref="T:System.Object" />, который необходимо сравнить с текущим объектом <see cref="T:System.Object" />.</param>
        <summary>Определяет, равен ли указанный объект <see cref="T:System.Object" /> текущему объекту <see cref="T:System.Object" />.</summary>
        <returns>Значение <see langword="true" />, если указанный объект <see cref="T:System.Object" /> равен текущему объекту <see cref="T:System.Object" />; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="iPEndPoint.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-значение для экземпляра <see cref="T:System.Net.IPEndPoint" />.</summary>
        <returns>Целочисленное хэш-значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.IPEndPoint.GetHashCode%2A> Метод возвращает хэш-код экземпляра конечной точки IP-адреса. Это значение можно использовать в качестве ключа в хэш-таблицах.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPort">
      <MemberSignature Language="C#" Value="public const int MaxPort = 65535;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxPort = (65535)" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPEndPoint.MaxPort" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxPort As Integer  = 65535" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxPort = 65535;" />
      <MemberSignature Language="F#" Value="val mutable MaxPort : int" Usage="System.Net.IPEndPoint.MaxPort" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>65535</MemberValue>
      <Docs>
        <summary>Определяет максимальное значение, которое может присваиваться свойству <see cref="P:System.Net.IPEndPoint.Port" />. Значение MaxPort установлено равным 0x0000FFFF. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.MaxPort> свойство используется для печати максимального значения, которое может быть назначено <xref:System.Net.IPEndPoint.Port%2A> свойству.  
  
 [!code-cpp[IPEndPoint_Properties#4](~/samples/snippets/cpp/VS_Snippets_Remoting/IPEndPoint_Properties/CPP/ipendpoint_properties.cpp#4)]
 [!code-csharp[IPEndPoint_Properties#4](~/samples/snippets/csharp/VS_Snippets_Remoting/IPEndPoint_Properties/CS/ipendpoint_properties.cs#4)]
 [!code-vb[IPEndPoint_Properties#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPEndPoint_Properties/VB/ipendpoint_properties.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinPort">
      <MemberSignature Language="C#" Value="public const int MinPort = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MinPort = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Net.IPEndPoint.MinPort" />
      <MemberSignature Language="VB.NET" Value="Public Const MinPort As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int MinPort = 0;" />
      <MemberSignature Language="F#" Value="val mutable MinPort : int" Usage="System.Net.IPEndPoint.MinPort" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Определяет минимальное значение, которое может присваиваться свойству <see cref="P:System.Net.IPEndPoint.Port" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.MinPort> свойство используется для вывода минимального значения, которое может быть присвоено <xref:System.Net.IPEndPoint.Port%2A> свойству.  
  
 [!code-cpp[IPEndPoint_Properties#4](~/samples/snippets/cpp/VS_Snippets_Remoting/IPEndPoint_Properties/CPP/ipendpoint_properties.cpp#4)]
 [!code-csharp[IPEndPoint_Properties#4](~/samples/snippets/csharp/VS_Snippets_Remoting/IPEndPoint_Properties/CS/ipendpoint_properties.cs#4)]
 [!code-vb[IPEndPoint_Properties#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/IPEndPoint_Properties/VB/ipendpoint_properties.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Количество частей (каждая часть отделяется точкой) в `s` определяет, как создается IP-адрес конечной точки. Адрес, соходящийся в одном компоненте, хранится непосредственно в сетевом адресе. Адрес из двух частей, удобно для указания адреса класса A, помещает начальную часть в первый байт и завершающую часть в правой части трех байтов сетевого адреса. Адрес из трех частей, удобно для указания адреса класса B, помещает первую часть в первый байт, вторую часть второго байта и последнюю часть в крайнем правом двух байтах сетевого адреса. Например:

|Число частей и пример`s`|IPv4-адрес для IPEndPoint. Address|Порт|
|-------------------------|--------------------------------|-------------------------|  
|1 — "1"|0.0.0.1|0|  
|2 — "20.2:80"|20.0.0.2|80|  
|2 — "20.65535:23"|20.0.255.255|23|  
|3 — "128.1.2:443"|128.1.0.2|443|  

> [!IMPORTANT]
> Обратите внимание, что этот метод принимает в качестве допустимого значения, которое может <xref:System.Int64>быть проанализировано как, <xref:System.Int64> а затем рассматривает его как длинное значение IP-адреса в сетевом байтом порядке, аналогично тому, как это делает Конструктор IPAddress. Это означает, что этот метод возвращает значение true, если Int64 анализируется успешно, даже если он представляет адрес, который не является допустимым IP-адресом. Например, если значение s равно "1", этот метод возвращает значение true, даже если "1" (или 0.0.0.1) не является допустимым IP-адресом, и вы можете ожидать, что этот метод возвратит значение false. Устранение этой ошибки приведет к нарушению работы существующих приложений, поэтому текущее поведение не изменится. Код может избежать такого поведения, гарантируя, что он использует только этот метод для анализа IP-адресов в точечно-десятичном формате.
 
Литеральные адреса IPv6 необходимо заключать в квадратные скобки [] при передаче конечной точки, указывающей номер порта; в противном случае квадратные скобки не являются обязательными.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPEndPoint Parse (ReadOnlySpan&lt;char&gt; s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPEndPoint Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char)) As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPEndPoint ^ Parse(ReadOnlySpan&lt;char&gt; s);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; System.Net.IPEndPoint" Usage="System.Net.IPEndPoint.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Диапазон с доступом только для чтения, содержащий конечную точку IP, выраженную в виде четырех чисел, разделенных точками, или в сетевом байтовом формате в случае протокола IPv4 и в системе записи "двоеточие-шестнадцатиричное число" в случае протокола IPv6.</param>
        <summary>Преобразует конечную точку IP-сети (адрес и порт), представленную в виде диапазона, доступного только для чтения, в экземпляр <see cref="T:System.Net.IPEndPoint" />.</summary>
        <returns>Объектное представление конечной точки IP-сети.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не является допустимой конечной точкой IP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Net.IPEndPoint Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IPEndPoint Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IPEndPoint ^ Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Net.IPEndPoint" Usage="System.Net.IPEndPoint.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая конечную точку IP, выраженную в виде четырех чисел, разделенных точками, или в сетевом байтовом формате в случае протокола IPv4 и в системе записи "двоеточие-шестнадцатиричное число" в случае протокола IPv6.</param>
        <summary>Преобразует конечную точку IP-сети (адрес и порт), представленную в виде строки, в экземпляр <see cref="T:System.Net.IPEndPoint" />.</summary>
        <returns>Объектное представление конечной точки IP-сети.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> — <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> не является допустимой конечной точкой IP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Net.IPEndPoint.Port" />
      <MemberSignature Language="VB.NET" Value="Public Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Port : int with get, set" Usage="System.Net.IPEndPoint.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает номер порта конечной точки.</summary>
        <value>Целое значение из диапазона от <see cref="F:System.Net.IPEndPoint.MinPort" /> до <see cref="F:System.Net.IPEndPoint.MaxPort" />, показывающее номер порта конечной точки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.Port%2A> свойство используется для задания номера <xref:System.Net.EndPoint>TCP-порта.  
  
 [!code-cpp[System.Net.IPEndPoint#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#3)]
 [!code-csharp[System.Net.IPEndPoint#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#3)]
 [!code-vb[System.Net.IPEndPoint#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, заданное для установленной операции, меньше <see cref="F:System.Net.IPEndPoint.MinPort" /> или больше <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public override System.Net.SocketAddress Serialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.SocketAddress Serialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.Serialize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Serialize () As SocketAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::SocketAddress ^ Serialize();" />
      <MemberSignature Language="F#" Value="override this.Serialize : unit -&gt; System.Net.SocketAddress" Usage="iPEndPoint.Serialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.SocketAddress</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выводит в последовательном виде сведения о конечной точке в экземпляр класса <see cref="T:System.Net.SocketAddress" />.</summary>
        <returns>Экземпляр класса <see cref="T:System.Net.SocketAddress" />, содержащий адрес сокета для конечной точки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере <xref:System.Net.IPEndPoint.Serialize%2A> метод используется для сериализации сведений о конечной точке <xref:System.Net.SocketAddress> в экземпляр.  
  
 [!code-cpp[System.Net.IPEndPoint#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#4)]
 [!code-csharp[System.Net.IPEndPoint#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#4)]
 [!code-vb[System.Net.IPEndPoint#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="iPEndPoint.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает IP-адрес и номер порта заданной конечной точки.</summary>
        <returns>Строка, содержащая IP-адрес и номер порта заданной конечной точки (например, 192.168.1.2:80).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере возвращается строковое представление IP-адреса и номера порта указанного <xref:System.Net.IPEndPoint>.  
  
 [!code-cpp[System.Net.IPEndPoint#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.IPEndPoint/CPP/ipendpoint.cpp#3)]
 [!code-csharp[System.Net.IPEndPoint#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.IPEndPoint/CS/ipendpoint.cs#3)]
 [!code-vb[System.Net.IPEndPoint#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.IPEndPoint/VB/ipendpoint.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Количество частей (каждая часть отделяется точкой) в `s` определяет, как создается IP-адрес конечной точки. Адрес, соходящийся в одном компоненте, хранится непосредственно в сетевом адресе. Адрес из двух частей, удобно для указания адреса класса A, помещает начальную часть в первый байт и завершающую часть в правой части трех байтов сетевого адреса. Адрес из трех частей, удобно для указания адреса класса B, помещает первую часть в первый байт, вторую часть второго байта и последнюю часть в крайнем правом двух байтах сетевого адреса. Например:

|Число частей и пример`s`|IPv4-адрес для IPEndPoint. Address|Порт|
|-------------------------|--------------------------------|-------------------------|  
|1 — "1"|0.0.0.1|0|  
|2 — "20.2:80"|20.0.0.2|80|  
|2 — "20.65535:23"|20.0.255.255|23|  
|3 — "128.1.2:443"|128.1.0.2|443|  

> [!IMPORTANT]
> Обратите внимание, что этот метод принимает в качестве допустимого значения, которое может <xref:System.Int64>быть проанализировано как, <xref:System.Int64> а затем рассматривает его как длинное значение IP-адреса в сетевом байтом порядке, аналогично тому, как это делает Конструктор IPAddress. Это означает, что этот метод возвращает значение true, если Int64 анализируется успешно, даже если он представляет адрес, который не является допустимым IP-адресом. Например, если значение s равно "1", этот метод возвращает значение true, даже если "1" (или 0.0.0.1) не является допустимым IP-адресом, и вы можете ожидать, что этот метод возвратит значение false. Устранение этой ошибки приведет к нарушению работы существующих приложений, поэтому текущее поведение не изменится. Код может избежать такого поведения, гарантируя, что он использует только этот метод для анализа IP-адресов в точечно-десятичном формате.
 
Литеральные адреса IPv6 необходимо заключать в квадратные скобки [] при передаче конечной точки, указывающей номер порта; в противном случае квадратные скобки не являются обязательными.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out System.Net.IPEndPoint result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] class System.Net.IPEndPoint&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.TryParse(System.ReadOnlySpan{System.Char},System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As IPEndPoint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] System::Net::IPEndPoint ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Net.IPEndPoint.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="result" Type="System.Net.IPEndPoint" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Проверяемая конечная точка IP.</param>
        <param name="result">При возврате этот метод содержит версию <see cref="T:System.Net.IPEndPoint" /> для <paramref name="s" />.</param>
        <summary>Пытается преобразовать конечную точку IP-сети (адрес и порт), представленную в виде диапазона, доступного только для чтения, в его эквивалент <see cref="T:System.Net.IPEndPoint" /> и возвращает значение, указывающее, было ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="s" /> можно проанализировать как конечную точку IP. В противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out System.Net.IPEndPoint result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] class System.Net.IPEndPoint&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.IPEndPoint.TryParse(System.String,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As IPEndPoint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] System::Net::IPEndPoint ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Net.IPEndPoint.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="result" Type="System.Net.IPEndPoint" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Проверяемая конечная точка IP.</param>
        <param name="result">При возврате этот метод содержит версию <see cref="T:System.Net.IPEndPoint" /> для <paramref name="s" />.</param>
        <summary>Пытается преобразовать конечную точку IP-сети (адрес и порт), представленную в виде строки, в ее эквивалент <see cref="T:System.Net.IPEndPoint" /> и возвращает значение, указывающее, было ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="s" /> можно проанализировать как конечную точку IP. В противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
