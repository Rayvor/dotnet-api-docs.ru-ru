<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2ed8342b6a4f9b27379dac13b40de5945ef9f64e" /><Meta Name="ms.sourcegitcommit" Value="f6fc130f7b9399b2b130a137d6b0b2b73c1d17b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/18/2019" /><Meta Name="ms.locfileid" Value="74154634" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides a simple, programmatically controlled HTTP protocol listener. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

 С помощью класса <xref:System.Net.HttpListener> можно создать простой прослушиватель протокола HTTP, отвечающий на HTTP-запросы. Прослушиватель активен в течение времени существования объекта <xref:System.Net.HttpListener> и выполняется в приложении с его разрешениями.
   
 Чтобы использовать <xref:System.Net.HttpListener>, создайте новый экземпляр класса с помощью конструктора <xref:System.Net.HttpListener> и используйте свойство <xref:System.Net.HttpListener.Prefixes%2A>, чтобы получить доступ к коллекции, содержащей строки, которые указывают, какие префиксы универсального кода ресурса (URI) должны обрабатываться <xref:System.Net.HttpListener>.
  
 Строка префикса URI состоит из схемы (HTTP или HTTPS), узла, дополнительного порта и необязательного пути. Пример полной строки префикса — *http://www.contoso.com:8080/customerData/*. Префиксы должны оканчиваться косой чертой ("/"). Объект <xref:System.Net.HttpListener> с префиксом, который наиболее близко соответствует запрошенному URI, отвечает на запрос. Несколько <xref:System.Net.HttpListener> объектов не могут добавить один и тот же префикс; исключение <xref:System.ComponentModel.Win32Exception> возникает, если <xref:System.Net.HttpListener> добавляет префикс, который уже используется.
  
 Если указан порт, элемент Host можно заменить на "\*", чтобы указать, что <xref:System.Net.HttpListener> принимает запросы, отправляемые в порт, если запрашиваемый URI не совпадает ни с одним другим префиксом. Например, чтобы получить все запросы, отправленные на порт 8080, если запрашиваемый URI не обрабатывается ни одним из <xref:System.Net.HttpListener>, префикс *http://\*: 8080/*. Аналогично, чтобы указать, что <xref:System.Net.HttpListener> принимает все запросы, отправляемые в порт, замените элемент Host символом "+". Например, *https://+:8080*. Символы "\*" и "+" могут присутствовать в префиксах, включающих пути.
  
 Начиная с .NET Core 2,0 или .NET Framework 4,6 в Windows 10, поддомены с подстановочными знаками поддерживаются в префиксах URI, которые управляются объектом <xref:System.Net.HttpListener>. Чтобы указать поддомен с подстановочными знаками, используйте символ "\*" как часть имени узла в префиксе URI. Например, *http://\*. foo.com/*. Передайте его в качестве аргумента в метод <xref:System.Net.HttpListenerPrefixCollection.Add%2A>. Это работает начиная с .NET Core 2,0 или .NET Framework 4,6 в Windows 10; в более ранних версиях это приводит к созданию <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > **Не** следует использовать подстановочные привязки верхнего уровня (*http://\*: 8080/* и *http://+:8080*). Это может создать уязвимость и поставить ваше приложение под угрозу. Сюда относятся и строгие, и нестрогие подстановочные знаки. Вместо этого используйте имена узлов в явном виде. Привязки с подстановочными знаками на уровне дочерних доменов (например `*.mysub.com`) не создают таких угроз безопасности, если вы полностью контролируете родительский домен (в отличие от варианта `*.com`, создающего уязвимость). Дополнительные сведения см. в документе [rfc7230, раздел 5.4](https://tools.ietf.org/html/rfc7230#section-5.4).
  
 Чтобы начать прослушивание запросов от клиентов, добавьте префиксы URI в коллекцию и вызовите метод <xref:System.Net.HttpListener.Start%2A>. <xref:System.Net.HttpListener> предлагает как синхронные, так и асинхронные модели для обработки клиентских запросов. Доступ к запросам и связанным с ними ответам осуществляется с помощью объекта <xref:System.Net.HttpListenerContext>, возвращаемого методом <xref:System.Net.HttpListener.GetContext%2A>, или его асинхронных аналогов, методов <xref:System.Net.HttpListener.BeginGetContext%2A> и <xref:System.Net.HttpListener.EndGetContext%2A>.
  
 Синхронная модель подходит, если приложение должно блокироваться при ожидании запроса клиента и если требуется обработать только один запрос за раз. Используя синхронную модель, вызовите метод <xref:System.Net.HttpListener.GetContext%2A>, который ожидает отправки клиентом запроса. Метод возвращает объект <xref:System.Net.HttpListenerContext> для обработки, когда происходит событие.
  
 В более сложной асинхронной модели приложение не блокируется при ожидании запросов, и каждый запрос обрабатывается в собственном потоке выполнения. Используйте метод <xref:System.Net.HttpListener.BeginGetContext%2A>, чтобы указать определяемый приложением метод, вызываемый для каждого входящего запроса. В этом методе вызовите метод <xref:System.Net.HttpListener.EndGetContext%2A>, чтобы получить запрос, обработать его и ответить.
  
 В любой модели доступ к входящим запросам осуществляется с помощью свойства <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> и представляются <xref:System.Net.HttpListenerRequest>ными объектами. Аналогично, доступ к ответам осуществляется с помощью свойства <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> и представляются <xref:System.Net.HttpListenerResponse> объектами. Эти объекты совместно используют некоторые функциональные возможности с объектами <xref:System.Net.HttpWebRequest> и <xref:System.Net.HttpWebResponse>, но последние объекты не могут использоваться совместно с <xref:System.Net.HttpListener>, поскольку они реализуют клиент, а не сервер, поведение.
  
 <xref:System.Net.HttpListener> может требовать проверку подлинности клиента. Можно указать определенную схему, которая будет использоваться для проверки подлинности, или указать делегат, определяющий используемую схему. Для получения сведений об удостоверении клиента необходимо иметь некоторую форму проверки подлинности. Дополнительные сведения см. в разделе Свойства <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>и <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>.
  
> [!NOTE]
> При создании <xref:System.Net.HttpListener> по протоколу HTTPS необходимо выбрать сертификат сервера для этого прослушивателя. В противном случае <xref:System.Net.HttpWebRequest> запрос этого <xref:System.Net.HttpListener> завершится ошибкой с непредвиденным закрытием соединения.
  
> [!NOTE]
> Можно настроить сертификаты сервера и другие параметры прослушивателя с помощью сетевой оболочки (Netsh. exe). Дополнительные сведения см. в разделе [Сетевая оболочка (Netsh)](/windows-server/networking/technologies/netsh/netsh) . Исполняемый файл начал доставляться с Windows Server 2008 и Windows Vista.
  
> [!NOTE]
> Если для <xref:System.Net.HttpListener>указана несколько схем проверки подлинности, прослушиватель будет выполнит клиенты в следующем порядке: `Negotiate`, `NTLM`, `Digest`, а затем `Basic`.

### <a name="httpsys"></a>HTTP.sys

Класс <xref:System.Net.HttpListener> построен на основе `HTTP.sys`, который является прослушивателем режима ядра, который обрабатывает весь трафик HTTP для Windows.
`HTTP.sys` обеспечивает управление подключениями, регулирование пропускной способности и ведение журнала веб-сервера.
Используйте средство [HttpCfg. exe](/windows/win32/http/httpcfg-exe) для добавления SSL-сертификатов.
  
## Examples
 В следующем примере кода показано использование <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/network-programming/changes-to-ntlm-authentication-for-httpwebrequest-in-version-3-5-sp1.md">Изменения проверки подлинности NTLM для HTTPWebRequest в версии 3,5 SP1</related>
    <related type="Article" href="/windows/win32/http/httpcfg-exe">HttpCfg.exe</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpListener" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед использованием экземпляра, возвращаемого этим конструктором, необходимо вызвать его метод <xref:System.Net.HttpListener.Start%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование конструктора <xref:System.Net.HttpListener> для создания нового объекта <xref:System.Net.HttpListener>. Полный пример см. в разделе <xref:System.Net.HttpListener> Class.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
 [!code-vb[Net_Listener_Basic#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">This class cannot be used on the current operating system. Windows Server 2003 or Windows XP SP2 is required to use instances of this class.</exception>
        <block subset="none" type="usage"><para>Примечание. Этот элемент выводит данные трассировки при включении трассировки сети в приложении. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shuts down the <see cref="T:System.Net.HttpListener" /> object immediately, discarding all currently queued requests.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод уничтожает все ресурсы, удерживаемые этим прослушивателем. Все ожидающие запросы не могут быть завершены.  
  
 После вызова этого метода вы получите <xref:System.ObjectDisposedException>, если попытаться использовать этот <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the scheme used to authenticate clients.</summary>
        <value>Битовая комбинация значений перечисления <see cref="T:System.Net.AuthenticationSchemes" />, которая указывает, как клиенты должны проходить аутентификацию. Значение по умолчанию — <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener> использует указанную схему для проверки подлинности всех входящих запросов. Методы <xref:System.Net.HttpListener.GetContext%2A> и <xref:System.Net.HttpListener.EndGetContext%2A> возвращают входящий запрос клиента, только если <xref:System.Net.HttpListener> успешно проходит проверку подлинности запроса.  
  
 Вы можете запросить удостоверение успешно прошедшего проверку подлинности клиента с помощью свойства <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType>.  
  
 Если вы хотите, чтобы объект <xref:System.Net.HttpListener> использовал разные механизмы проверки подлинности на основе характеристик получаемых им запросов (например, свойство запроса <xref:System.Net.HttpListenerRequest.Url%2A> или <xref:System.Net.HttpListenerRequest.UserHostName%2A>), необходимо реализовать метод, который выбирает схему проверки подлинности. Инструкции по выполнению этой задачи см. в документации по свойству <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>.  
  
> [!NOTE]
>  Чтобы задать для этого свойства включение дайджеста, NTLM или Negotiate, требуется <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода показано использование свойства <xref:System.Net.HttpListener.AuthenticationSchemes%2A> для указания схемы проверки подлинности.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate called to determine the protocol used to authenticate clients.</summary>
        <value>Делегат <see cref="T:System.Net.AuthenticationSchemeSelector" />, который вызывает метод, используемый для выбора протокола аутентификации. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если необходимо использовать один и тот же протокол проверки подлинности для всех запросов, обрабатываемых определенным экземпляром <xref:System.Net.HttpListener>, это свойство задавать не нужно. Чтобы указать протокол, используемый для всех клиентских запросов, используйте свойство <xref:System.Net.HttpListener.AuthenticationSchemes%2A>.  
  
 Если клиент не указал данные проверки подлинности в своих заголовках, <xref:System.Net.HttpListener> вызывает указанный делегат для каждого входящего запроса, не прошедшего проверку подлинности, чтобы определить, какой протокол следует использовать для проверки подлинности клиента. Методы <xref:System.Net.HttpListener.GetContext%2A> и <xref:System.Net.HttpListener.EndGetContext%2A> возвращают входящий запрос только в том случае, если <xref:System.Net.HttpListener> успешно прошел проверку подлинности запроса. Если запрос не может пройти проверку подлинности, <xref:System.Net.HttpListener> автоматически отправляет ответ 401. Удостоверение успешно прошедшего проверку подлинности клиента можно получить с помощью свойства <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType>.  
  
 Возможность делегирования выбора протокола проверки подлинности в метод для конкретного приложения полезна, если требуется, чтобы экземпляр <xref:System.Net.HttpListener> использовал разные протоколы проверки подлинности в зависимости от характеристик получаемых запросов (например, <xref:System.Net.HttpListenerRequest.Url%2A> или <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> свойства запроса).  
  
> [!NOTE]
>  Чтобы задать для этого свойства включение дайджеста, NTLM или Negotiate, требуется <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода задается значение этого свойства.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 В следующем примере кода показана реализация метода, вызываемого делегатом <xref:System.Net.AuthenticationSchemeSelector>.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when a client request is available.</param>
        <param name="state">A user-defined object that contains information about the operation. This object is passed to the <paramref name="callback" /> delegate when the operation completes.</param>
        <summary>Begins asynchronously retrieving an incoming request.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object that indicates the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpListener.BeginGetContext%2A> начинает асинхронный (не блокирующий) вызов для получения входящих клиентских запросов. Перед вызовом этого метода необходимо вызвать метод <xref:System.Net.HttpListener.Start%2A> и добавить по крайней мере один префикс универсального идентификатора ресурса (URI) для прослушивания путем добавления строк URI в <xref:System.Net.HttpListenerPrefixCollection>, возвращаемый свойством <xref:System.Net.HttpListener.Prefixes%2A>.  
  
 Асинхронная операция должна быть завершена путем вызова метода <xref:System.Net.HttpListener.EndGetContext%2A>. Как правило, метод вызывается делегатом `callback`.  
  
 Этот метод не блокируется при завершении операции. Чтобы получить входящий запрос и заблокировать его до завершения операции, вызовите метод <xref:System.Net.HttpListener.GetContext%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показано использование метода <xref:System.Net.HttpListener.BeginGetContext%2A> для указания метода обратного вызова, который будет обрабатывать входящие клиентские запросы.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 В следующем примере кода реализуется метод обратного вызова.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">A Win32 function call failed. Check the exception's <see cref="P:System.Net.HttpListenerException.ErrorCode" /> property to determine the cause of the exception.</exception>
        <exception cref="T:System.InvalidOperationException">This object has not been started or is currently stopped.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shuts down the <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода вы больше не можете использовать объект <xref:System.Net.HttpListener>. Чтобы временно приостановить <xref:System.Net.HttpListener> объект, используйте метод <xref:System.Net.HttpListener.Stop%2A>.  
  
 Этот метод завершает работу объекта <xref:System.Net.HttpListener> без обработки запросов в очереди. Все ожидающие запросы не могут быть завершены.  
  
## Examples  

В следующем примере кода демонстрируется вызов метода `Close`:
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
[!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a default list of Service Provider Names (SPNs) as determined by registered prefixes.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" />, содержащий список SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpListener.DefaultServiceNames%2A> используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Список имен участников-служб инициализируется из свойства <xref:System.Net.HttpListener.Prefixes%2A> при доступе и очистке при добавлении новых префиксов к свойству <xref:System.Net.HttpListener.Prefixes%2A>.  
  
 Свойство <xref:System.Net.HttpListener.DefaultServiceNames%2A> используется, если приложение не устанавливает свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> для своей политики расширенной защиты.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection>, получаемый со свойством <xref:System.Net.HttpListener.DefaultServiceNames%2A>, строится на основе свойства <xref:System.Net.HttpListener.Prefixes%2A> в соответствии со следующими правилами:  
  
1.  Если имя узла — "+", "*", или литерал IPv4 или IPv6 (эквивалентен "\*", но ограничен конкретным локальным интерфейсом), добавляется следующее имя участника-службы:  
  
 `"HTTP/"` и полное доменное имя компьютера.  
  
1.  Если имя узла не содержит точек (домены или поддомены), предпринимается попытка разрешения полного доменного имени с помощью DNS (аналогичное поведение, используемое <xref:System.Net.HttpWebRequest>). Если полное доменное имя можно разрешить, добавляются следующие имена участников-служб:  
  
 `"HTTP/"` и имя узла (короткое имя).  
  
 `"HTTP/"` и полное доменное имя узла.  
  
1.  Если имя узла содержит не точки (домены или поддомены) и полное доменное имя не удается разрешить, добавляется следующее имя участника-службы:  
  
 `"HTTP/"` и имя узла.  
  
1.  Если имя узла содержит точки (домены или поддомены), добавляется следующее имя участника-службы:  
  
 `"HTTP/"` и имя узла.  
  
 Свойство <xref:System.Net.HttpListener.DefaultServiceNames%2A> может использоваться приложением для просмотра списка имен участников-служб по умолчанию, которые будут использоваться для проверки подлинности, если пользовательский список не предоставляется. Если требуются другие имена участников-служб, приложение может добавить их с помощью одного из методов <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A>.  
  
 Использование расширенной защиты для принятия решений по политике на основе запрошенного URL-адреса является ненадежным, так как это можно сделать подмену. Вместо этого приложения должны полагаться на свойства <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> или <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A>, чтобы принимать такие решения по политике.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Интегрированная проверка подлинности Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that was obtained when the asynchronous operation was started.</param>
        <summary>Completes an asynchronous operation to retrieve an incoming client request.</summary>
        <returns>An <see cref="T:System.Net.HttpListenerContext" /> object that represents the client request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpListener.EndGetContext%2A> вызывается, как правило, в определяемом приложением методе обратного вызова, вызываемом делегатом, для получения объекта <xref:System.Net.HttpListenerContext>, содержащего входящий клиентский запрос и связанный с ним ответ. Этот метод завершает операцию, ранее запущенную с помощью вызова метода <xref:System.Net.HttpListener.BeginGetContext%2A>. Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Поскольку для вызова метода <xref:System.Net.HttpListener.EndGetContext%2A> требуется объект <xref:System.Net.HttpListener>, этот объект обычно передается в метод обратного вызова с помощью объекта состояния, переданного в метод <xref:System.Net.HttpListener.BeginGetContext%2A>. Этот объект состояния можно получить с помощью свойства <xref:System.IAsyncResult.AsyncState%2A> объекта `asyncResult`.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показана реализация метода обратного вызова, который вызывает метод <xref:System.Net.HttpListener.EndGetContext%2A>.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not obtained by calling the <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">A Win32 function call failed. Check the exception's <see cref="P:System.Net.HttpListenerException.ErrorCode" /> property to determine the cause of the exception.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> method was already called for the specified <paramref name="asyncResult" /> object.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> to use for extended protection for a session.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Свойство <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> позволяет настроить политику расширенной защиты для всего сеанса <xref:System.Net.HttpListener>. Свойство <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> позволяет настроить политику расширенной защиты для каждого отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно быть `null`. Экземпляр <xref:System.Net.HttpListener> получает маркер привязки канала (CBT) непосредственно из своего собственного сеанса TLS, если таковой имеется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> property, but the <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> property was not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> property to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> property after the <see cref="M:System.Net.HttpListener.Start" /> method was already called.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> property was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Интегрированная проверка подлинности Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate called to determine the <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> to use for each request.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Свойство <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> позволяет настроить политику расширенной защиты для всего сеанса <xref:System.Net.HttpListener>. Свойство <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> позволяет настроить расширенную политику защиты для отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно быть `null`. Экземпляр <xref:System.Net.HttpListener> получает маркер привязки канала (CBT) непосредственно из своего собственного сеанса TLS, если таковой имеется.  
  
 Для каждого запроса делегат может выбрать параметры, которые экземпляр <xref:System.Net.HttpListener> будет использовать для обеспечения расширенной защиты.  
  
 Если делегат возвращает `null` для этого свойства, он представляет <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, для свойства <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> которого задано значение <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> property, but the <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> property must be <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> property to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> property after the <see cref="M:System.Net.HttpListener.Start" /> method was already called.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">An attempt was made to set the <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> property on a platform that does not support extended protection.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Интегрированная проверка подлинности Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Waits for an incoming request and returns when one is received.</summary>
        <returns>An <see cref="T:System.Net.HttpListenerContext" /> object that represents a client request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом этого метода необходимо вызвать метод <xref:System.Net.HttpListener.Start%2A> и добавить по крайней мере один префикс URI для прослушивания путем добавления строк URI в <xref:System.Net.HttpListenerPrefixCollection>, возвращаемых свойством <xref:System.Net.HttpListener.Prefixes%2A>. Подробное описание префиксов см. в разделе Общие сведения о классе <xref:System.Net.HttpListener>.  
  
 Этот метод блокируется при ожидании входящего запроса. Если требуется, чтобы входящие запросы обрабатывались асинхронно (в отдельных потоках), чтобы приложение не блокировалось, используйте метод <xref:System.Net.HttpListener.BeginGetContext%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">A Win32 function call failed. Check the exception's <see cref="P:System.Net.HttpListenerException.ErrorCode" /> property to determine the cause of the exception.</exception>
        <exception cref="T:System.InvalidOperationException">This object has not been started or is currently stopped.  
  
-or- 
The <see cref="T:System.Net.HttpListener" /> does not have any Uniform Resource Identifier (URI) prefixes to respond to.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Waits for an incoming request as an asynchronous operation.</summary>
        <returns>The task object representing the asynchronous operation. The <see cref="P:System.Threading.Tasks.Task`1.Result" /> property on the task object returns an <see cref="T:System.Net.HttpListenerContext" /> object that represents a client request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокироваться. Возвращенный объект <xref:System.Threading.Tasks.Task%601> будет выполнен после получения входящего запроса.  
  
 Перед вызовом этого метода необходимо вызвать метод <xref:System.Net.HttpListener.Start%2A> и добавить по крайней мере один префикс URI для прослушивания путем добавления строк URI в <xref:System.Net.HttpListenerPrefixCollection>, возвращаемых свойством <xref:System.Net.HttpListener.Prefixes%2A>. Подробное описание префиксов см. в разделе Общие сведения о классе <xref:System.Net.HttpListener>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether your application receives exceptions that occur when an <see cref="T:System.Net.HttpListener" /> sends the response to the client.</summary>
        <value><see langword="true" />, если эта <see cref="T:System.Net.HttpListener" /> не должна возвращать исключения, происходящие при отправке ответа клиенту; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true`, если приложение не требует, чтобы ответ был успешно отправлен каждому клиенту.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether <see cref="T:System.Net.HttpListener" /> has been started.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.HttpListener" /> был запущен; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы запустить <xref:System.Net.HttpListener>, вызовите метод <xref:System.Net.HttpListener.Start%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого свойства для определения состояния прослушивания экземпляра.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether <see cref="T:System.Net.HttpListener" /> can be used with the current operating system.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Net.HttpListener" /> поддерживается; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс доступен только на компьютерах под управлением операционных систем Windows XP с пакетом обновления 2 (SP2) или Windows Server 2003.  
  
   
  
## Examples  
 В следующем примере кода показано использование свойства <xref:System.Net.HttpListener.IsSupported%2A> для определения возможности использования объекта <xref:System.Net.HttpListener> в текущей операционной системе.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) prefixes handled by this <see cref="T:System.Net.HttpListener" /> object.</summary>
        <value>Коллекция <see cref="T:System.Net.HttpListenerPrefixCollection" />, содержащая префиксы URI, которые может обрабатывать этот объект <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Префиксы представлены в канонической форме. Подробное описание префиксов см. в разделе Общие сведения о классе <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 В следующем примере кода показано использование свойства <xref:System.Net.HttpListener.Prefixes%2A> для получения и печати обрабатываемых префиксов URI.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the realm, or resource partition, associated with this <see cref="T:System.Net.HttpListener" /> object.</summary>
        <value>Значение <see cref="T:System.String" />, которое содержит имя области, связанной с этим объектом <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серверы используют сферы для секционирования защищенных ресурсов. Каждая секция может иметь собственную схему проверки подлинности и (или) базу данных авторизации. Области используются только для обычной проверки подлинности и дайджест-проверки подлинности. После успешного прохождения клиентом проверки подлинности ее результаты действительны для всех ресурсов в данной области. Подробное описание сфер см. в документе RFC 2617 по адресу [https://www.ietf.org/](https://www.ietf.org/).  
  
 Экземпляр <xref:System.Net.HttpListener> имеет только одну связанную область.  
  
   
  
## Examples  
 В следующем примере кода показано задание свойства <xref:System.Net.HttpListener.Realm%2A>.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
 [!code-vb[Net_Listener_Basic#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows this instance to receive incoming requests.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться перед вызовом метода <xref:System.Net.HttpListener.GetContext%2A> или <xref:System.Net.HttpListener.BeginGetContext%2A>.  
  
 После запуска объекта <xref:System.Net.HttpListener> можно использовать метод <xref:System.Net.HttpListener.Stop%2A> для его отмены.  
  
> [!NOTE]
>  Если этот экземпляр прослушивателя использует протокол HTTPS, необходимо установить и выбрать сертификат сервера. В противном случае <xref:System.Net.HttpWebRequest> запрос этого <xref:System.Net.HttpListener> завершится ошибкой с непредвиденным закрытием соединения. Сертификаты сервера и другие параметры прослушивателя можно настроить с помощью HttpCfg. exe. Дополнительные сведения см. в разделе [https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) .  
  
   
  
## Examples  
 В следующем примере кода показано использование метода <xref:System.Net.HttpListener.Start%2A> для начала обработки входящих запросов.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">A Win32 function call failed. Check the exception's <see cref="P:System.Net.HttpListenerException.ErrorCode" /> property to determine the cause of the exception.</exception>
        <exception cref="T:System.ObjectDisposedException">This object is closed.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes this instance to stop receiving incoming requests.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот экземпляр уже остановлен, вызов этого метода не оказывает никакого влияния.  
  
 После остановки объекта <xref:System.Net.HttpListener> можно использовать метод <xref:System.Net.HttpListener.Start%2A> для его перезапуска.  
  
   
  
## Examples  
 
В следующем примере кода показано использование метода <xref:System.Net.HttpListener.Stop%2A> для отмены обработки входящих запросов.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
[!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources held by this <see cref="T:System.Net.HttpListener" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения должны использовать метод <xref:System.Net.HttpListener.Close%2A> вместо вызова этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The timeout manager for this <see cref="T:System.Net.HttpListener" /> instance.</summary>
        <value>Диспетчер времени ожидания для этого экземпляра <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диспетчер времени ожидания определяет ограничения времени ожидания подключения для данного экземпляра <xref:System.Net.HttpListener>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether, when NTLM is used, additional requests using the same Transmission Control Protocol (TCP) connection are required to authenticate.</summary>
        <value><see langword="true" />, если <see cref="T:System.Security.Principal.IIdentity" /> первого запроса будет использоваться для последующих запросов к тому же соединению; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для этого свойства задано значение `true` и первый запрос по конкретному TCP-соединению проходит проверку подлинности с помощью NTLM, последующие запросы к тому же подключению TCP обрабатываются с использованием сведений проверки подлинности (<xref:System.Security.Principal.IIdentity>) первоначального запроса.  
  
 Это свойство не имеет значения, если NTLM не является протоколом проверки подлинности. Если в качестве протокола проверки подлинности указано Negotiate, это свойство действует, только если NTLM — это фактический протокол, используемый для проверки подлинности.  
  
> [!NOTE]
>  При установке этого свойства в `true` повышается производительность, поскольку <xref:System.Net.HttpListener> не отправляет дополнительные проблемы проверки подлинности NTLM, существует угроза безопасности, при которой не требуется, чтобы все запросы на предоставление сведений о проверке подлинности. Необходимо определить, стоит ли снижать безопасность с целью увеличения производительности.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
