<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="588a6abf2f44e4fe8c587db29a2520e40e47e9bd" /><Meta Name="ms.sourcegitcommit" Value="0609891c89ddaa91e4c02970acb00072fcc29baf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/13/2019" /><Meta Name="ms.locfileid" Value="65558563" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет простой программно управляемый прослушиватель протокола HTTP. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Net.HttpListener> класса можно создать простой прослушиватель протокола HTTP, отвечающий на HTTP-запросы. Прослушиватель активен в течение всего времени существования <xref:System.Net.HttpListener> объекта и выполняется в приложении с его разрешениями.
   
 Чтобы использовать <xref:System.Net.HttpListener>, создайте новый экземпляр класса <xref:System.Net.HttpListener> с помощью конструктора и используйте <xref:System.Net.HttpListener.Prefixes%2A> свойство, чтобы получить доступ к коллекции, содержащей строки, указывающие, какой универсальный код ресурса (URI) добавляет префикс <xref:System.Net.HttpListener>должен обрабатываться.
  
 Строка префикса URI состоит из схемы (HTTP или HTTPS), узла, дополнительного порта и необязательного пути. Пример полной строки префикса: *http://www.contoso.com:8080/customerData/*. Префиксы должны оканчиваться косой чертой ("/"). <xref:System.Net.HttpListener> Объект с префиксом, который наиболее близко соответствует запрошенному URI, отвечает на запрос. Несколько <xref:System.Net.HttpListener> объектов не могут добавить один и тот же <xref:System.ComponentModel.Win32Exception> префикс; <xref:System.Net.HttpListener> исключение создается, если добавляет префикс, который уже используется.
  
 Если указан порт, элемент Host можно заменить на "\*", чтобы указать <xref:System.Net.HttpListener> , что принимает запросы, отправляемые на порт, если запрашиваемый URI не совпадает ни с каким другим префиксом. Например, чтобы получить все запросы, отправленные на порт 8080, если запрашиваемый URI не обрабатывается <xref:System.Net.HttpListener>ни одним из них, то префиксом будет *http://\*: 8080/*. Аналогично, чтобы указать, <xref:System.Net.HttpListener> что компонент принимает все запросы, отправляемые в порт, замените элемент Host символом "+". Например, *https://+:8080*. Символы "\*" и "+" могут присутствовать в префиксах, включающих пути.
  
 Начиная с .NET Core 2,0 или .NET Framework 4,6 в Windows 10, поддомены с подстановочными знаками поддерживаются в префиксах URI, <xref:System.Net.HttpListener> управляемых объектом. Чтобы указать поддомен с подстановочными знаками, используйте\*символ "" как часть имени узла в префиксе URI. Например, *\*http://. foo.com/*. Передайте его в качестве аргумента <xref:System.Net.HttpListenerPrefixCollection.Add%2A> в метод. Это работает начиная с .NET Core 2,0 или .NET Framework 4,6 в Windows 10; в более ранних версиях это создает <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > **Не** следует использовать подстановочные привязки верхнего уровня (*http://\*: 8080/* и *http://+:8080*). Это может создать уязвимость и поставить ваше приложение под угрозу. Сюда относятся и строгие, и нестрогие подстановочные знаки. Вместо этого используйте имена узлов в явном виде. Привязки с подстановочными знаками на уровне дочерних доменов (например `*.mysub.com`) не создают таких угроз безопасности, если вы полностью контролируете родительский домен (в отличие от варианта `*.com`, создающего уязвимость). Дополнительные сведения см. в документе [rfc7230, раздел 5.4](https://tools.ietf.org/html/rfc7230#section-5.4).
  
 Чтобы начать прослушивание запросов от клиентов, добавьте префиксы URI в коллекцию и вызовите <xref:System.Net.HttpListener.Start%2A> метод. <xref:System.Net.HttpListener>предлагает как синхронные, так и асинхронные модели для обработки клиентских запросов. Доступ к запросам и связанным с ними <xref:System.Net.HttpListenerContext> ответам осуществляется с <xref:System.Net.HttpListener.GetContext%2A> помощью объекта, возвращаемого методом, или <xref:System.Net.HttpListener.BeginGetContext%2A> его <xref:System.Net.HttpListener.EndGetContext%2A> асинхронными аналогами, методами и.
  
 Синхронная модель подходит, если приложение должно блокироваться при ожидании запроса клиента и если требуется обработать только один запрос за раз. Используя синхронную модель, вызовите <xref:System.Net.HttpListener.GetContext%2A> метод, который ожидает отправки клиентом запроса. Метод возвращает <xref:System.Net.HttpListenerContext> объект для обработки, когда происходит событие.
  
 В более сложной асинхронной модели приложение не блокируется при ожидании запросов, и каждый запрос обрабатывается в собственном потоке выполнения. <xref:System.Net.HttpListener.BeginGetContext%2A> Используйте метод, чтобы указать определяемый приложением метод, вызываемый для каждого входящего запроса. В этом методе вызовите <xref:System.Net.HttpListener.EndGetContext%2A> метод, чтобы получить запрос, обработать его и ответить.
  
 В любой из этих моделей доступ к входящим запросам <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> осуществляется с помощью свойства и <xref:System.Net.HttpListenerRequest> представляются объектами. Аналогично, доступ к ответам <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> осуществляется с помощью свойства и <xref:System.Net.HttpListenerResponse> представляются объектами. Эти объекты совместно используют некоторые функциональные возможности <xref:System.Net.HttpWebRequest> с <xref:System.Net.HttpWebResponse> объектами и, но последние объекты не могут использоваться совместно с <xref:System.Net.HttpListener> , поскольку они реализуют клиент, а не сервер, поведение.
  
 <xref:System.Net.HttpListener> Может требоваться проверка подлинности клиента. Можно указать определенную схему, которая будет использоваться для проверки подлинности, или указать делегат, определяющий используемую схему. Для получения сведений об удостоверении клиента необходимо иметь некоторую форму проверки подлинности. Дополнительные сведения см. в <xref:System.Net.HttpListenerContext.User%2A>разделе Свойства, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>и <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> .
  
> [!NOTE]
> При создании <xref:System.Net.HttpListener> с помощью HTTPS необходимо выбрать сертификат сервера для этого прослушивателя. В противном случае <xref:System.Net.HttpListener> запросбудетзавершатьсяснепредвиденнымзакрытиемсоединения.<xref:System.Net.HttpWebRequest>
  
> [!NOTE]
> Можно настроить сертификаты сервера и другие параметры прослушивателя с помощью сетевой оболочки (Netsh. exe). Дополнительные сведения см. в разделе [Сетевая оболочка (Netsh)](/windows-server/networking/technologies/netsh/netsh) . Исполняемый файл начал доставляться с Windows Server 2008 и Windows Vista.
  
> [!NOTE]
> Если для <xref:System.Net.HttpListener>задано несколько схем проверки подлинности, прослушиватель выполнит запрос клиентов в следующем `Negotiate`порядке: `Digest` `Basic`, `NTLM`, и.
  
   
  
## Examples
 В следующем примере кода показано использование <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Изменения проверки подлинности NTLM для HTTPWebRequest в версии 3,5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед использованием экземпляра, возвращаемого этим конструктором, необходимо вызвать его <xref:System.Net.HttpListener.Start%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.HttpListener> конструктора для создания нового <xref:System.Net.HttpListener> объекта. Полный пример см. в <xref:System.Net.HttpListener> разделе о классе.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
 [!code-vb[Net_Listener_Basic#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Этот класс не может использоваться в этой операционной системе. Для использования экземпляров этого класса требуется операционная система Windows Server 2003 или Windows XP с пакетом обновления 2.</exception>
        <block subset="none" type="usage"><para>Примечание. Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Незамедлительно завершает работу объекта <see cref="T:System.Net.HttpListener" />, отменяя все текущие запросы в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод уничтожает все ресурсы, удерживаемые этим прослушивателем. Все ожидающие запросы не могут быть завершены.  
  
 После вызова этого метода вы получите исключение <xref:System.ObjectDisposedException> , если попытаться использовать его. <xref:System.Net.HttpListener>  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает схему, используемую для проверки подлинности клиентов.</summary>
        <value>Битовая комбинация значений перечисления <see cref="T:System.Net.AuthenticationSchemes" />, которая указывает, как клиенты должны проходить проверку подлинности. Значение по умолчанию — <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener> Использует указанную схему для проверки подлинности всех входящих запросов. Методы <xref:System.Net.HttpListener.GetContext%2A> <xref:System.Net.HttpListener> и <xref:System.Net.HttpListener.EndGetContext%2A> возвращают входящий запрос клиента только в случае успешной проверки подлинности запроса.  
  
 Вы можете запросить удостоверение успешно прошедшего проверку подлинности клиента с помощью <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> свойства.  
  
 Если требуется <xref:System.Net.HttpListener> , чтобы объект использовал разные механизмы проверки подлинности на основе характеристик получаемых им запросов (например, свойства <xref:System.Net.HttpListenerRequest.Url%2A> запроса или <xref:System.Net.HttpListenerRequest.UserHostName%2A> ), необходимо реализовать метод, который выбирает Схема проверки подлинности. Инструкции о том, как это сделать, см. <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> в документации по свойству.  
  
> [!NOTE]
>  Чтобы установить это свойство для включения дайджеста, NTLM или Negotiate, требуется <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.AuthenticationSchemes%2A> свойства для указания схемы проверки подлинности.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегата, вызываемого для определения протокола, который будет использоваться для проверки подлинности клиентов.</summary>
        <value>Делегат <see cref="T:System.Net.AuthenticationSchemeSelector" />, который вызывает метод, используемый для выбора протокола проверки подлинности. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если необходимо, чтобы один и тот же протокол проверки подлинности использовался для всех запросов <xref:System.Net.HttpListener>, обрабатываемых определенным экземпляром, не нужно задавать это свойство. Чтобы указать протокол, используемый для всех клиентских запросов, используйте <xref:System.Net.HttpListener.AuthenticationSchemes%2A> свойство.  
  
 Если клиент не указал данные проверки подлинности в своих заголовках <xref:System.Net.HttpListener> , метод вызывает указанный делегат для каждого входящего запроса, не прошедшего проверку подлинности, чтобы определить, какой протокол будет использоваться для проверки подлинности клиента. Методы <xref:System.Net.HttpListener.GetContext%2A> <xref:System.Net.HttpListener> и <xref:System.Net.HttpListener.EndGetContext%2A> возвращают входящий запрос только в случае успешной проверки подлинности запроса. Если запрос не может пройти проверку подлинности <xref:System.Net.HttpListener> , автоматически отправляет ответ 401. Удостоверение успешно прошедшего проверку подлинности клиента можно получить с <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> помощью свойства.  
  
 Возможность делегирования выбора протокола проверки подлинности в метод для конкретного приложения полезна, если требуется, <xref:System.Net.HttpListener> чтобы экземпляр использовал разные протоколы проверки подлинности в зависимости от характеристик получаемых запросов (для Пример: свойство запроса <xref:System.Net.HttpListenerRequest.Url%2A> или. <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>  
  
> [!NOTE]
>  Чтобы установить это свойство для включения дайджеста, NTLM или Negotiate, требуется <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода задается значение этого свойства.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 В следующем примере кода показана реализация метода, <xref:System.Net.AuthenticationSchemeSelector> вызываемого делегатом.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, указывающий на метод, который следует вызвать при наличии клиентского запроса.</param>
        <param name="state">Пользовательский объект, содержащий сведения об операции. Этот объект передается делегату <paramref name="callback" /> после завершения операции.</param>
        <summary>Начинает асинхронное получение входящего запроса.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.BeginGetContext%2A> Метод начинает асинхронный (не блокирующий) вызов для получения входящих клиентских запросов. Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метод и добавить по крайней мере один префикс универсального идентификатора ресурса (URI) для прослушивания путем добавления строк URI в объект, <xref:System.Net.HttpListenerPrefixCollection> возвращаемый <xref:System.Net.HttpListener.Prefixes%2A> свойством.  
  
 Асинхронная операция должна быть завершена путем вызова <xref:System.Net.HttpListener.EndGetContext%2A> метода. Как правило, метод вызывается `callback` делегатом.  
  
 Этот метод не блокируется при завершении операции. Чтобы получить входящий запрос и заблокировать его до завершения операции, вызовите <xref:System.Net.HttpListener.GetContext%2A> метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.BeginGetContext%2A> метода для указания метода обратного вызова, который будет обрабатывать входящие клиентские запросы.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 В следующем примере кода реализуется метод обратного вызова.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.InvalidOperationException">Этот объект не был запущен или в настоящее время остановлен.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает работу <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода вы больше не сможете использовать <xref:System.Net.HttpListener> объект. Чтобы временно приостановить <xref:System.Net.HttpListener> работу объекта, <xref:System.Net.HttpListener.Stop%2A> используйте метод.  
  
 Этот метод завершает работу <xref:System.Net.HttpListener> объекта без обработки запросов в очереди. Все ожидающие запросы не могут быть завершены.  
  
## Examples  

В следующем примере кода демонстрируется вызов `Close` метода:
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
[!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список имен поставщиков услуг (SPN) по умолчанию, определенный зарегистрированными префиксами.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" />, содержащий список SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Список имен участников-служб инициализируется из <xref:System.Net.HttpListener.Prefixes%2A> свойства при доступе и очистке при добавлении новых префиксов <xref:System.Net.HttpListener.Prefixes%2A> к свойству.  
  
 Свойство <xref:System.Net.HttpListener.DefaultServiceNames%2A> используется, если приложение не <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> устанавливает свойство для своей политики расширенной защиты.  
  
 Объект <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> , полученный <xref:System.Net.HttpListener.DefaultServiceNames%2A> со <xref:System.Net.HttpListener.Prefixes%2A> свойством, строится на основе свойства в соответствии со следующими правилами.  
  
1.  Если имя узла — "+", "*", или литерал IPv4 или IPv6 (эквивалентен "\*", но ограничен конкретным локальным интерфейсом), добавляется следующее имя участника-службы:  
  
 `"HTTP/"`а также полное доменное имя компьютера.  
  
1.  Если имя узла не содержит точек (домены или поддомены), предпринимается попытка разрешить полное доменное имя с помощью DNS (то же поведение, которое используется <xref:System.Net.HttpWebRequest>). Если полное доменное имя можно разрешить, добавляются следующие имена участников-служб:  
  
 `"HTTP/"`а также имя узла (короткое имя).  
  
 `"HTTP/"`а также полное доменное имя узла.  
  
1.  Если имя узла содержит не точки (домены или поддомены) и полное доменное имя не удается разрешить, добавляется следующее имя участника-службы:  
  
 `"HTTP/"`и имя узла.  
  
1.  Если имя узла содержит точки (домены или поддомены), добавляется следующее имя участника-службы:  
  
 `"HTTP/"`и имя узла.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Свойство может использоваться приложением для просмотра списка имен участников-служб по умолчанию, которые будут использоваться для проверки подлинности, если пользовательский список не указан. Если требуются другие имена участников-служб, приложение может добавить их с помощью одного <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> из методов.  
  
 Использование расширенной защиты для принятия решений по политике на основе запрошенного URL-адреса является ненадежным, так как это можно сделать подмену. Вместо этого приложения должны использовать свойства <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> или <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> для принятия таких решений о политике.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, который был получен при запуске асинхронной операции.</param>
        <summary>Завершает асинхронную операцию получения входящего клиентского запроса.</summary>
        <returns>Объект <see cref="T:System.Net.HttpListenerContext" />, представляющий клиентский запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод вызывается, как правило, в определяемом приложением методе обратного вызова, который вызывается делегатом <xref:System.Net.HttpListenerContext> для получения объекта, содержащего входящий клиентский запрос и связанный с ним ответ. <xref:System.Net.HttpListener.EndGetContext%2A> Этот метод завершает операцию, ранее запущенную с помощью вызова <xref:System.Net.HttpListener.BeginGetContext%2A> метода. Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Поскольку для вызова <xref:System.Net.HttpListener.EndGetContext%2A> метода <xref:System.Net.HttpListener> требуется объект, этот объект обычно передается в метод обратного вызова с помощью объекта <xref:System.Net.HttpListener.BeginGetContext%2A> состояния, переданного в метод. Этот объект состояния можно получить с помощью <xref:System.IAsyncResult.AsyncState%2A> свойства `asyncResult` объекта.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показана реализация метода обратного вызова, который вызывает <xref:System.Net.HttpListener.EndGetContext%2A> метод.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="asyncResult" /> не получено вызовом метода <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> уже был вызван для указанного объекта <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты сеанса.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Свойство позволяет настроить политику расширенной защиты для всего <xref:System.Net.HttpListener> сеанса. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Свойство позволяет настроить политику расширенной защиты для каждого отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно иметь значение `null`. <xref:System.Net.HttpListener> Экземпляр получает маркер привязки канала (CBT) непосредственно из своего собственного сеанса TLS, если таковой имеется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />, но свойство <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> не имело значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Предпринята попытка задать свойству <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> после вызова метода <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Свойству <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> было присвоено значение <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, не поддерживающей расширенную защиту.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает делегат, вызываемый для определения объекта <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который следует использовать для каждого запроса.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Свойство позволяет настроить политику расширенной защиты для всего <xref:System.Net.HttpListener> сеанса. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Свойство позволяет настроить расширенную политику защиты для отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно иметь значение `null`. <xref:System.Net.HttpListener> Экземпляр получает маркер привязки канала (CBT) непосредственно из своего собственного сеанса TLS, если таковой имеется.  
  
 Для каждого запроса делегат может выбрать параметры, которые <xref:System.Net.HttpListener> экземпляр будет использовать для обеспечения расширенной защиты.  
  
 Если делегат возвращает `null` для этого свойства, это <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> представляет <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> свойство, для <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>которого задано значение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />, но свойство <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Предпринята попытка задать свойству <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> после вызова метода <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Предпринята попытка задать свойство  <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> на платформе, не поддерживающей расширенную защиту.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ожидает входящий запрос и выполняет возврат при получении такого запроса.</summary>
        <returns>Объект <see cref="T:System.Net.HttpListenerContext" />, представляющий клиентский запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метод и добавить по крайней мере один префикс URI для прослушивания путем добавления строк URI в объект, <xref:System.Net.HttpListenerPrefixCollection> возвращаемый <xref:System.Net.HttpListener.Prefixes%2A> свойством. Подробное описание префиксов см. в <xref:System.Net.HttpListener> разделе Общие сведения о классе.  
  
 Этот метод блокируется при ожидании входящего запроса. Если требуется, чтобы входящие запросы обрабатывались асинхронно (в отдельных потоках), чтобы приложение не блокировало работу, <xref:System.Net.HttpListener.BeginGetContext%2A> используйте метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.InvalidOperationException">Этот объект не был запущен или в настоящее время остановлен.  
  
- или - 
Прослушиватель <see cref="T:System.Net.HttpListener" /> не имеет префиксов URI для ответа.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ожидает входящего запроса как асинхронной операции.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию. Свойство <see cref="P:System.Threading.Tasks.Task`1.Result" /> в объекте задачи возвращает объект <see cref="T:System.Net.HttpListenerContext" />, представляющий запрос клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокироваться. Возвращенный <xref:System.Threading.Tasks.Task%601> объект будет выполнен после получения входящего запроса.  
  
 Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метод и добавить по крайней мере один префикс URI для прослушивания путем добавления строк URI в объект, <xref:System.Net.HttpListenerPrefixCollection> возвращаемый <xref:System.Net.HttpListener.Prefixes%2A> свойством. Подробное описание префиксов см. в <xref:System.Net.HttpListener> разделе Общие сведения о классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое определяет, получает ли приложения исключения, которые возникают при отправке прослушивателем <see cref="T:System.Net.HttpListener" /> ответа клиенту.</summary>
        <value><see langword="true" />значение, если не <see langword="false" /> должновозвращатьисключения,происходящиеприотправкеответаклиенту;впротивномслучае—.<see cref="T:System.Net.HttpListener" /> Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте для этого свойства `true` значение, если приложению не требуется, чтобы ответ был успешно отправлен каждому клиенту.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли запущен прослушиватель <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Значение <see langword="true" />, если прослушиватель <see cref="T:System.Net.HttpListener" /> был запущен; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы запустить <xref:System.Net.HttpListener>, <xref:System.Net.HttpListener.Start%2A> вызовите метод.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого свойства для определения состояния прослушивания экземпляра.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли использовать прослушиватель <see cref="T:System.Net.HttpListener" /> в текущей операционной системе.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Net.HttpListener" /> поддерживается; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс доступен только на компьютерах под управлением операционных систем Windows XP с пакетом обновления 2 (SP2) или Windows Server 2003.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.IsSupported%2A> свойства для определения <xref:System.Net.HttpListener> возможности использования объекта в текущей операционной системе.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает префиксы URI, обрабатываемые этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Коллекция <see cref="T:System.Net.HttpListenerPrefixCollection" />, в которой содержатся префиксы URI, которые может обрабатывать этот объект <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Префиксы представлены в канонической форме. Подробное описание префиксов см. в <xref:System.Net.HttpListener> разделе Общие сведения о классе.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.Prefixes%2A> свойства для получения и печати обрабатываемых префиксов URI.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает область или раздел ресурса, связанные с этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Значение <see cref="T:System.String" />, которое содержит имя области, связанной с этим объектом <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серверы используют сферы для секционирования защищенных ресурсов. Каждая секция может иметь собственную схему проверки подлинности и (или) базу данных авторизации. Области используются только для обычной проверки подлинности и дайджест-проверки подлинности. После успешного прохождения клиентом проверки подлинности ее результаты действительны для всех ресурсов в данной области. Подробное описание сфер см. в RFC 2617 по адресу [https://www.ietf.org/](https://www.ietf.org/).  
  
 <xref:System.Net.HttpListener> У экземпляра есть только одна связанная область.  
  
   
  
## Examples  
 В следующем примере кода показано задание <xref:System.Net.HttpListener.Realm%2A> свойства.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
 [!code-vb[Net_Listener_Basic#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет этому экземпляру получать входящие запросы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться перед вызовом <xref:System.Net.HttpListener.GetContext%2A> метода или. <xref:System.Net.HttpListener.BeginGetContext%2A>  
  
 После запуска <xref:System.Net.HttpListener> объекта можно <xref:System.Net.HttpListener.Stop%2A> использовать метод, чтобы его отключить.  
  
> [!NOTE]
>  Если этот экземпляр прослушивателя использует протокол HTTPS, необходимо установить и выбрать сертификат сервера. В противном случае <xref:System.Net.HttpListener> запросбудетзавершатьсяснепредвиденнымзакрытиемсоединения.<xref:System.Net.HttpWebRequest> Сертификаты сервера и другие параметры прослушивателя можно настроить с помощью HttpCfg. exe. Дополнительные [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) сведения см. в разделе.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.Start%2A> метода для начала обработки входящих запросов.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заставляет этот экземпляр прекратить получать входящие запросы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот экземпляр уже остановлен, вызов этого метода не оказывает никакого влияния.  
  
 После остановки <xref:System.Net.HttpListener> объекта можно <xref:System.Net.HttpListener.Start%2A> использовать метод для его перезапуска.  
  
   
  
## Examples  
 
В следующем примере кода показано использование <xref:System.Net.HttpListener.Stop%2A> метода для отмены обработки входящих запросов.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
[!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <block subset="none" type="usage"><para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения должны использовать <xref:System.Net.HttpListener.Close%2A> метод вместо вызова этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Диспетчер времени ожидания для этого экземпляра <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Диспетчер времени ожидания для этого экземпляра <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диспетчер времени ожидания определяет ограничения времени ожидания подключения для данного <xref:System.Net.HttpListener> экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое управляет, должны ли дополнительные запросы, использующие TCP-подключение, проходить проверку подлинности при использовании протокола NTLM.</summary>
        <value>Значение <see langword="true" />, если сведения об идентификации <see cref="T:System.Security.Principal.IIdentity" /> первого запроса будут использоваться для последующих запросов на том же подключении, в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для `true` этого свойства задано значение и первый запрос по конкретному TCP-соединению проходит проверку подлинности с помощью NTLM, последующие запросы по этому же TCP-соединению<xref:System.Security.Principal.IIdentity>обрабатываются с использованием сведений о проверке подлинности () начального значения получения.  
  
 Это свойство не имеет значения, если NTLM не является протоколом проверки подлинности. Если в качестве протокола проверки подлинности указано Negotiate, это свойство действует, только если NTLM — это фактический протокол, используемый для проверки подлинности.  
  
> [!NOTE]
>  При задании этого свойства `true` для повышения производительности, <xref:System.Net.HttpListener> поскольку не отправляет дополнительные проблемы проверки подлинности NTLM, существует угроза безопасности, при которой не требуется, чтобы все запросы на предоставление сведений о проверке подлинности. Необходимо определить, стоит ли снижать безопасность с целью увеличения производительности.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
  </Members>
</Type>