<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a36b2762317640c0807dd57933a88f6eb251b886" /><Meta Name="ms.sourcegitcommit" Value="f55040f35c19a83c85beb55243330558f6e369be" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/10/2019" /><Meta Name="ms.locfileid" Value="66818552" /></Metadata><TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Управляет коллекцией объектов <see cref="T:System.Net.ServicePoint" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> — Это статический класс, используемый для создания, обслуживания и удаления всех экземпляров <xref:System.Net.ServicePoint> класса.  
  
 Когда приложение запрашивает подключение к Интернет-ресурсу универсальный код ресурса (URI) через <xref:System.Net.ServicePointManager> объекта, <xref:System.Net.ServicePointManager> возвращает <xref:System.Net.ServicePoint> , содержащий сведения о соединении для узла и определили схемы с помощью URI. Если имеется существующий <xref:System.Net.ServicePoint> объект для этого узла и схема, <xref:System.Net.ServicePointManager> возвращает существующий объект <xref:System.Net.ServicePoint> объекта; в противном случае <xref:System.Net.ServicePointManager> создает новый объект <xref:System.Net.ServicePoint> объекта.  
  
 .NET Framework 4.6 включает новую функцию безопасности, блокирующее небезопасных шифрования и хэширования алгоритмы для подключений. Приложений с помощью TLS/SSL через API-интерфейсы, такие как <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>т. д. и предназначенные для .NET Framework 4.6 получить более надежные и безопасные поведение по умолчанию.  
  
 Разработчики имеют возможность отказаться от этого поведения для обеспечения взаимодействия с существующими службами SSL3 или TLS с служб RC4. [В этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы отключить новое поведение.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.ServicePoint> объект для подключений к URI `www.contoso.com`.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager-элемент (параметры сети)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или устанавливает политику для сертификатов сервера.</summary>
        <value>Объект, реализующий интерфейс <see cref="T:System.Net.ICertificatePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.ServicePointManager.CertificatePolicy%2A> свойству <xref:System.Net.ICertificatePolicy> объект интерфейса <xref:System.Net.ServicePointManager> объект использует политики сертификата, определенные в этом экземпляре, а не политику сертификата по умолчанию.  
  
 Политика по умолчанию позволяет действительные сертификаты и действительные сертификаты с истекшим сроком действия.  
  
   
  
## Examples  
 В следующем примере кода показано, как перехватить исключение для пользовательской политики сертификатов. Предполагается, что был определен объект политики сертификатов, что универсальный код ресурса (URI) веб-ресурса, содержится в переменной `myUri`и имеется метод с именем `ProcessResponse` , выполняющий работу приложения.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы задать <see cref="P:System.Net.ServicePointManager.CertificatePolicy" /> свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, проверяется ли сертификат по списку отзыва сертификатов.</summary>
        <value>Значение <see langword="true" />, если проверяется список отзыва сертификатов; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> является `true`, сертификат проверяется по списку отзыва сертификатов, как часть процесса проверки сертификатов. Значение по умолчанию — `false`.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы задать это свойство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число одновременных подключений, разрешенное объектом <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Максимальное число одновременных подключений, разрешенное объектом <see cref="T:System.Net.ServicePoint" />. Ограничение числа подключений по умолчанию — 10 для приложений ASP.NET, размещенное и 2 для всех остальных. Когда приложение выполняется как узел ASP.NET, невозможно изменить значение этого свойства в файле конфигурации, если для свойства autoConfig задано значение <see langword="true" />. Однако можно изменить это значение программными средствами, если свойство autoConfig имеет значение <see langword="true" />. Задайте нужное значение один раз, при загрузке AppDomain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> Свойство задает по умолчанию максимальное число одновременных подключений, <xref:System.Net.ServicePointManager> назначает объект <xref:System.Net.ServicePoint.ConnectionLimit%2A> свойства при создании <xref:System.Net.ServicePoint> объектов.  
  
 Изменение <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> свойство не влияет на существующие <xref:System.Net.ServicePoint> объектов; он влияет только на <xref:System.Net.ServicePoint> объекты, которые инициализируются после изменения. Если значение этого свойства не задано, напрямую или через конфигурацию, по умолчанию устанавливается значение константы <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Любые изменения <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> свойство влияет на подключения HTTP 1.0 и HTTP 1.1. Это не невозможно отдельно изменить ограничение числа подключений для протоколов HTTP 1.0 и HTTP 1.1.
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> меньше или равно 0.</exception>
        <permission cref="T:System.Net.WebPermission">для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Допустимое по умолчанию количество непостоянных подключений (4) в объекте <see cref="T:System.Net.ServicePoint" />, подключенном к серверу HTTP/1.0 или к более старшей версии сервера. Это поле является константой, но больше не используется в платформе .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Допустимое по умолчанию количество постоянных подключений (2) в объекте <see cref="T:System.Net.ServicePoint" />, подключенном к серверу HTTP/1.1 или к более старшей версии сервера. Это поле является константой и используется для инициализации свойства <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />, если значение свойства <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> не было задано напрямую или посредством конфигурации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> свойство, с помощью этого поля.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает промежуток времени, в течение которого разрешение DNS-имени считается допустимым.</summary>
        <value>Значение времени ожидания в миллисекундах. Значение -1 указывает на бесконечное время ожидания. По умолчанию установлено значение 120 000 миллисекунд (2 минуты).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, происходит ли чередование допустимых IP-адресов при разрешении DNS-имен.</summary>
        <value>Значение <see langword="false" />, если при разрешении DNS-имен всегда возвращается первый IP-адрес определенного узла, в противном случае — <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если более одного IP-адрес связан с именем узла, разрешение DNS обычно возвращает только первый IP-адрес. Если задано это свойство `true`, то последующие разрешение DNS будут последовательно все доступные IP-адреса для определенного узла. Этот параметр полезен, если служба использует DNS в качестве механизма балансировки нагрузки между серверами или кластерами серверов.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Net.Security.EncryptionPolicy" /> для этого экземпляра <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Политика шифрования, используемая для данного экземпляра <see cref="T:System.Net.ServicePointManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение не указано в файле конфигурации <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> по умолчанию свойство <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. Это применяется к сеанс SSL/TLS на это <xref:System.Net.ServicePointManager> экземпляра.  
  
 Использование шифр Null необходим, если настроена политика шифрования <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">ServicePointManager-элемент (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое определяет, используется ли поведение 100-Continue.</summary>
        <value>Значение <see langword="true" />, чтобы включить поведение 100-Continue. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если присвоить этому свойству `true`, 100-по-прежнему используется поведение. Клиент запрашивает, использующих `PUT` и `POST` методов будет добавлять заголовке Expect запроса, если <xref:System.Net.ServicePointManager.Expect100Continue%2A> свойство `true` и <xref:System.Net.HttpWebRequest.ContentLength%2A> свойства не равно нулю или <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство имеет значение true. Ожидается, что клиент будет 100-по-прежнему ответа от сервера, чтобы указать, что клиент должен отправить данные. Этот механизм позволяет клиентам избежать отправки больших объемов данных по сети, когда сервер, на основе заголовков запроса, планирует отклонить запрос.  
  
 Предположим, например, <xref:System.Net.ServicePointManager.Expect100Continue%2A> свойство `false`. Когда запрос отправляется на сервер, он включает данные. Если после прочтения заголовков запроса, сервер требует проверки подлинности и необходимо отправить ответ 401, клиент должен повторно отправить данные с помощью правильные заголовки проверки подлинности.  
  
 Если это свойство имеет `true`, заголовки запроса отправляются на сервер. Если сервер не отклонил запрос, он отправляет 100-по-прежнему ответа сигнализации, что данные могут передаваться. Если в примере выше, сервер требует проверки подлинности, он отправляет ответ 401 и клиент не отправляет данные без необходимости.  
  
 Изменение значения этого свойства не влияет на существующие <xref:System.Net.ServicePoint> объектов. Только новых <xref:System.Net.ServicePoint> затрагиваются объекты, созданные после изменения.  
  
 100-продолжить, поведение не используется для запросов HTTP 1.0, даже если это свойство имеет значение `true`.  
  
 Expect 100-по-прежнему поведение полностью описаны в разделе IETF RFC 2616 10.1.1.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью при работе с данным запросом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Uri" /> интернет-ресурса, с которым осуществляется связь.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью с заданным объектом <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий связью для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Возвращает метод <xref:System.Net.ServicePoint> объект, связанный с указанным имя узла в Интернете. Если не <xref:System.Net.ServicePoint> объект существует для этого узла <xref:System.Net.ServicePointManager> объекта создает его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">URI интернет-ресурса, с которым осуществляется связь.</param>
        <param name="proxy">Данные прокси-сервера для этого запроса.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью с ресурсом, имеющим заданный URI.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий связью для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Возвращает метод <xref:System.Net.ServicePoint> объект, связанный с указанным имя узла в Интернете. Если не <xref:System.Net.ServicePoint> объект существует для этого узла <xref:System.Net.ServicePointManager> объекта создает его.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода для доступа к <xref:System.Net.ServicePoint> объекта.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">URI, заданный в параметре <paramref name="uriString" />, является неправильным.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Uri" />, содержащий адрес интернет-ресурса, с которым осуществляется связь.</param>
        <param name="proxy">Данные прокси-сервера для этого запроса.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью с заданным объектом <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий связью для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.FindServicePoint%2A> Возвращает метод <xref:System.Net.ServicePoint> объект, связанный с указанным имя узла в Интернете. Если не <xref:System.Net.ServicePoint> объект существует для этого узла <xref:System.Net.ServicePointManager> объекта создает его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное время бездействия объекта <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Выраженное в миллисекундах максимальное время бездействия объекта <see cref="T:System.Net.ServicePoint" />. По умолчанию установлено значение 100 000 миллисекунд (100 секунд).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> Свойство задает максимальное время простоя <xref:System.Net.ServicePointManager> назначает объект <xref:System.Net.ServicePoint.MaxIdleTime%2A> свойства при создании <xref:System.Net.ServicePoint> объектов. Изменения этого значения влияют только на <xref:System.Net.ServicePoint> объекты, которые инициализируются после изменения значения.  
  
 После <xref:System.Net.ServicePoint> объект был неактивен в течение времени, указанного в <xref:System.Net.ServicePoint.MaxIdleTime%2A>, он подходит для сборки мусора. Объект <xref:System.Net.ServicePoint> объект бездействует, когда список подключений, связанный с <xref:System.Net.ServicePoint> объект пуст.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> меньше <see cref="F:System.Threading.Timeout.Infinite" /> или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, обслуживаемых в произвольный момент времени.</summary>
        <value>Максимальное число обслуживаемых объектов <see cref="T:System.Net.ServicePoint" />. Значение по умолчанию, равное 0, свидетельствует об отсутствии ограничений на число объектов <see cref="T:System.Net.ServicePoint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если при уменьшении <xref:System.Net.ServicePointManager.MaxServicePoints%2A> свойство ниже число <xref:System.Net.ServicePoint> объектов в настоящее время существования, <xref:System.Net.ServicePointManager> удаляет <xref:System.Net.ServicePoint> объектов со временем наибольшую длительность бездействующего. Если число <xref:System.Net.ServicePoint> объектов с активными соединениями больше, чем значение <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, <xref:System.Net.ServicePointManager> объекта удалений <xref:System.Net.ServicePoint> объекты, как они становятся неактивными.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Значение свойства <see langword="true" /> заставляет все исходящие соединения TCP из HttpWebRequest использовать собственный параметр сокета SO_REUSE_UNICASTPORT. Это приводит к совместному использованию базовых исходящих портов. Это удобно в сценариях, в которых за короткое время создается большое количество исходящих подключений и приложение рискует запуститься без портов.</summary>
        <value>Возвращает <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию — `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает протокол безопасности, используемый объектами <see cref="T:System.Net.ServicePoint" />, которые управляются объектом <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Одно из значений, определенных в перечислении <see cref="T:System.Net.SecurityProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Это свойство выбирает версию протокол Secure Sockets Layer (SSL) или безопасности транспортного уровня (TLS), используемый для новых подключений; существующие соединения не изменяются.  
  
Начиная с .NET Framework 4.7, значение по умолчанию этого свойства является <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Это позволяет сетевые интерфейсы API на основе .NET Framework <xref:System.Net.Security.SslStream> (например, FTP, HTTP и SMTP) наследовать протоколы безопасности по умолчанию из операционной системы или все пользовательские настройки, выполняемые системным администратором. Сведения о какой SSL/TLS протоколы включены по умолчанию в каждой версии операционной системы Windows, см. в разделе [протоколы TLS/SSL (Schannel SSP)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Для версий .NET Framework с помощью .NET Framework 4.6.2 значение по умолчанию не отображается для этого свойства. Области безопасности постоянно изменяются и по умолчанию протоколы и уровни защиты изменяются со временем избежание уязвимых мест. Значения по умолчанию зависят от конфигурации отдельного компьютера, установленного программного обеспечения и примененные исправления.  
  
 Код должен зависят от никогда не неявно, с помощью уровень защиты, определенный, или на предположении, что по умолчанию используется определенный уровень безопасности. Если приложение зависит от использования уровня безопасности, необходимо явно указать этот уровень и проверьте, убедитесь, что это действительно, используется в рамках установленного подключения. Кроме того код должен разрабатываться устойчивость изменения, которые поддерживаются протоколы, таким образом изменения часто выполняются с небольшой предварительное уведомление для устранения возникающих угроз.  
  
 .NET Framework 4.6 включает новую функцию безопасности, блокирующее небезопасных шифрования и хэширования алгоритмы для подключений. Приложения, с помощью протокола TLS/SSL через API-интерфейсы, такие как HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream т. д. и предназначенные для .NET Framework 4.6 получают более надежные и безопасные поведение по умолчанию.  
  
 Разработчики имеют возможность отказаться от этого поведения для сохранения функциональной совместимости с существующей SSL3 службами или TLS с служб RC4. [В этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы отключить новое поведение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Значение, указанное для задания свойства, не является допустимым значением перечисления <see cref="T:System.Net.SecurityProtocolType" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает обратный вызов для проверки сертификата сервера.</summary>
        <value>Объект <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Приложение может задать <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> свойство к методу, чтобы использовать для пользовательской проверки сертификата сервера с помощью клиента. При выполнении пользовательской проверки `sender` параметр, передаваемый <xref:System.Net.Security.RemoteCertificateValidationCallback> может быть строкового имени узла или объекта, производного от <xref:System.Net.WebRequest> (<xref:System.Net.HttpWebRequest>, например) в зависимости от <xref:System.Net.ServicePointManager.CertificatePolicy%2A> свойство.  
  
При пользовательской проверки не используется, имя сертификата сравнивается с именем узла, используемый для создания запроса. Например если <xref:System.Net.WebRequest.Create%28System.String%29> был передан параметр `"https://www.contoso.com/default.html"`, по умолчанию задается для клиента для проверки сертификата с `www.contoso.com`.  

Несмотря на то, что многоадресного делегата, только значение, возвращаемое из обработчика событий последнего выполненного считается заслуживающих доверия. Другими словами, можно присоединить несколько делегатов, и все они получения обратного вызова из <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Каждый обратный вызов возвращает значение, указывающее, принимается ли сертификат или нет; Тем не менее учитывается только значение из последнего делегата.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы задать <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" /> свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveTime" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="enabled">Если этот параметр имеет значение true, параметр поддержания активности соединения TCP будет включен с помощью указанных значений <paramref name="keepAliveTime" /> и <paramref name="keepAliveInterval" />.  
  
Если этот параметр имеет значение false, параметр поддержания активности TCP отключен, и остальные параметры игнорируются.  
  
Значением по умолчанию является false.</param>
        <param name="keepAliveTime">Задает время ожидания в миллисекундах при отсутствии активности до отправки первого пакета поддержания активности.  
  
Значение должно быть больше нуля.  При передаче значения, меньшего или равного нулю, возникает исключение <see cref="T:System.ArgumentOutOfRangeException" />.</param>
        <param name="keepAliveInterval">Задает интервал в миллисекундах между успешной отправкой пакетов поддержания активности в случае отсутствия подтверждения.  
  
Значение должно быть больше нуля.  При передаче значения, меньшего или равного нулю, возникает исключение <see cref="T:System.ArgumentOutOfRangeException" />.</param>
        <summary>Включает или отключает параметр поддержания активности соединения TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может запрашивать, что поставщик TCP/IP включить использование пакетов поддержания активности соединения TCP. Значение по умолчанию — что отключено использование пакетов поддержания активности соединения TCP.  
  
 Параметры по умолчанию в сокета TCP инициализировать аут поддержания активности устанавливается равным 2 часа и интервал проверки активности равным 1 секунде. `keepAliveTime` Параметр указывает время ожидания в миллисекундах, при отсутствии активности до отправки первого пакета поддержания активности. `keepAliveInterval` Параметр задает интервал в миллисекундах, между ними при последовательных пакеты проверки активности отправляются в том случае, если не получено подтверждение. Число проб активности не может быть изменено и имеет значение 10.  
  
 Если подключение TCP удаляется в результате активность, <xref:System.Net.Sockets.SocketError> из <xref:System.Net.Sockets.SocketError.NetworkReset> возвращается в любые вызовы выполняется на сокете, и все последующие вызовы будут завершаться <xref:System.Net.Sockets.SocketError> из <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="keepAliveTime" /> или <paramref name="keepAliveInterval" /> меньше или равно 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, используется ли алгоритм Nagle точками обслуживания, которыми управляет объект <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Значение <see langword="true" /> для использования алгоритма Nagle; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Алгоритм Nagle используется для уменьшения сетевого трафика путем буферизации небольших пакетов данных и передачи их в виде одного пакета. Этот процесс также называется «уменьшает»; Он широко используется, так как уменьшает количество передаваемых пакетов и снижает затраты времени на пакет.  
  
 Изменение значения этого свойства не влияет на существующие <xref:System.Net.ServicePoint> объектов. Затрагиваются только новые точки обслуживания, созданные после изменения.  
  
 Алгоритм Nagle полностью описан в стандарте IETF RFC 896.  
  
   
  
## Examples  
 В следующем примере кода этому свойству.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>