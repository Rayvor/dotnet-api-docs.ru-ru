<Type Name="ServicePointManager" FullName="System.Net.ServicePointManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6dd36d192a603d127fbd71ed1b5c8cc24d8e3c49" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026447" /></Metadata><TypeSignature Language="C#" Value="public class ServicePointManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ServicePointManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.ServicePointManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ServicePointManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServicePointManager" />
  <TypeSignature Language="F#" Value="type ServicePointManager = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.ServicePoint</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Управляет коллекцией объектов <see cref="T:System.Net.ServicePoint" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePointManager> является статическим классом, используемым для создания, сопровождения и удаления экземпляров класса <xref:System.Net.ServicePoint>.  
  
 Когда приложение запрашивает подключение к универсальному идентификатору ресурса (URI) Интернет-ресурса через объект <xref:System.Net.ServicePointManager>, <xref:System.Net.ServicePointManager> возвращает объект <xref:System.Net.ServicePoint>, который содержит сведения о соединении для узла и схемы, идентифицируемые по универсальному коду ресурса (URI). Если для этого узла и схемы имеется существующий объект <xref:System.Net.ServicePoint>, объект <xref:System.Net.ServicePointManager> возвращает существующий объект <xref:System.Net.ServicePoint>. в противном случае объект <xref:System.Net.ServicePointManager> создает новый объект <xref:System.Net.ServicePoint>.  
  
 .NET Framework 4,6 включает новую функцию безопасности, которая блокирует небезопасные алгоритмы шифрования и хеширования для подключений. Приложения, использующие TLS/SSL через API-интерфейсы, такие как <xref:System.Net.Http.HttpClient>, <xref:System.Net.HttpWebRequest>, <xref:System.Net.FtpWebRequest>, <xref:System.Net.Mail.SmtpClient>, <xref:System.Net.Security.SslStream>и т. д. и нацеливание .NET Framework 4,6, по умолчанию получают более безопасное поведение.  
  
 Разработчики могут захотеть отказаться от этого поведения, чтобы обеспечить взаимодействие с имеющимися службами SSL3 Services или TLS w/RC4. В [этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы новое поведение было отключено.  
  
   
  
## Examples  
 В следующем примере кода создается объект <xref:System.Net.ServicePoint> для соединений с URI `www.contoso.com`.  
  
 [!code-cpp[Classic ServicePoint Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePoint Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePoint Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePoint Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePoint Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePoint Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.ServicePoint" />
    <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">Элемент ServicePointManager (параметры сети)</related>
  </Docs>
  <Members>
    <Member MemberName="CertificatePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.ICertificatePolicy CertificatePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.ICertificatePolicy CertificatePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CertificatePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CertificatePolicy As ICertificatePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::ICertificatePolicy ^ CertificatePolicy { System::Net::ICertificatePolicy ^ get(); void set(System::Net::ICertificatePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CertificatePolicy : System.Net.ICertificatePolicy with get, set" Usage="System.Net.ServicePointManager.CertificatePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use ServerCertificateValidationCallback instead", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICertificatePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или устанавливает политику для сертификатов сервера.</summary>
        <value>Объект, реализующий интерфейс <see cref="T:System.Net.ICertificatePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для свойства <xref:System.Net.ServicePointManager.CertificatePolicy%2A> задан объект интерфейса <xref:System.Net.ICertificatePolicy>, объект <xref:System.Net.ServicePointManager> использует политику сертификата, определенную в этом экземпляре, а не политику сертификата по умолчанию.  
  
 Политика сертификатов по умолчанию разрешает действительные сертификаты и действительные сертификаты с истекшим сроком действия.  
  
   
  
## Examples  
 В следующем примере кода показано, как перехватить исключение политики сертификата для пользовательской политики сертификата. Предполагается, что объект политики сертификатов определен, что универсальный код ресурса (URI) для веб-ресурса содержится в переменной `myUri`и имеется метод с именем `ProcessResponse`, выполняющий работу приложения.  
  
 [!code-cpp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/CS/source.cs#1)]
 [!code-vb[Classic ServicePointManager.CertificatePolicy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic ServicePointManager.CertificatePolicy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для задания свойства <see cref="P:System.Net.ServicePointManager.CertificatePolicy" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public static bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.ServicePointManager.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("CRL checks not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, проверяется ли сертификат по списку отзыва сертификатов.</summary>
        <value>Значение <see langword="true" />, если проверяется список отзыва сертификатов; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.ServicePointManager.CheckCertificateRevocationList%2A> `true`, сертификат проверяется по списку отзыва центра сертификации в ходе процесса проверки сертификата. Значение по умолчанию — `false`.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Для задания этого свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ClientCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ClientCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ClientCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ClientCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ClientCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ClientCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultConnectionLimit">
      <MemberSignature Language="C#" Value="public static int DefaultConnectionLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultConnectionLimit" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultConnectionLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultConnectionLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultConnectionLimit : int with get, set" Usage="System.Net.ServicePointManager.DefaultConnectionLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число одновременных подключений, разрешенное объектом <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Максимальное число одновременных подключений, разрешенное объектом <see cref="T:System.Net.ServicePoint" />. По умолчанию максимальное число подключений равно 10 для приложений, размещенных в ASP.NET, и 2 — для всех остальных. Когда приложение выполняется как узел ASP.NET, невозможно изменить значение этого свойства в файле конфигурации, если для свойства autoConfig задано значение <see langword="true" />. Однако можно изменить это значение программными средствами, если свойство autoConfig имеет значение <see langword="true" />. Задайте нужное значение один раз, при загрузке AppDomain.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> задает максимальное число одновременных соединений по умолчанию, которое объект <xref:System.Net.ServicePointManager> присваивает свойству <xref:System.Net.ServicePoint.ConnectionLimit%2A> при создании объектов <xref:System.Net.ServicePoint>.  
  
 Изменение свойства <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> не влияет на существующие объекты <xref:System.Net.ServicePoint>; Он влияет только на <xref:System.Net.ServicePoint> объекты, которые инициализируются после изменения. Если значение этого свойства не задано ни непосредственно, ни через конфигурацию, значение по умолчанию равно константе <xref:System.Net.ServicePointManager.DefaultPersistentConnectionLimit>.  
  
> [!NOTE]
>  Любые изменения свойства <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> влияют на соединения HTTP 1,0 и HTTP 1,1. Невозможно отдельно изменить ограничение на число подключений для протоколов HTTP 1,0 и HTTP 1,1.
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> меньше или равно 0.</exception>
        <permission cref="T:System.Net.WebPermission">Для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="DefaultNonPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultNonPersistentConnectionLimit = (4)" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultNonPersistentConnectionLimit As Integer  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultNonPersistentConnectionLimit = 4;" />
      <MemberSignature Language="F#" Value="val mutable DefaultNonPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultNonPersistentConnectionLimit" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Количество непостоянных подключений по умолчанию (4), разрешенное в объекте <see cref="T:System.Net.ServicePoint" />, подключенном к серверу HTTP/1.0 или к более старшей версии сервера. Это поле является константой, но больше не используется в платформе .NET Framework 2.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPersistentConnectionLimit">
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 2;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (2)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="F:System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 2;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="val mutable DefaultPersistentConnectionLimit : int" Usage="System.Net.ServicePointManager.DefaultPersistentConnectionLimit" />
      <MemberSignature Language="C#" Value="public const int DefaultPersistentConnectionLimit = 10;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultPersistentConnectionLimit = (10)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultPersistentConnectionLimit As Integer  = 10" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultPersistentConnectionLimit = 10;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Допустимое по умолчанию количество постоянных подключений (2) в объекте <see cref="T:System.Net.ServicePoint" />, подключенном к серверу HTTP/1.1 или к более старшей версии сервера. Это поле является константой и используется для инициализации свойства <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" />, если значение свойства <see cref="P:System.Net.ServicePointManager.DefaultConnectionLimit" /> не было задано напрямую или через конфигурацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода свойство <xref:System.Net.ServicePointManager.DefaultConnectionLimit%2A> задается с помощью этого поля.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DnsRefreshTimeout">
      <MemberSignature Language="C#" Value="public static int DnsRefreshTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DnsRefreshTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DnsRefreshTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DnsRefreshTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DnsRefreshTimeout : int with get, set" Usage="System.Net.ServicePointManager.DnsRefreshTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее промежуток времени, в течение которого разрешение DNS-имени считается допустимым.</summary>
        <value>Значение времени ожидания в миллисекундах. Значение -1 указывает на бесконечное время ожидания. По умолчанию установлено значение 120 000 миллисекунд (2 минуты).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EnableDnsRoundRobin">
      <MemberSignature Language="C#" Value="public static bool EnableDnsRoundRobin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableDnsRoundRobin" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableDnsRoundRobin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableDnsRoundRobin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDnsRoundRobin : bool with get, set" Usage="System.Net.ServicePointManager.EnableDnsRoundRobin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, происходит ли чередование допустимых IP-адресов при разрешении DNS-имен.</summary>
        <value>Значение <see langword="false" />, если при разрешении DNS-имен всегда возвращается первый IP-адрес определенного узла, в противном случае — <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если с именем узла связано более одного IP-адреса, разрешение DNS обычно возвращает только первый IP-адрес. Если задать для этого свойства значение `true`, последующие разрешения DNS будут циклически проходить через все доступные IP-адреса для определенного узла. Этот параметр полезен, если служба использует DNS в качестве механизма балансировки нагрузки между серверами или кластерами серверов.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePointWhidbey#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/cpp/servicepoint.cpp#1)]
 [!code-csharp[System.Net.ServicePointWhidbey#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/CS/servicepoint.cs#1)]
 [!code-vb[System.Net.ServicePointWhidbey#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePointWhidbey/VB/servicepoint.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionPolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Security.EncryptionPolicy EncryptionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.Security.EncryptionPolicy EncryptionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EncryptionPolicy As EncryptionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::EncryptionPolicy EncryptionPolicy { System::Net::Security::EncryptionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionPolicy : System.Net.Security.EncryptionPolicy" Usage="System.Net.ServicePointManager.EncryptionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Always returns EncryptionPolicy.RequireEncryption.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.EncryptionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Net.Security.EncryptionPolicy" /> для этого экземпляра <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Политика шифрования, используемая для данного экземпляра <see cref="T:System.Net.ServicePointManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение не указано в файле конфигурации, то свойство <xref:System.Net.ServicePointManager.EncryptionPolicy%2A> по умолчанию устанавливается в значение <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType>. Это относится к сеансу SSL/TLS на этом <xref:System.Net.ServicePointManager> экземпляре.  
  
 Использование шифра NULL требуется, если для политики шифрования задано значение <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="P:System.Net.Configuration.ServicePointManagerElement.EncryptionPolicy" />
        <altmember cref="T:System.Net.Security.EncryptionPolicy" />
        <related type="Article" href="https://msdn.microsoft.com/library/6e5def51-3646-4ef6-a7bd-c69151321bec">Элемент ServicePointManager (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="Expect100Continue">
      <MemberSignature Language="C#" Value="public static bool Expect100Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Expect100Continue" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.Expect100Continue" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Expect100Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Expect100Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Expect100Continue : bool with get, set" Usage="System.Net.ServicePointManager.Expect100Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое определяет, используется ли поведение 100-Continue.</summary>
        <value>Значение <see langword="true" />, чтобы включить поведение 100-Continue. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство имеет значение `true`, используется поведение 100-Continue. Клиентские запросы, использующие методы `PUT` и `POST`, добавляют к запросу заголовок Expect, если свойство <xref:System.Net.ServicePointManager.Expect100Continue%2A> имеет значение `true`, а свойство <xref:System.Net.HttpWebRequest.ContentLength%2A> имеет значение true.<xref:System.Net.HttpWebRequest.SendChunked%2A> Клиент будет получать ответ от сервера 100-Continue, чтобы указать, что клиент должен отправить данные для отправки. Этот механизм позволяет клиентам избежать отправки больших объемов данных по сети, когда сервер на основе заголовков запроса намеревается отклонить запрос.  
  
 Предположим, например, <xref:System.Net.ServicePointManager.Expect100Continue%2A> свойство `false`. Когда запрос отправляется на сервер, он включает данные. Если после считывания заголовков запроса сервер требует проверки подлинности и должен отправить ответ 401, клиент должен повторно отправить данные с соответствующими заголовками проверки подлинности.  
  
 Если это свойство имеет значение `true`, заголовки запроса отправляются на сервер. Если сервер не отклонил запрос, он отправляет ответ 100-Continue, указывающий, что данные могут быть переданы. Если, как в предыдущем примере, сервер требует проверки подлинности, он отправляет ответ 401 и клиент не передавал данные.  
  
 Изменение значения этого свойства не влияет на существующие объекты <xref:System.Net.ServicePoint>. Затрагиваются только новые объекты <xref:System.Net.ServicePoint>, созданные после изменения.  
  
 Поведение 100-Continue не используется для запросов HTTP 1,0, даже если это свойство имеет значение `true`.  
  
 Ожидаемое поведение 100-Continue полностью описано в разделе "IETF RFC 2616" 10.1.1.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindServicePoint">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления взаимодействием при работе с данным запросом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Uri" /> интернет-ресурса, с которым осуществляется связь.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью с заданным объектом <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий взаимодействиями для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.ServicePointManager.FindServicePoint%2A> возвращает объект <xref:System.Net.ServicePoint>, связанный с указанным именем узла в Интернете. Если для этого узла не существует <xref:System.Net.ServicePoint> объекта, объект <xref:System.Net.ServicePointManager> создает его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (string uriString, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(string uriString, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.String,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (uriString As String, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(System::String ^ uriString, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : string * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (uriString, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="uriString">URI интернет-ресурса, с которым осуществляется связь.</param>
        <param name="proxy">Данные прокси-сервера для этого запроса.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления связью с ресурсом, имеющим заданный URI.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий взаимодействиями для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.ServicePointManager.FindServicePoint%2A> возвращает объект <xref:System.Net.ServicePoint>, связанный с указанным именем узла в Интернете. Если для этого узла не существует <xref:System.Net.ServicePoint> объекта, объект <xref:System.Net.ServicePointManager> создает его.  
  
   
  
## Examples  
 В следующем примере кода показано, как вызвать этот метод для доступа к объекту <xref:System.Net.ServicePoint>.  
  
 [!code-cpp[System.Net.ServicePoint#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#7)]
 [!code-csharp[System.Net.ServicePoint#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#7)]
 [!code-vb[System.Net.ServicePoint#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">URI, заданный в параметре <paramref name="uriString" />, является неправильным.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="FindServicePoint">
      <MemberSignature Language="C#" Value="public static System.Net.ServicePoint FindServicePoint (Uri address, System.Net.IWebProxy proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.ServicePoint FindServicePoint(class System.Uri address, class System.Net.IWebProxy proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.FindServicePoint(System.Uri,System.Net.IWebProxy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindServicePoint (address As Uri, proxy As IWebProxy) As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::ServicePoint ^ FindServicePoint(Uri ^ address, System::Net::IWebProxy ^ proxy);" />
      <MemberSignature Language="F#" Value="static member FindServicePoint : Uri * System.Net.IWebProxy -&gt; System.Net.ServicePoint" Usage="System.Net.ServicePointManager.FindServicePoint (address, proxy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="proxy" Type="System.Net.IWebProxy" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Uri" />, содержащий адрес интернет-ресурса, с которым осуществляется связь.</param>
        <param name="proxy">Данные прокси-сервера для этого запроса.</param>
        <summary>Находит существующий объект <see cref="T:System.Net.ServicePoint" /> или создает новый объект <see cref="T:System.Net.ServicePoint" /> для управления взаимодействиями с заданным объектом <see cref="T:System.Uri" />.</summary>
        <returns>Объект <see cref="T:System.Net.ServicePoint" />, управляющий взаимодействиями для запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.ServicePointManager.FindServicePoint%2A> возвращает объект <xref:System.Net.ServicePoint>, связанный с указанным именем узла в Интернете. Если для этого узла не существует <xref:System.Net.ServicePoint> объекта, объект <xref:System.Net.ServicePointManager> создает его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Достигнуто максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, определенное в свойстве <see cref="P:System.Net.ServicePointManager.MaxServicePoints" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePointIdleTime">
      <MemberSignature Language="C#" Value="public static int MaxServicePointIdleTime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePointIdleTime" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePointIdleTime As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePointIdleTime { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePointIdleTime : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePointIdleTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное время бездействия объекта <see cref="T:System.Net.ServicePoint" />.</summary>
        <value>Выраженное в миллисекундах максимальное время бездействия объекта <see cref="T:System.Net.ServicePoint" />. По умолчанию установлено значение 100 000 миллисекунд (100 секунд).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.ServicePointManager.MaxServicePointIdleTime%2A> задает максимальное время простоя, которое объект <xref:System.Net.ServicePointManager> присваивает свойству <xref:System.Net.ServicePoint.MaxIdleTime%2A> при создании объектов <xref:System.Net.ServicePoint>. Изменения этого значения затрагивают только <xref:System.Net.ServicePoint> объекты, которые инициализируются после изменения значения.  
  
 После неактивности объекта <xref:System.Net.ServicePoint> в течение времени, указанного в <xref:System.Net.ServicePoint.MaxIdleTime%2A>, он может подлежат сборке мусора. Объект <xref:System.Net.ServicePoint> бездействует, если список соединений, связанных с объектом <xref:System.Net.ServicePoint>, пуст.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <see cref="P:System.Net.ServicePointManager.MaxServicePointIdleTime" /> меньше <see cref="F:System.Threading.Timeout.Infinite" /> или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">Для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="MaxServicePoints">
      <MemberSignature Language="C#" Value="public static int MaxServicePoints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxServicePoints" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.MaxServicePoints" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxServicePoints As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxServicePoints { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxServicePoints : int with get, set" Usage="System.Net.ServicePointManager.MaxServicePoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество объектов <see cref="T:System.Net.ServicePoint" />, обслуживаемых в произвольный момент времени.</summary>
        <value>Максимальное число обслуживаемых объектов <see cref="T:System.Net.ServicePoint" />. Значение по умолчанию, равное 0, свидетельствует об отсутствии ограничений на число объектов <see cref="T:System.Net.ServicePoint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При уменьшении свойства <xref:System.Net.ServicePointManager.MaxServicePoints%2A> под числом объектов <xref:System.Net.ServicePoint>, которые в настоящее время существуют, <xref:System.Net.ServicePointManager> удаляет объекты <xref:System.Net.ServicePoint> с наибольшим временем простоя. Если число объектов <xref:System.Net.ServicePoint> с активными соединениями превышает значение <xref:System.Net.ServicePointManager.MaxServicePoints%2A>, объект <xref:System.Net.ServicePointManager> удаляет объекты <xref:System.Net.ServicePoint>, так как они становятся бездействующими.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#8)]
 [!code-csharp[System.Net.ServicePoint#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#8)]
 [!code-vb[System.Net.ServicePoint#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <see cref="P:System.Net.ServicePointManager.MaxServicePoints" /> имеет значение меньше 0 или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Net.WebPermission">Для неограниченных веб-разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.WebPermission" />
      </Docs>
    </Member>
    <Member MemberName="ReusePort">
      <MemberSignature Language="C#" Value="public static bool ReusePort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ReusePort" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ReusePort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ReusePort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ReusePort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReusePort : bool with get, set" Usage="System.Net.ServicePointManager.ReusePort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Значение свойства <see langword="true" /> заставляет все исходящие соединения TCP из HttpWebRequest использовать собственный параметр сокета SO_REUSE_UNICASTPORT. Это приводит к совместному использованию базовых исходящих портов. Это удобно в сценариях, в которых за короткое время создается большое количество исходящих подключений и приложение рискует запуститься без портов.</summary>
        <value>Возвращает <see cref="T:System.Boolean" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию — `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityProtocol">
      <MemberSignature Language="C#" Value="public static System.Net.SecurityProtocolType SecurityProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Net.SecurityProtocolType SecurityProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.SecurityProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityProtocol As SecurityProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::SecurityProtocolType SecurityProtocol { System::Net::SecurityProtocolType get(); void set(System::Net::SecurityProtocolType value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityProtocol : System.Net.SecurityProtocolType with get, set" Usage="System.Net.ServicePointManager.SecurityProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.SecurityProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает протокол безопасности, используемый объектами <see cref="T:System.Net.ServicePoint" />, которые управляются объектом <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Одно из значений, определенных в перечислении <see cref="T:System.Net.SecurityProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Это свойство выбирает версию протокола SSL (SSL) или протокол TLS, который будет использоваться для новых соединений. существующие соединения не изменяются.  
  
Начиная с .NET Framework 4,7, значение этого свойства по умолчанию равно <xref:System.Net.SecurityProtocolType.SystemDefault?displayProperty=nameWithType>. Это позволяет .NET Framework сетевые интерфейсы API, основанные на <xref:System.Net.Security.SslStream> (например, FTP, HTTP и SMTP), наследовать протоколы безопасности по умолчанию от операционной системы или от любых пользовательских конфигураций, выполняемых системным администратором. Сведения о том, какие протоколы SSL/TLS включены по умолчанию в каждой версии операционной системы Windows, см. [в разделе протоколы в TLS/SSL (Schannel SSP)](https://msdn.microsoft.com/library/windows/desktop/mt808159.aspx).
 
Для версий .NET Framework с помощью .NET Framework 4.6.2 для этого свойства не указаны значения по умолчанию. Постоянно изменяется ландшафт безопасности, а протоколы и уровни защиты по умолчанию изменяются с течением времени, чтобы избежать известных слабых мест. Значения по умолчанию зависят от конфигурации отдельного компьютера, установленного программного обеспечения и примененных исправлений.  
  
 Код никогда не должен зависеть от использования определенного уровня защиты или от предположения, что данный уровень безопасности используется по умолчанию. Если приложение зависит от использования определенного уровня безопасности, необходимо явно указать этот уровень и убедиться, что он фактически используется в установленном соединении. Кроме того, код должен быть спроектирован так, чтобы быть надежным в тех изменениях, в которых поддерживаются протоколы, так как такие изменения часто делаются с небольшим предварительным уведомлением для устранения новых угроз.  
  
 .NET Framework 4,6 включает новую функцию безопасности, которая блокирует небезопасные алгоритмы шифрования и хеширования для подключений. Приложения, использующие TLS/SSL через API, такие как HttpClient, HttpWebRequest, Фтпклиент, SmtpClient, SslStream и т. д. .NET Framework 4,6, обеспечивают более безопасное поведение по умолчанию.  
  
 Разработчики могут захотеть отказаться от этого поведения, чтобы обеспечить взаимодействие с имеющимися службами SSL3 Services или TLS w/RC4. В [этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы новое поведение было отключено.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Значение, указанное для задания свойства, не является допустимым значением перечисления <see cref="T:System.Net.SecurityProtocolType" />.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Net.SecurityProtocolType" />
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public static System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.ServicePointManager.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает обратный вызов для проверки сертификата сервера.</summary>
        <value>Объект <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Приложение может задать для свойства <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A> метод, который будет использоваться клиентом сертификата сервера для пользовательской проверки. При выполнении пользовательской проверки параметр `sender`, передаваемый в <xref:System.Net.Security.RemoteCertificateValidationCallback>, может быть именем строки узла или объектом, производным от <xref:System.Net.WebRequest> (например,<xref:System.Net.HttpWebRequest>) в зависимости от свойства <xref:System.Net.ServicePointManager.CertificatePolicy%2A>.  
  
Если пользовательская проверка не используется, имя сертификата сравнивается с именем узла, использованным для создания запроса. Например, если <xref:System.Net.WebRequest.Create%28System.String%29> был передан параметр `"https://www.contoso.com/default.html"`, по умолчанию клиент должен проверить сертификат по `www.contoso.com`.  

Несмотря на то, что является групповым делегатом, только значение, возвращаемое последним обработчиком событий, считается полномочным. Иными словами, можно присоединить несколько делегатов и получить обратный вызов от <xref:System.Net.ServicePointManager.ServerCertificateValidationCallback%2A>. Каждый обратный вызов возвращает значение, указывающее, принимается ли сертификат или нет. Однако учитывается только значение последнего делегата.
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для задания свойства <see cref="P:System.Net.ServicePointManager.ServerCertificateValidationCallback" />. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
        <altmember cref="T:System.Net.ServicePoint" />
        <altmember cref="T:System.Security.Permissions.SecurityPermission" />
      </Docs>
    </Member>
    <Member MemberName="ServerCipherSuitesCallback">
      <MemberSignature Language="C#" Value="public static System.Net.CipherSuitesCallback ServerCipherSuitesCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.CipherSuitesCallback ServerCipherSuitesCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ServerCipherSuitesCallback As CipherSuitesCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::CipherSuitesCallback ^ ServerCipherSuitesCallback { System::Net::CipherSuitesCallback ^ get(); void set(System::Net::CipherSuitesCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCipherSuitesCallback : System.Net.CipherSuitesCallback with get, set" Usage="System.Net.ServicePointManager.ServerCipherSuitesCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Obsolete("This API is no longer supported.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CipherSuitesCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTcpKeepAlive">
      <MemberSignature Language="C#" Value="public static void SetTcpKeepAlive (bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTcpKeepAlive(bool enabled, int32 keepAliveTime, int32 keepAliveInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.ServicePointManager.SetTcpKeepAlive(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTcpKeepAlive (enabled As Boolean, keepAliveTime As Integer, keepAliveInterval As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);" />
      <MemberSignature Language="F#" Value="static member SetTcpKeepAlive : bool * int * int -&gt; unit" Usage="System.Net.ServicePointManager.SetTcpKeepAlive (enabled, keepAliveTime, keepAliveInterval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveTime" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="keepAliveInterval" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="enabled">Если этот параметр имеет значение true, параметр поддержания активности соединения TCP будет включен с помощью указанных значений <paramref name="keepAliveTime" /> и <paramref name="keepAliveInterval" />.  
  
Если этот параметр имеет значение false, параметр поддержания активности TCP отключен, и остальные параметры игнорируются.  
  
Значением по умолчанию является false.</param>
        <param name="keepAliveTime">Задает время ожидания в миллисекундах при отсутствии активности до отправки первого пакета поддержания активности.  
  
Значение должно быть больше нуля.  При передаче значения, меньшего или равного нулю, возникает исключение <see cref="T:System.ArgumentOutOfRangeException" />.</param>
        <param name="keepAliveInterval">Задает интервал в миллисекундах между успешной отправкой пакетов поддержания активности в случае отсутствия подтверждения.  
  
Значение должно быть больше нуля.  При передаче значения, меньшего или равного нулю, возникает исключение <see cref="T:System.ArgumentOutOfRangeException" />.</param>
        <summary>Включает или отключает параметр поддержания активности соединения TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может запросить, чтобы поставщик TCP/IP мог использовать пакеты проверки активности для подключения TCP. По умолчанию использование пакетов проверки активности в TCP-соединении отключено.  
  
 Параметры по умолчанию при инициализации сокета TCP устанавливает время ожидания проверки активности в 2 часа и интервал проверки активности равным 1 секунде. Параметр `keepAliveTime` указывает время ожидания (в миллисекундах) без активности, пока не будет отправлен первый пакет проверки активности. Параметр `keepAliveInterval` указывает интервал (в миллисекундах) между отправкой последовательных пакетов поддержания активности, если подтверждение не получено. Число зондов проверки активности не может быть изменено и равно 10.  
  
 Если TCP-соединение отбрасывается в результате проверки активности, то для всех выполняемых в сокете вызовов возвращается <xref:System.Net.Sockets.SocketError> <xref:System.Net.Sockets.SocketError.NetworkReset>, а последующие вызовы будут завершаться с <xref:System.Net.Sockets.SocketError> <xref:System.Net.Sockets.SocketError.NotConnected>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="keepAliveTime" /> или <paramref name="keepAliveInterval" /> меньше или равно 0.</exception>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
    <Member MemberName="UseNagleAlgorithm">
      <MemberSignature Language="C#" Value="public static bool UseNagleAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseNagleAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseNagleAlgorithm As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseNagleAlgorithm { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseNagleAlgorithm : bool with get, set" Usage="System.Net.ServicePointManager.UseNagleAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.ServicePoint</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, используется ли алгоритм Nagle точками обслуживания, которыми управляет объект <see cref="T:System.Net.ServicePointManager" />.</summary>
        <value>Значение <see langword="true" /> для использования алгоритма Nagle; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Алгоритм Nagle используется для уменьшения сетевого трафика путем буферизации небольших пакетов данных и передачи их в виде одного пакета. Этот процесс также называется "наглинг"; Он широко используется, так как уменьшает количество переданных пакетов и снижает нагрузку на пакет.  
  
 Изменение значения этого свойства не влияет на существующие объекты <xref:System.Net.ServicePoint>. Затрагиваются только новые точки обслуживания, созданные после изменения.  
  
 Алгоритм Nagle полностью описан в стандарте IETF RFC 896.  
  
   
  
## Examples  
 В следующем примере кода задается это свойство.  
  
 [!code-cpp[System.Net.ServicePoint#10](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#10)]
 [!code-csharp[System.Net.ServicePoint#10](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#10)]
 [!code-vb[System.Net.ServicePoint#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.ServicePoint" />
      </Docs>
    </Member>
  </Members>
</Type>
