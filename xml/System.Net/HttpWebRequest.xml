<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e54702bd9f2f554404509ab2481b05930a20958a" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026499" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет связанную с HTTP реализацию класса <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Не рекомендуется использовать `HttpWebRequest` для новой разработки. Вместо этого используйте класс <xref:System.Net.Http.HttpClient?displayProperty=nameWithType>.

 Класс <xref:System.Net.HttpWebRequest> обеспечивает поддержку свойств и методов, определенных в <xref:System.Net.WebRequest>, а также дополнительных свойств и методов, позволяющих пользователю напрямую взаимодействовать с серверами, использующими протокол HTTP.  
  
 Не используйте конструктор <xref:System.Net.HttpWebRequest.%23ctor%2A>. Используйте метод <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> для инициализации новых объектов <xref:System.Net.HttpWebRequest>. Если схема универсального кода ресурса (URI) имеет `http://` или `https://`, <xref:System.Net.WebRequest.Create%2A> возвращает объект <xref:System.Net.HttpWebRequest>.  
  
 Метод <xref:System.Net.HttpWebRequest.GetResponse%2A> выполняет синхронный запрос к ресурсу, указанному в свойстве <xref:System.Net.HttpWebRequest.RequestUri%2A>, и возвращает <xref:System.Net.HttpWebResponse>, содержащий объект ответа. Данные ответа могут быть получены с помощью потока, возвращенного <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Если объект ответа или поток ответа закрыт, оставшиеся данные будут утрачены. Оставшиеся данные будут остановлены, и сокет будет повторно использован для последующих запросов при закрытии объекта ответа или потока, если выполняются следующие условия: это запрос на проверку активности или конвейер, необходимо получить только небольшой объем данных или оставшиеся данные получаются в течение небольшого интервала времени. Если ни одно из указанных условий не удерживается или превышено время очистки, сокет будет закрыт. Для соединений со сроком поддержания активности или конвейеров настоятельно рекомендуется, чтобы приложение считывает потоки до конца файла. Это гарантирует, что сокет будет повторно использован для последующих запросов, что приведет к повышению производительности и меньшему объему используемых ресурсов.  
  
 Если требуется отправить данные в ресурс, метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> возвращает объект <xref:System.IO.Stream>, используемый для отправки данных. Методы <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> и <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> обеспечивают асинхронный доступ к потоку отправки данных.  
  
 Для проверки подлинности клиента с <xref:System.Net.HttpWebRequest>сертификат клиента должен быть установлен в хранилище сертификатов "Мои сертификаты" текущего пользователя.  
  
 Класс <xref:System.Net.HttpWebRequest> создает исключение <xref:System.Net.WebException> при возникновении ошибок при доступе к ресурсу. Свойство <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> содержит <xref:System.Net.WebExceptionStatus> значение, указывающее источник ошибки. Если <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, свойство <xref:System.Net.WebException.Response%2A> содержит <xref:System.Net.HttpWebResponse>, полученный от ресурса.  
  
 <xref:System.Net.HttpWebRequest> предоставляет общие значения HTTP-заголовка, отправляемые в Интернет-ресурс в виде свойств, задаются методами или задаются системой. в следующей таблице содержится полный список. В качестве пар "имя-значение" можно задать другие заголовки в свойстве <xref:System.Net.HttpWebRequest.Headers%2A>. Обратите внимание, что серверы и кэши могут изменить или добавить заголовки во время запроса.  
  
 В следующей таблице перечислены заголовки HTTP, которые устанавливаются либо свойствами, либо методами, либо системой.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается свойством <xref:System.Net.HttpWebRequest.Accept%2A>.|  
|Подключение|Устанавливается свойством <xref:System.Net.HttpWebRequest.Connection%2A> <xref:System.Net.HttpWebRequest.KeepAlive%2A>.|  
|Длина содержимого|Задается свойством <xref:System.Net.HttpWebRequest.ContentLength%2A>.|  
|Тип содержимого|Задается свойством <xref:System.Net.HttpWebRequest.ContentType%2A>.|  
|Требование|Задается свойством <xref:System.Net.HttpWebRequest.Expect%2A>.|  
|Дата|Задается системой в качестве текущей даты.|  
|Host|Задается системой текущими сведениями об узле.|  
|Если-Modified — с|Задается свойством <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>.|  
|Диапазон|Задается методом <xref:System.Net.HttpWebRequest.AddRange%2A>.|  
|Источник ссылки|Задается свойством <xref:System.Net.HttpWebRequest.Referer%2A>.|  
|Кодировка при переносе|Задается свойством <xref:System.Net.HttpWebRequest.TransferEncoding%2A> (свойство <xref:System.Net.HttpWebRequest.SendChunked%2A> должно иметь значение `true`).|  
|Агент пользователя|Задается свойством <xref:System.Net.HttpWebRequest.UserAgent%2A>.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> регистрируется автоматически. Вам не нужно вызывать метод <xref:System.Net.WebRequest.RegisterPrefix%2A> для регистрации <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> перед использованием URI, начинающихся с `http://` или `https://`.  
  
 В файле конфигурации локального компьютера или приложения может указываться использование прокси-сервера по умолчанию. Если указано свойство <xref:System.Net.HttpWebRequest.Proxy%2A>, параметры прокси-сервера из свойства <xref:System.Net.HttpWebRequest.Proxy%2A> переопределяют локальный компьютер или файл конфигурации приложения, а экземпляр <xref:System.Net.HttpWebRequest> будет использовать указанные параметры прокси-сервера. Если в файле конфигурации не указан прокси-сервер и свойство <xref:System.Net.HttpWebRequest.Proxy%2A> не задано, то класс <xref:System.Net.HttpWebRequest> использует параметры прокси-сервера, унаследованные от Internet Explorer на локальном компьютере. Если в Internet Explorer нет параметров прокси-сервера, запрос отправляется непосредственно на сервер.  
  
 Класс <xref:System.Net.HttpWebRequest> анализирует список обхода прокси-сервера с подстановочными знаками, унаследованными от Internet Explorer, по сравнению со списком пропусков, который анализируется непосредственно обозревателем Internet Explorer. Например, класс <xref:System.Net.HttpWebRequest> будет анализировать список пропусков "NT *" из Internet Explorer как регулярное выражение "NT. $". Это отличается от поведения Internet Explorer в собственном режиме. Поэтому URL-адрес "`http://intxxxxx`" будет обходить прокси-сервер с помощью класса <xref:System.Net.HttpWebRequest>, но не будет обходить прокси-сервер с помощью Internet Explorer.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL по мере их создания и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторного использования сеанса SSL платформа использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если таковой имеется) или пытается повторно использовать анонимные сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> пуст.  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie по умолчанию отключены. Если вы хотите использовать файлы cookie, используйте свойство <xref:System.Net.HttpWebRequest.CookieContainer%2A>, чтобы включить файлы cookie.  
  
 .NET Framework 4,6 включает новую функцию безопасности, которая блокирует небезопасные алгоритмы шифрования и хеширования для подключений. Приложения, использующие TLS/SSL через API, такие как HttpClient, HttpWebRequest, Фтпклиент, SmtpClient, SslStream и т. д. .NET Framework 4,6, обеспечивают более безопасное поведение по умолчанию.  
  
 Разработчики могут захотеть отказаться от этого поведения, чтобы обеспечить взаимодействие с имеющимися службами SSL3 Services или TLS w/RC4. В [этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы новое поведение было отключено.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.HttpWebRequest> для `http://www.contoso.com/`URI.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">для доступа к запрошенному URI или любому URI, к которому перенаправляется запрос. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Изменения проверки подлинности NTLM для HTTPWebRequest в версии 3,5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Net.HttpWebRequest" />. Эти конструкторы устарели. Дополнительные сведения см. в разделе "Заметки".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Оба конструктора <xref:System.Net.HttpWebRequest> являются устаревшими и не должны использоваться. Вызовите метод <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>, чтобы инициализировать новые объекты <xref:System.Net.HttpWebRequest>.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Net.HttpWebRequest" />. Этот конструктор является устаревшим.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации нового объекта <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с новым объектом <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" /> на основе указанных экземпляров классов <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />. Этот конструктор является устаревшим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение должно работать в режиме полного доверия при использовании сериализации.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет запрос в Интернет-ресурс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.Abort%2A> отменяет запрос к ресурсу. После отмены запроса вызов метода <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>или <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> приводит к <xref:System.Net.WebException>у со свойством <xref:System.Net.WebException.Status%2A>, для которого задано значение <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 Метод <xref:System.Net.HttpWebRequest.Abort%2A> синхронно выполняет обратный вызов, указанный в методах <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, если метод <xref:System.Net.HttpWebRequest.Abort%2A> вызывается, когда выполняется любая из этих операций. Это может привести к потенциальным проблемам взаимоблокировки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Сетевая трассировка](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 В случае асинхронных запросов клиентское приложение отвечает за реализацию собственного механизма ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Accept" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Accept" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы очистить заголовок HTTP `Accept`, задайте для свойства <xref:System.Net.HttpWebRequest.Accept%2A> значение `null`.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.Accept%2A>.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет в запрос заголовок диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет в запрос заголовок диапазона байтов.  
  
 Если `range` положительный, параметр `range` задает начальную точку диапазона. Сервер должен начать отправку данных из параметра `range`, указанного в конце данных в сущности HTTP.  
  
 Если `range` является отрицательным, параметр `range` задает конечную точку диапазона. Сервер должен начать отправку данных с начала данных в сущности HTTP в указанный параметр `range`.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Пример заголовка диапазона в запросе протокола HTTP, запрашивающего сервер, который отправляет первые 100 байт (от начала до байта 99), будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `range` будет иметь значение-99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
   
  
## Examples  
 В следующем примере кода в запрос добавляется заголовок диапазона.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет в запрос заголовок диапазона байтов.  
  
 Если `range` положительный, параметр `range` задает начальную точку диапазона. Сервер должен начать отправку данных из параметра `range`, указанного в конце данных в сущности HTTP.  
  
 Если `range` является отрицательным, параметр `range` задает конечную точку диапазона. Сервер должен начать отправку данных с начала данных в сущности HTTP в указанный параметр `range`.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Пример заголовка диапазона в запросе протокола HTTP, запрашивающего сервер, который отправляет первые 100 байт (от начала до байта 99), будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `range` будет иметь значение-99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет в запрос заголовок диапазона байтов.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `from` будет указан как 0, а параметр `to` будет указан как 99. Этот метод автоматически задает для спецификатора диапазона значение "байт".  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
   
  
## Examples  
 В следующем примере кода в запрос добавляется заголовок диапазона.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет в запрос заголовок диапазона байтов.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `from` будет указан как 0, а параметр `to` будет указан как 99. Этот метод автоматически задает для спецификатора диапазона значение "байт".  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет к запросу заголовок диапазона.  
  
 Если `range` положительный, параметр `range` задает начальную точку диапазона. Сервер должен начать отправку данных из параметра `range`, указанного в конце данных в сущности HTTP.  
  
 Если `range` является отрицательным, параметр `range` задает конечную точку диапазона. Сервер должен начать отправку данных с начала данных в сущности HTTP в указанный параметр `range`.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Параметр `rangeSpecifier` обычно задается как "bytes", так как это единственный описатель диапазона, распознаваемый большинством HTTP-серверов. Установка параметра `rangeSpecifier` в другую строку обеспечивает поддержку настраиваемых описателей диапазона, отличных от байтов (спецификатор диапазона байтов, определенный в RFC 2616 консорциумом IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере параметр `rangeSpecifier` задается как "bytes", а параметр `range` — значение-99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges в ответе. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет к запросу заголовок диапазона.  
  
 Если `range` положительный, параметр `range` задает начальную точку диапазона. Сервер должен начать отправку данных из параметра `range`, указанного в конце данных в сущности HTTP.  
  
 Если `range` является отрицательным, параметр `range` задает конечную точку диапазона. Сервер должен начать отправку данных с начала данных в сущности HTTP в указанный параметр `range`.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Параметр `rangeSpecifier` обычно задается как "bytes", так как это единственный описатель диапазона, распознаваемый большинством HTTP-серверов. Установка параметра `rangeSpecifier` в другую строку обеспечивает поддержку настраиваемых описателей диапазона, отличных от байтов (спецификатор диапазона байтов, определенный в RFC 2616 консорциумом IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере параметр `rangeSpecifier` задается как "bytes", а параметр `range` — значение-99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges в ответе. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет к запросу заголовок диапазона.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Параметр `rangeSpecifier` обычно задается как "bytes", так как это единственный описатель диапазона, распознаваемый большинством HTTP-серверов. Установка параметра `rangeSpecifier` в другую строку обеспечивает поддержку настраиваемых описателей диапазона, отличных от байтов (спецификатор диапазона байтов, определенный в RFC 2616 консорциумом IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `rangeSpecifier` будет указан как "bytes", параметр `from` — 0, а параметр `to` — 99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges в ответе. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Строка, указанная в заголовке Accept-Ranges, — это описатель диапазона, который будет указан в параметре `rangeSpecifier` для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> добавляет к запросу заголовок диапазона.  
  
 Так как все сущности HTTP представлены в сообщениях HTTP как последовательности байтов, понятие диапазона байтов имеет смысл для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции с диапазонами байтов.  
  
 Заголовок Range в запросе позволяет клиенту запросить, чтобы он получал некоторую часть указанного диапазона байтов в сущности HTTP. Серверы не должны поддерживать запросы заголовков диапазонов.  
  
 Параметр `rangeSpecifier` обычно задается как "bytes", так как это единственный описатель диапазона, распознаваемый большинством HTTP-серверов. Установка параметра `rangeSpecifier` в другую строку обеспечивает поддержку настраиваемых описателей диапазона, отличных от байтов (спецификатор диапазона байтов, определенный в RFC 2616 консорциумом IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает первые 100 байт, будет выглядеть следующим образом:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере параметр `rangeSpecifier` будет указан как "bytes", параметр `from` — 0, а параметр `to` — 99.  
  
 HTTP-сервер указывает на поддержку заголовков диапазонов с заголовком Accept-Ranges в ответе. Ниже приведен пример заголовка Accept-Ranges с сервера, который поддерживает диапазоны байтов.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Строка, указанная в заголовке Accept-Ranges, — это описатель диапазона, который будет указан в параметре `rangeSpecifier` для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа сервера, то сервер не поддерживает заголовки диапазонов. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа из запроса диапазона анализируются только заголовки HTTP, связанные со всем запросом, и становятся доступными через свойства класса <xref:System.Net.HttpWebResponse>. Заголовки, связанные с каждым диапазоном, возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает код URI интернет-ресурса, который фактически отвечает на запрос.</summary>
        <value>Класс <see cref="T:System.Uri" />, идентифицирующий интернет-ресурс, который фактически отвечает на запрос. По умолчанию это код URI, используемый методом <see cref="M:System.Net.WebRequest.Create(System.String)" /> для инициализации запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства <xref:System.Net.HttpWebRequest.Address%2A> задается универсальный код ресурса (URI) после выполнения всех перенаправлений, происходящих во время запроса.  
  
 Универсальный код ресурса (URI) исходного запроса хранится в свойстве <xref:System.Net.HttpWebRequest.RequestUri%2A>.  
  
   
  
## Examples  
 В следующем примере кода проверяется, был ли объект <xref:System.Net.HttpWebRequest> `req` был перенаправлен в другое место для выполнения запроса, и присваивает переменной `hasChanged` значение `true`, если запрос был перенаправлен. в противном случае `hasChanged` имеет значение `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, должен ли запрос следовать ответам переадресации.</summary>
        <value>Значение <see langword="true" />, если запрос должен автоматически следовать ответам переадресации, получаемым от интернет-ресурса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте для параметра <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> значение `true`, если требуется, чтобы запрос автоматически подследовался к новому расположению ресурса по заголовкам перенаправления HTTP. Максимальное количество перенаправлений, которое следует отслеживать, задается свойством <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>.  
  
 Если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> имеет значение `false`, то приложению возвращаются все ответы с кодом состояния HTTP из 300 в 399.  
  
 Заголовок авторизации удаляется при автоматическом перенаправлении, а <xref:System.Net.HttpWebRequest> автоматически пытается повторно пройти проверку подлинности в перенаправленном расположении. На практике это означает, что приложение не может добавить пользовательские сведения о проверке подлинности в заголовок авторизации, если возможно возникнет перенаправление. Вместо этого приложение должно реализовать и зарегистрировать настраиваемый модуль проверки подлинности. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> и связанный класс используются для реализации пользовательского модуля проверки подлинности. Метод <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> регистрирует пользовательский модуль проверки подлинности.  
  
   
  
## Examples  
 В следующем примере кода используется свойство <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>, позволяющее запросу следовать ответам перенаправления.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, полученных от интернет-ресурса.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, получаемых от интернет-ресурса; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="C#" Value="public bool AllowWriteStreamBuffering { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowWriteStreamBuffering As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, отправляемых в интернет-ресурс.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, отправляемых в интернет-ресурс; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> `true`, данные помещаются в буфер памяти, поэтому они готовы к повторному выполнению в случае перенаправления или запросов на проверку подлинности.  
  
   
  
## Examples  
 В следующем примере кода свойство <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> используется для отключения буферизации данных.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Установка <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> <see langword="true" /> может вызвать проблемы с производительностью при отправке больших наборов данных, так как буфер может использовать всю доступную память.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип используемой распаковки.</summary>
        <value>Объект <see cref="T:System.Net.DecompressionMethods" />, указывающий тип используемого распаковки.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Текущее состояние объекта не позволяет задать это свойство.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Класс <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> запускает асинхронный запрос для потока, используемого для отправки данных для <xref:System.Net.HttpWebRequest>. Асинхронный метод обратного вызова использует метод <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> для возврата фактического потока.  
  
 Метод <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> требует завершения некоторых синхронных задач установки (например, разрешение DNS, обнаружение прокси-сервера и подключение через сокет TCP), прежде чем этот метод станет асинхронным. В результате этот метод никогда не должен вызываться в потоке пользовательского интерфейса, поскольку может занять значительное время (до нескольких минут в зависимости от параметров сети), чтобы завершить первоначальные задачи синхронной установки, прежде чем будет вызвано исключение для ошибки или метод выполнен.  
  
 Дополнительные сведения о пуле потоков см. в разделе [управляемый пул потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Приложение не может смешивать синхронные и асинхронные методы для конкретного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> необходимо использовать метод <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода метод <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> используется для выполнения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Свойство <see cref="P:System.Net.HttpWebRequest.Method" /> имеет значение GET или HEAD.  
  
-или- 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Поток используется предыдущим вызовом в <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  
  
-или- 
В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с нулевой длиной содержимого не был правильно получен и закрыт. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" /></param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос ответа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> запускает асинхронный запрос ответа от Интернет-ресурса. Асинхронный метод обратного вызова использует метод <xref:System.Net.HttpWebRequest.EndGetResponse%2A> для возврата фактической <xref:System.Net.WebResponse>.  
  
 В нескольких случаях возникает <xref:System.Net.ProtocolViolationException>, если свойства, заданные для класса <xref:System.Net.HttpWebRequest>, конфликтуют. Это исключение возникает, если приложение задает свойство <xref:System.Net.HttpWebRequest.ContentLength%2A>, а свойство <xref:System.Net.HttpWebRequest.SendChunked%2A> — `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить фрагмент на сервер, который поддерживает только протокол HTTP 1,0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные, не устанавливая свойство <xref:System.Net.HttpWebRequest.ContentLength%2A> или <xref:System.Net.HttpWebRequest.SendChunked%2A> `false` при отключении буферизации и при подключении KeepAlive (свойство <xref:System.Net.HttpWebRequest.KeepAlive%2A> `true`)`.`  
  
 При появлении <xref:System.Net.WebException> используйте свойства <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> исключения, чтобы определить ответ от сервера.  
  
 Метод <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> требует завершения некоторых синхронных задач установки (например, разрешение DNS, обнаружение прокси-сервера и подключение через сокет TCP), прежде чем этот метод станет асинхронным. В результате этот метод никогда не должен вызываться в потоке пользовательского интерфейса, поскольку может занять значительное время (до нескольких минут в зависимости от параметров сети), чтобы завершить первоначальные задачи синхронной установки, прежде чем будет вызвано исключение для ошибки или метод выполнен.  
  
 Дополнительные сведения о пуле потоков см. в разделе [управляемый пул потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Приложение не может смешивать синхронные и асинхронные методы для конкретного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> необходимо использовать метод <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода метод <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> используется для выполнения асинхронного запроса Интернет – ресурса.  
  
> [!NOTE]
>  В случае асинхронных запросов клиентское приложение отвечает за реализацию собственного механизма ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже используется предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  
  
-или- 
В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> равно GET или HEAD, и либо <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, либо <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  
  
-или- 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, и какое-либо одно из значений <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, или <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.  
  
-или- 
Запрос <see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
-или- 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, но приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.HttpWebRequest.ClientCertificates" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает коллекцию сертификатов безопасности, связанных с данным запросом.</summary>
        <value>Коллекция <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />, содержащая сертификаты безопасности, связанные этим с запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может добавить сертификат в коллекцию, но может не иметь прав доступа к нему. Чтобы использовать сертификат, содержащийся в коллекции, приложение должно иметь те же права доступа, что и сущность, выдавшей сертификат.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL по мере их создания и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторного использования сеанса SSL платформа использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если таковой имеется) или пытается повторно использовать анонимные сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> пуст.  
  
> [!NOTE]
>  По соображениям производительности не следует добавлять сертификат клиента в <xref:System.Net.HttpWebRequest>, если только не известно, что сервер запросит его.  
>   
>  Пример кода, иллюстрирующий перечисление сертификатов в хранилище сертификатов клиента, см. в разделе класс <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для операции задания указано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Connection" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Connection" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запрос отправляет свойство <xref:System.Net.HttpWebRequest.Connection%2A> в Интернет-ресурс в качестве заголовка `Connection` HTTP. Если значение свойства <xref:System.Net.HttpWebRequest.KeepAlive%2A> `true`, то значение "Проверка активности" добавляется в конец заголовка `Connection`.  
  
 Чтобы очистить заголовок HTTP `Connection`, задайте для свойства <xref:System.Net.HttpWebRequest.Connection%2A> значение `null`.  
  
 Изменение свойства <xref:System.Net.HttpWebRequest.Connection%2A> после запуска запроса путем вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода свойство <xref:System.Net.HttpWebRequest.Connection%2A> используется для задания значения заголовка HTTP подключения.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для <see cref="P:System.Net.HttpWebRequest.Connection" /> задано значение "Проверка активности" или "Закрыто".</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя группы подключения для запроса.</summary>
        <value>Имя группы подключения для данного запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> позволяет связать запрос с группой соединений. Это полезно, когда приложение выполняет запросы к одному серверу для разных пользователей, например веб-сайт, который получает сведения о клиентах с сервера базы данных.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать сведения о пользователе для формирования группы соединений, предполагая, что переменные `username`, `password`и `domain` задаются приложением перед вызовом этого кода.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждая группа соединений создает дополнительные соединения для сервера. Это может привести к превышению числа подключений, заданных свойством <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> для этого сервера.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Группирование подключений</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает заголовок HTTP <see langword="Content-length" />.</summary>
        <value>Количество байтов данных, отправляемых в интернет-ресурс. Значение по умолчанию, равное –1, показывает, что свойство не установлено и отсутствуют данные запроса, предназначенные для отправки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.ContentLength%2A> содержит значение, отправляемое в качестве заголовка `Content-length` HTTP с запросом.  
  
 Любое значение, отличное от-1, в свойстве <xref:System.Net.HttpWebRequest.ContentLength%2A> указывает на то, что запрос отправляет данные и в свойстве <xref:System.Net.HttpWebRequest.Method%2A> разрешено устанавливать только методы, которые отправляют данные.  
  
 После того как для свойства <xref:System.Net.HttpWebRequest.ContentLength%2A> задано значение, это число байтов должно быть записано в поток запроса, возвращаемый путем вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или методов <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> и <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода свойству <xref:System.Net.HttpWebRequest.ContentLength%2A> присваивается длина отправляемой строки.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новое значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Content-type" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Content-type" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.ContentType%2A> содержит тип носителя запроса. Значения, назначенные свойству <xref:System.Net.HttpWebRequest.ContentType%2A>, заменяют любое существующее содержимое, когда запрос отправляет `Content-type` заголовок HTTP.  
  
 Чтобы очистить заголовок HTTP `Content-type`, задайте для свойства <xref:System.Net.HttpWebRequest.ContentType%2A> значение `null`.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если параметр <xref:System.Net.WebHeaderCollection> установлен, значение свойства будет утрачено.  
  
   
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.ContentType%2A>.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод делегата, вызываемый при получении от интернет-ресурса HTTP-ответа 100-continue.</summary>
        <value>Делегат, реализующий метод обратного вызова, который выполняется при возвращении от интернет-ресурса ответа HTTP Continue. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> указывает метод обратного вызова, который вызывается, когда клиент получает ответ 100-Continue.  
  
 Если задано свойство <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>, клиент вызывает делегат при каждом получении ответов протокола типа <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100). Это полезно, если требуется, чтобы клиент отображал состояние данных, получаемых из Интернет-ресурса.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах до получения ответа 100-Continue с сервера.</summary>
        <value>Время ожидания в миллисекундах до получения ответа 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если получен ответ 100-Continue до истечения времени ожидания, то тело сущности можно отправить.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer CookieContainer { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieContainer As CookieContainer" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает файлы cookie, связанные с запросом.</summary>
        <value>Контейнер <see cref="T:System.Net.CookieContainer" />, в котором содержатся файлы cookie, связанные с этим запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.CookieContainer%2A> предоставляет экземпляр класса <xref:System.Net.CookieContainer>, который содержит файлы cookie, связанные с этим запросом.  
  
 по умолчанию <xref:System.Net.HttpWebRequest.CookieContainer%2A> `null`. Необходимо назначить объект <xref:System.Net.CookieContainer> свойству, чтобы файлы cookie возвращались в свойстве <xref:System.Net.HttpWebResponse.Cookies%2A> <xref:System.Net.HttpWebResponse>, возвращаемом методом <xref:System.Net.HttpWebRequest.GetResponse%2A>.  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie по умолчанию отключены. Если вы хотите использовать файлы cookie, используйте свойство <xref:System.Net.HttpWebRequest.CookieContainer%2A>, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода запрос отправляется на URL-адрес и отображаются файлы cookie, возвращенные в ответе.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает информацию о проверке подлинности запроса.</summary>
        <value>Класс <see cref="T:System.Net.ICredentials" />, содержащий учетные данные для проверки подлинности, связанные с запросом. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.Credentials%2A> содержит сведения о проверке подлинности для идентификации создателя запроса. Свойством <xref:System.Net.HttpWebRequest.Credentials%2A> может быть <xref:System.Net.NetworkCredential>, в этом случае сведения о пользователе, пароле и домене, содержащиеся в объекте <xref:System.Net.NetworkCredential>, используются для проверки подлинности запроса или <xref:System.Net.CredentialCache>. в этом случае для определения пользователя, пароля и сведений о домене, используемых для проверки подлинности запроса, используется универсальный код ресурса (URI) запроса.  
  
 В большинстве клиентских сценариев следует использовать свойство <xref:System.Net.CredentialCache.DefaultCredentials%2A>, которое содержит учетные данные пользователя, выполнившего вход в систему. Для этого задайте для свойства <xref:System.Net.WebClient.UseDefaultCredentials%2A> значение `true` вместо задания этого свойства.  
  
 Если класс <xref:System.Net.HttpWebRequest> используется в приложении среднего уровня, например в приложении ASP.NET, учетные данные в свойстве <xref:System.Net.CredentialCache.DefaultCredentials%2A> принадлежат учетной записи, запускающей страницу ASP (учетные данные на стороне сервера). Как правило, этому свойству следует присвоить учетные данные клиента, от имени которого выполняется запрос.  
  
> [!NOTE]
>  Схему проверки подлинности NTLM нельзя использовать для олицетворения другого пользователя. Протокол Kerberos должен быть специально настроен для поддержки олицетворения.  
  
 Чтобы ограничить HttpWebRequest одним или несколькими методами проверки подлинности, используйте класс <xref:System.Net.CredentialCache> и свяжите учетные данные с одной или несколькими схемами проверки подлинности.  
  
 Поддерживаемые схемы проверки подлинности включают в себя дайджест, Negotiate, Kerberos, NTLM и базовый.  
  
 По соображениям безопасности, при автоматическом перенаправлении, Храните учетные данные, которые необходимо добавить в перенаправление, в <xref:System.Net.CredentialCache> и присвойте его этому свойству. Это свойство будет автоматически установлено в `null` при перенаправлении, если оно содержит что-либо, кроме <xref:System.Net.CredentialCache>. Если для этого значения свойства автоматически задано значение `null` в этих условиях, учетные данные не будут отправляться в непреднамеренное назначение.
  
## Examples  
 В следующем примере кода задаются учетные данные для запроса.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка HTTP <see langword="Date" /> для использования в HTTP-запросе.</summary>
        <value>Значение заголовка Date в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заголовок даты `null`, для возвращаемого значения будет задано значение <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Свойство <xref:System.Net.HttpWebRequest.Date%2A> — это стандартный объект <xref:System.DateTime?displayProperty=nameWithType>, который может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. При использовании свойства <xref:System.Net.HttpWebRequest.Date%2A> можно задать любой тип времени. Если задано или получено <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, предполагается, что свойство <xref:System.Net.HttpWebRequest.Date%2A> будет <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Местное время).  
  
 Классы в пространстве имен <xref:System.Net> всегда записывают его во время передачи в стандартной форме <xref:System.Net.HttpWebRequest.Date%2A>, используя формат GMT (UTC).  
  
 Если свойство <xref:System.Net.HttpWebRequest.Date%2A> имеет значение <xref:System.DateTime.MinValue?displayProperty=nameWithType>, то `Date` заголовок HTTP удаляется из свойства <xref:System.Net.HttpWebRequest.Headers%2A> и <xref:System.Net.WebHeaderCollection>.  
  
 Если свойство <xref:System.Net.HttpWebRequest.Date%2A> имеет значение <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что заголовок HTTP `Date` не включен в свойство <xref:System.Net.HttpWebRequest.Headers%2A> и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> установлен и предпринята попытка отправить <xref:System.Net.HttpWebRequest> без тела, то <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> будут создаваться с помощью методов <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>и <xref:System.Net.HttpWebRequest.EndGetResponse%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает политику кэширования для этого запроса.</summary>
        <value>Свойство <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, которое указывает политику кэширования, действующую для этого запроса, если неприменима любая другая политика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание этого свойства регистрирует указанную политику для схем HTTP и HTTPS. Эта политика используется для этого запроса, если:  
  
 Для этого запроса не указано свойство <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType>.  
  
-или-
  
 Файлы конфигурации компьютера и приложения не указывают политику кэширования, применимую к универсальному идентификатору ресурса (URI), используемому для создания этого запроса.  
  
 Политика кэширования определяет, может ли запрошенный ресурс быть взят из кэша вместо отправки запроса на компьютер узла ресурсов.  
  
 Копия ресурса добавляется в кэш только в том случае, если поток ответа для ресурса извлекается и считывается в конец потока. Поэтому другой запрос к тому же ресурсу может использовать кэшированную копию в зависимости от уровня политики кэша для этого запроса.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает наибольшую длину по умолчанию для ответа HTTP об ошибке.</summary>
        <value>Наибольшая длина по умолчанию для ответа HTTP об ошибке.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение по умолчанию для свойства <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>Длина в килобайтах (1024 байта) или максимум по умолчанию для получаемых заголовков ответов. В файле конфигурации по умолчанию это значение устанавливается равным 64 килобайтам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа получила строку состояния ответа и все дополнительные управляющие символы, полученные как часть протокола HTTP. Значение-1 означает отсутствие ограничения на полученные заголовки ответа; значение 0 означает, что все запросы завершаются ошибкой.  
  
 Это значение также может быть изменено в файле конфигурации. Влияние этого свойства можно переопределить, задав свойство <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> в экземпляре класса <xref:System.Net.HttpWebRequest>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> завершает асинхронный запрос для потока, который был запущен методом <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>. После возврата объекта <xref:System.IO.Stream> можно отправить данные с <xref:System.Net.HttpWebRequest> с помощью метода <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Перед записью данных в поток необходимо задать значение свойства <xref:System.Net.HttpWebRequest.ContentLength%2A>.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>, чтобы закрыть поток и освободить подключение для повторного использования. Сбой закрытия потока приводит к тому, что приложение закончит работу.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода метод <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> используется для завершения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершен, и поток недоступен.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult * TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, context)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult * TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <param name="context">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> завершает асинхронный запрос для потока, который был запущен методом <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, и выводит <xref:System.Net.TransportContext>, связанный с потоком. После возврата объекта <xref:System.IO.Stream> можно отправить данные с <xref:System.Net.HttpWebRequest> с помощью метода <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой, могут запрашивать транспортный уровень, используемый <xref:System.Net.HttpWebRequest>, чтобы получить маркер привязки канала (CBT) из базового TLS-канала. Метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> предоставляет доступ к этим сведениям для методов HTTP, которые имеют текст запроса (`POST` и `PUT` запросы). Это необходимо только в том случае, если приложение реализует собственную проверку подлинности и требует доступа к CBT.  
  
> [!NOTE]
>  Если приложению необходимо задать значение свойства <xref:System.Net.HttpWebRequest.ContentLength%2A>, это необходимо сделать перед извлечением потока и записью в него данных.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>, чтобы закрыть поток и освободить подключение для повторного использования. Сбой закрытия потока приводит к тому, что приложение закончит работу.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершен, и поток недоступен.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Интегрированная проверка подлинности Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос ответа.</param>
        <summary>Завершает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.EndGetResponse%2A> завершает асинхронный запрос для Интернет ресурса, который был запущен путем вызова метода <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.Net.HttpWebResponse.Close%2A>, чтобы закрыть поток и освободить соединение. Если этого не сделать, это может привести к нехватке подключений в приложении.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода метод <xref:System.Net.HttpWebRequest.EndGetResponse%2A> используется для завершения асинхронного запроса Интернет – ресурса.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью <paramref name="asyncResult." />.  
  
-или- 
Свойство <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше 0, но данные не были записаны в поток запроса.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Expect" />.</summary>
        <value>Содержимое заголовка HTTP <see langword="Expect" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Значение этого свойства хранится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Для <see langword="Expect" /> указана строка, содержащая значение 100-continue в виде подстроки.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-значение для экземпляра <see cref="T:System.Net.WebRequest" />.</summary>
        <returns>Целочисленное хэш-значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Метод GetHashCode возвращает код хэша веб-запроса. Это значение можно использовать в качестве ключа в хэш-таблицах.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты, входящие в <xref:System.Runtime.Serialization.SerializationInfo>, автоматически отправляются и сериализуются модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> возвращает поток, используемый для отправки данных для <xref:System.Net.HttpWebRequest>. После возврата объекта <xref:System.IO.Stream> можно отправить данные с <xref:System.Net.HttpWebRequest> с помощью метода <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>.  
  
 Если приложению необходимо задать значение свойства <xref:System.Net.HttpWebRequest.ContentLength%2A>, это необходимо сделать перед извлечением потока.  
  
 Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>, чтобы закрыть поток и освободить подключение для повторного использования. Сбой закрытия потока приводит к тому, что приложение закончит работу.  
  
> [!NOTE]
>  Приложение не может смешивать синхронные и асинхронные методы для конкретного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> необходимо использовать метод <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> для возврата экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Свойство <see cref="P:System.Net.HttpWebRequest.Method" /> имеет значение GET или HEAD.  
  
-или- 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Истекло время ожидания для запроса.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с нулевой длиной содержимого не был правильно получен и закрыт. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : TransportContext -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> возвращает поток, используемый для отправки данных для <xref:System.Net.HttpWebRequest> и выводит <xref:System.Net.TransportContext>, связанный с потоком. После возврата объекта <xref:System.IO.Stream> можно отправить данные с <xref:System.Net.HttpWebRequest> с помощью метода <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой, могут запрашивать транспортный уровень, используемый <xref:System.Net.HttpWebRequest>, чтобы получить маркер привязки канала (CBT) из базового TLS-канала. Метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> предоставляет доступ к этим сведениям для методов HTTP, которые имеют текст запроса (`POST` и `PUT` запросы). Это необходимо только в том случае, если приложение реализует собственную проверку подлинности и требует доступа к CBT.  
  
 Если приложению необходимо задать значение свойства <xref:System.Net.HttpWebRequest.ContentLength%2A>, это необходимо сделать перед извлечением потока.  
  
 Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>, чтобы закрыть поток и освободить подключение для повторного использования. Сбой закрытия потока приводит к тому, что приложение закончит работу.  
  
> [!NOTE]
>  Приложение не может смешивать синхронные и асинхронные методы для конкретного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> необходимо использовать метод <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Методу <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> не удалось получить <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Свойство <see cref="P:System.Net.HttpWebRequest.Method" /> имеет значение GET или HEAD.  
  
-или- 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Истекло время ожидания для запроса.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Интегрированная проверка подлинности Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ответ от интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.HttpWebRequest.GetResponse%2A> возвращает объект <xref:System.Net.WebResponse>, содержащий ответ от Интернет-ресурса. Фактически возвращаемый экземпляр является <xref:System.Net.HttpWebResponse>и может быть приведен к этому классу для доступа к свойствам, связанным с HTTP.  
  
 В нескольких случаях возникает <xref:System.Net.ProtocolViolationException>, если свойства, заданные для класса <xref:System.Net.HttpWebRequest>, конфликтуют. Это исключение возникает, если приложение задает свойство <xref:System.Net.HttpWebRequest.ContentLength%2A>, а свойство <xref:System.Net.HttpWebRequest.SendChunked%2A> — `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить фрагмент на сервер, который поддерживает только протокол HTTP 1,0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные, не устанавливая свойство <xref:System.Net.HttpWebRequest.ContentLength%2A> или <xref:System.Net.HttpWebRequest.SendChunked%2A> `false` при отключении буферизации и при подключении KeepAlive (свойство <xref:System.Net.HttpWebRequest.KeepAlive%2A> `true`)`.`  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.Net.HttpWebResponse.Close%2A>, чтобы закрыть поток и освободить соединение. Если этого не сделать, это может привести к нехватке подключений в приложении.  
  
 При использовании метода POST необходимо получить поток запроса, записать данные для отправки и закрыть поток. Этот метод блокирует ожидание публикации содержимого; Если время ожидания не задано и вы не предоставляете содержимое, вызывающий поток блокируется в течение неограниченного времени.  
  
> [!NOTE]
>  Несколько вызовов <xref:System.Net.HttpWebRequest.GetResponse%2A> возвращают один и тот же объект ответа. запрос не выдается повторно.  
  
> [!NOTE]
>  Приложение не может смешивать синхронные и асинхронные методы для конкретного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> необходимо использовать метод <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  При появлении <xref:System.Net.WebException> используйте свойства <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> исключения, чтобы определить ответ от сервера.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie по умолчанию отключены. Если вы хотите использовать файлы cookie, используйте свойство <xref:System.Net.HttpWebRequest.CookieContainer%2A>, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода возвращается ответ для запроса.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже используется предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> равно GET или HEAD, и либо <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше или равно нулю, либо <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  
  
-или- 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.  
  
-или- 
Запрос <see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.GetResponse" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
-или- 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, но приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако этот запрос содержит данные, которые будут отправлены на сервер. Запросы, отправляющие данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Истекло время ожидания для запроса.  
  
-или- 
во время обработки запроса возникла ошибка.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="C#" Value="public bool HaveResponse { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HaveResponse As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HaveResponse { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли получен ответ от интернет-ресурса.</summary>
        <value>Значение <see langword="true" />, если ответ получен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода проверяется свойство <xref:System.Net.HttpWebRequest.HaveResponse%2A>, чтобы определить, был ли получен ответ от Интернет-ресурса.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает коллекцию пар "имя-значение", из которых создаются заголовки HTTP.</summary>
        <value>Коллекция <see cref="T:System.Net.WebHeaderCollection" />, содержащая пары "имя-значение", из которых состоят заголовки HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Коллекция <xref:System.Net.HttpWebRequest.Headers%2A> содержит заголовки протоколов, связанные с запросом. В следующей таблице перечислены заголовки HTTP, которые не хранятся в коллекции <xref:System.Net.HttpWebRequest.Headers%2A>, но задаются системой или задаются свойствами или методами.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается свойством <xref:System.Net.HttpWebRequest.Accept%2A>.|  
|Подключение|Задается свойством <xref:System.Net.HttpWebRequest.Connection%2A> и свойством <xref:System.Net.HttpWebRequest.KeepAlive%2A>.|  
|Длина содержимого|Задается свойством <xref:System.Net.HttpWebRequest.ContentLength%2A>.|  
|Тип содержимого|Задается свойством <xref:System.Net.HttpWebRequest.ContentType%2A>.|  
|Требование|Задается свойством <xref:System.Net.HttpWebRequest.Expect%2A>.|  
|Дата|Задается свойством <xref:System.Net.HttpWebRequest.Date%2A>.|  
|Host|Задается свойством <xref:System.Net.HttpWebRequest.Host%2A>.|  
|Если-Modified — с|Задается свойством <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>.|  
|Диапазон|Задается методом <xref:System.Net.HttpWebRequest.AddRange%2A>.|  
|Источник ссылки|Задается свойством <xref:System.Net.HttpWebRequest.Referer%2A>.|  
|Кодировка при переносе|Задается свойством <xref:System.Net.HttpWebRequest.TransferEncoding%2A> (свойство <xref:System.Net.HttpWebRequest.SendChunked%2A> должно иметь значение true).|  
|Агент пользователя|Задается свойством <xref:System.Net.HttpWebRequest.UserAgent%2A>.|  
  
 При попытке установить один из этих защищенных заголовков метод <xref:System.Net.WebHeaderCollection.Add%2A> создает исключение <xref:System.ArgumentException>.  
  
 Изменение свойства <xref:System.Net.HttpWebRequest.Headers%2A> после запуска запроса вызовом метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
 Не следует рассчитывать, что значения заголовка останутся без изменений, так как веб-серверы и кэши могут изменять или добавлять заголовки к веб-запросу.  
  
   
  
## Examples  
 В следующем примере кода используется свойство <xref:System.Net.HttpWebRequest.Headers%2A> для вывода пар "имя-значение" заголовка HTTP в консоль.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка Host для использования в HTTP-запросе независимо от URI запроса.</summary>
        <value>Значение заголовка Host в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.Host%2A> можно использовать для задания значения заголовка узла для использования в HTTP-запросе независимо от URI запроса. Свойство <xref:System.Net.HttpWebRequest.Host%2A> может состоять из имени узла и необязательного номера порта. Заголовок узла без сведений о порте подразумевает порт по умолчанию для запрошенной службы (например, порт 80 для URL-адреса HTTP).  
  
 Формат указания узла и порта должен соответствовать правилам, описанным в разделе 14,23 RFC2616, опубликованном IETF. Пример соответствия этим требованиям, в котором указывается порт 8080, будет иметь следующее значение для свойства <xref:System.Net.HttpWebRequest.Host%2A>:  
  
 `www.contoso.com:8080`  
  
 Использование свойства <xref:System.Net.HttpWebRequest.Host%2A> для явного указания настраиваемого значения заголовка узла также влияет на кэширование, файлы cookie и проверку подлинности. Когда приложение предоставляет учетные данные для определенного префикса URI, приложения должны использовать URI, содержащий значение заголовка узла, а не целевой сервер в URI. Ключ, используемый при кэшировании ресурсов, использует значение заголовка узла вместо универсального кода ресурса (URI) запроса. Файлы cookie хранятся в <xref:System.Net.CookieContainer> и логически группируются по доменному имени сервера. Если в приложении указан заголовок узла, это значение будет использоваться в качестве домена.  
  
 Если свойство <xref:System.Net.HttpWebRequest.Host%2A> не задано, то значение заголовка узла, используемое в HTTP-запросе, основывается на универсальном коде ресурса (URI) запроса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заголовок узла не может иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Заголовку узла не может задано недопустимое значение.</exception>
        <exception cref="T:System.InvalidOperationException">Нельзя установить заголовок узла после начала отправки <see cref="T:System.Net.HttpWebRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="If-Modified-Since" />.</summary>
        <value>Объект <see cref="T:System.DateTime" />, в котором размещено содержимое заголовка HTTP <see langword="If-Modified-Since" />. Значением по умолчанию являются текущие дата и время.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> — это стандартный объект <xref:System.DateTime?displayProperty=nameWithType>, который может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. При использовании свойства <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> можно задать любой тип времени. Если задано или получено <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, предполагается, что свойство <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> будет <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (Местное время).  
  
 Классы в пространстве имен <xref:System.Net> всегда записывают его во время передачи в стандартной форме <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>, используя формат GMT (UTC).  
  
 Если свойство <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> имеет значение <xref:System.DateTime.MinValue?displayProperty=nameWithType>, то `If-Modified-Since` заголовок HTTP удаляется из свойства <xref:System.Net.HttpWebRequest.Headers%2A> и <xref:System.Net.WebHeaderCollection>.  
  
 Если свойство <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> имеет значение <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что заголовок HTTP `If-Modified-Since` не включен в свойство <xref:System.Net.HttpWebRequest.Headers%2A> и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода проверяется свойство <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, необходимо ли устанавливать постоянное подключение к интернет-ресурсу.</summary>
        <value>Значение <see langword="true" />, если запрос к интернет-ресурсу должен содержать заголовок HTTP <see langword="Connection" /> со значением Keep-alive; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true`, чтобы отправить заголовок `Connection` HTTP со значением поддержания активности. Приложение использует <xref:System.Net.HttpWebRequest.KeepAlive%2A> для указания предпочтений для постоянных соединений. Если свойство <xref:System.Net.HttpWebRequest.KeepAlive%2A> `true`, приложение устанавливает постоянные подключения к серверам, которые их поддерживают.  
  
> [!NOTE]
>  При использовании HTTP/1.1 по умолчанию сохраняется активность. Установка <xref:System.Net.HttpWebRequest.KeepAlive%2A> в `false` может привести к отправке заголовка `Connection: Close` на сервер.  
  
   
  
## Examples  
 В следующем примере кода свойству <xref:System.Net.HttpWebRequest.KeepAlive%2A> присваивается значение `false`, чтобы избежать установления постоянного подключения к Интернет-ресурсу.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество переадресаций, выполняемых запросом.</summary>
        <value>Максимальное количество ответов переадресации, указаниям которых следует запрос. Значение по умолчанию — 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> задает максимальное число перенаправлений для запроса, если свойство <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> имеет значение `true`.  
  
   
  
## Examples  
 В следующем примере кода задается значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Задано значение 0 или меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальную допустимую длину заголовков ответов.</summary>
        <value>Длина заголовков ответов, выраженная в килобайтах (1024 байта).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа включает строку состояния ответа и все дополнительные управляющие символы, полученные как часть протокола HTTP. Значение-1 означает, что в заголовках ответа ограничение не наложено; значение 0 означает, что все запросы завершаются ошибкой.  
  
 Если свойство <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> не задано явно, по умолчанию используется значение свойства <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>.  
  
 Если длина полученного заголовка ответа превышает значение свойства <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>, то методы <xref:System.Net.HttpWebRequest.EndGetResponse%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> вызовут <xref:System.Net.WebException> со свойством <xref:System.Net.WebException.Status%2A>, для которого установлено значение <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 В следующем примере кода задается значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство установлено уже после отправки запроса.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает формат носителя запроса.</summary>
        <value>Формат носителя запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Net.HttpWebRequest.MediaType%2A> влияет на свойство <xref:System.Net.HttpWebResponse.CharacterSet%2A>. При задании <xref:System.Net.HttpWebRequest.MediaType%2A> в запросе соответствующий тип носителя выбирается из списка наборов символов, возвращаемых в HTTP-заголовке ответа `Content-type`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод для запроса.</summary>
        <value>Метод запроса, используемый для связи с интернет-ресурсом. Значение по умолчанию — GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства <xref:System.Net.HttpWebRequest.Method%2A> можно задать любую из глаголов HTTP 1,1: GET, HEAD, POST, WHERE, DELETE, TRACE или OPTIONS.  
  
 Если для свойства <xref:System.Net.HttpWebRequest.ContentLength%2A> задано любое значение, отличное от-1, то свойству <xref:System.Net.HttpWebRequest.Method%2A> должно быть присвоено свойство протокола, которое передает данные.  
  
   
  
## Examples  
 В следующем примере кода для свойства <xref:System.Net.HttpWebRequest.Method%2A> задается значение POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не указан.  
  
 -или-  
  
 Строка метода содержит недопустимые символы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли конвейерная передача запроса в интернет-ресурс.</summary>
        <value>Значение <see langword="true" />, если должна выполняться конвейерная передача запроса; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение использует свойство <xref:System.Net.HttpWebRequest.Pipelined%2A> для указания предпочтений для конвейерных подключений. Когда <xref:System.Net.HttpWebRequest.Pipelined%2A> `true`, приложение выполняет конвейерное подключение к серверам, которые их поддерживают.  
  
 Конвейерные соединения создаются, только если свойство <xref:System.Net.HttpWebRequest.KeepAlive%2A> также `true`.  
  
   
  
## Examples  
 В следующем примере кода значение свойства <xref:System.Net.HttpWebRequest.Pipelined%2A> выводится на консоль.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли отправлять заголовок авторизации вместе с запросом.</summary>
        <value>Значение <see langword="true" />, если с запросом требуется отправить заголовок авторизации HTTP после выполнения аутентификации; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После успешной проверки подлинности клиентского запроса к определенному <xref:System.Uri>, если <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `true` и указаны учетные данные, заголовок авторизации отправляется с каждым запросом на любой <xref:System.Uri>, соответствующий определенному <xref:System.Uri> вплоть до последней косой черты. Поэтому, если клиент успешно прошел проверку подлинности на определенном <xref:System.Uri>, который содержит следующее:  
  
 `http://www.contoso.com/firstpath/`  
  
 Затем заголовок авторизации для предварительной проверки подлинности отправляется с каждым запросом в любой из следующих <xref:System.Uri> экземпляров:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Однако заголовок авторизации не отправляется с запросами ни к одному из следующих экземпляров <xref:System.Uri>:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Если запрос клиента к определенному <xref:System.Uri> не прошел проверку подлинности, запрос использует стандартные процедуры проверки подлинности.  
  
 За исключением первого запроса, свойство <xref:System.Net.WebRequest.PreAuthenticate%2A> указывает, следует ли отправлять сведения о проверке подлинности с последующими запросами к <xref:System.Uri>, который соответствует конкретному <xref:System.Uri> вплоть до последней косой черты, не дожидаясь возникновения запроса сервером.  
  
 В следующем диалоговом окне между клиентом и сервером показан результат этого свойства. В диалоговом окне предполагается, что используется обычная проверка подлинности.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `false`:  
  
 Клиент: GET Сомеурл  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: получение с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 Клиент: GET Сомеурл  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: получение с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `true`:  
  
 Клиент: GET Сомеурл  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: получение с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 Клиент: получение Сомеурл с заголовками авторизации  
  
 Если схема проверки подлинности не поддерживает предварительную проверку подлинности, значение этого свойства игнорируется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает версию HTTP-протокола, используемую для запроса.</summary>
        <value>Версия HTTP-протокола, используемая для запроса. Значение по умолчанию: <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Net.HttpWebRequest> поддерживает только версии 1,0 и 1,1 протокола HTTP. При установке <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> другой версии возникает исключение.  
  
> [!NOTE]
>  Чтобы задать версию HTTP текущего запроса, используйте поля <xref:System.Net.HttpVersion.Version10> и <xref:System.Net.HttpVersion.Version11> класса <xref:System.Net.HttpVersion>.  
  
   
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.ProtocolVersion%2A>.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для версии HTTP задано значение, отличное от 1.0 или 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о прокси-сервере для запроса.</summary>
        <value>Объект <see cref="T:System.Net.IWebProxy" />, используемый в качестве прокси-сервера для этого запроса. Значение по умолчанию устанавливается путем вызова свойства <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.Proxy%2A> определяет объект <xref:System.Net.WebProxy>, используемый для обработки запросов к ресурсам в Интернете. Чтобы указать, что прокси-сервер использовать не нужно, задайте для свойства <xref:System.Net.HttpWebRequest.Proxy%2A> экземпляр прокси-сервера, возвращаемый методом <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>.  
  
 В файле конфигурации локального компьютера или приложения может указываться использование прокси-сервера по умолчанию. Если указано свойство <xref:System.Net.HttpWebRequest.Proxy%2A>, параметры прокси-сервера из свойства <xref:System.Net.HttpWebRequest.Proxy%2A> переопределяют локальный компьютер или файл конфигурации приложения, а экземпляр <xref:System.Net.HttpWebRequest> будет использовать указанные параметры прокси-сервера. Если в файле конфигурации не указан прокси-сервер и свойство <xref:System.Net.HttpWebRequest.Proxy%2A> не задано, то класс <xref:System.Net.HttpWebRequest> использует параметры прокси-сервера, унаследованные от Internet Explorer на локальном компьютере. Если в Internet Explorer нет параметров прокси-сервера, запрос отправляется непосредственно на сервер.  
  
 Класс <xref:System.Net.HttpWebRequest> анализирует список обхода прокси-сервера с подстановочными знаками, унаследованными от Internet Explorer, так же как и список пропусков, который анализируется непосредственно Internet Explorer. Например, класс <xref:System.Net.HttpWebRequest> будет анализировать список пропусков "NT *" из Internet Explorer как регулярное выражение "NT.\*". Поэтому URL-адрес "`http://nt.com`" будет обходить прокси-сервер с помощью класса <xref:System.Net.HttpWebRequest> и с помощью Internet Explorer.  
  
 Класс <xref:System.Net.HttpWebRequest> поддерживает обход локального прокси-сервера. Класс рассматривает назначение как локальные, если выполняются следующие условия.  
  
-   Назначение содержит неструктурированное имя (в URL-адресе нет точек).  
  
-   Назначение содержит петлевой адрес (<xref:System.Net.IPAddress.Loopback> или <xref:System.Net.IPAddress.IPv6Loopback>), или назначение содержит <xref:System.Net.IPAddress>, назначенный локальному компьютеру.  
  
-   Суффикс домена назначения соответствует суффиксу домена локального компьютера (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Изменение свойства <xref:System.Net.HttpWebRequest.Proxy%2A> после запуска запроса путем вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>. Сведения об элементе proxy см. в разделе [\&lt; defaultProxy\&gt; Элемент (параметры сети)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.Net.HttpWebRequest.Proxy%2A> для получения сведений о прокси-сервере для запроса.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметру <see cref="P:System.Net.HttpWebRequest.Proxy" /> задается значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью вызова <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет разрешения на запрошенную операцию.</exception>
        <permission cref="T:System.Net.WebPermission">Для получения или задания свойства <see cref="P:System.Net.HttpWebRequest.Proxy" />. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Настройка веб-приложений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Настройка прокси-сервера</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Автоматическое обнаружение прокси-сервера</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах при записи в поток или при чтении из него.</summary>
        <value>Число миллисекунд до истечения времени ожидания записи или чтения. Значение по умолчанию — 300 000 миллисекунд (5 минут).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> используется при записи в поток, возвращаемый методом <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, или при чтении из потока, возвращенного методом <xref:System.Net.HttpWebResponse.GetResponseStream%2A>.  
  
 В частности, свойство <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> управляет временем ожидания для метода <xref:System.IO.Stream.Read%2A>, который используется для чтения потока, возвращаемого методом <xref:System.Net.HttpWebResponse.GetResponseStream%2A>, и для метода <xref:System.IO.Stream.Write%2A>, который используется для записи в поток, возвращаемый методом <xref:System.Net.HttpWebRequest.GetRequestStream%2A>.  
  
 Чтобы указать количество времени ожидания завершения запроса, используйте свойство <xref:System.Net.HttpWebRequest.Timeout%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано задание свойства <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос уже был отправлен.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше или равно нулю и не равно <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Referer" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Referer" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> имеет значение `true`, свойство <xref:System.Net.HttpWebRequest.Referer%2A> задается автоматически при перенаправлении запроса на другой сайт.  
  
 Чтобы очистить заголовок HTTP `Referer`, задайте для свойства <xref:System.Net.HttpWebRequest.Referer%2A> значение `null`.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.Referer%2A>.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный код URI запроса.</summary>
        <value>Объект <see cref="T:System.Uri" />, который содержит код URI интернет-ресурса, переданный методу <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Uri>, передаваемый в <xref:System.Net.HttpWebRequest> вызовом <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 После заголовка перенаправления свойство <xref:System.Net.HttpWebRequest.RequestUri%2A> не изменяется. Чтобы получить фактический URI, который ответил на запрос, изучите свойство <xref:System.Net.HttpWebRequest.Address%2A>.  
  
   
  
## Examples  
 В следующем примере кода проверяется, был ли объект <xref:System.Net.HttpWebRequest> `req` был перенаправлен в другое место для выполнения запроса, и присваивает переменной `hasChanged` значение `true`, если запрос был перенаправлен. в противном случае `hasChanged` имеет значение `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будут ли отправляться данные в интернет-ресурс в виде сегментов.</summary>
        <value>Значение <see langword="true" />, если требуется отправлять данные в интернет-ресурс сегментами. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.HttpWebRequest.SendChunked%2A> `true`, запрос отправляет данные в Интернет-ресурс в сегментах. Интернет ресурс должен поддерживать получение фрагментированных данных.  
  
 Изменение свойства <xref:System.Net.HttpWebRequest.SendChunked%2A> после запуска запроса путем вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере кода свойству <xref:System.Net.HttpWebRequest.SendChunked%2A> присваивается значение `true`, чтобы данные могли быть отправлены в виде сегментов в Интернет ресурс.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает функцию обратного вызова для проверки сертификата сервера.</summary>
        <value>Функция обратного вызова для проверки сертификата сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию функция обратного вызова не задана и свойство <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает точку обслуживания, используемую для запроса.</summary>
        <value>Объект <see cref="T:System.Net.ServicePoint" />, представляющий сетевое подключение к интернет-ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> может отличаться от <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType>, если запрос перенаправляется.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, поддерживает ли запрос <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>Значение <see langword="true" />, если запрос поддерживает <see cref="T:System.Net.CookieContainer" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты, входящие в <xref:System.Runtime.Serialization.SerializationInfo>, автоматически отправляются и сериализуются модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение времени ожидания в миллисекундах для методов <see cref="M:System.Net.HttpWebRequest.GetResponse" /> и <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Число миллисекунд ожидания перед истечением времени ожидания запроса. Значение по умолчанию — 100 000 миллисекунд (100 секунд).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> — число миллисекунд, в течение которых последующий синхронный запрос, выполненный с помощью метода <xref:System.Net.HttpWebRequest.GetResponse%2A>, ожидает ответа, а метод <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ожидает поток. <xref:System.Net.HttpWebRequest.Timeout%2A> применяется ко всему запросу и ответу, а не по отдельности для вызовов методов <xref:System.Net.HttpWebRequest.GetRequestStream%2A> и <xref:System.Net.HttpWebRequest.GetResponse%2A>. Если ресурс не возвращается в течение времени ожидания, запрос выдает <xref:System.Net.WebException> со свойством <xref:System.Net.WebException.Status%2A>, для которого задано значение <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 Перед вызовом метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> необходимо задать свойство <xref:System.Net.HttpWebRequest.Timeout%2A>. Изменение свойства <xref:System.Net.HttpWebRequest.Timeout%2A> после вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> не оказывает никакого влияния  
  
 Свойство <xref:System.Net.HttpWebRequest.Timeout%2A> не влияет на асинхронные запросы, выполняемые с помощью метода <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> или <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>.  
  
> [!CAUTION]
>  В случае асинхронных запросов клиентское приложение реализует собственный механизм времени ожидания. См. пример в методе <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>.  
  
 Чтобы указать период времени ожидания до истечения времени ожидания операции чтения или записи, используйте свойство <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 Возврат или истечение времени ожидания запроса службы доменных имен (DNS) может занять до 15 секунд. Если запрос содержит имя узла, требующее разрешения, и для параметра <xref:System.Net.FileWebRequest.Timeout%2A> значение меньше 15 секунд, может потребоваться 15 секунд или более, прежде чем будет создано <xref:System.Net.WebException>, чтобы указать время ожидания запроса.  
  
   
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.Timeout%2A> объекта <xref:System.Net.HttpWebRequest>.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение меньше нуля и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="Transfer-encoding" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Transfer-encoding" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прежде чем можно будет задать свойство <xref:System.Net.HttpWebRequest.TransferEncoding%2A>, необходимо сначала задать для свойства <xref:System.Net.HttpWebRequest.SendChunked%2A> значение `true`. Очистка <xref:System.Net.HttpWebRequest.TransferEncoding%2A> путем установки значения `null` не влияет на значение <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Значения, присвоенные свойству <xref:System.Net.HttpWebRequest.TransferEncoding%2A>, заменяют любое существующее содержимое.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается, если <see cref="P:System.Net.HttpWebRequest.SendChunked" /> имеет значение <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> установлено значение Chunked.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли разрешено совместное использование высокоскоростного подключения с проверкой подлинности NTLM.</summary>
        <value>Значение <see langword="true" />, если необходимо сохранить открытым подключение, прошедшее проверку подлинности. В противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства по умолчанию — `false`, что приводит к закрытию текущего соединения после завершения запроса. Приложение должно проходить последовательность проверки подлинности при каждом выпуске нового запроса.  
  
 Если это свойство имеет значение `true`, то соединение, используемое для получения ответа, остается открытым после выполнения проверки подлинности. В этом случае другие запросы, для которых это свойство имеет значение `true`, могут использовать соединение без повторной проверки подлинности. Иными словами, если подключение прошло проверку подлинности для пользователя а, пользователь б может повторно использовать подключение. запрос пользователя б выполняется на основе учетных данных пользователя а.  
  
> [!CAUTION]
>  Так как приложение может использовать подключение без проверки подлинности, необходимо убедиться, что в системе отсутствует административная уязвимость при установке этого свойства в `true`. Если приложение отправляет запросы нескольким пользователям (олицетворяет несколько учетных записей пользователей) и использует проверку подлинности для защиты ресурсов, не устанавливайте для этого свойства значение `true`, если только не используются группы соединений, как описано ниже.  
  
 Рекомендуется включить этот механизм, если возникли проблемы с производительностью и приложение выполняется на веб-сервере с встроенной проверкой подлинности Windows.  
  
 Включение этого параметра открывает систему для угроз безопасности. Если свойству <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> присвоено значение `true` обязательно выполните следующие меры предосторожности.  
  
-   Используйте свойство <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> для управления подключениями для разных пользователей. Это позволяет избежать потенциального использования подключения приложениями, не прошедшими проверку подлинности. Например, пользователь а должен иметь уникальное имя группы соединений, которое отличается от имени пользователя B. Это обеспечивает уровень изоляции для каждой учетной записи пользователя.  
  
-   Запустите приложение в защищенной среде, чтобы избежать возможных эксплойтов подключения.  
  
 При управлении внутренним сервером в качестве альтернативы можно отключить сохранение проверки подлинности. Это повышает производительность до меньшей степени, но является более безопасным. Для получения дополнительных сведений выполните поиск по запросу Аусперсистенце в библиотеке MSDN по адресу [https://msdn.microsoft.com/library](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Если для обоих <xref:System.Net.WebRequest.PreAuthenticate%2A> и <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> задано значение `true`, каждый запрос отправляется с помощью соединения из ненадежного пула, но с заголовком авторизации.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Для задания этого свойства требуется неограниченное веб-разрешение.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое управляет отправкой учетных данных по умолчанию вместе с запросами.</summary>
        <value><see langword="true" />, если используются учетные данные по умолчанию; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true`, если запросы, выполняемые этим объектом <xref:System.Net.HttpWebRequest>, должны пройти проверку подлинности, используя учетные данные пользователя, выполнившего вход в систему. Для клиентских приложений это предпочтительное поведение в большинстве сценариев. Для приложений среднего уровня, таких как приложения ASP.NET, вместо использования этого свойства обычно задается свойство <xref:System.Net.HttpWebRequest.Credentials%2A> учетным данным клиента, от имени которого выполняется запрос.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка задать для этого свойства значение после отправки запроса.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение HTTP-заголовка <see langword="User-agent" />.</summary>
        <value>Значение HTTP-заголовка <see langword="User-agent" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Значение этого свойства хранится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода задается свойство <xref:System.Net.HttpWebRequest.UserAgent%2A>.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
