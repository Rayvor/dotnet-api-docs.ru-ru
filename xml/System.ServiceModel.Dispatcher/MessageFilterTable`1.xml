<Type Name="MessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.MessageFilterTable&lt;TFilterData&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d3554c90028926a9ffd768ccde269bf01ddf4199" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70320615" /></Metadata><TypeSignature Language="C#" Value="public class MessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageFilterTable`1&lt;TFilterData&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable, class System.ServiceModel.Dispatcher.IMessageFilterTable`1&lt;!TFilterData&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageFilterTable(Of TFilterData)&#xA;Implements ICollection(Of KeyValuePair(Of MessageFilter, TFilterData)), IDictionary(Of MessageFilter, TFilterData), IEnumerable(Of KeyValuePair(Of MessageFilter, TFilterData)), IMessageFilterTable(Of TFilterData)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TFilterData&gt;&#xA;public ref class MessageFilterTable : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::ServiceModel::Dispatcher::IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="F#" Value="type MessageFilterTable&lt;'FilterData&gt; = class&#xA;    interface IMessageFilterTable&lt;'FilterData&gt;&#xA;    interface IDictionary&lt;MessageFilter, 'FilterData&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TFilterData">Тип <c>FilterData</c> , связанный с фильтром.</typeparam>
    <summary>Предоставляется информация по общему применению таблицы фильтров.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> принимает фильтры любого типа. Он группирует их во внутренние таблицы, содержащие все фильтры заданного типа. При добавлении фильтр помещается во внутреннюю таблицу фильтров, если она уже существует, содержащую фильтры этого типа. Если такой таблицы не существует, то вызывается метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.CreateFilterTable%2A> для выделения новой таблицы фильтров соответствующего типа. Вызов метода <xref:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable%2A> является операцией по умолчанию.  
  
 Это поведение по умолчанию можно изменить, если явно задать тип таблицы фильтра, связанной с типом фильтра. При первом добавлении типа фильтра в таблицу создается тип таблицы фильтров, постоянно связанный с типом фильтра.  
  
 Приоритетом является целое число, используемое для группировки фильтров в блок приоритетов и упорядочения их обработки. Чем больше значение целого числа, присвоенного типу фильтра, тем выше его приоритет при обработке. Все таблицы фильтров в сегменте приоритетов вычисляются вместе. Сегменты с низким приоритетом вычисляются только в случае, если для сегментов высокого приоритета не обнаружено совпадений. Таблица фильтров присваивает приоритет по умолчанию, который устанавливается для всех добавляемых фильтров.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageFilterTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageFilterTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> с приоритетом по умолчанию 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чем больше целое число, присвоенное таблице фильтров, тем выше ее приоритет при проверке сообщений на совпадение. Приоритет по умолчанию можно задать с помощью <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageFilterTable (int defaultPriority);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 defaultPriority) cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultPriority As Integer)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageFilterTable(int defaultPriority);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt; : int -&gt; System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;" Usage="new System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt; defaultPriority" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public MessageFilterTable (int default_priority);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 default_priority) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (default_priority As Integer)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageFilterTable(int default_priority);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt; : int -&gt; System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;" Usage="new System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt; default_priority" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultPriority" Type="System.Int32" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="default_priority" Type="System.Int32" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="defaultPriority">Приоритет таблицы фильтров по умолчанию.</param>
        <param name="default_priority">Приоритет таблицы фильтров по умолчанию.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> с исходным приоритетом, заданным по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чем больше целое число, присвоенное таблице фильтров, тем выше ее приоритет при проверке сообщений на совпадение. Конструктор без параметров присваивает значение `defaultPriority` 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет фильтр и сопоставленные <paramref name="FilterData" /> в таблицу фильтров.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Add(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit&#xA;override this.Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit" Usage="messageFilterTable.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Пара <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt;, добавленная в таблицу.</param>
        <summary>Добавляет пару «фильтр/<paramref name="FilterData" />» (ключ-значение) в таблицу фильтров.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="item" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.MessageFilter filter, TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(class System.ServiceModel.Dispatcher.MessageFilter filter, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Add(System.ServiceModel.Dispatcher.MessageFilter,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As MessageFilter, data As TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData data);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit&#xA;override this.Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit" Usage="messageFilterTable.Add (filter, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
      </Parameters>
      <Docs>
        <param name="filter">Свойство <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, используемое в качестве ключа в добавляемой паре.</param>
        <param name="data">Параметр <c>FilterData</c>, связанный с фильтром, используемым в качестве значения в добавляемой паре.</param>
        <summary>Добавляет фильтр и сопоставленные <paramref name="FilterData" /> в таблицу фильтров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присваивает фильтру приоритет по умолчанию. Для указания приоритета используйте метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.Add%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filter" /> уже присутствует в таблице.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.MessageFilter filter, TFilterData data, int priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.ServiceModel.Dispatcher.MessageFilter filter, !TFilterData data, int32 priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Add(System.ServiceModel.Dispatcher.MessageFilter,`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As MessageFilter, data As TFilterData, priority As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData data, int priority);" />
      <MemberSignature Language="F#" Value="member this.Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData * int -&gt; unit" Usage="messageFilterTable.Add (filter, data, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
        <Parameter Name="priority" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="filter">Свойство <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, используемое в качестве ключа в добавляемой паре.</param>
        <param name="data">Параметр <c>FilterData</c>, связанный с фильтром, используемым в качестве значения в добавляемой паре.</param>
        <param name="priority">Приоритет добавляемого фильтра.</param>
        <summary>Добавляет фильтр и сопоставленные ему <paramref name="FilterData" /> в таблицу фильтров действий с указанным приоритетом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приоритетом является целое число, используемое для группировки фильтров в блок приоритетов и упорядочения их обработки. Чем больше значение целого числа, присвоенного типу фильтра, тем выше его приоритет при обработке. Все таблицы фильтров в сегменте приоритетов вычисляются вместе. Сегменты с низким приоритетом вычисляются только в случае, если для сегментов высокого приоритета не обнаружено совпадений. Используйте метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.Add%2A> для добавления фильтра с приоритетом по умолчанию. Приоритет по умолчанию можно задать с помощью <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.DefaultPriority%2A>. Исходное значение по умолчанию равно 0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filter" /> не может иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="filter" /> уже присутствует в таблице.</exception>
        <exception cref="T:System.InvalidOperationException">Тип параметра <paramref name="filter" /> не соответствует типу таблицы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="messageFilterTable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все фильтры и сопоставленные им данные фильтра из таблицы фильтров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.Collections.Generic.ICollection%601.Clear%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Contains(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="messageFilterTable.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;<see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, <c>FilterData</c>&gt; для поиска в таблице.</param>
        <summary>Определяет, содержит ли таблица фильтров указанный фильтр и соответствующий ему параметр <paramref name="FilterData" />.</summary>
        <returns>Значение <see langword="true" />, если пара <paramref name="filter" />/<paramref name="FilterData" /> содержится в таблице фильтров; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод `Contains` коллекции <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.ContainsKey(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="messageFilterTable.ContainsKey filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Проверка на наличие <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />.</param>
        <summary>Определяет, содержит ли таблица фильтров указанный фильтр.</summary>
        <returns>Имеет значение <see langword="true" />, если параметр <paramref name="filter" /> содержится в таблице фильтров; в ином случае принимает значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод `ContainsKey` коллекции <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[] array, int arrayIndex);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;[] array, int32 arrayIndex) cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.CopyTo(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of MessageFilter, TFilterData)(), arrayIndex As Integer)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ array, int arrayIndex);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit" Usage="messageFilterTable.CopyTo (array, arrayIndex)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[] array, int index);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;[] array, int32 index) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of MessageFilter, TFilterData)(), index As Integer)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ array, int index);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit" Usage="messageFilterTable.CopyTo (array, index)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[]" Index="0" />
        <Parameter Name="arrayIndex" Type="System.Int32" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Массив типа<see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; с индексацией от нуля, в который копируются пары.</param>
        <param name="arrayIndex">Индекс, с которого начинается копирование.</param>
        <param name="index">Индекс, с которого начинается копирование.</param>
        <summary>Копирует пары «фильтр/<paramref name="FilterData" />» в массив, начинающийся с указанного индекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод `CopyTo` коллекции <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество пар фильтр/<paramref name="FilterData" />, находящихся в таблице фильтров.</summary>
        <value>Количество пар фильтр/<paramref name="FilterData" />, находящихся в таблице фильтров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство реализует свойство <xref:System.Collections.Generic.ICollection%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFilterTable">
      <MemberSignature Language="C#" Value="protected virtual System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt; CreateFilterTable (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Dispatcher.IMessageFilterTable`1&lt;!TFilterData&gt; CreateFilterTable(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.CreateFilterTable(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateFilterTable (filter As MessageFilter) As IMessageFilterTable(Of TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::ServiceModel::Dispatcher::IMessageFilterTable&lt;TFilterData&gt; ^ CreateFilterTable(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member CreateFilterTable : System.ServiceModel.Dispatcher.MessageFilter -&gt; System.ServiceModel.Dispatcher.IMessageFilterTable&lt;'FilterData&gt;&#xA;override this.CreateFilterTable : System.ServiceModel.Dispatcher.MessageFilter -&gt; System.ServiceModel.Dispatcher.IMessageFilterTable&lt;'FilterData&gt;" Usage="messageFilterTable.CreateFilterTable filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Объект <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, помещаемый в создаваемую таблицу фильтров.</param>
        <summary>Приписывает таблице фильтров указанный тип фильтров.</summary>
        <returns>Создаваемый объект <see cref="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" />, содержащий указанный фильтр.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPriority">
      <MemberSignature Language="C#" Value="public int DefaultPriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultPriority" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.DefaultPriority" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultPriority { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPriority : int with get, set" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.DefaultPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает для таблицы фильтров приоритет по умолчанию.</summary>
        <value>Приоритет, присваиваемый фильтрам, добавляемым в таблицу фильтров, по умолчанию. Значение по умолчанию для приоритета по умолчанию равно 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приоритетом по умолчанию называется приоритет, автоматически присваиваемый фильтру, добавляемому в таблицу фильтров, если приоритет явно не задан. Приоритетом фильтра является целое число, используемое для группирования фильтров в сегменты, по которым упорядочивается обработка. Чем больше значение целого числа, присвоенного типу фильтра, тем выше его приоритет при обработке. Все таблицы фильтров в сегменте приоритетов вычисляются вместе. Сегменты с низким приоритетом вычисляются только в случае, если для сегментов высокого приоритета не обнаружено совпадений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;" Usage="messageFilterTable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий итерацию по таблице фильтров.</summary>
        <returns>Объект <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;KeyValuePair&lt;Filter, <paramref name="FilterData" />&gt;&gt; для итерации таблицы фильтров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод `GetEnumerator` коллекции <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное или буферизованное сообщение критерию соответствия одного фильтра, и возвращает этот фильтр в параметре <see langword="out" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверяет, удовлетворяет ли сообщение любому из фильтров в таблице фильтров.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter filter);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.Message * MessageFilter -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.Message * MessageFilter -&gt; bool" Usage="messageFilterTable.GetMatchingFilter (message, filter)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.Message * MessageFilter -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.Message * MessageFilter -&gt; bool" Usage="messageFilterTable.GetMatchingFilter (message, result)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" Index="0" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="result" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.ServiceModel.Channels.Message" /> для проверки.</param>
        <param name="filter">Параметр <see langword="out" />, содержащий фильтр, которому удовлетворяет параметр <paramref name="message" />. Если фильтр не найден, параметру присваивается значение по умолчанию.</param>
        <param name="result">Параметр <see langword="out" />, содержащий фильтр, которому удовлетворяет параметр <paramref name="message" />. Если фильтр не найден, параметру присваивается значение по умолчанию.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение критерию соответствия одного фильтра, и возвращает этот фильтр в параметре <see langword="out" />.</summary>
        <returns><see langword="true" />, если сообщение удовлетворяет критерию соответствия одного <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> в таблице; <see langword="false" />, если не найдено ни одного фильтра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что только один фильтр будет удовлетворять сообщению, и этот фильтр требуется.  
  
 Если текст сообщения должен проверяться фильтром в таблице фильтров, то используйте <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> версию метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Более одного объекта <see cref="T:System.ServiceModel.Dispatcher.ActionMessageFilter" /> соответствует параметру <paramref name="messageBuffer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer buffer, out System.ServiceModel.Dispatcher.MessageFilter filter);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer buffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (buffer As MessageBuffer, ByRef filter As MessageFilter) As Boolean" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ buffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer * MessageFilter -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer * MessageFilter -&gt; bool" Usage="messageFilterTable.GetMatchingFilter (buffer, filter)" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer buffer, out System.ServiceModel.Dispatcher.MessageFilter result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer buffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (buffer As MessageBuffer, ByRef result As MessageFilter) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ buffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer * MessageFilter -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer * MessageFilter -&gt; bool" Usage="messageFilterTable.GetMatchingFilter (buffer, result)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="result" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Объект <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> для проверки.</param>
        <param name="filter">Параметр <see langword="out" />, содержащий фильтр, которому удовлетворяет параметр <paramref name="buffer" />.</param>
        <param name="result">Параметр <see langword="out" />, содержащий фильтр, которому удовлетворяет параметр <paramref name="buffer" />.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение критерию соответствия одного фильтра, и возвращает этот фильтр в параметре <see langword="out" />.</summary>
        <returns><see langword="true" />, если сообщение удовлетворяет критериям соответствия только одного фильтра в таблице; <see langword="false" />, если не соответствует ни одному фильтру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что только один фильтр будет удовлетворять сообщению, и этот фильтр требуется возвратить.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Более одного объекта <see cref="T:System.ServiceModel.Dispatcher.ActionMessageFilter" /> соответствует параметру <paramref name="messageBuffer" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение или буферизованное сообщение критерию соответствия хотя бы одного объекта <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, и добавляет соответствующие фильтры в коллекцию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям сообщения, и эти фильтры требуются.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="messageFilterTable.GetMatchingFilters (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.ServiceModel.Channels.Message" /> для проверки.</param>
        <param name="results">Ссылочный параметр, в котором хранятся объекты <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, соответствующие условиям фильтра <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение критерию соответствия хотя бы одного объекта <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, и добавляет соответствующие фильтры в коллекцию.</summary>
        <returns><see langword="true" />, если критерию соответствия хотя бы одного объекта <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> в таблице удовлетворяет параметр <paramref name="message" />; <see langword="false" />, если не найдено ни одного фильтра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям сообщения, и эти фильтры требуются.  
  
 Этот метод производит проверку на наличие совпадающих с критериями поиска фильтров в блоке наивысших приоритетов фильтров, в котором находится хотя бы одно соответствие.  
  
 Фильтрам в таблице не разрешается проверять текст сообщения.  
  
 Объекты <xref:System.ServiceModel.Dispatcher.MessageFilter>, соответствующие запросу, хранятся в параметре `results` коллекции <xref:System.Collections.Generic.ICollection%601>. Параметр `FilterData` затем может быть восстановлен из таблицы фильтров путем использования этих фильтров в качестве ключей с методами, предоставляемыми словарем <xref:System.Collections.Generic.IDictionary%602>.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="results" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Была предпринята попытка проверить содержимое текста сообщения с помощью фильтра.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (buffer As MessageBuffer, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::MessageBuffer ^ buffer, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="messageFilterTable.GetMatchingFilters (buffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">Объект <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> для проверки.</param>
        <param name="results">Ссылочный параметр, в котором хранятся объекты <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, соответствующие условиям фильтра <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное буферизованное сообщение критерию соответствия хотя бы одного фильтра, и добавляет соответствующие критериям фильтры из блока наивысших приоритетов фильтров, в котором найдено хотя бы одно соответствие, в коллекцию.</summary>
        <returns><see langword="true" />, если параметр <paramref name="message" /> удовлетворяет критерию соответствия по крайней мере одного фильтра из таблицы; <see langword="false" />, если не удовлетворяются критерии ни одного из фильтров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям буферизованного сообщения, и эти фильтры требуются.  
  
 Фильтрам в таблице разрешается проверять текст сообщения.  
  
 Объекты <xref:System.ServiceModel.Dispatcher.MessageFilter>, соответствующие запросу, хранятся в параметре `results` коллекции <xref:System.Collections.Generic.ICollection%601>. Параметр `FilterData` затем может быть восстановлен из таблицы фильтров путем использования этих фильтров в качестве ключей с методами, предоставляемыми словарем <xref:System.Collections.Generic.IDictionary%602>.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="results" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение или буферизованное сообщение критерию соответствия одного объекта <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, и добавляет соответствующие данные фильтра в коллекцию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте один из этих методов, если предполагается, что только один фильтр будет удовлетворять сообщению и требуется восстановить только параметр `FilterData`.  
  
 Используйте метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.GetMatchingValue%2A> для проверки заголовков сообщений, а для проверки буферизованного сообщения используйте метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.GetMatchingValue%2A>, который может также просматривать текст сообщения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.Message * 'FilterData -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.Message * 'FilterData -&gt; bool" Usage="messageFilterTable.GetMatchingValue (message, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.ServiceModel.Channels.Message" /> для проверки.</param>
        <param name="data">Параметр <see langword="out" />, хранящий параметр <c>FilterData</c>, удовлетворяющий условиям <paramref name="message" />.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное сообщение критерию соответствия одного объекта <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, и добавляет соответствующие данные фильтра в коллекцию.</summary>
        <returns><see langword="true" />, если сообщение удовлетворяет критериям соответствия одного фильтра в таблице; <see langword="false" />, если не соответствует ни одному фильтру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что только один фильтр будет удовлетворять сообщению и требуется восстановить только параметр `FilterData`.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Найдено несколько фильтров, соответствующих параметру <paramref name="message" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Была предпринята попытка проверить содержимое текста сообщения с помощью фильтра.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer buffer, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer buffer, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (buffer As MessageBuffer, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::MessageBuffer ^ buffer, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.MessageBuffer * 'FilterData -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.MessageBuffer * 'FilterData -&gt; bool" Usage="messageFilterTable.GetMatchingValue (buffer, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Объект <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> для проверки.</param>
        <param name="data">Параметр <see langword="out" />, хранящий параметр <c>FilterData</c>, удовлетворяющий условиям <paramref name="buffer" />.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное буферизованное сообщение критерию соответствия одного фильтра, и добавляет соответствующие данные фильтра в коллекцию.</summary>
        <returns><see langword="true" />, если буферизованное сообщение удовлетворяет критериям соответствия одного фильтра в таблице; <see langword="false" />, если не соответствует ни одному фильтру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что только один фильтр будет удовлетворять буферизованному сообщению и требуется восстановить только параметр `FilterData`. Поскольку производится поиск соответствия фильтра буферизованному сообщению, то фильтр может задавать условия в тексте сообщения.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Найдено несколько фильтров, соответствующих параметру <paramref name="messageBuffer" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное или буферизованное сообщение критерию соответствия хотя бы одного фильтра, и добавляет параметр <paramref name="FilterData" /> фильтров, для которых имеется соответствие, в коллекцию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям сообщения или буферизованного сообщения, и требуется только параметр `FilterData`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="messageFilterTable.GetMatchingValues (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.ServiceModel.Channels.Message" /> для проверки.</param>
        <param name="results">Параметр ссылки, хранящий параметр <c>FilterData</c> найденных фильтров действий в универсальной коллекции <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt;.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное или буферизованное сообщение критерию соответствия хотя бы одного фильтра, и добавляет параметр <paramref name="FilterData" /> фильтров, для которых имеется соответствие, в коллекцию.</summary>
        <returns><see langword="true" />, если сообщение удовлетворяет критериям соответствия только одного фильтра в таблице; <see langword="false" />, если не соответствует ни одному фильтру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям сообщения, требуются только параметр `FilterData` и текст сообщения не проверяется.  
  
 Параметр `FilterData` найденных объектов <xref:System.ServiceModel.Dispatcher.MessageFilter> хранится в параметре `results` коллекции <xref:System.Collections.Generic.ICollection%601>.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="results" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Была предпринята попытка проверить содержимое текста сообщения с помощью фильтра.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (buffer As MessageBuffer, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::MessageBuffer ^ buffer, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="messageFilterTable.GetMatchingValues (buffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">Объект <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> для проверки.</param>
        <param name="results">Параметр ссылки, хранящий данные фильтров, которые удовлетворяют условию параметра <paramref name="buffer" />.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли заданное буферизованное сообщение критерию соответствия одного фильтра, и добавляет параметр <paramref name="FilterData" /> найденных фильтров в коллекцию <paramref name="results" />.</summary>
        <returns><see langword="true" />, если буферизованное сообщение удовлетворяет критериям соответствия одного объекта <see cref="T:System.ServiceModel.Dispatcher.ActionMessageFilter" /> в таблице; <see langword="false" />, если не соответствует ни одному фильтру.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, если предполагается, что несколько фильтров будут удовлетворять условиям буферизованного сообщения, и требуется только параметр `FilterData`.  
  
 Параметр `FilterData` найденных объектов <xref:System.ServiceModel.Dispatcher.MessageFilter> хранится в параметре `results` коллекции <xref:System.Collections.Generic.ICollection%601>.  
  
 Этот метод реализует <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="results" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPriority">
      <MemberSignature Language="C#" Value="public int GetPriority (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetPriority(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.GetPriority(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPriority (filter As MessageFilter) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetPriority(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="member this.GetPriority : System.ServiceModel.Dispatcher.MessageFilter -&gt; int" Usage="messageFilterTable.GetPriority filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Объект <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, помещаемый в создаваемую таблицу фильтров.</param>
        <summary>Возвращает приоритет конкретного фильтра в таблице.</summary>
        <returns>Приоритет фильтра <paramref name="filter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приоритетом является целое число, используемое для группировки фильтров в блок приоритетов и упорядочения их обработки. Чем больше значение целого числа, присвоенного типу фильтра, тем выше его приоритет при обработке. Все таблицы фильтров в сегменте приоритетов вычисляются вместе. Сегменты с низким приоритетом вычисляются только в случае, если для сегментов высокого приоритета не обнаружено совпадений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанного фильтра нет в таблице фильтров.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, доступен ли фильтр только для чтения.</summary>
        <value>Принимает значение <see langword="false" /> для всех таблиц фильтров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> должен быть предназначен не только для чтения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TFilterData this[System.ServiceModel.Dispatcher.MessageFilter filter] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TFilterData Item(class System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.Item(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(filter As MessageFilter) As TFilterData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TFilterData default[System::ServiceModel::Dispatcher::MessageFilter ^] { TFilterData get(System::ServiceModel::Dispatcher::MessageFilter ^ filter); void set(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData value); };" />
      <MemberSignature Language="F#" Value="member this.Item(System.ServiceModel.Dispatcher.MessageFilter) : 'FilterData with get, set" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFilterData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Фильтр <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, связанный с данными фильтра для получения или задания данных.</param>
        <summary>Получает или задает данные фильтра, связанные с указанным параметром <paramref name="filter" />.</summary>
        <value>Данные фильтра, связанные с параметром <paramref name="filter" />. Если указанный параметр <paramref name="filter" /> не найден, операция получения создает исключение <see cref="T:System.Collections.Generic.KeyNotFoundException" />, а операция задания значения создает новый элемент с указанным параметром <paramref name="filter" /> в качестве ключа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство `Item` (индексатор в C#) предоставляет возможность доступа к данным фильтра, связанным с параметром `filter` в таблице коллекции фильтров с помощью следующего синтаксиса.  
  
```csharp  
myFilters[filter]  
  
```  
  
```vb  
myFilters(filter)  
  
```  
  
 Для добавления новых элементов можно также использовать свойство `Item`, задавая значение пары параметр `filter`/данные фильтра, которой нет в таблице действующих фильтров. Однако, если указанный параметр `filter` уже есть в таблице, задание свойства `Item` перезаписывает прежнее значение. Метод <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.Add%2A> напротив не изменяет данные фильтра уже существующего параметра `filter`.  
  
 Словарь `item` является парой фильтр/`FilterData` в случае <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Свойство получено и параметр <paramref name="filter" /> не найден в таблице.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of MessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ Keys { System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию всех фильтров, содержащихся в таблице фильтров.</summary>
        <value>Коллекция <see cref="T:System.Collections.Generic.ICollection`1" /> всех фильтров, содержащихся в таблице фильтров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство реализует свойство <xref:System.Collections.Generic.IDictionary%602.Keys%2A>. Словарь <xref:System.Collections.Generic.IDictionary%602><Filter, `FilterData`>, который реализует таблица фильтров, использует <xref:System.ServiceModel.Dispatcher.MessageFilter> в качестве ключа, а параметр `FilterData` — в качестве значения пары.  
  
 Порядок фильтров, возвращаемых в коллекции, не указывается, но порядок будет точно таким же, что и параметры `FilterData` в коллекции, возвращаемой свойством <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.Values%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет фильтр и сопоставленные данные фильтра из таблицы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Remove(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="messageFilterTable.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; для удаления из таблицы.</param>
        <summary>Удаляет указанную пару «фильтр/<paramref name="FilterData" />» из таблицы фильтров.</summary>
        <returns><see langword="true" />, если пара фильтр/<paramref name="FilterData" /> была найдена и удалена; <see langword="false" />, если пара не была найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ фильтра параметра `item` есть, то сопоставлен с данными, отличными от данных параметра `FilterData`, то методу не удастся удалить фильтр и будет возвращено значение `false`.  
  
 Этот метод реализует <xref:System.Collections.Generic.SynchronizedReadOnlyCollection%601.System%23Collections%23Generic%23ICollection%7BT%7D%23Remove%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.Remove(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="messageFilterTable.Remove filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">Объект <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> для удаления.</param>
        <summary>Удаляет фильтр и сопоставленный ему параметр <paramref name="FilterData" /> из таблицы фильтров.</summary>
        <returns><see langword="true" />, если фильтр был найден и удален; <see langword="false" />, если фильтр не был найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.Collections.Generic.SynchronizedReadOnlyCollection%601.System%23Collections%23Generic%23ICollection%7BT%7D%23Remove%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий итерацию по таблице фильтров.</summary>
        <returns>Перечислитель <see cref="T:System.Collections.Generic.IEnumerator`1" />, который может использоваться для итерации по таблице фильтров.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.Collections.IEnumerable.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (System.ServiceModel.Dispatcher.MessageFilter filter, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(class System.ServiceModel.Dispatcher.MessageFilter filter, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.MessageFilterTable`1.TryGetValue(System.ServiceModel.Dispatcher.MessageFilter,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (filter As MessageFilter, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(System::ServiceModel::Dispatcher::MessageFilter ^ filter, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; bool&#xA;override this.TryGetValue : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; bool" Usage="messageFilterTable.TryGetValue (filter, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">Параметр <paramref name="filter" />, используемый в качестве ключа для извлечения данных.</param>
        <param name="data">Объект <paramref name="data" />, связанный с объектом <paramref name="filter" />.</param>
        <summary>Проверяет, хранится ли фильтр в таблице фильтров.</summary>
        <returns><see langword="true" />, если в таблице фильтров есть фильтр, содержащий связанные с ним данные; в ином случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является эффективным способом проверки наличия фильтра в таблице фильтров, поскольку если фильтр не присутствует в таблице, то он выдает значение `false`, а не вызывает исключение. При попытке извлечь фильтр из таблицы фильтров, если он там не был найден, то генерируется исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TFilterData&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.MessageFilterTable`1.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ Values { System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'FilterData&gt;" Usage="System.ServiceModel.Dispatcher.MessageFilterTable&lt;'FilterData&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TFilterData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию всех параметров <paramref name="FilterData" />, содержащихся в таблице фильтров.</summary>
        <value>Коллекция <see cref="T:System.Collections.Generic.ICollection`1" /> всех параметров <paramref name="FilterData" />, содержащихся в таблице фильтров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство реализует свойство <xref:System.Collections.Generic.IDictionary%602.Values%2A>. Словарь <xref:System.Collections.Generic.IDictionary%602><Filter, `FilterData`>, который реализует таблица фильтров, использует <xref:System.ServiceModel.Dispatcher.MessageFilter> в качестве ключа, а параметр `FilterData` — в качестве значения пары.  
  
 Порядок возвращаемых в коллекции параметров `FilterData` не указан, но он будет точно таким же, как и порядок соответствующих фильтров в коллекции, возвращаемой свойством <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.Keys%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
