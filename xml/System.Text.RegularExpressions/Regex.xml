<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c08141570b114082146d0cd7184fc89c6417b48" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70521145" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет постоянное регулярное выражение.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс представляет обработчик регулярных выражений .NET Framework. Его можно использовать для быстрого анализа больших объемов текста, чтобы найти определенные шаблоны символов. для извлечения, изменения, замены или удаления текстовых подстрок; и, чтобы добавить извлеченные строки в коллекцию для создания отчета.  
  
> [!NOTE]
>  Если основным интересом является проверка строки путем определения того, соответствует ли она определенному шаблону, можно использовать <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> класс.  
  
 Чтобы использовать регулярные выражения, необходимо определить шаблон, который необходимо определить в текстовом потоке, с помощью синтаксиса, описанного в статье [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Затем при необходимости можно создать <xref:System.Text.RegularExpressions.Regex> объект. Наконец, вызывается метод, который выполняет некоторую операцию, например замену текста, совпадающего с шаблоном регулярного выражения, или определение соответствия шаблону.  
  
> [!NOTE]
>  Некоторые распространенные шаблоны регулярных выражений см. в разделе [примеры регулярных выражений](~/docs/standard/base-types/regular-expression-examples.md). Существует также ряд Интернет-библиотек шаблонов регулярных выражений, например, один из них на [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a>Дополнительные сведения об использовании <xref:System.Text.RegularExpressions.Regex> класса см. в следующих разделах этой статьи:  
  
-   [Сравнение регулярных выражений и строковых методов](#regex_vs_string)  
  
-   [Статические и экземпляры методы](#static_vs_instance)  
  
-   [Выполнение операций с регулярными выражениями](#regex_ops)  
  
-   [Определение значения времени ожидания](#define_timeout)  
  
 Дополнительные сведения о языке регулярных выражений см. в [кратком справочнике по элементам языка регулярных выражений](~/docs/standard/base-types/regular-expression-language-quick-reference.md) или в одной из следующих брошюр, который вы можете скачать и распечатать:  
  
 [Краткий справочник в формате Word (DOCX)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx);  
 [Краткий справочник в формате PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf).  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Сравнение регулярных выражений и строковых методов  
 <xref:System.String?displayProperty=nameWithType> Класс включает несколько методов поиска и сравнения, которые можно использовать для выполнения сопоставления шаблонов с текстом. <xref:System.String.Contains%2A?displayProperty=nameWithType>Например, методы, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> определяют, содержит ли экземпляр строки указанную подстроку, а также <xref:System.String.IndexOf%2A?displayProperty=nameWithType>методы, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>и <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> возвращают начальную расположение указанной подстроки в строке. При поиске определенной строки используйте <xref:System.String?displayProperty=nameWithType> методы класса. <xref:System.Text.RegularExpressions.Regex> Используйте класс при поиске определенного шаблона в строке. Дополнительные сведения и примеры см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md).  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Статические и экземпляры методы  
 После определения шаблона регулярного выражения его можно предоставить обработчику регулярных выражений одним из двух способов:  
  
-   Путем создания экземпляра <xref:System.Text.RegularExpressions.Regex> объекта, представляющего регулярное выражение. Для этого необходимо передать шаблон <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> регулярного выражения конструктору. Объект является неизменяемым; при создании экземпляра <xref:System.Text.RegularExpressions.Regex> объекта с регулярным выражением регулярное выражение этого объекта не может быть изменено. <xref:System.Text.RegularExpressions.Regex>  
  
-   Указав как регулярное выражение, так и текст для поиска `static` в методе (`Shared` в Visual Basic). <xref:System.Text.RegularExpressions.Regex> Это позволяет использовать регулярное выражение без явного создания <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 Все <xref:System.Text.RegularExpressions.Regex> методы идентификации шаблонов включают как статические, так и перегрузки экземпляров.  
  
 Обработчик регулярных выражений должен компилировать определенный шаблон, прежде чем можно будет использовать шаблон. Поскольку <xref:System.Text.RegularExpressions.Regex> объекты являются неизменяемыми, это одноразовая процедура, возникающая <xref:System.Text.RegularExpressions.Regex> при вызове конструктора класса или статического метода. Чтобы исключить необходимость повторной компиляции одного регулярного выражения, обработчик регулярных выражений кэширует скомпилированные регулярные выражения, используемые в вызовах статических методов. В результате методы сопоставления регулярных выражений обеспечивают сравнимую производительность для статических методов и экземпляров.  
  
> [!IMPORTANT]
>  В .NET Framework версиях 1,0 и 1,1 все скомпилированные регулярные выражения, которые были использованы в вызовах экземпляров или статических методов, были кэшированы. Начиная с .NET Framework 2,0, кэшируются только регулярные выражения, используемые в вызовах статических методов.  
  
 Однако кэширование может негативно сказаться на производительности в следующих двух случаях:  
  
-   При использовании вызовов статических методов с большим количеством регулярных выражений. По умолчанию обработчик регулярных выражений кэширует 15 последних использованных статических регулярных выражений. Если в приложении используется более 15 статических регулярных выражений, то необходимо повторно скомпилировать некоторые регулярные выражения. Чтобы предотвратить повторную компиляцию, можно увеличить <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> свойство.  
  
-   При создании экземпляров новых <xref:System.Text.RegularExpressions.Regex> объектов с регулярными выражениями, которые ранее были скомпилированы. Например, следующий код определяет регулярное выражение для поиска повторяющихся слов в текстовом потоке. Хотя в примере используется одно регулярное выражение, он создает новый <xref:System.Text.RegularExpressions.Regex> объект для обработки каждой строки текста. Это приводит к перекомпиляции регулярного выражения при каждой итерации цикла.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Чтобы предотвратить повторную компиляцию, необходимо создать экземпляр одного <xref:System.Text.RegularExpressions.Regex> объекта, доступного для всего кода, который требуется, как показано в следующем примере переписывания.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Выполнение операций с регулярными выражениями  
 Если вы решили создать экземпляр <xref:System.Text.RegularExpressions.Regex> объекта и вызвать его методы или вызвать статические методы <xref:System.Text.RegularExpressions.Regex> , класс предлагает следующие функции сопоставления шаблонов:  
  
-   Проверка соответствия. Чтобы определить, <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> существует ли соответствие, вызовите метод.  
  
-   Извлечение одного совпадения. <xref:System.Text.RegularExpressions.Regex.Match%2A> Метод вызывается для <xref:System.Text.RegularExpressions.Match> получения объекта, представляющего первое совпадение в строке или в части строки. Последующие соответствия можно получить, вызвав <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод.  
  
-   Получение всех совпадений. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод вызывается для <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> получения объекта, который представляет все совпадения, найденные в строке или в части строки.  
  
-   Замена совпадающего текста. Для замены совпадающего текста вызывается <xref:System.Text.RegularExpressions.Regex.Replace%2A> метод. Замещающий текст также может быть определен регулярным выражением. Кроме того, некоторые <xref:System.Text.RegularExpressions.Regex.Replace%2A> методы <xref:System.Text.RegularExpressions.MatchEvaluator> включают параметр, который позволяет программно определять замещающий текст.  
  
-   Создание массива строк, сформированного из частей входной строки. Вызовите <xref:System.Text.RegularExpressions.Regex.Split%2A> метод, чтобы разделить входную строку в позициях, определенных регулярным выражением.  
  
 Помимо методов сопоставления шаблонов, <xref:System.Text.RegularExpressions.Regex> класс включает несколько специальных методов:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Метод переводит все символы, которые могут интерпретироваться как операторы регулярных выражений, в регулярном выражении или входной строке.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод удаляет эти escape-символы.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Метод создает сборку, содержащую предопределенные регулярные выражения. .NET Framework содержит примеры этих специальных сборок в <xref:System.Web.RegularExpressions?displayProperty=nameWithType> пространстве имен.  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Определение значения времени ожидания  
 .NET Framework поддерживает полнофункциональный язык регулярных выражений, обеспечивающий значительную мощность и гибкость при сопоставлении шаблонов. Тем не менее, мощность и гибкость получаются за счет: риск низкой производительности. Регулярные выражения, которые плохо работают, удивительно просты в создании. В некоторых случаях операции с регулярными выражениями, зависящие от избыточного поиска с возвратом, могут перестать отвечать на запросы при обработке текста, который почти соответствует шаблону регулярного выражения. Дополнительные сведения о обработчике регулярных выражений .NET Framework см. в разделе [сведения о поведении регулярных](~/docs/standard/base-types/details-of-regular-expression-behavior.md)выражений. Дополнительные сведения о избыточном поиске с возвратом см. в разделе [Поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], можно определить интервал времени ожидания для совпадений регулярных выражений. Если обработчик регулярных выражений не может найти соответствие в течение этого интервала времени, операция сопоставления создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. В большинстве случаев это не позволяет обработчику регулярных выражений израсходовать вычислительную мощность, пытаясь сопоставить текст, который почти соответствует шаблону регулярного выражения. Это также может означать, что интервал времени ожидания был установлен слишком мал, или что текущая нагрузка компьютера привела к общему снижению производительности.  
  
 Способ, которым обрабатывается исключение, зависит от причины исключения. Если исключение возникает из-за того, что интервал времени ожидания задан слишком мал или из-за чрезмерной загрузки компьютера, можно увеличить интервал времени ожидания и повторить операцию сопоставления. Если исключение возникает из-за того, что регулярное выражение зависит от избыточного поиска с возвратом, можно предположить, что совпадение не существует, и при необходимости можно зарегистрировать сведения, которые помогут изменить шаблон регулярного выражения.  
  
 Можно задать интервал времени ожидания, вызвав <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор при создании экземпляра объекта регулярного выражения. Для статических методов можно задать интервал времени ожидания, вызвав перегрузку соответствующего метода, имеющего `matchTimeout` параметр. Если значение времени ожидания не задано явно, значение времени ожидания по умолчанию определяется следующим образом:  
  
-   С помощью значения времени ожидания приложения, если оно существует. Это может быть любое значение времени ожидания, которое применяется к домену приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается экземпляр объекта, или вызову статического метода. Можно задать значение времени ожидания приложения, вызвав <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод, чтобы присвоить строковое представление <xref:System.TimeSpan> значения свойству "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   С помощью значения <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, если не задано значение времени ожидания для приложения.  
  
> [!IMPORTANT]
>  Рекомендуется устанавливать значение времени ожидания во всех операциях сопоставления шаблона регулярного выражения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 [Вернуться к примечаниям](#remarks)  
  
   
  
## Examples  
 В следующем примере регулярное выражение используется для проверки повторяющихся вхождений слов в строке. Можно интерпретировать регулярное выражение `\b(?<word>\w+)\s+(\k<word>)\b` , как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начать совпадение на границе слова.|  
|`(?<word>\w+)`|Совпадение с одним или несколькими символами слова до границы слова. Назовите эту захваченную группу `word`.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|`(\k<word>)`|Соответствует захваченной группе с именем `word`.|  
|`\b`|Соответствует границе слова.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 В следующем примере показано использование регулярного выражения для проверки того, представляет ли строка значение валюты или имеет правильный формат для представления значения валюты. В этом <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>случае регулярное выражение создается динамически из свойств <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>,, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> для текущего языка и региональных параметров пользователя. Если текущий язык и региональные параметры системы — en-US, результирующее регулярное `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`выражение будет иметь значение. Это регулярное выражение можно интерпретировать, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начните с начала строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`[\+-]?`|Совпадение с нулевым или одним вхождением знака плюс или минус.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\$?`|Совпадение с нулевым или одним вхождением знака доллара.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\d*`|Соответствует нулю или нескольким десятичным числам.|  
|`\.?`|Совпадение с нулем или одним символом десятичной запятой.|  
|`\d{2}?`|Совпадение двух десятичных цифр ноль или один раз.|  
|`(\d*\.?\d{2}?){1}`|Соответствие шаблону целой и дробной цифр, разделенных символом десятичной запятой, по крайней мере один раз.|  
|`$`|Совпадение с концом строки.|  
  
 В этом случае регулярное выражение предполагает, что допустимая строка валюты не содержит символы разделителя групп и что она не содержит дробных разрядов или числа цифр дробной части, определенных <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> свойством текущего языка и региональных параметров.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Так как регулярное выражение в этом примере создается динамически, во время разработки неизвестно, может ли обработчик регулярных выражений интерпретироваться как обычный символ денежной единицы, десятичный знак или положительные и отрицательные знаки. операторы языка выражений. Во избежание невозможности интерпретации в примере каждая динамически формируемая строка <xref:System.Text.RegularExpressions.Regex.Escape%2A> передается в метод.  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" /> Класс является неизменяемым (только для чтения) и потокобезопасным. <see cref="T:System.Text.RegularExpressions.Regex" />объекты могут создаваться в любом потоке и совместно использоваться потоками. Дополнительные сведения см. в статье [безопасность потоков](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Регулярные выражения в .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">Регулярные выражения — краткий справочник (загрузить в формате Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">Регулярные выражения — краткий справочник (загрузить в формате PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что этот конструктор защищен; Он может вызываться только классами, производными <xref:System.Text.RegularExpressions.Regex> от класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для заданного регулярного выражения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 Вызов конструктора эквивалентен <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> вызову <xref:System.Text.RegularExpressions.RegexOptions.None> конструктора со значением для `options` аргумента. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29>  
  
 <xref:System.Text.RegularExpressions.Regex> Объект является неизменяемым. Это означает, что его можно использовать только для шаблона соответствия, который вы определили при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 Этот конструктор создает экземпляр объекта регулярного выражения, который пытается выполнить поиск с учетом регистра любых алфавитных `pattern`символов, определенных в. Для совпадения без учета регистра используйте <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> конструктор.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот конструктор для создания экземпляра регулярного выражения, совпадающего с любым словом, начинающимся с букв "a" или "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Обратите внимание, что шаблон регулярного выражения не может соответствовать слову «the» в начале текста, поскольку при сравнении по умолчанию учитывается регистр. Пример сравнения без учета регистра см. в <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> описании конструктора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию для домена приложения, в котором он создается. Если значение времени ожидания не было определено для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания операции. Для создания <see cref="T:System.Text.RegularExpressions.Regex" /> <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />объекта рекомендуется использовать конструктор, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованный шаблон и сведения <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Целевой объект этой сериализации. (Этот параметр не используется; задайте значение <see langword="null" />.)</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />, используя сериализованные данные.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Шаблон, содержащий <paramref name="info" />, имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> содержит недопустимый флаг <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, изменяющими шаблон.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 <xref:System.Text.RegularExpressions.Regex> Объект является неизменяемым. Это означает, что его можно использовать только для параметров соответствия, которые вы определяете при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот конструктор для создания экземпляра регулярного выражения, совпадающего с любым словом, начинающимся с букв "a" или "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Обратите внимание, что коллекция Match включает слово «The», которое начинается с текста `options` , поскольку параметр определяет сравнение без учета регистра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> содержит недопустимый флаг.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию для домена приложения, в котором он создается. Если значение времени ожидания не было определено для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания операции. Для создания <see cref="T:System.Text.RegularExpressions.Regex" /> <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />объекта рекомендуется использовать конструктор, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, которые изменяют шаблон, и значение, указывающее, как долго метод сравнения с шаблоном должен пытаться найти совпадение, прежде чем время ожидания истечет.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 <xref:System.Text.RegularExpressions.Regex> Объект является неизменяемым. Это означает, что его можно использовать только для шаблона соответствия, который вы определили при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен попытаться найти соответствие до истечения времени ожидания. Если в течение этого интервала времени совпадения не найдены, метод сопоставления шаблонов создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, <xref:System.Text.RegularExpressions.Regex> в котором создается объект. Методы сопоставления шаблона экземпляра, которые последают `matchTimeout` за интервал времени ожидания, включают следующее:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Для установки разумного интервала времени ожидания учитывайте следующие факторы.  
  
-   Длина и сложность шаблона регулярного выражения. Более длинные и более сложные регулярные выражения требуют больше времени, чем более короткие и простые.  
  
-   Ожидаемая загрузка компьютера. Обработка занимает больше времени на системах с высоким уровнем использования ЦП и памяти.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор для создания экземпляра <xref:System.Text.RegularExpressions.Regex> объекта со значением времени ожидания, равным одной секунде. Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> При возникновении исключения в примере значение времени ожидания увеличивается до максимального значения, равного трем секундам. В противном случае он отказывается от попытки сопоставить шаблон.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- или - 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество записей в текущей статической кэш-памяти скомпилированных регулярных выражений.</summary>
        <value>Максимальное количество записей в статической кэш-памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс поддерживает внутренний кэш скомпилированных регулярных выражений, используемых в вызовах статических методов. Если значение, указанное в операции задания, меньше текущего размера кэша, записи кэша отбрасываются, пока размер кэша не станет равным указанному значению.  
  
 По умолчанию кэш содержит 15 скомпилированных статических регулярных выражений. Обычно приложению не нужно изменять размер кэша. <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> Свойство следует использовать только в том случае, если требуется отключить кэширование или если имеется необычно большой кэш.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.</exception>
        <block subset="none" type="usage"><para>В .NET Framework до [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]версии регулярные выражения, используемые в статических вызовах и методах экземпляра, были кэшированы. Начиная с [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], кэшируются только регулярные выражения, используемые в вызовах статических методов.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; доступ к нему можно получить только из класса, производного <xref:System.Text.RegularExpressions.Regex> от класса.  
  
 Операция задания пытается преобразовать значение, присвоенное свойству <xref:System.Collections.Hashtable> объекту; если это преобразование завершается неудачно, <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> вызывается конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; доступ к нему можно получить только из класса, производного <xref:System.Text.RegularExpressions.Regex> от класса.  
  
 Операция задания пытается преобразовать значение, присвоенное свойству <xref:System.Collections.Hashtable> объекту; если это преобразование завершается неудачно, <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> вызывается конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Компилирует регулярные выражения и сохраняет их на диск в единой сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

В .NET Core вызовы `Regex.CompileToAssembly` метода вызывают исключение a; запись сборки в <xref:System.PlatformNotSupportedException>сборку не поддерживается.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод создает сборку .NET Framework, в которой каждое регулярное выражение, определенное `regexinfos` в массиве, представлено классом. <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Как правило, <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> метод вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` параметрами и `name` соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем Режекслиб. dll. Сборка включает два скомпилированных регулярных выражения. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует двум одинаковым смежным словам. Во-вторых `Utilities.RegularExpressions.EmailAddress`, проверяет, имеет ли строка правильный формат для адреса электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 После этого регулярное выражение, которое проверяет строку на наличие повторяющихся слов, создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции второго примера требуется ссылка на Режекслиб. dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  
  
- или - 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="assemblyname" /> или <paramref name="regexinfos" /> — <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, на [!INCLUDE[net_v45](~/includes/net-v45-md.md)] которой установлен или ее пункт выпуски [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], вы используете <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , а метод используется для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, которая [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе, в которой [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] установлены вместо более поздних версий.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте статические методы или метод экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметром при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызове регулярного выражения. метод сопоставления шаблонов.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод создает сборку .NET Framework, в которой каждое регулярное выражение, определенное `regexinfos` в массиве, представлено классом. <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Как правило, <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> метод вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` параметрами и `name` соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
 Поскольку метод создает .NET Framework сборку из вызова метода вместо использования ключевого слова определения класса определенного языка (например, `class` в C# или `Class`... <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>`End Class` в Visual Basic) он не позволяет назначать атрибуты .NET Framework сборке с помощью стандартного синтаксиса атрибутов языка разработки. `attributes` Параметр предоставляет альтернативный метод для определения атрибутов, применяемых к сборке. Для каждого атрибута, который необходимо применить к сборке, выполните следующие действия.  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который необходимо вызвать.  
  
2.  <xref:System.Type> Получите объект, представляющий класс атрибута, который необходимо применить к новой сборке.  
  
3.  Вызовите <xref:System.Type> метод объекта Attribute, чтобы получить <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который требуется вызвать. <xref:System.Type.GetConstructor%2A> Передайте <xref:System.Type> метод массив объектов, представляющий типы параметров конструктора. <xref:System.Type.GetConstructor%2A>  
  
4.  <xref:System.Object> Создайте массив, определяющий параметры для передачи в конструктор атрибута.  
  
5.  Создайте экземпляр <xref:System.Reflection.ConstructorInfo> объекта, передав конструктору объект, полученный на шаге 3, и <xref:System.Object> массив, созданный на шаге 4. <xref:System.Reflection.Emit.CustomAttributeBuilder>  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо `attributes` параметра в <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем режекслиб. dll и к ней <xref:System.Reflection.AssemblyTitleAttribute> применяется атрибут. Сборка включает два скомпилированных регулярных выражения. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует двум одинаковым смежным словам. Во-вторых `Utilities.RegularExpressions.EmailAddress`, проверяет, имеет ли строка правильный формат для адреса электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Можно проверить, <xref:System.Reflection.AssemblyTitleAttribute> применен ли атрибут к сборке, проверив его манифест с помощью программы отражения, такой как Ildasm.  
  
 После этого регулярное выражение, которое проверяет строку на наличие повторяющихся слов, создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции второго примера требуется ссылка на Режекслиб. dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, на [!INCLUDE[net_v45](~/includes/net-v45-md.md)] которой установлен или ее пункт выпуски [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], вы используете <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , а метод используется для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, которая [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе, в которой [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] установлены вместо более поздних версий.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте статические методы или метод экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметром при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызове регулярного выражения. метод сопоставления шаблонов.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <param name="resourceFile">Имя файла ресурса Win32 для включения в сборку.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> и указанный файл ресурсов в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод [\], AssemblyName, кустоматтрибутебуилдер\<XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. режекскомпилатионинфо% 5b% 5D% 2CSystem. Reflection. имя_сборки% 2CSystem. Reflection. Emit. кустоматтрибутебуилдер% 5b% 5D% 2CSystem. String% 29 > создает сборку .NET Framework, в которой каждое `regexinfos` регулярное выражение, определенное в массиве, представлено классом. Как правило, метод\][, AssemblyName,\<кустоматтрибутебуилдер XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. режекскомпилатионинфо% 5b% 5D% 2CSystem. Reflection. имя_сборки% 2CSystem. Reflection. Emit. кустоматтрибутебуилдер% 5b% 5D% 2CSystem. String% 29 > вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` параметрами и `name` соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
 Поскольку метод создает .NET Framework сборку из вызова метода вместо использования ключевого слова определения класса определенного языка (например, `class` в C# или `Class`... <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>`End Class` в Visual Basic) он не позволяет назначать атрибуты .NET Framework сборке с помощью стандартного синтаксиса атрибутов языка разработки. `attributes` Параметр предоставляет альтернативный метод для определения атрибутов, применяемых к сборке. Для каждого атрибута, который необходимо применить к сборке, выполните следующие действия.  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который необходимо вызвать.  
  
2.  <xref:System.Type> Получите объект, представляющий класс атрибута, который необходимо применить к новой сборке.  
  
3.  Вызовите <xref:System.Type> метод объекта Attribute, чтобы получить <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который требуется вызвать. <xref:System.Type.GetConstructor%2A> Передайте <xref:System.Type> метод массив объектов, представляющий типы параметров конструктора. <xref:System.Type.GetConstructor%2A>  
  
4.  <xref:System.Object> Создайте массив, определяющий параметры для передачи в конструктор атрибута.  
  
5.  Создайте экземпляр <xref:System.Reflection.ConstructorInfo> объекта, передав конструктору объект, полученный на шаге 3, и <xref:System.Object> массив, созданный на шаге 4. <xref:System.Reflection.Emit.CustomAttributeBuilder>  
  
 Затем можно <xref:System.Reflection.Emit.CustomAttributeBuilder> передать массив этих объектов вместо `attributes` параметра в [\], AssemblyName, кустоматтрибутебуилдер\<XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. режекскомпилатионинфо% 5b% 5D% 2CSystem. Reflection. имя_сборки% 2CSystem. Reflection. Emit. кустоматтрибутебуилдер% 5b% 5D% 2CSystem. String% 29 >.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <see cref="P:System.Reflection.AssemblyName.Name" /> параметра <paramref name="assemblyname" /> является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Параметр <paramref name="resourceFile" /> назначает недопустимый файл ресурсов Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="resourceFile" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, на [!INCLUDE[net_v45](~/includes/net-v45-md.md)] которой установлен или ее пункт выпуски [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], вы используете <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> , а метод используется для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, которая [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе, в которой [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] установлены вместо более поздних версий.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте статические методы или метод экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметром при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызове регулярного выражения. метод сопоставления шаблонов.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая преобразуемый текст.</param>
        <summary>Преобразует минимальный набор символов (\\, *, +, ?, |, {, [, (,), ^, $,., # и пробел), заменяя их escape-кодами. При этом обработчику регулярных выражений дается команда интерпретировать эти символы буквально, а не как метасимволы.</summary>
        <returns>Строка символов с метасимволами, приведенными в преобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A>Преобразует строку, чтобы обработчик регулярных выражений мог интерпретировать все метасимволы, которые он может содержать как символьные литералы. Например, рассмотрим регулярное выражение, которое предназначено для извлечения комментариев, разделенных прямыми открывающими и закрывающими квадратными скобками ([и]) из текста. В следующем примере регулярное выражение "[(. *?)]" интерпретируется как класс символов. Вместо того, чтобы сопоставлять комментарии, внедренные во входной текст, регулярное выражение соответствует каждой открывающей или закрывающей круглой скобке, точке, звездочке или вопросительному знаку.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Однако если открывающая квадратная скобка передается <xref:System.Text.RegularExpressions.Regex.Escape%2A> в метод, то регулярное выражение завершается с совпадающими комментариями, внедренными во входную строку. Это показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 В регулярном выражении, которое определено с помощью статического текста, символы, которые должны интерпретироваться буквально, а не как метасимволы, могут быть экранированы перед ними с помощью символа\\обратной косой черты () <xref:System.Text.RegularExpressions.Regex.Escape%2A> , а также путем вызова метода. В регулярном выражении, которое определяется динамически с помощью символов, неизвестных во время разработки, вызов <xref:System.Text.RegularExpressions.Regex.Escape%2A> метода особенно важен, чтобы механизм регулярных выражений интерпретирует отдельные символы как литералы, а не чем метасимволы.  
  
> [!NOTE]
>  Если шаблон регулярного выражения содержит либо символ решетки (#), либо символы-разделители, они должны быть экранированы, если входной текст анализируется с <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> включенным параметром.  
  
 Хотя <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод экранирует прямой Открытие квадратная скобка ([) и открыв скобки ({}), он не экранирует их соответствующий закрывающий символов (] и}). В большинстве случаев их экранирование не требуется. Если закрывающей квадратной скобке или фигурной скобке не предшествует соответствующий открывающий символ, обработчик регулярных выражений интерпретирует его буквально. Если открывающая квадратная скобка или фигурная скобка интерпретируется как метасимвол, обработчик регулярных выражений интерпретирует первый соответствующий закрывающий символ как метасимвол. Если это не требуемое поведение, закрывающую квадратную скобку или фигурную скобку следует заключать в escape\\-последовательность, явно добавив символ обратной косой черты (). Иллюстрации см. в разделе "пример".  
  
   
  
## Examples  
 В следующем примере из текста извлекаются комментарии. Предполагается, что комментарии разделяются символом начала комментария и символом конца комментария, выбранным пользователем. Поскольку символы комментария должны интерпретироваться буквально, они передаются <xref:System.Text.RegularExpressions.Regex.Escape%2A> в метод, чтобы убедиться, что они не могут быть правильно интерпретированы как метасимволы. Кроме того, в примере явно проверяется, является ли введенный пользователем символ завершающего комментария закрывающей квадратной скобкой (]) или фигурной скобкой (}). Если это так, то символ обратной\\косой черты () добавляется в начало квадратной скобки или скобки, чтобы интерпретироваться буквально. Обратите внимание, что в примере <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> также используется коллекция для вывода только комментария, а не комментария вместе с его открывающими и закрывающими символами комментария.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Escape-знаки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Этот член переопределяет <see cref="M:System.Object.Finalize" />; по данной теме может быть доступна более полная документация.

Позволяет объекту <see cref="T:System.Object" /> попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как объект <see cref="T:System.Object" /> будет утилизирован в процессе сборки мусора.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив имен группы записи для регулярного выражения.</summary>
        <returns>Строковый массив имен группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Коллекция имен групп содержит набор строк, используемых для именования захваченных групп в выражении. Даже если группы записи не называются явно, им автоматически присваиваются числовые имена ("0", "1", "2", "3" и т. д.). Именованная группа "0" представляет весь текст, соответствующий шаблону регулярного выражения. Нумерованные группы предшествуют явно именованным группам в коллекции, а именованные группы отображаются в том порядке, в котором они определены в шаблоне регулярного выражения.  
  
 Для определения количества групп <xref:System.Array.Length%2A> в регулярном выражении можно использовать свойство в массиве, возвращаемом этим методом.  
  
   
  
## Examples  
 В следующем примере определяется метод общего назначения `ShowMatches` , который отображает имена групп регулярных выражений и соответствующих им текста.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 В этом случае шаблон `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` регулярного выражения предназначен для анализа простого предложения, а также для обнаружения его первого слова, последнего слова и конца знака препинания. В следующей таблице показано, как интерпретируется шаблон регулярного выражения:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<FirstWord>\w+)`|Совпадение с одним или несколькими символами слова. `FirstWord` Это именованная группа.|  
|оформляет?|Совпадение с нулем или одним символом пробела.|  
|(\w+)|Совпадение с одним или несколькими символами слова. Это вторая группа записи.|  
|\s|Соответствует пробелу.|  
|((\w +) \s) *|Совпадение с нулем или несколькими вхождениями одного или нескольких символов слова, за которыми следует пробел. Это первая группа записи.|  
|(? \<Ластворд > \w +)?|Совпадение с нулевым или одним вхождением одного или нескольких символов слов. `LastWord` Это именованная группа.|  
|(? \<Пунктуация > \п{по})|Совпадение с символом, категорией Юникода которой является знак препинания, другой. `Punctuation` Это именованная группа.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив номеров групп записи, что соответствует именам групп в массиве.</summary>
        <returns>Целочисленный массив номеров групп.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Доступ к группам захвата без имени и именованной группы можно получить по числу. Неименованные группы нумеруются слева направо, начиная с 1. (Группа записи в индексе 0 (ноль) представляет совпадение как целое.)  Затем именованные группы нумеруются слева направо, начиная с числа, которое больше числа неименованных групп записи.  
  
 Ссылка на группу по ее номеру, а не по имени строки, может обеспечить более быстрый доступ.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\b((?<word>\w+)\s*)+(?<end>[.?!])`, которое соответствует предложению. Регулярное выражение включает три группы записи: неименованную группу, в которой захватывается отдельное слово, а также символ пробела, который может следовать за ним. Группа с именем `word` , которая фиксирует отдельные слова в предложении и группу с именем `end` , которая захватывает знаки пунктуации, завершающие предложение. В примере вызывается <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> метод для получения числа всех захваченных групп, а затем отображается захваченная строка. Кроме того, <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод используется для указания, соответствует ли определенная нумерованная группа именованной группе.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<word>\w+)`|Совпадение с одним или несколькими символами слов и присвоение совпадающих строк группе `word`с именем.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`((?<word>\w+)\s*)`|`word` Назначьте захваченную группу, за которой следуют все захваченные символы пробела, в первую захваченную группу.|  
|`((?<word>\w+)\s*)+`|Совпадение с шаблоном одного или нескольких символов слов, за которыми следует любой символ пробела, один или несколько раз.|  
|`(?<end>[.?!])`|Совпадение с точкой, вопросительным знаком или восклицательным знаком. Назначьте сопоставленный символ `end` захваченной группе.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Номер группы для преобразования в соответствующее имя группы.</param>
        <summary>Получает имя группы, соответствующее указанному номеру группы.</summary>
        <returns>Строка, содержащая имя группы, связанное с указанным номером группы. При отсутствии имени группы, соответствующей параметру <paramref name="i" />, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные группы записи, которые выделяют части выражения в соответствии с шаблоном. Нумерованные группы разделяются синтаксисом (*часть выражения*) и присваиваются числа на основе их порядка в регулярном выражении. Именованные группы разделяются синтаксисом (?`<` *имя* часть выражения) или (?) ** `>` *Name*"*часть выражения*", где *Name* — имя, по которому будет идентифицирована часть выражения. (Дополнительные сведения см. в разделе [конструкции группирования](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Метод определяет как именованные группы, так и нумерованные группы по их порядковым позициям в регулярном выражении. Нулевое значение порядкового номера всегда представляет собой полное регулярное выражение. Затем все пронумерованные группы подсчитываются до именованных групп, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `i` — номер именованной группы, метод возвращает имя группы. Если `i` — номер неименованной группы, метод возвращает строковое представление числа. Например, если `i` значение равно 1, метод возвращает «1». Если `i` не является числом захваченной группы, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>значение.  
  
 Если найдено соответствие шаблону, то значение, возвращаемое этим методом, можно затем использовать для получения <xref:System.Text.RegularExpressions.Group> объекта, который представляет захваченную группу <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> из свойства. <xref:System.Text.RegularExpressions.GroupCollection> Объект возвращается <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>  свойством.  
  
   
  
## Examples  
 В следующем примере определяется шаблон регулярного выражения, который соответствует строке адреса, содержащей название города США, имя штата и почтовый индекс. В примере используется <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод для получения имен захваченных групп. Затем эти имена используются для получения соответствующих захваченных групп для совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Совпадение с одним или несколькими символами алфавита или пробелами. Присвоить этой захваченной `city`группе имя.|  
|`,`|Совпадение с запятой (,), за которым следует пробельный символ.|  
|`(?<state>[A-Za-z]{2})`|Совпадение с двумя алфавитными символами. Присвоить этой захваченной `state`группе имя. За этой группой должен следовать символ пробела.|  
|`(?<zip>\d{5}(-\d{4})?)`|Совпадение с пятью числовыми цифрами, за которыми следует ноль или одно вхождение дефиса, за которым следуют четыре цифры. Присвоить этой захваченной `zip`группе имя.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя группы для преобразования в соответствующий номер группы.</param>
        <summary>Возвращает номер группы, соответствующий указанному имени группы.</summary>
        <returns>Номер группы, соответствующий указанному имени группы, или -1, если <paramref name="name" /> является недопустимым именем группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные группы записи, которые выделяют части выражения в соответствии с шаблоном. Нумерованные группы разделяются синтаксисом (*часть выражения*) и присваиваются числа на основе их порядка в регулярном выражении. Именованные группы разделяются синтаксисом (?`<` *имя* часть выражения) или (?) ** `>` *Name*"*часть выражения*", где *Name* — имя, по которому будет идентифицирована часть выражения. (Дополнительные сведения см. в разделе [конструкции группирования](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Метод определяет как именованные группы, так и нумерованные группы по их порядковым позициям в регулярном выражении. Нулевое значение порядкового номера всегда представляет собой полное регулярное выражение. Затем все пронумерованные группы подсчитываются до именованных групп, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `name` является строковым представлением номера группы, присутствующего в шаблоне регулярного выражения, метод возвращает это число. Если `name` соответствует именованной группе записи, представленной в шаблоне регулярного выражения, метод возвращает соответствующее ему число. `name` При сравнении с именем группы учитывается регистр. Если `name` не соответствует имени захваченной группы или строковому представлению номера группы записи, метод возвращает значение-1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для операции сравнения с шаблоном не используется конечное время ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор класса и ряд статических методов сопоставления <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> используют константу, чтобы указать, что попытка найти соответствие шаблону не должна истекает. <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
> [!WARNING]
>  Установка значения времени ожидания для <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> обработчика регулярных выражений может привести к тому, что регулярные выражения, зависящие от избыточного поиска с возвратом, перестают отвечать на запросы при обработке текста, который почти соответствует шаблону регулярного выражения. При отключении времени ожидания следует убедиться, что регулярное выражение не зависит от избыточного поиска с возвратом и обрабатывает текст, который почти соответствует шаблону регулярного выражения.  
>   
>  Дополнительные сведения об обработке поиска с возвратом см. в разделе Поиск с [возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Константу можно передать в качестве значения `matchTimeout` аргумента следующих членов: <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ссылки уже инициализированы.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Максимальное время, которое может пройти в операции сравнения с шаблоном перед истечением срока ожидания операции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает на то, обнаруживает ли регулярное выражение соответствие во входной строке.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызовите метод или.  
  
 Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> метода для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Расположение символа, с которого необходимо начать поиск.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие (начинающееся с указанной позиции в этой строке) регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызовите метод или.  
  
 Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> метода для определения, является ли строка допустимым номером части. Он ищет номер части, следующий за двоеточием (:) символ в строке. Метод используется для определения позиции символа двоеточия, который затем передается <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> в метод. <xref:System.String.IndexOf%28System.Char%29> Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызовите метод или.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> заданным методом `pattern` , и вызовом метода экземпляра. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одиночной буквой`a` ( `z` от `A` или `Z`до) или цифровым символом.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр<paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для проверки соответствия <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, используя указанные параметры сопоставления.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызовите метод или.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданным параметром `pattern` , и параметрами <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> регулярного выражения, `options` заданными и вызывающими экземпляром. Method. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов метода с параметром, имеющим значение <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , эквивалентен определению следующего регулярного выражения: `options` <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения см. пример для <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для проверки соответствия <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, с помощью указанных параметров сопоставления и интервала времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции <xref:System.Text.RegularExpressions.Regex.Match%2A> , <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызовите метод или.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданным параметром `pattern` , и параметрами <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> регулярного выражения, `options` заданными и вызывающими экземпляром. Method. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метода для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ. Сопоставление шаблона регулярного выражения должно производиться с минимальным поиском во входной строке, поэтому метод устанавливает интервал времени ожидания 500 миллисекунд.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным `Z`символом от `A` до или любого числового символа.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов метода с параметром, имеющим значение <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , эквивалентен определению следующего регулярного выражения: `options` <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения см. пример для <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- или - 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит во входной строке подстроку, совпадающую с шаблоном регулярного выражения, и возвращает первое вхождение в качестве единого объекта <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке первое вхождение регулярного выражения, указанного в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод возвращенного объекта. Можно также получить все совпадения в одном вызове метода, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метод.  
  
 Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере выполняется поиск совпадений шаблона регулярного выражения в строке, а затем выводятся соответствующие группы, записи и позиции записи.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Шаблон `(\w+)\s+(car)` регулярного выражения сопоставляет вхождения слова «автомобиль» и предшествующее ему слово. Он интерпретируется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|автомобиле|Совпадение со строкой литерала "Car". Это вторая группа записи.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Отсчитываемая от нуля позиция символа, с которой начинается поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения, начиная с позиции символа во входной строке или после нее  `startat` . <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> выполняется поиск метода, определяется вызовом одного <xref:System.Text.RegularExpressions.Regex> из конструкторов класса. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 При необходимости можно указать начальную точку в строке с помощью `startat` параметра. Когда обработчик регулярных выражений выполняет синтаксический анализ слева направо (по умолчанию), сопоставление и просмотр перемещаются правее, начиная с символа, `startat`указанного в. Когда обработчик регулярных выражений выполняет синтаксический анализ справа налево (когда шаблон регулярного выражения создается с <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> параметром), сопоставление и сканирование перемещаются в обратном направлении и начинаются с `startat` символа, который начинается с 1. Если не указать начальную точку, поиск начинается с позиции по умолчанию `startat` . Если регулярное выражение выполняет поиск слева направо, то положением `startat` по умолчанию является левый `input`конец; при поиске справа налево значение по умолчанию `startat` — справа `input`.  
  
 Если необходимо ограничить совпадение, чтобы оно начиналось с определенной позиции символа в строке, а обработчик регулярных выражений не проверит оставшуюся часть строки на соответствие, закрепите регулярное выражение с помощью `\G` (слева для слева направо). узор или справа для шаблона с письмом справа налево). Это ограничит соответствие, поэтому оно должно начинаться именно в `startat`.  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в или `startat` после позиции символа `input` в, совпадающей с шаблоном регулярного выражения. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод возвращенного объекта. Можно также получить все совпадения в одном вызове метода, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> метод.  
  
 Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке первое вхождение заданного регулярного выражения.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> . В этом случае обработчик регулярных выражений кэширует шаблон регулярного выражения.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод возвращенного объекта. Можно также получить все совпадения в одном вызове метода, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метод вызывается для поиска первого слова, содержащего хотя бы один `z` символ <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> , а затем вызывает метод для поиска дополнительных совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b\w*z+\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`z+`|Совпадение с `z` одним или несколькими вхождениями символа.|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для получения соответствия <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="beginning">Отсчитываемая от нуля позиция символа во входной строке, определяющая самую левую позицию диапазона поиска.</param>
        <param name="length">Количество символов в подстроке для включения в поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции и выполняя поиск только по указанному количеству символов.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения в части входной строки. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> выполняется поиск метода, определяется вызовом одного <xref:System.Text.RegularExpressions.Regex> из конструкторов класса. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод ищет `beginning` часть, определенную параметрами и `length` для шаблона регулярного выражения. `input` <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> `beginning`всегда определяет индекс крайнего левого символа, включаемого в поиск, и `length` определяет максимальное число символов для поиска. Вместе они определяют диапазон поиска. Если поиск продолжается слева направо (по умолчанию), обработчик регулярных выражений выполняет поиск `beginning` символа по индексу в позиции с индексом `beginning`  +  `length` -1. Если экземпляр обработчика регулярных выражений был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> параметра, чтобы поиск осуществлялся справа налево, обработчик регулярных выражений ищет из символа в индексе `beginning`  +  `length` -1 значение символ по индексу `beginning`. Этот метод возвращает первое совпадение, найденное в этом диапазоне. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод возвращенного объекта.  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать значение времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр<paramref name="beginning" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  
  
- или - 
 Параметр <paramref name="length" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  
  
-или- 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> определяет позицию, которая находится вне диапазона <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с помощью <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктора и вызову метода экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> .  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод возвращенного объекта. Можно также получить все совпадения в одном вызове метода, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, которое соответствует словам, начинающимся с буквы "a". Он использует <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> параметр, чтобы гарантировать, что регулярное выражение находит слова, начинающиеся с прописной буквы "a" и строчной буквы "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Возможные интерпретации шаблона регулярного выражения `\ba\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`a`|Совпадение с символом "a".|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для получения соответствия <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Метод возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с помощью <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктора и вызову метода экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> .  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, найден ли шаблон регулярного выражения во входной строке, проверив значение <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Group.Success%2A> свойства возвращенного объекта. Если найдено совпадение, <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство возвращаемого объекта `input` содержит подстроку, соответствующую шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить, повторно вызвав <xref:System.Text.RegularExpressions.Match> <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод возвращенного объекта. Можно также получить все совпадения в одном вызове метода, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" /> .  
  
- или - 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ищет во входной строке все вхождения регулярного выражения и возвращает все соответствия.</summary>
        <block subset="none" type="usage"><para>При повторении попытки сопоставления путем вызова <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> метода обработчик регулярных выражений выдает пустое соответствие. Обычно обработчик регулярных выражений начинает поиск следующего совпадения в том месте, где было слева предыдущее совпадение. Однако после пустого совпадения обработчик регулярных выражений перемещается на один символ перед попыткой следующего совпадения. Такое поведение гарантирует, что обработчик регулярных выражений будет проходить через строку. В противном случае, поскольку пустое соответствие не приводит к перемещению вперед, следующее совпадение будет начинаться точно так же, как и предыдущее совпадение, и при этом одна и та же пустая строка будет сопоставлена повторно.  
  
В следующем примере шаблон регулярного выражения <c>а *</c> ищет ноль или более вхождений буквы "a" в строке "абаабб". Как видно из выходных данных примера, полученный <see cref="T:System.Text.RegularExpressions.MatchCollection" /> объект содержит шесть <see cref="T:System.Text.RegularExpressions.Match" /> объектов. Первая попыток соответствия находит первый "a". Второе совпадение начинается точно там, где заканчивается первое соответствие, перед первым b; Он находит нулевые вхождения "a" и возвращает пустую строку. Третье соответствие не начинается точно там, где заканчивается второе соответствие, поскольку второе совпадение вернуло пустую строку. Вместо этого он начинается с одного символа позже, после первого "b". Третье совпадение находит два вхождения "a" и возвращает "AA". Четвертая попыток соответствия начинается с того места, где заканчивается третье соответствие, перед вторым "b" и возвращает пустую строку. В пятой попытке сопоставления один символ передается, чтобы он начинался перед третьим "b", и возвращает пустую строку. Шестое совпадение начинается после последней "b" и снова возвращает пустую строку.  
  
[! код-CSharp[System. Text. RegularExpressions. Regex. соответствует # 9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! код-VB[System. Text. RegularExpressions. Regex. соответствует # 9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод аналогичен <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> методу, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Коллекция включает только соответствия и завершается в первом несовпадении.  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> выполняется поиск метода, определяется вызовом одного <xref:System.Text.RegularExpressions.Regex> из конструкторов класса. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод использует отложенное вычисление для заполнения возвращаемого <xref:System.Text.RegularExpressions.MatchCollection> объекта. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Доступ к членам этой коллекции, <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> например и, <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, `foreach` например C# в `For Each`и...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метода не <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> вызывает исключение. Однако исключение возникает при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объектом, возвращаемым этим методом, <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> если свойство не равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , а операция сопоставления превышает интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метод используется для обнаружения слов в предложении, заканчивающемся на «ES».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Позиция символа во входной строке, с которой необходимо начать поиск.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод аналогичен <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> методу, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> выполняется поиск метода, определяется вызовом одного <xref:System.Text.RegularExpressions.Regex> из конструкторов класса. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод использует отложенное вычисление для заполнения возвращаемого <xref:System.Text.RegularExpressions.MatchCollection> объекта. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Доступ к членам этой коллекции, <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> например и, <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, `foreach` например C# в `For Each`и...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метода не <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> вызывает исключение. Однако исключение возникает при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объектом, возвращаемым этим методом, <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> если свойство не равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> , а операция сопоставления превышает интервал времени ожидания. 
  
   
  
## Examples  
 В следующем примере <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод используется для поиска первого слова в предложении, которое заканчивается на "ES", а затем <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> вызывает метод для определения любых дополнительных слов, заканчивающихся на "ES".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод аналогичен <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> методу, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Matches`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод использует отложенное вычисление для заполнения возвращаемого <xref:System.Text.RegularExpressions.MatchCollection> объекта. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Доступ к членам этой коллекции, <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> например и, <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, `foreach` например C# в `For Each`и...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метода не <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> вызывает исключение. Однако исключение возникает при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объектом, возвращаемым этим методом, если интервал времени ожидания определяется свойством "REGEX_DEFAULT_MATCH_TIMEOUT" текущего домена приложения и соответствующей операцией. превышает этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод используется для обнаружения любого слова в предложении, которое заканчивается на "ES".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для получения нескольких совпадений <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблонов рекомендуется использовать статический метод, который позволяет указать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод аналогичен <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> методу, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Matches`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод использует отложенное вычисление для заполнения возвращаемого <xref:System.Text.RegularExpressions.MatchCollection> объекта. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Доступ к членам этой коллекции, <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> например и, <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, `foreach` например C# в `For Each`и...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метода не <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> вызывает исключение. Однако исключение возникает при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объектом, возвращаемым этим методом, если интервал времени ожидания определяется свойством "REGEX_DEFAULT_MATCH_TIMEOUT" текущего домена приложения и соответствующей операцией. превышает этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод для обнаружения любого слова в предложении, заканчивающемся на "ES", а затем <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> вызывается метод для выполнения сравнения шаблона со входной строкой без учета регистра. Как видно из выходных данных, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для получения нескольких совпадений <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблонов рекомендуется использовать статический метод, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод аналогичен <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> методу, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Matches`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод использует отложенное вычисление для заполнения возвращаемого <xref:System.Text.RegularExpressions.MatchCollection> объекта. <xref:System.Text.RegularExpressions.Regex.Matches%2A> Доступ к членам этой коллекции, <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> например и, <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, `foreach` например C# в `For Each`и...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов <xref:System.Text.RegularExpressions.Regex.Matches%2A> метода не <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> вызывает исключение. Однако при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объектом, возвращаемым этим методом, возникает исключение, если операция сопоставления превышает этот интервал времени ожидания, заданный`matchTimeout` параметром.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод для выполнения сравнения с учетом регистра, совпадающего с любым словом в предложении, заканчивающемся на «ES». Затем он вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы выполнить сравнение шаблона с входной строкой без учета регистра. В обоих случаях интервал времени ожидания устанавливается равным одной секунде. Как видно из выходных данных, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" /> .  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает интервал времени ожидания текущего экземпляра.</summary>
        <value>Максимальный интервал времени, который может пройти в операции сравнения с шаблоном, прежде чем возникнет исключение <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />, или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, если контроль времени ожидания отключен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет приблизительный максимальный интервал времени, <xref:System.Text.RegularExpressions.Regex> в течение которого экземпляр должен выполнить одну операцию сопоставления до истечения времени ожидания операции. <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Обработчик регулярных выражений создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение во время следующей проверки по времени после истечения интервала времени ожидания. Это предотвращает обработку обработчиком регулярных выражений входных строк, требующих избыточного поиска с возвратом. Дополнительные сведения см. в разделе Поиск с [возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md) и рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 Это свойство доступно только для чтения. Его значение можно задать <xref:System.Text.RegularExpressions.Regex> явно для отдельного объекта, <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> вызвав конструктор; Кроме того, можно задать его значение для всех <xref:System.Text.RegularExpressions.Regex> <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> операций сопоставления в домене приложения, вызвав метод и предоставив <xref:System.TimeSpan> значение для свойства "REGEX_DEFAULT_MATCH_TIMEOUT", как показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Если не задать явно интервал времени ожидания, используется значение <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> по умолчанию, а операции сопоставления не истечения времени ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает параметр, которые были переданы в конструктор <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Один или несколько членов перечисления <see cref="T:System.Text.RegularExpressions.RegexOptions" />, представляющих параметры, переданные в конструктор <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Text.RegularExpressions.Regex.Options%2A> свойства состоит из одного или нескольких элементов <xref:System.Text.RegularExpressions.RegexOptions> перечисления. Если в <xref:System.Text.RegularExpressions.Regex> конструкторе класса не определены никакие параметры, его значение равно <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Доступные параметры подробно описаны в разделе [Параметры регулярных выражений](~/docs/standard/base-types/regular-expression-options.md) .  
  
 Обратите внимание <xref:System.Text.RegularExpressions.Regex.Options%2A> , что свойство не отражает встроенные параметры, определенные в самом шаблоне регулярного выражения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" />является базовым классом регулярных выражений, созданных <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> методом. Эти скомпилированные регулярные выражения используют реализацию базового класса для <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойства. При вызове из производного класса <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство возвращает параметры, которые были переданы <paramref name="options" /> в параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Параметры регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>В указанной входной строке заменяет строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале `input` строки. Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 Параметр указывает строку, которая будет заменять каждое совпадение  `input` в.  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\s+`, которое соответствует одному или нескольким символам пробела. Строка замены "" заменяет их одним символом пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 В следующем примере определяется регулярное выражение, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`и `$2`шаблон замены, который удаляет из числового значения либо начальный, либо завершающий символ валюты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\p{Sc}`|Совпадение с символом валюты. `{Sc}`обозначает любой символ, который является членом символа Юникода, категории валюты.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{Sc}\s?)?`|Совпадение с нулем или одним вхождением сочетания символа валюты, за которым следует ноль или один символ пробела. Это первая группа записи.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\.?`|Совпадение с нулем или одним вхождением точки (используется в качестве символа десятичного разделителя).|  
|`((?<=\.)\d+)?`|Если точка является предыдущим символом, соответствует одной или нескольким десятичным цифрам. Этот шаблон можно сопоставить с нулем или один раз.|  
|`(\d+\.?((?<=\.)\d+)?)`|Соответствует шаблону из одной или нескольких десятичных цифр, за которыми следует необязательная точка и дополнительные десятичные цифры. Это вторая группа записи. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> метода заменяет все совпадение значением этой захваченной группы.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Если первая захваченная группа существует, соответствует пустой строке. В противном случае соответствует нулю или одному символу пробела, за которым следует символ валюты.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="replacement" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метода и передаче каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере кода отображается исходная строка, соответствующая каждому слову в исходной строке, преобразует первый символ каждого совпадения в верхний регистр, а затем отображает преобразованную строку.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале `input` строки. Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` имеет отрицательное значение, замена продолжается до конца строки. Если `count` превышает число совпадений, все совпадения заменяются.  
  
 Параметр указывает строку, которая будет заменять первые `count` совпадения в  `input` .  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере первые пять вхождений повторяющихся символов заменяются одним символом. Шаблон `(\w)\1` регулярного выражения сопоставляет последовательные вхождения одного символа и назначает первое вхождение первой группе записи. Шаблон `$1` замены заменяет все совпадения первой захваченной группой.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="replacement" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Replace`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Поиск соответствий начинается в начале `input` строки.  
  
 Параметр указывает строку, которая будет заменять каждое совпадение  `input` в.  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\s+`, которое соответствует одному или нескольким символам пробела. Строка замены "" заменяет их одним символом пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство, чтобы включить имя локального компьютера, <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> и метод для включения имен логических дисков. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`| Совпадение двух последовательных`\`символов обратной косой черты (). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`(?i:" + Environment.MachineName + ")`|Выполнение совпадения строки, возвращаемой <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойством, без учета регистра.|  
|`(?:\.\w+)*`|Соответствует символу точки`.`(), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`| Совпадение с символом обратной косой черты (`\`).|  
|`((?i:[" + driveNames + "]))`|Выполните сопоставление класса символов без учета регистра, состоящего из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Совпадение с литералом знака`$`доллара ().|  
  
 Шаблон `$1` замены заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для замены соответствия <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метода и передаче каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется <xref:System.Text.RegularExpressions.MatchEvaluator> делегат для вызова метода с именем `WordScramble` , который шифрует отдельные буквы в слове. Для этого `WordScramble` метод создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метода, а отсортированный массив предоставляется в качестве аргумента <xref:System.String> конструктору класса. Затем вновь созданная строка возвращается `WordScramble` методом. Шаблон `\w+` регулярного выражения соответствует одному или нескольким символам слова; обработчик регулярных выражений продолжит добавлять символы к совпадению до тех пор, пока не встретится символ, отличный от слова, например пробел.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для вычисления и замены соответствия <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> эквивалентен вызову метода и передаче первых <xref:System.Text.RegularExpressions.Match> `count` объектов из возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере регулярное выражение используется для намеренного написания недопустимых частей слов в списке. Он использует регулярное выражение `\w*(ie|ei)\w*` для сопоставления слов, содержащих символы "IE" или "EI". Он передает первую половину соответствующих слов `ReverseLetter` в метод, который, в свою очередь, <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> использует метод для отмены "i" и "e" в соответствующей строке. Остальные слова останутся без изменений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Определение регулярного выражения `\w*(ie|ei)\w*` показано в таблице ниже.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
|<code>(ie&#124;ei)</code>|Совпадение с "IE" или "EI".|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
  
 Шаблон `([ie])([ie])` регулярного выражения `ReverseLetter` в методе соответствует первому символу "i" или "e" в дифсонг "IE" или "EI" и назначает букву первой захваченной группе. Он соответствует второму символу "i" или "e" и назначает букву второй группе записи. Затем два символа меняются местами, вызывая <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод с шаблоном `$2$1`замены.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное возможное количество случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в `input` строке в позиции `startat` , указанной параметром. Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` имеет отрицательное значение, замена продолжается до конца строки. Если `count` превышает число совпадений, все совпадения заменяются.  
  
 Параметр указывает строку, которая будет заменять каждое совпадение  `input` в.  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере два пробела, кроме первой строки строки. Он определяет шаблон регулярного выражения, `^.*$`который соответствует строке текста, <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> вызывает метод для сопоставления первой строки `Match.Index` строки и использует свойства и `Match.Count` для определения начальной позицией второго штрих.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Шаблон регулярного выражения `^.*$` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Соответствует началу строки. (Обратите внимание <xref:System.Text.RegularExpressions.Regex> , что экземпляр объекта был создан с <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> помощью параметра; в противном случае этот класс символов будет соответствовать только началу входной строки.)|  
|`.*`|Совпадение с любым символом ноль или более раз.|  
|`$`|Совпадение с концом строки. (Обратите внимание <xref:System.Text.RegularExpressions.Regex> , что экземпляр объекта был создан с <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> помощью параметра; в противном случае этот класс символов будет соответствовать только началу входной строки.)|  
  
 Строка замены (`vbCrLf + "$&"` в `"\n$&"` Visual Basic C#) добавляет новую строку перед совпадающей строкой. Обратите `\n` внимание, C# что в примере интерпретируется как символ новой строки C# компилятором; он не представляет escape-последовательность символов регулярного выражения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="replacement" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Replace`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Если `options`  для параметра указано значение, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается с начала входной строки и перемещается вправо.  
  
 Параметр указывает строку, которая будет заменять каждое совпадение  `input` в.  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство, чтобы включить имя локального компьютера, <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> и метод для включения имен логических дисков. При сравнении строк регулярного выражения регистр не учитывается. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`| Совпадение двух последовательных`\`символов обратной косой черты (). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадение со строкой, возвращаемой <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойством.|  
|`(?:\.\w+)*`|Соответствует символу точки`.`(), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`| Совпадение с символом обратной косой черты (`\`).|  
|`([" + driveNames + "])`|Соответствует классу символов, который состоит из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Совпадение с литералом знака`$`доллара ().|  
  
 Шаблон `$1` замены заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для замены соответствия <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />шаблону рекомендуется использовать статический метод, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения в, если выполняется любое из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метода и передаче каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Если `options`  для параметра указано значение, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается с начала входной строки и перемещается вправо.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется <xref:System.Text.RegularExpressions.MatchEvaluator> делегат для вызова метода с именем `WordScramble` , который шифрует отдельные буквы в слове. Для этого `WordScramble` метод создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метода, а отсортированный массив предоставляется в качестве аргумента <xref:System.String> конструктору класса. Затем вновь созданная строка возвращается `WordScramble` методом. Шаблон `\w+` регулярного выражения соответствует одному или нескольким символам слова; обработчик регулярных выражений продолжит добавлять символы к совпадению до тех пор, пока не встретится символ, отличный от слова, например пробел. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метода `\w+  # Matches all the characters in a word.` включает параметр, чтобы комментарий в шаблоне регулярного выражения игнорировался обработчиком регулярных выражений. <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> эквивалентен вызову метода и передаче первых <xref:System.Text.RegularExpressions.Match> `count` объектов из возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="evaluator" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода `Replace`экземпляра.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Если `options`  для параметра указано значение, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается с начала входной строки и перемещается вправо.  
  
 Параметр указывает строку, которая будет заменять каждое совпадение  `input` в.  `replacement` `replacement`может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон `a*${test}b` замены вставляет строку "a *", за которой следует подстрока, совпадающая `test` с группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство для включения имени локального компьютера <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> и метода для включения имен логических дисков. Все сравнения строк регулярного выражения не чувствительны к регистру и время ожидания одной операции замены, если соответствие не найдено в течение 0,5 секунды. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`| Совпадение двух последовательных`\`символов обратной косой черты (). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадение со строкой, возвращаемой <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойством.|  
|`(?:\.\w+)*`|Соответствует символу точки`.`(), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`| Совпадение с символом обратной косой черты (`\`).|  
|`([" + driveNames + "])`|Соответствует классу символов, который состоит из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Совпадение с литералом знака`$`доллара ().|  
  
 Шаблон `$1` замены заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющих параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все подстроки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Если замещающая строка не может быть задана шаблоном регулярного выражения.  
  
-   Значение, если строка замены является результатом некоторой обработки, выполненной с соответствующей строкой.  
  
-   Значение, если строка замены является результатом условной обработки.  
  
 Метод эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метода и передаче каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегату.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления <xref:System.Text.RegularExpressions.MatchEvaluator> с делегатом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Если `options`  для параметра указано значение, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается с начала входной строки и перемещается вправо.  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания позволяет предотвратить появление в регулярных выражениях, которые полагаются на избыточное средство поиска с возвратом, перестают отвечать при обработке входных данных, содержащих близких соответствий. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 Поскольку метод возвращает `input` значение без изменений, если совпадение нет, можно <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> использовать метод, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется <xref:System.Text.RegularExpressions.MatchEvaluator> делегат для вызова метода с именем `WordScramble` , который шифрует отдельные буквы в слове. Для этого `WordScramble` метод создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метода, а отсортированный массив предоставляется в качестве аргумента <xref:System.String> конструктору класса. Затем вновь созданная строка возвращается `WordScramble` методом. Шаблон `\w+` регулярного выражения соответствует одному или нескольким символам слова; обработчик регулярных выражений продолжит добавлять символы к совпадению до тех пор, пока не встретится символ, отличный от слова, например пробел. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метода `\w+  # Matches all the characters in a word.` включает параметр, чтобы комментарий в шаблоне регулярного выражения игнорировался обработчиком регулярных выражений. <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- или - 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее на то, выполняется ли регулярным выражением поиск справа налево.</summary>
        <value>Значение <see langword="true" />, если регулярное выражение выполняет поиск справа налево; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A>имеет `true` значение, <xref:System.Text.RegularExpressions.Regex> Если <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>  экземпляр был создан с параметром.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных соответствием регулярного выражения.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной входной строкой.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон `\d+` регулярного выражения используется для разбиения входной строки на числовые символы. Поскольку строка начинается и заканчивается соответствующими числовыми символами, значением первого и последнего элемента возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются скобки записи, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. Например:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Обратите внимание, что возвращаемый массив также содержит пустую строку в начале и в конце массива.  
  
 Исключение возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Параметр задает максимальное число подстрок, в `input` которые может быть разбита строка. Последняя строка содержит неразделенную оставшуюся часть строки. `count` Нулевое `count` значение обеспечивает по умолчанию разделение как можно меньшего числа раз.  
  
 Если несколько совпадений находятся рядом друг с другом или если в начале или в конце `input`обнаружено совпадение, а число найденных совпадений не `count`меньше, то в массив вставляется пустая строка. Таким образом, пустые строки, являющиеся результатом смежных совпадений или из совпадений в начале или конце входной строки, учитываются при определении того, равно `count`ли число сопоставленных подстрок. В следующем примере регулярное выражение `/d+` используется для разбиения входной строки, включающей одну или несколько десятичных цифр, в максимум три подстроки. Поскольку начало входной строки соответствует шаблону регулярного выражения, первый элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>, второй — Первый набор букв во входной строке, а третий содержит остаток строки. Это следует за третьим совпадением.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Если в регулярном выражении используются скобки записи, любой захваченный текст включается в массив разделенных строк. Однако все элементы массива, содержащие захваченный текст, не учитываются при определении того, достигнуто `count`ли количество совпадений. Например, при разделении строки "Apple-Априкот-Плам-груш-" в максимум четыре подстроки создается массив из семи элементов, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1 в возвращаемый массив включается только захваченный текст из первого набора скобок записи. Начиная с .NET Framework 2,0, весь захваченный текст добавляется в возвращаемый массив. Однако элементы в возвращаемом массиве, содержащие захваченный текст, не учитываются при определении того, равно `count`ли число сопоставленных подстрок. Например, в следующем коде регулярное выражение использует два набора скобок записи для извлечения элементов даты из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Затем при вызове <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> метода в возвращаемом массиве указывается не более двух элементов. Если пример кода компилируется и выполняется в .NET Framework 1,0 или 1,1, метод возвращает массив строк из двух элементов. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, метод возвращает массив строк из трех элементов.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. В следующем примере строка "символы" разбивается на столько элементов, сколько есть во входной строке. Поскольку строка NULL соответствует началу входной строки, в начало возвращаемого массива вставляется пустая строка. В результате десятый элемент будет состоять из двух символов в конце входной строки.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Исключение возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> `input` Строка разделяется столько раз, сколько возможно. Если `pattern` `input` в строке не найден, возвращаемое значение содержит один элемент, значение которого является исходной строкой. `input`  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Для самостоятельного управления временем существования скомпилированных регулярных выражений используйте <xref:System.Text.RegularExpressions.Regex.Split%2A> методы экземпляра.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон `\d+` регулярного выражения используется для разбиения входной строки на числовые символы. Поскольку строка начинается и заканчивается соответствующими числовыми символами, значением первого и последнего элемента возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются скобки записи, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%2A> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. Например:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Обратите внимание, что возвращаемый массив также содержит пустую строку в начале и в конце массива.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции разбиения превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" /> или <paramref name="pattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для разделения текста в шаблоне <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />рекомендуется использовать статический метод, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />. Поиск шаблона регулярного выражения начинается с указанной позиции элемента во входной строке.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%2A?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Параметр задает максимальное число подстрок, на `input` которые разделяется строка. Последняя строка содержит неразделенную оставшуюся часть строки. `count` Нулевое `count` значение обеспечивает по умолчанию разделение как можно меньшего числа раз. `startat` Параметр определяет точку, в которой начинается поиск первого разделителя (он может использоваться для пропуска начальных пробелов).  
  
 Если в строке `count`+ 1 не найдено совпадений, метод возвращает одноэлементный массив, `input` содержащий строку. Если найдено одно или несколько совпадений, первый элемент возвращаемого массива содержит первую часть строки из первого символа до одного символа перед совпадением.  
  
 Если несколько совпадений находятся рядом друг с другом, а число найденных совпадений не `count`меньше, то в массив вставляется пустая строка. Аналогично, если найдено соответствие в `startat`, которое является первым символом в строке, первый элемент возвращаемого массива является пустой строкой. Таким образом, пустые строки, являющиеся результатом смежных совпадений, учитываются при определении того, равно `count`ли число сопоставленных подстрок. В следующем примере регулярное выражение `\d+` используется для поиска начальной позиции первой подстроки числовых символов в строке, а затем для разделения строки до трех раз, начиная с этой позиции. Так как шаблон регулярного выражения соответствует началу входной строки, возвращаемый массив строк состоит из пустой строки, алфавитной строки из пяти символов и оставшейся части строки.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Если в регулярном выражении используются скобки записи, любой захваченный текст включается в массив разделенных строк. Однако все элементы массива, содержащие захваченный текст, не учитываются при определении того, достигнуто `count`ли количество совпадений. Например, разбиение строки "" Apple-Априкот-Плам-груш-граната-ананас-печь "в максимум четыре подстроки, начиная с символа 15 в строке, приводит к последующему массиву из семи элементов, как показано в приведенном ниже коде.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения отдельных слов в строке. Первый набор скобок записи захватывает дефис, а второй набор захватывает вертикальную линию. Если пример кода компилируется и запускается под .NET Framework 1,0 или 1,1, он исключает символы вертикальной черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%2A> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. В следующем примере строка "символы" разбивается на столько элементов, сколько содержит входная строка, начиная с символа "a". Поскольку строка NULL соответствует концу входной строки, в конце возвращаемого массива вставляется пустая строка.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Исключение возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктором. <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создан объект. Если время ожидания не определено в <xref:System.Text.RegularExpressions.Regex> вызове конструктора или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной `input` строкой.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Для самостоятельного управления временем существования скомпилированных регулярных выражений используйте <xref:System.Text.RegularExpressions.Regex.Split%2A> методы экземпляра.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса.  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон `[a-z]+` регулярного выражения используется для разбиения входной строки на любой алфавитный символ в верхнем или нижнем регистре. Поскольку строка начинается и заканчивается соответствующими буквами, значением первого и последнего элемента возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются скобки записи, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%2A> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение возникает, если время выполнения операции разбиения превышает интервал времени ожидания, указанный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, запрещающее истечение времени ожидания метода. Для разделения текста в шаблоне <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />рекомендуется использовать статический метод, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы похожи на метод, за исключением того, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> что разделяет строку с разделителем, определенным регулярным выражением, а не набором символов. <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной `input` строкой.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Для самостоятельного управления временем существования скомпилированных регулярных выражений используйте <xref:System.Text.RegularExpressions.Regex.Split%2A> методы экземпляра.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса.  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон `[a-z]+` регулярного выражения используется для разбиения входной строки на любой алфавитный символ в верхнем или нижнем регистре. Поскольку строка начинается и заканчивается соответствующими буквами, значением первого и последнего элемента возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются скобки записи, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, будет <xref:System.Text.RegularExpressions.Regex.Split%2A> разделять строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении.  
  
 `matchTimeout` Параметр указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout`переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" /> .  
  
- или - 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить <paramref name="matchTimeout" /> параметру соответствующее значение, например две секунды. Если вы отключаете время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, механизм регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Этот параметр зарезервирован для использования в будущем.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает шаблон регулярного выражения, который был передан в конструктор <see langword="Regex" />.</summary>
        <returns>Параметр <paramref name="pattern" />, который был передан в конструктор <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, которые в символьном виде описывают строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" />является базовым классом регулярных выражений, созданных <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> методом. Эти скомпилированные регулярные выражения используют <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> реализацию базового класса. При вызове из производного класса <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> метод возвращает строку, которая была передана <paramref name="pattern" /> в параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая текст для преобразования.</param>
        <summary>Преобразует все escape-символы во входной строке обратно в символы.</summary>
        <returns>Строка символов с любыми преобразованными символами, приведенными в их непреобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод выполняет одно из следующих двух преобразований:  
  
-   Он обращает преобразование, выполняемое <xref:System.Text.RegularExpressions.Regex.Escape%2A> методом, удаляя Escape\\-символ ("") из каждого символа, экранированного методом. К \\ним относятся символы, *, +,? &#124;,, {, [, (,), ^, $,., # и пробелы. Кроме того <xref:System.Text.RegularExpressions.Regex.Unescape%2A> , метод отменяет escape-символы закрывающей скобки (]) и закрывающих фигурных скобок (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A>нельзя допустить обратную escape-строку идеальной, так как она не может определить, какие символы были экранированы,  
  
-   Он заменяет шестнадцатеричные значения в буквальных строковых литералах фактическими печатаемыми символами. Например, он заменяется @"\x07" на "\a" или @"\x0A" "\n". Он преобразует в поддерживаемые escape-символы, такие как \a, \b, \e, \n, \r, \f, \t, \v и буквенно-цифровые символы.
  
 Если метод встречает другие escape-последовательности, которые не могут быть преобразованы, например \w или \s, он <xref:System.ArgumentException>создает исключение. <xref:System.Text.RegularExpressions.Regex.Unescape%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> включает нераспознанную escape-последовательность.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Время ожидания, которое требуется проверить.</param>
        <summary>Проверяет, попадает ли интервал времени ожидания в допустимый диапазон.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное время ожидания выходит за пределы допустимого диапазона.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
