<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6ba72417c6c8b7deea08ca767c5c49a961f95d7" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75053819" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет неизменяемое регулярное выражение.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Text.RegularExpressions.Regex> представляет обработчик регулярных выражений .NET Framework. Его можно использовать для быстрого анализа больших объемов текста, чтобы найти определенные шаблоны символов. для извлечения, изменения, замены или удаления текстовых подстрок; и, чтобы добавить извлеченные строки в коллекцию для создания отчета.  
  
> [!NOTE]
>  Если основным интересом является проверка строки путем определения того, соответствует ли она определенному шаблону, можно использовать класс <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>.  
  
 Чтобы использовать регулярные выражения, необходимо определить шаблон, который необходимо определить в текстовом потоке, с помощью синтаксиса, описанного в статье [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Затем при необходимости можно создать объект <xref:System.Text.RegularExpressions.Regex>. Наконец, вызывается метод, который выполняет некоторую операцию, например замену текста, совпадающего с шаблоном регулярного выражения, или определение соответствия шаблону.  
  
> [!NOTE]
>  Некоторые распространенные шаблоны регулярных выражений см. в разделе [примеры регулярных выражений](~/docs/standard/base-types/regular-expression-examples.md). Существует также ряд Интернет-библиотек шаблонов регулярных выражений, например, один из них на [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a>Дополнительные сведения об использовании класса <xref:System.Text.RegularExpressions.Regex> см. в следующих разделах этой статьи:  
  
-   [Сравнение регулярных выражений и строковых методов](#regex_vs_string)  
  
-   [Статические и экземпляры методы](#static_vs_instance)  
  
-   [Выполнение операций с регулярными выражениями](#regex_ops)  
  
-   [Определение значения времени ожидания](#define_timeout)  
  
 Дополнительные сведения о языке регулярных выражений см. в [кратком справочнике по элементам языка регулярных выражений](~/docs/standard/base-types/regular-expression-language-quick-reference.md) или в одной из следующих брошюр, который вы можете скачать и распечатать:  
  
 [Краткий справочник в формате Word (DOCX)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx);  
 [Краткий справочник в формате PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf).  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Сравнение регулярных выражений и строковых методов  
 Класс <xref:System.String?displayProperty=nameWithType> включает несколько методов поиска и сравнения, которые можно использовать для выполнения сопоставления шаблонов с текстом. Например, методы <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> определяют, содержит ли экземпляр строки указанную подстроку. методы <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>и <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> возвращают начальную точку указанной подстроки в строке. При поиске определенной строки используйте методы класса <xref:System.String?displayProperty=nameWithType>. Используйте класс <xref:System.Text.RegularExpressions.Regex> при поиске определенного шаблона в строке. Дополнительные сведения и примеры см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md).  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Статические и экземпляры методы  
 После определения шаблона регулярного выражения его можно предоставить обработчику регулярных выражений одним из двух способов:  
  
-   Путем создания экземпляра объекта <xref:System.Text.RegularExpressions.Regex>, представляющего регулярное выражение. Для этого необходимо передать шаблон регулярного выражения конструктору <xref:System.Text.RegularExpressions.Regex.%23ctor%2A>. Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым; При создании экземпляра объекта <xref:System.Text.RegularExpressions.Regex> с регулярным выражением регулярное выражение этого объекта не может быть изменено.  
  
-   Предоставляя как регулярное выражение, так и текст для поиска в методе <xref:System.Text.RegularExpressions.Regex> `static` (`Shared` в Visual Basic). Это позволяет использовать регулярное выражение без явного создания объекта <xref:System.Text.RegularExpressions.Regex>.  
  
 Все методы идентификации <xref:System.Text.RegularExpressions.Regex> шаблона включают как статические, так и перегрузки экземпляров.  
  
 Обработчик регулярных выражений должен компилировать определенный шаблон, прежде чем можно будет использовать шаблон. Поскольку <xref:System.Text.RegularExpressions.Regex> объекты являются неизменяемыми, это одноразовая процедура, возникающая при вызове конструктора классов <xref:System.Text.RegularExpressions.Regex> или статического метода. Чтобы исключить необходимость повторной компиляции одного регулярного выражения, обработчик регулярных выражений кэширует скомпилированные регулярные выражения, используемые в вызовах статических методов. В результате методы сопоставления регулярных выражений обеспечивают сравнимую производительность для статических методов и экземпляров.  
  
> [!IMPORTANT]
>  В .NET Framework версиях 1,0 и 1,1 все скомпилированные регулярные выражения, которые были использованы в вызовах экземпляров или статических методов, были кэшированы. Начиная с .NET Framework 2,0, кэшируются только регулярные выражения, используемые в вызовах статических методов.  
  
 Однако кэширование может негативно сказаться на производительности в следующих двух случаях:  
  
-   При использовании вызовов статических методов с большим количеством регулярных выражений. По умолчанию обработчик регулярных выражений кэширует 15 последних использованных статических регулярных выражений. Если в приложении используется более 15 статических регулярных выражений, то необходимо повторно скомпилировать некоторые регулярные выражения. Чтобы предотвратить повторную компиляцию, можно увеличить свойство <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.  
  
-   При создании экземпляра новых <xref:System.Text.RegularExpressions.Regex> объектов с регулярными выражениями, которые ранее были скомпилированы. Например, следующий код определяет регулярное выражение для поиска повторяющихся слов в текстовом потоке. Хотя в примере используется одно регулярное выражение, он создает новый объект <xref:System.Text.RegularExpressions.Regex> для обработки каждой строки текста. Это приводит к перекомпиляции регулярного выражения при каждой итерации цикла.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Чтобы предотвратить повторную компиляцию, необходимо создать экземпляр одного <xref:System.Text.RegularExpressions.Regex> объекта, доступного для всего кода, который требуется, как показано в следующем примере переписывания.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Выполнение операций с регулярными выражениями  
 Если вы решили создать экземпляр объекта <xref:System.Text.RegularExpressions.Regex> и вызвать его методы или вызвать статические методы, класс <xref:System.Text.RegularExpressions.Regex> предлагает следующие функциональные возможности сопоставления шаблонов:  
  
-   Проверка соответствия. Чтобы определить, существует ли соответствие, вызовите метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>.  
  
-   Извлечение одного совпадения. Метод <xref:System.Text.RegularExpressions.Regex.Match%2A> вызывается для получения объекта <xref:System.Text.RegularExpressions.Match>, представляющего первое совпадение в строке или в части строки. Последующие соответствия можно получить, вызвав метод <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>.  
  
-   Получение всех совпадений. Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> вызывается для получения объекта <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType>, который представляет все совпадения, найденные в строке или в части строки.  
  
-   Замена совпадающего текста. Для замены совпадающего текста вызывается метод <xref:System.Text.RegularExpressions.Regex.Replace%2A>. Замещающий текст также может быть определен регулярным выражением. Кроме того, некоторые из <xref:System.Text.RegularExpressions.Regex.Replace%2A> методов включают в себя параметр <xref:System.Text.RegularExpressions.MatchEvaluator>, который позволяет программно определять текст замены.  
  
-   Создание массива строк, сформированного из частей входной строки. Вызовите метод <xref:System.Text.RegularExpressions.Regex.Split%2A>, чтобы разделить входную строку в позициях, определенных регулярным выражением.  
  
 В дополнение к методам сопоставления шаблонов класс <xref:System.Text.RegularExpressions.Regex> включает несколько специальных методов:  
  
-   Метод <xref:System.Text.RegularExpressions.Regex.Escape%2A> escape-последовательность символов, которые могут интерпретироваться как операторы регулярных выражений в регулярном выражении или входной строке.  
  
-   Метод <xref:System.Text.RegularExpressions.Regex.Unescape%2A> удаляет эти escape-символы.  
  
-   Метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> создает сборку, содержащую предопределенные регулярные выражения. .NET Framework содержит примеры этих специальных сборок в пространстве имен <xref:System.Web.RegularExpressions?displayProperty=nameWithType>.  
  
 [Вернуться к примечаниям](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Определение значения времени ожидания  
 .NET Framework поддерживает полнофункциональный язык регулярных выражений, обеспечивающий значительную мощность и гибкость при сопоставлении шаблонов. Тем не менее, мощность и гибкость получаются за счет: риск низкой производительности. Регулярные выражения, которые плохо работают, удивительно просты в создании. В некоторых случаях операции с регулярными выражениями, зависящие от избыточного поиска с возвратом, могут перестать отвечать на запросы при обработке текста, который почти соответствует шаблону регулярного выражения. Дополнительные сведения о обработчике регулярных выражений .NET Framework см. в разделе [сведения о поведении регулярных](~/docs/standard/base-types/details-of-regular-expression-behavior.md)выражений. Дополнительные сведения о избыточном поиске с возвратом см. в разделе [Поиск с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)]можно определить интервал времени ожидания для совпадений регулярных выражений. Если обработчик регулярных выражений не может найти соответствие в течение этого интервала времени, операция сопоставления создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. В большинстве случаев это не позволяет обработчику регулярных выражений израсходовать вычислительную мощность, пытаясь сопоставить текст, который почти соответствует шаблону регулярного выражения. Это также может означать, что интервал времени ожидания был установлен слишком мал, или что текущая нагрузка компьютера привела к общему снижению производительности.  
  
 Способ, которым обрабатывается исключение, зависит от причины исключения. Если исключение возникает из-за того, что интервал времени ожидания задан слишком мал или из-за чрезмерной загрузки компьютера, можно увеличить интервал времени ожидания и повторить операцию сопоставления. Если исключение возникает из-за того, что регулярное выражение зависит от избыточного поиска с возвратом, можно предположить, что совпадение не существует, и при необходимости можно зарегистрировать сведения, которые помогут изменить шаблон регулярного выражения.  
  
 Можно задать интервал времени ожидания, вызвав конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> при создании экземпляра объекта регулярного выражения. Для статических методов можно задать интервал времени ожидания, вызвав перегрузку соответствующего метода, имеющего параметр `matchTimeout`. Если значение времени ожидания не задано явно, значение времени ожидания по умолчанию определяется следующим образом:  
  
-   С помощью значения времени ожидания приложения, если оно существует. Это может быть любое значение времени ожидания, которое применяется к домену приложения, в котором создается экземпляр объекта <xref:System.Text.RegularExpressions.Regex> или вызову статического метода. Можно задать значение времени ожидания приложения, вызвав метод <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>, чтобы присвоить строковое представление <xref:System.TimeSpan> значения свойству "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   При использовании значения <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, если не задано значение времени ожидания для приложения.  
  
> [!IMPORTANT]
>  Рекомендуется устанавливать значение времени ожидания во всех операциях сопоставления шаблона регулярного выражения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 [Вернуться к примечаниям](#remarks)  
  
   
  
## Examples  
 В следующем примере регулярное выражение используется для проверки повторяющихся вхождений слов в строке. Можно интерпретировать `\b(?<word>\w+)\s+(\k<word>)\b` регулярного выражения, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начать совпадение на границе слова.|  
|`(?<word>\w+)`|Совпадение с одним или несколькими символами слова до границы слова. Назовите эту захваченную группу `word`.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|`(\k<word>)`|Сопоставьте захваченную группу с именем `word`.|  
|`\b`|Соответствует границе слова.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 В следующем примере показано использование регулярного выражения для проверки того, представляет ли строка значение валюты или имеет правильный формат для представления значения валюты. В этом случае регулярное выражение строится динамически на основе свойств <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> для текущего языка и региональных параметров пользователя. Если текущий язык и региональные параметры системы — en-US, то результирующее регулярное выражение будет `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Это регулярное выражение можно интерпретировать, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начните с начала строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`[\+-]?`|Совпадение с нулевым или одним вхождением знака плюс или минус.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\$?`|Совпадение с нулевым или одним вхождением знака доллара.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\d*`|Соответствует нулю или нескольким десятичным числам.|  
|`\.?`|Совпадение с нулем или одним символом десятичной запятой.|  
|`\d{2}?`|Совпадение двух десятичных цифр ноль или один раз.|  
|`(\d*\.?\d{2}?){1}`|Соответствие шаблону целой и дробной цифр, разделенных символом десятичной запятой, по крайней мере один раз.|  
|`$`|Совпадение с концом строки.|  
  
 В этом случае регулярное выражение предполагает, что допустимая строка валюты не содержит символы разделителя групп и что она не содержит дробных разрядов или числа цифр дробной части, определенных свойством <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> текущего языка и региональных параметров.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Так как регулярное выражение в этом примере создается динамически, во время разработки неизвестно, может ли обработчик регулярных выражений интерпретироваться как обычный символ денежной единицы, десятичный знак или положительные и отрицательные знаки. операторы языка выражений. Чтобы предотвратить невозможность интерпретации, в примере каждый динамически сформированная строка передается методу <xref:System.Text.RegularExpressions.Regex.Escape%2A>.  
  
 ]]></format>
    </remarks>
    <threadsafe>Класс <see cref="T:System.Text.RegularExpressions.Regex" /> является неизменяемым (только для чтения) и потокобезопасным. <see cref="T:System.Text.RegularExpressions.Regex" /> объекты могут создаваться в любом потоке и совместно использоваться потоками. Дополнительные сведения см. в статье [безопасность потоков](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Регулярные выражения в .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">Регулярные выражения — краткий справочник (загрузить в формате Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">Регулярные выражения — краткий справочник (загрузить в формате PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что этот конструктор защищен; Он может вызываться только классами, производными от класса <xref:System.Text.RegularExpressions.Regex>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для заданного регулярного выражения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 Вызов конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> эквивалентен вызову конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> со значением <xref:System.Text.RegularExpressions.RegexOptions.None> для аргумента `options`.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым. Это означает, что его можно использовать только для шаблона соответствия, который вы определили при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 Этот конструктор создает экземпляр объекта регулярного выражения, который пытается выполнить поиск с учетом регистра любых алфавитных символов, определенных в `pattern`. Для совпадения без учета регистра используйте конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот конструктор для создания экземпляра регулярного выражения, совпадающего с любым словом, начинающимся с букв "a" или "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Обратите внимание, что шаблон регулярного выражения не может соответствовать слову «the» в начале текста, поскольку при сравнении по умолчанию учитывается регистр. Пример сравнения без учета регистра см. в разделе Конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает объект <see cref="T:System.Text.RegularExpressions.Regex" />, который использует значение времени ожидания по умолчанию для домена приложения, в котором он создается. Если для домена приложения не определено значение времени ожидания, то объект <see cref="T:System.Text.RegularExpressions.Regex" /> использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечение времени ожидания операции. Для создания <see cref="T:System.Text.RegularExpressions.Regex" />ного объекта рекомендуется использовать конструктор <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованный шаблон и сведения <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Назначение для данной сериализации. (Этот параметр не используется; задайте значение <see langword="null" />.)</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />, используя сериализованные данные.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Шаблон, содержащий <paramref name="info" />, имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> содержит недопустимый флаг <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, изменяющими шаблон.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым. Это означает, что его можно использовать только для параметров соответствия, которые вы определяете при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот конструктор для создания экземпляра регулярного выражения, совпадающего с любым словом, начинающимся с букв "a" или "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Обратите внимание, что коллекция Match включает слово «The», которое начинается с текста, поскольку в параметре `options` определены сравнения без учета регистра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> содержит недопустимый флаг.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает объект <see cref="T:System.Text.RegularExpressions.Regex" />, который использует значение времени ожидания по умолчанию для домена приложения, в котором он создается. Если для домена приложения не определено значение времени ожидания, то объект <see cref="T:System.Text.RegularExpressions.Regex" /> использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечение времени ожидания операции. Для создания <see cref="T:System.Text.RegularExpressions.Regex" />ного объекта рекомендуется использовать конструктор <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, которые изменяют шаблон, и значение, указывающее, как долго метод сравнения с шаблоном должен пытаться найти совпадение, прежде чем время ожидания истечет.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткие справочные](~/docs/standard/base-types/regular-expression-language-quick-reference.md) материалы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым. Это означает, что его можно использовать только для шаблона соответствия, который вы определили при его создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен попытаться найти соответствие до истечения времени ожидания. Если в течение этого интервала времени совпадения не найдены, метод сопоставления шаблонов вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Методы сопоставления шаблона экземпляра, которые поблюдают за `matchTimeout` интервалом ожидания, включают следующее:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Для установки разумного интервала времени ожидания учитывайте следующие факторы.  
  
-   Длина и сложность шаблона регулярного выражения. Более длинные и более сложные регулярные выражения требуют больше времени, чем более короткие и простые.  
  
-   Ожидаемая загрузка компьютера. Обработка занимает больше времени на системах с высоким уровнем использования ЦП и памяти.  
  
   
  
## Examples  
 В следующем примере вызывается конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> для создания экземпляра объекта <xref:System.Text.RegularExpressions.Regex> со значением времени ожидания, равным одной секунде. Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом. При возникновении <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> в примере увеличивается значение времени ожидания вплоть до максимального значения, равного трем секундам. В противном случае он отказывается от попытки сопоставить шаблон.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество записей в текущей статической кэш-памяти скомпилированных регулярных выражений.</summary>
        <value>Максимальное количество записей в статической кэш-памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Text.RegularExpressions.Regex> поддерживает внутренний кэш скомпилированных регулярных выражений, используемых в вызовах статических методов. Если значение, указанное в операции задания, меньше текущего размера кэша, записи кэша отбрасываются, пока размер кэша не станет равным указанному значению.  
  
 По умолчанию кэш содержит 15 скомпилированных статических регулярных выражений. Обычно приложению не нужно изменять размер кэша. Свойство <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> используется только в том случае, если требуется отключить кэширование или если используется необычно большой кэш.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.</exception>
        <block subset="none" type="usage"><para>В .NET Framework до [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]регулярные выражения, используемые в статических вызовах и методах экземпляра, были кэшированы. Начиная с [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], кэшируются только регулярные выражения, используемые в вызовах статических методов.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; доступ к нему можно получить только из класса, производного от класса <xref:System.Text.RegularExpressions.Regex>.  
  
 Операция задания пытается преобразовать значение, присвоенное свойству, в объект <xref:System.Collections.Hashtable>; Если это преобразование завершается неудачно, вызывается конструктор <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; доступ к нему можно получить только из класса, производного от класса <xref:System.Text.RegularExpressions.Regex>.  
  
 Операция задания пытается преобразовать значение, присвоенное свойству, в объект <xref:System.Collections.Hashtable>; Если это преобразование завершается неудачно, вызывается конструктор <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Компилирует регулярные выражения и сохраняет их на диск в единой сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

В .NET Core вызовы метода `Regex.CompileToAssembly` создают <xref:System.PlatformNotSupportedException>; запись сборки не поддерживается.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> создает сборку .NET Framework, в которой каждое регулярное выражение, определенное в массиве `regexinfos`, представлено классом. Как правило, метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от класса <xref:System.Text.RegularExpressions.Regex>.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем Режекслиб. dll. Сборка включает два скомпилированных регулярных выражения. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует двум одинаковым смежным словам. Вторая, `Utilities.RegularExpressions.EmailAddress`, проверяет, имеет ли строка правильный формат для адреса электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 После этого регулярное выражение, которое проверяет строку на наличие повторяющихся слов, создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции второго примера требуется ссылка на Режекслиб. dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если разработка выполняется на системе, в которой установлены [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее выпуски, вы назначите [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и используете метод <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], а не более поздними версиями.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте методы static или instance <see cref="T:System.Text.RegularExpressions.Regex" /> с параметром <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> при создании экземпляра объекта <see cref="T:System.Text.RegularExpressions.Regex" /> или вызова метода сопоставления шаблона регулярного выражения.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> создает сборку .NET Framework, в которой каждое регулярное выражение, определенное в массиве `regexinfos`, представлено классом. Как правило, метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от класса <xref:System.Text.RegularExpressions.Regex>.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
 Поскольку метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> создает сборку .NET Framework из вызова метода вместо использования ключевого слова определения класса определенного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не позволяет назначать атрибуты .NET Framework сборке с помощью стандартного синтаксиса атрибутов языка разработки. Параметр `attributes` предоставляет альтернативный метод для определения атрибутов, применяемых к сборке. Для каждого атрибута, который необходимо применить к сборке, выполните следующие действия.  
  
1.  Создайте массив объектов <xref:System.Type>, представляющих типы параметров конструктора атрибута, который необходимо вызвать.  
  
2.  Получите объект <xref:System.Type>, представляющий класс атрибута, который необходимо применить к новой сборке.  
  
3.  Вызовите метод <xref:System.Type.GetConstructor%2A> атрибута <xref:System.Type> объекта, чтобы получить объект <xref:System.Reflection.ConstructorInfo>, представляющий конструктор атрибута, который требуется вызвать. Передайте метод <xref:System.Type.GetConstructor%2A> массив объектов <xref:System.Type>, представляющих типы параметров конструктора.  
  
4.  Создайте массив <xref:System.Object>, определяющий параметры для передачи в конструктор атрибута.  
  
5.  Создайте экземпляр объекта <xref:System.Reflection.Emit.CustomAttributeBuilder>, передав конструктору объект <xref:System.Reflection.ConstructorInfo>, полученный на шаге 3, и массив <xref:System.Object>, созданный на шаге 4.  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо параметра `attributes` в метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем Режекслиб. dll и к ней применяется атрибут <xref:System.Reflection.AssemblyTitleAttribute>. Сборка включает два скомпилированных регулярных выражения. Первый, `Utilities.RegularExpressions.DuplicatedString`, соответствует двум одинаковым смежным словам. Вторая, `Utilities.RegularExpressions.EmailAddress`, проверяет, имеет ли строка правильный формат для адреса электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Можно проверить, применен ли атрибут <xref:System.Reflection.AssemblyTitleAttribute> к сборке, проверив его манифест с помощью программы отражения, такой как ILDasm.  
  
 После этого регулярное выражение, которое проверяет строку на наличие повторяющихся слов, создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции второго примера требуется ссылка на Режекслиб. dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если разработка выполняется на системе, в которой установлены [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее выпуски, вы назначите [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и используете метод <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], а не более поздними версиями.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте методы static или instance <see cref="T:System.Text.RegularExpressions.Regex" /> с параметром <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> при создании экземпляра объекта <see cref="T:System.Text.RegularExpressions.Regex" /> или вызова метода сопоставления шаблона регулярного выражения.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <param name="resourceFile">Имя файла ресурса Win32 для включения в сборку.</param>
        <summary>Компилирует один или несколько указанных объектов <see cref="T:System.Text.RegularExpressions.Regex" /> и указанный файл ресурсов в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод [\], AssemblyName, Кустоматтрибутебуилдер\<XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. Режекскомпилатионинфо% 5B% 5D% 2CSystem. Reflection. AssemblyName% 2CSystem. отражение. Emit. Кустоматтрибутебуилдер% 5B% 5D% 2CSystem. String %29 > создает сборку .NET Framework, в которой каждое регулярное выражение, определенное в массиве `regexinfos`, представлено классом. Как правило, метод [\], AssemblyName, Кустоматтрибутебуилдер\<XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. Режекскомпилатионинфо% 5B% 5D% 2CSystem. Reflection. имя_сборки% 2CSystem. Reflection. Emit. Кустоматтрибутебуилдер% 5B% 5D% 2CSystem. String %29 > вызывается из отдельного приложения, создающего сборку скомпилированных регулярных выражений. Каждое регулярное выражение, входящее в сборку, имеет следующие характеристики.  
  
-   Он является производным от класса <xref:System.Text.RegularExpressions.Regex>.  
  
-   Ей присваивается полное имя, определяемое `fullnamespace` и `name` параметров соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет конструктор по умолчанию (или без параметров).  
  
 Как правило, код, который создает экземпляр и использует скомпилированное регулярное выражение, находится в сборке или приложении, отдельном от кода, который создает сборку.  
  
 Поскольку метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> создает сборку .NET Framework из вызова метода вместо использования ключевого слова определения класса определенного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не позволяет назначать атрибуты .NET Framework сборке с помощью стандартного синтаксиса атрибутов языка разработки. Параметр `attributes` предоставляет альтернативный метод для определения атрибутов, применяемых к сборке. Для каждого атрибута, который необходимо применить к сборке, выполните следующие действия.  
  
1.  Создайте массив объектов <xref:System.Type>, представляющих типы параметров конструктора атрибута, который необходимо вызвать.  
  
2.  Получите объект <xref:System.Type>, представляющий класс атрибута, который необходимо применить к новой сборке.  
  
3.  Вызовите метод <xref:System.Type.GetConstructor%2A> атрибута <xref:System.Type> объекта, чтобы получить объект <xref:System.Reflection.ConstructorInfo>, представляющий конструктор атрибута, который требуется вызвать. Передайте метод <xref:System.Type.GetConstructor%2A> массив объектов <xref:System.Type>, представляющих типы параметров конструктора.  
  
4.  Создайте массив <xref:System.Object>, определяющий параметры для передачи в конструктор атрибута.  
  
5.  Создайте экземпляр объекта <xref:System.Reflection.Emit.CustomAttributeBuilder>, передав конструктору объект <xref:System.Reflection.ConstructorInfo>, полученный на шаге 3, и массив <xref:System.Object>, созданный на шаге 4.  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо параметра `attributes` в [\], AssemblyName, Кустоматтрибутебуилдер\<XREF: System. Text. RegularExpressions. Regex. CompileToAssembly% 28System. Text. RegularExpressions. Режекскомпилатионинфо% 5B% 5D% 2CSystem. Reflection. имя_сборки% 2CSystem. Reflection. Emit. Кустоматтрибутебуилдер% 5B% 5D% 2CSystem. String %29 > метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением свойства <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения одного или более объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Параметр <paramref name="resourceFile" /> назначает недопустимый файл ресурсов Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный свойством <paramref name="resourceFile" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если разработка выполняется на системе, в которой установлены [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее выпуски, вы назначите [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и используете метод <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> для создания сборки, содержащей скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] создает исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
— Сборка, которая содержит скомпилированные регулярные выражения, в системе с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], а не более поздними версиями.  
  
— Вместо вызова <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и получения скомпилированного регулярного выражения из сборки используйте методы static или instance <see cref="T:System.Text.RegularExpressions.Regex" /> с параметром <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> при создании экземпляра объекта <see cref="T:System.Text.RegularExpressions.Regex" /> или вызова метода сопоставления шаблона регулярного выражения.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая преобразуемый текст.</param>
        <summary>Преобразует минимальный набор символов (\\, *, +, ?, |, {, [, (,), ^, $,., # и пробел), заменяя их escape-кодами. При этом обработчику регулярных выражений дается команда интерпретировать эти символы буквально, а не как метасимволы.</summary>
        <returns>Строка символов с метасимволами, приведенными в преобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> преобразует строку, чтобы обработчик регулярных выражений мог интерпретировать любые метасимволы, которые могут содержаться в виде символьных литералов. Например, рассмотрим регулярное выражение, которое предназначено для извлечения комментариев, разделенных прямыми открывающими и закрывающими квадратными скобками ([и]) из текста. В следующем примере регулярное выражение "[(. *?)]" интерпретируется как класс символов. Вместо того, чтобы сопоставлять комментарии, внедренные во входной текст, регулярное выражение соответствует каждой открывающей или закрывающей круглой скобке, точке, звездочке или вопросительному знаку.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Однако если открывающая квадратная скобка передается в метод <xref:System.Text.RegularExpressions.Regex.Escape%2A>, то регулярное выражение завершается успешно при совпадении комментариев, внедренных во входную строку. Это демонстрируется в следующем примере:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 В регулярном выражении, которое определено с помощью статического текста, символы, которые должны интерпретироваться буквально, а не как метасимволы, могут быть экранированы перед ними с помощью символа обратной косой черты (\\), а также путем вызова метода <xref:System.Text.RegularExpressions.Regex.Escape%2A>. В регулярном выражении, которое определено динамически с помощью символов, неизвестных во время разработки, вызов метода <xref:System.Text.RegularExpressions.Regex.Escape%2A> особенно важен для того, чтобы механизм регулярных выражений интерпретирует отдельные символы как литералы, а не как метасимволы.  
  
> [!NOTE]
>  Если шаблон регулярного выражения содержит либо символ решетки (#), либо символы-разделители, они должны быть экранированы, если входной текст анализируется с включенным параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>.  
  
 Хотя <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод экранирует прямой Открытие квадратная скобка ([) и открыв скобки ({}), он не экранирует их соответствующий закрывающий символов (] и}). В большинстве случаев их экранирование не требуется. Если закрывающей квадратной скобке или фигурной скобке не предшествует соответствующий открывающий символ, обработчик регулярных выражений интерпретирует его буквально. Если открывающая квадратная скобка или фигурная скобка интерпретируется как метасимвол, обработчик регулярных выражений интерпретирует первый соответствующий закрывающий символ как метасимвол. Если это не требуемое поведение, закрывающую скобку или фигурную скобку следует заключать в escape-последовательность, явно добавив символ обратной косой черты (\\). Иллюстрации см. в разделе "пример".  
  
   
  
## Examples  
 В следующем примере из текста извлекаются комментарии. Предполагается, что комментарии разделяются символом начала комментария и символом конца комментария, выбранным пользователем. Поскольку символы комментария должны интерпретироваться буквально, они передаются методу <xref:System.Text.RegularExpressions.Regex.Escape%2A>, чтобы убедиться, что они не могут быть неверно интерпретированы как метасимволы. Кроме того, в примере явно проверяется, является ли введенный пользователем символ завершающего комментария закрывающей квадратной скобкой (]) или фигурной скобкой (}). Если это так, то символ обратной косой черты (\\) добавляется в начало квадратной скобки или скобки, чтобы интерпретироваться буквально. Обратите внимание, что в примере также используется коллекция <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> для вывода только комментария, а не комментария вместе с его открывающими и закрывающими символами комментария.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Escape-знаки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Этот член переопределяет <see cref="M:System.Object.Finalize" />; по данной теме может быть доступна более полная документация.

Позволяет объекту <see cref="T:System.Object" /> попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как объект <see cref="T:System.Object" /> будет утилизирован в процессе сборки мусора.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив имен группы записи для регулярного выражения.</summary>
        <returns>Строковый массив имен группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Коллекция имен групп содержит набор строк, используемых для именования захваченных групп в выражении. Даже если группы записи не называются явно, им автоматически присваиваются числовые имена ("0", "1", "2", "3" и т. д.). Именованная группа "0" представляет весь текст, соответствующий шаблону регулярного выражения. Нумерованные группы предшествуют явно именованным группам в коллекции, а именованные группы отображаются в том порядке, в котором они определены в шаблоне регулярного выражения.  
  
 Для определения количества групп в регулярном выражении можно использовать свойство <xref:System.Array.Length%2A> массива, возвращаемого этим методом.  
  
   
  
## Examples  
 В следующем примере определяется метод `ShowMatches` общего назначения, который отображает имена групп регулярных выражений и соответствующих им текста.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 В этом случае шаблон регулярного выражения `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` предназначен для анализа простого предложения, а также для обнаружения его первого слова, последнего слова и конца знака препинания. В следующей таблице показано, как интерпретируется шаблон регулярного выражения:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<FirstWord>\w+)`|Совпадение с одним или несколькими символами слова. Это `FirstWord` именованная группа.|  
|оформляет?|Совпадение с нулем или одним символом пробела.|  
|(\w+)|Совпадение с одним или несколькими символами слова. Это вторая группа записи.|  
|\s|Соответствует пробелу.|  
|((\w+)\s)*|Совпадение с нулем или несколькими вхождениями одного или нескольких символов слова, за которыми следует пробел. Это первая группа записи.|  
|(?\<Ластворд > \w +)?|Совпадение с нулевым или одним вхождением одного или нескольких символов слов. Это `LastWord` именованная группа.|  
|(?\<знаки препинания > \П{по})|Совпадение с символом, категорией Юникода которой является знак препинания, другой. Это `Punctuation` именованная группа.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив номеров групп записи, что соответствует именам групп в массиве.</summary>
        <returns>Целочисленный массив номеров групп.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Доступ к группам захвата без имени и именованной группы можно получить по числу. Неименованные группы нумеруются слева направо, начиная с 1. (Группа записи в индексе 0 (ноль) представляет совпадение как целое.)  Затем именованные группы нумеруются слева направо, начиная с числа, которое больше числа неименованных групп записи.  
  
 Ссылка на группу по ее номеру, а не по имени строки, может обеспечить более быстрый доступ.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\b((?<word>\w+)\s*)+(?<end>[.?!])`, которое соответствует предложению. Регулярное выражение включает три группы записи: неименованную группу, в которой захватывается отдельное слово, а также символ пробела, который может следовать за ним. Группа с именем `word`, которая фиксирует отдельные слова в предложении; и группа с именем `end`, которая захватывает знаки пунктуации, завершающие предложение. В примере вызывается метод <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> для получения числа всех захваченных групп, а затем отображается захваченная строка. Кроме того, метод <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> используется, чтобы указать, соответствует ли определенная нумерованная группа именованной группе.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<word>\w+)`|Совпадение с одним или несколькими символами слов и присвоение совпадающих строк группе с именем `word`.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`((?<word>\w+)\s*)`|Назначьте `word` захваченную группу, за которой следует все захваченные символы пробела, в первую захваченную группу.|  
|`((?<word>\w+)\s*)+`|Совпадение с шаблоном одного или нескольких символов слов, за которыми следует любой символ пробела, один или несколько раз.|  
|`(?<end>[.?!])`|Совпадение с точкой, вопросительным знаком или восклицательным знаком. Назначьте сопоставленный символ группе записи `end`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Номер группы для преобразования в соответствующее имя группы.</param>
        <summary>Получает имя группы, соответствующее указанному номеру группы.</summary>
        <returns>Строка, содержащая имя группы, связанное с указанным номером группы. При отсутствии имени группы, соответствующей параметру <paramref name="i" />, метод возвращает значение <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные группы записи, которые выделяют части выражения в соответствии с шаблоном. Нумерованные группы разделяются синтаксисом (*часть выражения*) и присваиваются числа на основе их порядка в регулярном выражении. Именованные группы разделяются синтаксисом (?`<`*имя*`>`*часть выражения*) или (?) *Name*"*часть выражения*", где *Name* — имя, по которому будет идентифицирована часть выражения. (Дополнительные сведения см. в разделе [конструкции группирования](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Метод <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> определяет как именованные группы, так и нумерованные группы по их порядковым позициям в регулярном выражении. Нулевое значение порядкового номера всегда представляет собой полное регулярное выражение. Затем все пронумерованные группы подсчитываются до именованных групп, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `i` — номер именованной группы, метод возвращает имя группы. Если `i` — номер неименованной группы, метод возвращает строковое представление числа. Например, если `i` равен 1, метод возвращает «1». Если `i` не является числом захваченной группы, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Если найдено соответствие шаблону, то значение, возвращаемое этим методом, можно затем использовать для получения объекта <xref:System.Text.RegularExpressions.Group>, который представляет захваченную группу из свойства <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>. Объект <xref:System.Text.RegularExpressions.GroupCollection> возвращается свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере определяется шаблон регулярного выражения, который соответствует строке адреса, содержащей название города США, имя штата и почтовый индекс. В примере используется метод <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> для получения имен захваченных групп. Затем эти имена используются для получения соответствующих захваченных групп для совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Совпадение с одним или несколькими символами алфавита или пробелами. Назначить этой захваченной группе имя `city`.|  
|`,`|Совпадение с запятой (,), за которым следует пробельный символ.|  
|`(?<state>[A-Za-z]{2})`|Совпадение с двумя алфавитными символами. Назначить этой захваченной группе имя `state`. За этой группой должен следовать символ пробела.|  
|`(?<zip>\d{5}(-\d{4})?)`|Совпадение с пятью числовыми цифрами, за которыми следует ноль или одно вхождение дефиса, за которым следуют четыре цифры. Назначить этой захваченной группе имя `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя группы для преобразования в соответствующий номер группы.</param>
        <summary>Возвращает номер группы, соответствующий указанному имени группы.</summary>
        <returns>Номер группы, соответствующий указанному имени группы, или -1, если <paramref name="name" /> является недопустимым именем группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные группы записи, которые выделяют части выражения в соответствии с шаблоном. Нумерованные группы разделяются синтаксисом (*часть выражения*) и присваиваются числа на основе их порядка в регулярном выражении. Именованные группы разделяются синтаксисом (?`<`*имя*`>`*часть выражения*) или (?) *Name*"*часть выражения*", где *Name* — имя, по которому будет идентифицирована часть выражения. (Дополнительные сведения см. в разделе [конструкции группирования](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Метод <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> определяет как именованные группы, так и нумерованные группы по их порядковым позициям в регулярном выражении. Нулевое значение порядкового номера всегда представляет собой полное регулярное выражение. Затем все пронумерованные группы подсчитываются до именованных групп, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `name` является строковым представлением номера группы, присутствующего в шаблоне регулярного выражения, метод возвращает это число. Если `name` соответствует именованной группе записи, представленной в шаблоне регулярного выражения, метод возвращает соответствующее ему число. При сравнении `name` с именем группы учитывается регистр. Если `name` не соответствует имени захваченной группы или строковому представлению номера группы записи, метод возвращает значение-1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для операции сравнения с шаблоном не используется конечное время ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор класса <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> и ряд статических методов сопоставления используют константу <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, чтобы указать, что попытка найти соответствие шаблону не должна превышать истечение времени ожидания.  
  
> [!WARNING]
>  Установка значения времени ожидания для обработчика регулярных выражений на <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> может привести к тому, что регулярные выражения, зависящие от избыточного поиска с возвратом, перестают отвечать на запросы при обработке текста, который почти соответствует шаблону регулярного выражения. При отключении времени ожидания следует убедиться, что регулярное выражение не зависит от избыточного поиска с возвратом и обрабатывает текст, который почти соответствует шаблону регулярного выражения.  
>   
>  Дополнительные сведения об обработке поиска с возвратом см. в разделе Поиск с [возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Константа <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> может быть представлена в качестве значения аргумента `matchTimeout` следующих членов:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ссылки уже инициализированы.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Максимальное время, которое может пройти в операции сравнения с шаблоном перед истечением срока ожидания операции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает на то, обнаруживает ли регулярное выражение соответствие во входной строке.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции, вызовите метод <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Расположение символа, с которого необходимо начать поиск.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие (начинающееся с указанной позиции в этой строке) регулярному выражению, заданному в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции, вызовите метод <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> для определения, является ли строка допустимым номером части. Он ищет номер части, следующий за двоеточием (:) символ в строке. Метод <xref:System.String.IndexOf%28System.Char%29> используется для определения позиции символа двоеточия, который затем передается методу <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции, вызовите метод <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A>.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданным в `pattern` и вызовом метода экземпляра <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Совпадение с одним алфавитным символом (`a` с помощью `z` или `A` через `Z`) или числового символа.|  
|`$`|Конец совпадения в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для проверки соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, используя указанные параметры сопоставления.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции, вызовите метод <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A>.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданным в `pattern`, и параметрами регулярных выражений, заданными `options` и вызова метода экземпляра <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> с параметром `options`, для которого задано значение <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, эквивалентно определению следующего регулярного выражения:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения см. пример для метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для проверки соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, с помощью указанных параметров сопоставления и интервала времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если регулярное выражение обнаруживает соответствие; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> обычно используется для проверки строки или для обеспечения соответствия строки определенному шаблону без извлечения этой строки для последующей манипуляции. Если необходимо определить, соответствует ли одна или несколько строк шаблону регулярного выражения, а затем извлечь их для последующей манипуляции, вызовите метод <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A>.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с шаблоном регулярного выражения, заданным в `pattern`, и параметрами регулярных выражений, заданными `options` и вызова метода экземпляра <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> для определения, является ли строка допустимым номером части. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, содержащий четыре символа, должен состоять из буквенно-цифрового символа, за которым следуют два цифровых символа, за которыми следует буквенно-цифровой символ. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен содержать три цифровых символа, за которыми следует буквенно-цифровой символ. Сопоставление шаблона регулярного выражения должно производиться с минимальным поиском во входной строке, поэтому метод устанавливает интервал времени ожидания 500 миллисекунд.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`\d{2}`|Совпадение с двумя числовыми символами.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно трех числовых символов.|  
|`(-\d{3}){2}`|Найдите дефис, за которым следуют три числовых символа, и сопоставьте два вхождения этого шаблона.|  
|`[A-Z0-9]`|Совпадение с любым одиночным буквенным символом от `A` до `Z`или любого числового символа.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> с параметром `options`, для которого задано значение <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, эквивалентно определению следующего регулярного выражения:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения см. пример для метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит во входной строке подстроку, совпадающую с шаблоном регулярного выражения, и возвращает первое вхождение в качестве единого объекта <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке первое вхождение регулярного выражения, указанного в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input`, которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> возвращенного <xref:System.Text.RegularExpressions.Match> объекта. Можно также получить все совпадения в одном вызове метода, вызвав метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере выполняется поиск совпадений шаблона регулярного выражения в строке, а затем выводятся соответствующие группы, записи и позиции записи.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Шаблон регулярного выражения `(\w+)\s+(car)` сопоставляет вхождения слова «автомобиль» и предшествующее ему слово. Он интерпретируется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|`\s+`|Совпадение с одним или несколькими символами пробела.|  
|автомобиле|Совпадение со строкой литерала "Car". Это вторая группа записи.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Отсчитываемая от нуля позиция символа, с которой начинается поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения, начиная с позиции `startat` символа во входной строке или после нее. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого выполняется поиск <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> метода, определяется вызовом одного из конструкторов классов <xref:System.Text.RegularExpressions.Regex>. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 При необходимости можно указать начальную точку в строке с помощью параметра `startat`. Когда обработчик регулярных выражений выполняет синтаксический анализ слева направо (по умолчанию), сопоставление и просмотр перемещаются правее, начиная с символа, указанного в `startat`. Когда обработчик регулярных выражений выполняет синтаксический анализ справа налево (если шаблон регулярного выражения создается с параметром <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>), сопоставление и сканирование перемещаются в обратном направлении и начинаются с символа, который находится в `startat`-1. Если не указать начальную точку, поиск начинается с позиции `startat` по умолчанию. Если регулярное выражение выполняет поиск слева направо, то `startat` по умолчанию находится слева от `input`; Если выполняется поиск справа налево, то `startat` по умолчанию находится справа от `input`.  
  
 Если необходимо ограничить соответствие, чтобы оно начиналось с определенной позиции символа в строке, а обработчик регулярных выражений не проверял остаток строки на соответствие, закрепите регулярное выражение с `\G` (слева для шаблона слева направо или справа для шаблона с письмом справа налево). Это ограничит совпадение так, что оно должно начинаться ровно `startat`.  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в или после `startat` позиции символа в `input`, соответствующей шаблону регулярного выражения. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> возвращенного <xref:System.Text.RegularExpressions.Match> объекта. Можно также получить все совпадения в одном вызове метода, вызвав метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке первое вхождение заданного регулярного выражения.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метод эквивалентен созданию объекта <xref:System.Text.RegularExpressions.Regex> с указанным шаблоном регулярного выражения и вызовом метода <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> экземпляра. В этом случае обработчик регулярных выражений кэширует шаблон регулярного выражения.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input`, которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> возвращенного <xref:System.Text.RegularExpressions.Match> объекта. Можно также получить все совпадения в одном вызове метода, вызвав метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> для поиска первого слова, содержащего хотя бы один `z` символ, а затем вызывает метод <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> для поиска дополнительных совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b\w*z+\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`z+`|Совпадение с одним или несколькими вхождениями `z` символа.|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для получения соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет задать интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="beginning">Отсчитываемая от нуля позиция символа во входной строке, определяющая самую левую позицию диапазона поиска.</param>
        <param name="length">Количество символов в подстроке для включения в поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции и выполняя поиск только по указанному количеству символов.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения в части входной строки. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого выполняется поиск <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> метода, определяется вызовом одного из конструкторов классов <xref:System.Text.RegularExpressions.Regex>. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> ищет часть `input`, определяемую параметрами `beginning` и `length` для шаблона регулярного выражения. `beginning` всегда определяет индекс крайнего левого символа, включаемого в поиск, а `length` определяет максимальное число символов для поиска. Вместе они определяют диапазон поиска. Если поиск продолжается слева направо (по умолчанию), обработчик регулярных выражений выполняет поиск из символа в индексе `beginning` символу по индексу `beginning` + `length`-1. Если экземпляр обработчика регулярных выражений был создан с помощью параметра <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>, чтобы поиск осуществлялся справа налево, обработчик регулярных выражений выполняет поиск из символа в индексе `beginning` + `length`-1 в символ в индексе `beginning`. Этот метод возвращает первое совпадение, найденное в этом диапазоне. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> возвращенного <xref:System.Text.RegularExpressions.Match> объекта.  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать значение времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="beginning" /> меньше нуля или больше длины параметра <paramref name="input" />.  
  
-или- 
 Значение параметра <paramref name="length" /> меньше нуля или больше длины параметра <paramref name="input" />.  
  
-или- 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> указывает положение, вне диапазона <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с помощью конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> и вызовом метода <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> экземпляра.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input`, которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A> возвращенного <xref:System.Text.RegularExpressions.Match> объекта. Можно также получить все совпадения в одном вызове метода, вызвав метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции сопоставления превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, которое соответствует словам, начинающимся с буквы "a". В нем используется параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, чтобы гарантировать, что регулярное выражение находит слова, начинающиеся с прописной буквы "a" и строчной буквы "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Возможные интерпретации шаблона регулярного выражения `\ba\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`a`|Совпадение с символом "a".|  
|`\w*`|Совпадение с нулем, одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для получения соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет задать интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> возвращает первую подстроку, которая соответствует шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемых для создания шаблона регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод эквивалентен созданию <xref:System.Text.RegularExpressions.Regex> объекта с помощью конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> и вызовом метода <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> экземпляра.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Чтобы определить, найден ли шаблон регулярного выражения во входной строке, проверьте значение свойства <xref:System.Text.RegularExpressions.Group.Success%2A> возвращаемого объекта <xref:System.Text.RegularExpressions.Match>. Если найдено совпадение, возвращаемое свойство <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> содержит подстроку из `input`, которая соответствует шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input`, которая соответствует шаблону регулярного выражения. Последующие совпадения можно получить путем повторного вызова метода <xref:System.Text.RegularExpressions.Match.NextMatch%2A> возвращенного <xref:System.Text.RegularExpressions.Match> объекта. Можно также получить все совпадения в одном вызове метода, вызвав метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ищет во входной строке все вхождения регулярного выражения и возвращает все соответствия.</summary>
        <block subset="none" type="usage"><para>При повторении попытки сопоставления путем вызова метода <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> механизм регулярных выражений выдает пустое соответствие. Обычно обработчик регулярных выражений начинает поиск следующего совпадения в том месте, где было слева предыдущее совпадение. Однако после пустого совпадения обработчик регулярных выражений перемещается на один символ перед попыткой следующего совпадения. Такое поведение гарантирует, что обработчик регулярных выражений будет проходить через строку. В противном случае, поскольку пустое соответствие не приводит к перемещению вперед, следующее совпадение будет начинаться точно так же, как и предыдущее совпадение, и при этом одна и та же пустая строка будет сопоставлена повторно.  
  
В следующем примере шаблон регулярного выражения <c>а *</c> ищет ноль или более вхождений буквы "a" в строке "абаабб". Как видно из выходных данных примера, полученный объект <see cref="T:System.Text.RegularExpressions.MatchCollection" /> содержит шесть объектов <see cref="T:System.Text.RegularExpressions.Match" />. Первая попыток соответствия находит первый "a". Второе совпадение начинается точно там, где заканчивается первое соответствие, перед первым b; Он находит нулевые вхождения "a" и возвращает пустую строку. Третье соответствие не начинается точно там, где заканчивается второе соответствие, поскольку второе совпадение вернуло пустую строку. Вместо этого он начинается с одного символа позже, после первого "b". Третье совпадение находит два вхождения "a" и возвращает "AA". Четвертая попыток соответствия начинается с того места, где заканчивается третье соответствие, перед вторым "b" и возвращает пустую строку. В пятой попытке сопоставления один символ передается, чтобы он начинался перед третьим "b", и возвращает пустую строку. Шестое совпадение начинается после последней "b" и снова возвращает пустую строку.  
  
[! код-CSharp[System. Text. RegularExpressions. Regex. соответствует # 9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! код-VB[System. Text. RegularExpressions. Regex. соответствует # 9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Коллекция включает только соответствия и завершается в первом несовпадении.  
  
 Шаблон регулярного выражения, для которого выполняется поиск <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метода, определяется вызовом одного из конструкторов классов <xref:System.Text.RegularExpressions.Regex>. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> использует отложенное вычисление для заполнения возвращаемого объекта <xref:System.Text.RegularExpressions.MatchCollection>. Доступ к членам этой коллекции, например <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>, приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, например `foreach` C# в и `For Each`...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> не вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Однако исключение возникает при выполнении операции над объектом <xref:System.Text.RegularExpressions.MatchCollection>, возвращаемым этим методом, если свойство <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> не <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и операция сопоставления превышает интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> используется для обнаружения слов в предложении, заканчивающемся на «ES».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Позиция символа во входной строке, с которой необходимо начать поиск.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Шаблон регулярного выражения, для которого выполняется поиск <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метода, определяется вызовом одного из конструкторов классов <xref:System.Text.RegularExpressions.Regex>. Дополнительные сведения об элементах, которые могут формировать шаблон регулярного выражения, см. в разделе [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> использует отложенное вычисление для заполнения возвращаемого объекта <xref:System.Text.RegularExpressions.MatchCollection>. Доступ к членам этой коллекции, например <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>, приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, например `foreach` C# в и `For Each`...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> не вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Однако исключение возникает при выполнении операции над объектом <xref:System.Text.RegularExpressions.MatchCollection>, возвращаемым этим методом, если свойство <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> не <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и операция сопоставления превышает интервал времени ожидания. 
  
   
  
## Examples  
 В следующем примере метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> используется для поиска первого слова в предложении, которое заканчивается на "ES", а затем вызывает метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> для определения дополнительных слов, заканчивающихся на "ES".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Matches`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> использует отложенное вычисление для заполнения возвращаемого объекта <xref:System.Text.RegularExpressions.MatchCollection>. Доступ к членам этой коллекции, например <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>, приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, например `foreach` C# в и `For Each`...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> не вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Однако исключение возникает при выполнении операции над объектом <xref:System.Text.RegularExpressions.MatchCollection>, возвращаемым этим методом, если интервал времени ожидания определяется свойством "REGEX_DEFAULT_MATCH_TIMEOUT" текущего домена приложения, а операция сопоставления превышает этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> для обнаружения любого слова в предложении, которое заканчивается на "ES".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для получения нескольких совпадений шаблонов рекомендуется использовать статический метод, <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет указать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Matches`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> использует отложенное вычисление для заполнения возвращаемого объекта <xref:System.Text.RegularExpressions.MatchCollection>. Доступ к членам этой коллекции, например <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>, приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, например `foreach` C# в и `For Each`...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> не вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Однако исключение возникает при выполнении операции над объектом <xref:System.Text.RegularExpressions.MatchCollection>, возвращаемым этим методом, если интервал времени ожидания определяется свойством "REGEX_DEFAULT_MATCH_TIMEOUT" текущего домена приложения, а операция сопоставления превышает этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> для обнаружения любого слова в предложении, заканчивающемся на «ES», а затем вызывается метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> для выполнения сравнения шаблона со входной строкой без учета регистра. Как видно из выходных данных, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для получения нескольких совпадений шаблонов рекомендуется использовать статический метод, <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Коллекция объектов <see cref="T:System.Text.RegularExpressions.Match" />, найденных при поиске. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>, за исключением того, что он возвращает сведения обо всех совпадениях, найденных во входной строке, а не на одном совпадении. Он эквивалентен следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Статические `Matches` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Matches`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Метод <xref:System.Text.RegularExpressions.Regex.Matches%2A> использует отложенное вычисление для заполнения возвращаемого объекта <xref:System.Text.RegularExpressions.MatchCollection>. Доступ к членам этой коллекции, например <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType>, приводит к немедленному заполнению коллекции. Чтобы воспользоваться преимуществами отложенного вычисления, необходимо выполнить итерацию коллекции, используя конструкцию, например `foreach` C# в и `For Each`...`Next` в Visual Basic.  
  
 Из-за отложенного вычисления вызов метода <xref:System.Text.RegularExpressions.Regex.Matches%2A> не вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Однако при выполнении операции над объектом <xref:System.Text.RegularExpressions.MatchCollection>, возвращенным этим методом, возникает исключение, если операция сопоставления превышает этот интервал времени ожидания, заданный параметром`matchTimeout`.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> для выполнения сравнения с учетом регистра, совпадающего с любым словом в предложении, заканчивающемся на «ES». Затем вызывается метод <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> для выполнения сравнения шаблона со входной строкой без учета регистра. В обоих случаях интервал времени ожидания устанавливается равным одной секунде. Как видно из выходных данных, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение со строкой литерала "ES".|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает интервал времени ожидания текущего экземпляра.</summary>
        <value>Максимальный интервал времени, который может пройти в операции сравнения с шаблоном, прежде чем возникнет исключение <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />, или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, если контроль времени ожидания отключен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> определяет приблизительный максимальный интервал времени, в течение которого экземпляр <xref:System.Text.RegularExpressions.Regex> выполняет одну операцию сопоставления до истечения времени ожидания операции. Обработчик регулярных выражений создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> во время следующей проверки по времени после истечения интервала времени ожидания. Это предотвращает обработку обработчиком регулярных выражений входных строк, требующих избыточного поиска с возвратом. Дополнительные сведения см. в разделе Поиск с [возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md) и рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 Это свойство доступно только для чтения. Его значение можно задать явно для отдельного объекта <xref:System.Text.RegularExpressions.Regex>, вызвав конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Кроме того, можно задать его значение для всех <xref:System.Text.RegularExpressions.Regex> совпадающих операций в домене приложения, вызвав метод <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> и указав значение <xref:System.TimeSpan> для свойства "REGEX_DEFAULT_MATCH_TIMEOUT", как показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Если не задать явно интервал времени ожидания, используется значение по умолчанию <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, а операции сопоставления не истечения времени ожидания.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает параметр, которые были переданы в конструктор <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Один или несколько членов перечисления <see cref="T:System.Text.RegularExpressions.RegexOptions" />, представляющих параметры, переданные в конструктор <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Text.RegularExpressions.Regex.Options%2A> состоит из одного или нескольких элементов перечисления <xref:System.Text.RegularExpressions.RegexOptions>. Если в конструкторе класса <xref:System.Text.RegularExpressions.Regex> не определены никакие параметры, его значение равно <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Доступные параметры подробно описаны в разделе [Параметры регулярных выражений](~/docs/standard/base-types/regular-expression-options.md) .  
  
 Обратите внимание, что свойство <xref:System.Text.RegularExpressions.Regex.Options%2A> не отражает встроенные параметры, определенные в самом шаблоне регулярного выражения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданных методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />. Эти скомпилированные регулярные выражения используют реализацию базового класса для свойства <see cref="P:System.Text.RegularExpressions.Regex.Options" />. При вызове из производного класса свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Возвращает параметры, которые были переданы в параметр <paramref name="options" /> конструктора класса <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />, который использовался для определения регулярного выражения.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Параметры регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>В указанной входной строке заменяет строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка для замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале строки `input`. Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>.  
  
 Параметр `replacement` указывает строку, которая будет заменять каждое совпадение в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\s+`, соответствующее одному или нескольким символам пробела. Строка замены "" заменяет их одним символом пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 В следующем примере определяется регулярное выражение, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`и шаблон замены, `$2`, который удаляет из числового значения либо начальный, либо завершающий символ валюты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\p{Sc}`|Совпадение с символом валюты. `{Sc}` обозначает любой символ, который является членом символа Юникода, категории Currency.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{Sc}\s?)?`|Совпадение с нулем или одним вхождением сочетания символа валюты, за которым следует ноль или один символ пробела. Это первая группа записи.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\.?`|Совпадение с нулем или одним вхождением точки (используется в качестве символа десятичного разделителя).|  
|`((?<=\.)\d+)?`|Если точка является предыдущим символом, соответствует одной или нескольким десятичным цифрам. Этот шаблон можно сопоставить с нулем или один раз.|  
|`(\d+\.?((?<=\.)\d+)?)`|Соответствует шаблону из одной или нескольких десятичных цифр, за которыми следует необязательная точка и дополнительные десятичные цифры. Это вторая группа записи. Вызов метода <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> заменяет все совпадение значением этой захваченной группы.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Если первая захваченная группа существует, соответствует пустой строке. В противном случае соответствует нулю или одному символу пробела, за которым следует символ валюты.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> и передаче каждого объекта <xref:System.Text.RegularExpressions.Match> в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции в делегат `evaluator`.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>.  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере кода отображается исходная строка, соответствующая каждому слову в исходной строке, преобразует первый символ каждого совпадения в верхний регистр, а затем отображает преобразованную строку.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка для замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в начале строки `input`. Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, все совпадения заменяются.  
  
 Параметр `replacement` указывает строку, которая будет заменять первый `count` совпадений в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере первые пять вхождений повторяющихся символов заменяются одним символом. Шаблон регулярного выражения `(\w)\1` сопоставляет последовательные вхождения одного символа и назначает первое вхождение первой группе записи. Шаблон замены `$1` заменяет все совпадения первой захваченной группой.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка для замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Replace`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Поиск соответствий начинается в начале строки `input`.  
  
 Параметр `replacement` указывает строку, которая будет заменять каждое совпадение в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение `\s+`, соответствующее одному или нескольким символам пробела. Строка замены "" заменяет их одним символом пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 В следующем примере используется метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует свойство <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> для включения имени локального компьютера, а метод <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> — для включения имен логических дисков. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Совпадение двух последовательных символов обратной косой черты (`\`). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`(?i:" + Environment.MachineName + ")`|Выполните поиск строки, возвращаемой свойством <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>, без учета регистра.|  
|`(?:\.\w+)*`|Соответствует символу периода (`.`), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`|Совпадение с символом обратной косой черты (`\`).|  
|`((?i:[" + driveNames + "]))`|Выполните сопоставление класса символов без учета регистра, состоящего из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Соответствует литеральному знаку доллара (`$`).|  
  
 Шаблон замены `$1` заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для замены соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> и передаче каждого объекта <xref:System.Text.RegularExpressions.Match> в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции в делегат `evaluator`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется делегат <xref:System.Text.RegularExpressions.MatchEvaluator> для вызова метода с именем `WordScramble`, который шифрует отдельные буквы в слове. Для этого метод `WordScramble` создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова метода <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>, а упорядоченный массив предоставляется в качестве аргумента конструктору <xref:System.String> класса. После этого вновь созданная строка возвращается методом `WordScramble`. Шаблон регулярного выражения `\w+` соответствует одному или нескольким символам слова; обработчик регулярных выражений будет по-прежнему добавлять символы к совпадению до тех пор, пока не встретится символ, не являющийся буквой, например символ пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для вычисления и замены соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> и передаче первого объекта `count`<xref:System.Text.RegularExpressions.Match> в возвращаемую коллекцию <xref:System.Text.RegularExpressions.MatchCollection> в делегат `evaluator`.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>.  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере регулярное выражение используется для намеренного написания недопустимых частей слов в списке. Он использует регулярное выражение `\w*(ie|ei)\w*` для сопоставления слов, содержащих символы "IE" или "EI". Он передает первую половину соответствующих слов в метод `ReverseLetter`, который, в свою очередь, использует метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>, чтобы обратить "i" и "e" в соответствующей строке. Остальные слова останутся без изменений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Определение регулярного выражения `\w*(ie|ei)\w*` показано в таблице ниже.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
|<code>(ie&#124;ei)</code>|Совпадение с "IE" или "EI".|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
  
 Шаблон регулярного выражения, `([ie])([ie])` в методе `ReverseLetter`, соответствует первому символу "i" или "e" в дифсонг "IE" или "EI" и назначает букву первой захваченной группе. Он соответствует второму символу "i" или "e" и назначает букву второй группе записи. Затем два символа меняются местами, вызывая метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> с шаблоном замены `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка для замены.</param>
        <param name="count">Максимальное возможное количество случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск соответствий начинается в строке `input` в позиции, указанной параметром `startat`. Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, все совпадения заменяются.  
  
 Параметр `replacement` указывает строку, которая будет заменять каждое совпадение в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере два пробела, кроме первой строки строки. Он определяет шаблон регулярного выражения, `^.*$`, который соответствует строке текста, вызывает метод <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> для сопоставления первой строки строки и использует свойства `Match.Index` и `Match.Count`, чтобы определить начальную точку второй строки.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Шаблон регулярного выражения `^.*$` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Соответствует началу строки. (Обратите внимание, что экземпляр объекта <xref:System.Text.RegularExpressions.Regex> был создан с помощью параметра <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>. в противном случае этот класс символов будет соответствовать только началу входной строки.)|  
|`.*`|Соответствует любому символу ноль или более раз.|  
|`$`|Совпадение с концом строки. (Обратите внимание, что экземпляр объекта <xref:System.Text.RegularExpressions.Regex> был создан с помощью параметра <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>. в противном случае этот класс символов будет соответствовать только началу входной строки.)|  
  
 Строка замены (`vbCrLf + "$&"` в Visual Basic, `"\n$&"` в C#) добавляет новую строку перед совпадающей строкой. Обратите внимание, что C# `\n` в примере интерпретируется C# компилятором как символ новой строки. Он не представляет escape-последовательность символов регулярного выражения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка для замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Replace`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Если для параметра `options` указано <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается в начале входной строки и перемещается вправо.  
  
 Параметр `replacement` указывает строку, которая будет заменять каждое совпадение в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует свойство <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> для включения имени локального компьютера, а метод <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> — для включения имен логических дисков. При сравнении строк регулярного выражения регистр не учитывается. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Совпадение двух последовательных символов обратной косой черты (`\`). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадение со строкой, возвращаемой свойством <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>.|  
|`(?:\.\w+)*`|Соответствует символу периода (`.`), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`|Совпадение с символом обратной косой черты (`\`).|  
|`([" + driveNames + "])`|Соответствует классу символов, который состоит из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Соответствует литеральному знаку доллара (`$`).|  
  
 Шаблон замены `$1` заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает после интервала, который равен значению времени ожидания по умолчанию для домена приложения, в котором он вызывается. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для замены соответствия шаблону рекомендуется использовать статический метод <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения в, если выполняется любое из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> и передаче каждого объекта <xref:System.Text.RegularExpressions.Match> в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции в делегат `evaluator`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Если для параметра `options` указано <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается в начале входной строки и перемещается вправо.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется делегат <xref:System.Text.RegularExpressions.MatchEvaluator> для вызова метода с именем `WordScramble`, который шифрует отдельные буквы в слове. Для этого метод `WordScramble` создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова метода <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>, а упорядоченный массив предоставляется в качестве аргумента конструктору <xref:System.String> класса. После этого вновь созданная строка возвращается методом `WordScramble`. Шаблон регулярного выражения `\w+` соответствует одному или нескольким символам слова; обработчик регулярных выражений будет по-прежнему добавлять символы к совпадению до тех пор, пока не встретится символ, не являющийся буквой, например символ пробела. Вызов метода <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> включает параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` игнорируется обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяется указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Замещающая строка не может быть задается шаблоном замены регулярных выражений.  
  
-   Строка замены, полученная в результате некоторой обработки в сопоставленной строке.  
  
-   Строка замены, полученная в результате условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> и передаче первого объекта `count`<xref:System.Text.RegularExpressions.Match> в возвращаемую коллекцию <xref:System.Text.RegularExpressions.MatchCollection> в делегат `evaluator`.  
  
 Регулярное выражение — это шаблон, определяемый конструктором для текущего объекта <xref:System.Text.RegularExpressions.Regex>.  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции замены превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка для замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические `Replace` методы эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> объекта с указанным шаблоном регулярного выражения и вызовом метода экземпляра `Replace`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Если для параметра `options` указано <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается в начале входной строки и перемещается вправо.  
  
 Параметр `replacement` указывает строку, которая будет заменять каждое совпадение в `input`. `replacement` может состоять из любого сочетания литерального текста и [подстановки](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку "a *", за которой следует подстрока, совпадающая с `test` группой записи, если она есть, за которой следует строка "b". Символ * не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это единственные элементы языка регулярных выражений, распознаваемые в шаблоне замены. Все остальные элементы языка регулярных выражений, включая [escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допускаются только в шаблонах регулярных выражений и не распознаются в шаблонах замены.  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> для замены имен локальных компьютеров и дисков в UNC-пути локальным путем к файлу. Регулярное выражение использует свойство <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> для включения имени локального компьютера и метода <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> для включения имен логических дисков. Все сравнения строк регулярного выражения не чувствительны к регистру и время ожидания одной операции замены, если соответствие не найдено в течение 0,5 секунды. Для успешного выполнения примера необходимо заменить литеральную строку "Мойкомпьютер" на имя локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Шаблон регулярного выражения определяется следующим выражением:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Совпадение двух последовательных символов обратной косой черты (`\`). Поскольку символ обратной косой черты интерпретируется как escape-символ, каждая обратная косая черта должна быть экранирована другой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадение со строкой, возвращаемой свойством <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>.|  
|`(?:\.\w+)*`|Соответствует символу периода (`.`), за которым следует один или несколько символов слова. Это совпадение может встретиться ноль или более раз. Сопоставленная часть выражения не фиксируется.|  
|`\\`|Совпадение с символом обратной косой черты (`\`).|  
|`([" + driveNames + "])`|Соответствует классу символов, который состоит из отдельных букв диска. Это совпадение является первой захваченной частью выражения.|  
|`\$`|Соответствует литеральному знаку доллара (`$`).|  
  
 Шаблон замены `$1` заменяет все совпадения первой захваченной частью выражения. То есть имя компьютера и диска в формате UNC заменяет букву диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющих параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все подстроки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> удобен для замены соответствия регулярного выражения, если выполняется одно из следующих условий.  
  
-   Если замещающая строка не может быть задана шаблоном регулярного выражения.  
  
-   Значение, если строка замены является результатом некоторой обработки, выполненной с соответствующей строкой.  
  
-   Значение, если строка замены является результатом условной обработки.  
  
 Метод эквивалентен вызову метода <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> и передаче каждого объекта <xref:System.Text.RegularExpressions.Match> в возвращенной <xref:System.Text.RegularExpressions.MatchCollection> коллекции в делегат `evaluator`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Параметр `evaluator` является делегатом для настраиваемого метода, который определяется и проверяет каждое совпадение. Пользовательский метод должен иметь следующую сигнатуру для сопоставления с делегатом <xref:System.Text.RegularExpressions.MatchEvaluator>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет найденные входные данные.  
  
 Если для параметра `options` указано <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>, Поиск соответствий начинается в конце входной строки и перемещается влево; в противном случае поиск начинается в начале входной строки и перемещается вправо.  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания позволяет предотвратить появление в регулярных выражениях, которые полагаются на избыточное средство поиска с возвратом, перестают отвечать при обработке входных данных, содержащих близких соответствий. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 Поскольку метод возвращает `input` без изменений, если совпадений нет, можно использовать метод <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>, чтобы определить, выполнил ли метод какие-либо замены во входной строке.  
  
   
  
## Examples  
 В следующем примере используется регулярное выражение для извлечения отдельных слов из строки, а затем используется делегат <xref:System.Text.RegularExpressions.MatchEvaluator> для вызова метода с именем `WordScramble`, который шифрует отдельные буквы в слове. Для этого метод `WordScramble` создает массив, содержащий символы в совпадении. Он также создает параллельный массив, который заполняется случайными числами с плавающей запятой. Массивы сортируются путем вызова метода <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>, а упорядоченный массив предоставляется в качестве аргумента конструктору <xref:System.String> класса. После этого вновь созданная строка возвращается методом `WordScramble`. Шаблон регулярного выражения `\w+` соответствует одному или нескольким символам слова; обработчик регулярных выражений будет по-прежнему добавлять символы к совпадению до тех пор, пока не встретится символ, не являющийся буквой, например символ пробела. Вызов метода <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> включает параметр <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` игнорируется обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее на то, выполняется ли регулярным выражением поиск справа налево.</summary>
        <value>Значение <see langword="true" />, если регулярное выражение выполняет поиск справа налево; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> `true`, если экземпляр <xref:System.Text.RegularExpressions.Regex> был создан с помощью параметра <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Разделяет входную строку на массив подстрок в месте, определенном совпадением с регулярным выражением.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной входной строкой.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон регулярного выражения используется `\d+` для разделения входной строки на числовые символы. Поскольку строка начинается и заканчивается соответствующими числовыми символами, значение первого и последнего элементов возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются круглые скобки, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. Например:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Обратите внимание, что возвращаемый массив также содержит пустую строку в начале и в конце массива.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%2A?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Параметр `count` задает максимальное число подстрок, в которые может быть разбита строка `input`. Последняя строка содержит неразделенную оставшуюся часть строки. Значение `count`, равное нулю, обеспечивает поведение по умолчанию при разделении столько раз, сколько возможно.  
  
 Если несколько совпадений находятся рядом друг с другом или если в начале или в конце `input`найдено совпадение, а количество найденных совпадений составляет по меньшей мере два значения меньше `count`, в массив вставляется пустая строка. Таким образом, пустые строки, являющиеся результатом смежных совпадений или из совпадений в начале или конце входной строки, учитываются при определении того, равно ли число сопоставленных подстрок `count`. В следующем примере регулярное выражение `/d+` используется для разбиения входной строки, включающей одну или несколько десятичных цифр, в максимум три подстроки. Поскольку начало входной строки соответствует шаблону регулярного выражения, первый элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>, второй — Первый набор алфавитных символов во входной строке, а третий — остаток строки, следующий за третьим совпадением.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Если в регулярном выражении используются скобки записи, любой захваченный текст включается в массив разделенных строк. Однако все элементы массива, содержащие захваченный текст, не учитываются при определении того, достигнуто ли число совпадений `count`. Например, при разделении строки "Apple-Априкот-Плам-груш-" в максимум четыре подстроки создается массив из семи элементов, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1 в возвращаемый массив включается только захваченный текст из первого набора скобок записи. Начиная с .NET Framework 2,0, весь захваченный текст добавляется в возвращаемый массив. Однако элементы в возвращаемом массиве, содержащие захваченный текст, не учитываются при определении того, равно ли число сопоставленных подстрок `count`. Например, в следующем коде регулярное выражение использует два набора скобок записи для извлечения элементов даты из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Затем при вызове метода <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> в возвращаемом массиве указывается не более двух элементов. Если пример кода компилируется и выполняется в .NET Framework 1,0 или 1,1, метод возвращает массив строк из двух элементов. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, метод возвращает массив строк из трех элементов.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. В следующем примере строка "символы" разбивается на столько элементов, сколько есть во входной строке. Поскольку строка NULL соответствует началу входной строки, в начало возвращаемого массива вставляется пустая строка. В результате десятый элемент будет состоять из двух символов в конце входной строки.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%2A?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Строка `input` разделяется столько раз, сколько возможно. Если `pattern` не найден в строке `input`, возвращаемое значение содержит один элемент, значение которого является исходной строкой `input`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Чтобы самостоятельно управлять временем существования скомпилированных регулярных выражений, используйте методы экземпляра <xref:System.Text.RegularExpressions.Regex.Split%2A>.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон регулярного выражения используется `\d+` для разделения входной строки на числовые символы. Поскольку строка начинается и заканчивается соответствующими числовыми символами, значение первого и последнего элементов возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются круглые скобки, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%2A> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. Например:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Обратите внимание, что возвращаемый массив также содержит пустую строку в начале и в конце массива.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для разделения текста в шаблоне рекомендуется использовать статический метод, <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в конструкторе <see cref="T:System.Text.RegularExpressions.Regex" />. Поиск шаблона регулярного выражения начинается с указанной позиции элемента во входной строке.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%2A?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Параметр `count` указывает максимальное число подстрок, в которых разбивается `input` строка. Последняя строка содержит неразделенную оставшуюся часть строки. Значение `count`, равное нулю, обеспечивает поведение по умолчанию при разделении столько раз, сколько возможно. Параметр `startat` определяет точку, в которой начинается поиск первого разделителя (он может использоваться для пропуска начальных пробелов).  
  
 Если в строке `count`+ 1 не найдено совпадений, метод возвращает одноэлементный массив, содержащий `input` строку. Если найдено одно или несколько совпадений, первый элемент возвращаемого массива содержит первую часть строки из первого символа до одного символа перед совпадением.  
  
 Если несколько совпадений находятся рядом друг с другом, а количество найденных совпадений составляет по крайней мере два значения меньше `count`, в массив вставляется пустая строка. Аналогично, если найдено совпадение в `startat`, которое является первым символом в строке, первый элемент возвращаемого массива является пустой строкой. Таким образом, пустые строки, являющиеся результатом смежных совпадений, учитываются при определении того, соответствует ли число сопоставленных подстрок `count`. В следующем примере регулярное выражение `\d+` используется для поиска начальной позиции первой подстроки числовых символов в строке, а затем для разделения строки до трех раз, начиная с этой позиции. Так как шаблон регулярного выражения соответствует началу входной строки, возвращаемый массив строк состоит из пустой строки, алфавитной строки из пяти символов и оставшейся части строки.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Если в регулярном выражении используются скобки записи, любой захваченный текст включается в массив разделенных строк. Однако все элементы массива, содержащие захваченный текст, не учитываются при определении того, достигнуто ли число совпадений `count`. Например, разбиение строки "" Apple-Априкот-Плам-груш-граната-ананас-печь "в максимум четыре подстроки, начиная с символа 15 в строке, приводит к последующему массиву из семи элементов, как показано в приведенном ниже коде.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения отдельных слов в строке. Первый набор скобок записи захватывает дефис, а второй набор захватывает вертикальную линию. Если пример кода компилируется и запускается под .NET Framework 1,0 или 1,1, он исключает символы вертикальной черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%2A> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении. В следующем примере строка "символы" разбивается на столько элементов, сколько содержит входная строка, начиная с символа "a". Поскольку строка NULL соответствует концу входной строки, в конце возвращаемого массива вставляется пустая строка.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный конструктором <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>. Если не задать интервал времени ожидания при вызове конструктора, исключение создается, если операция превышает любое значение времени ожидания, установленное для домена приложения, в котором создается объект <xref:System.Text.RegularExpressions.Regex>. Если время ожидания не определено в вызове конструктора <xref:System.Text.RegularExpressions.Regex> или в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startat" /> меньше нуля или больше длины параметра <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной строкой `input`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Чтобы самостоятельно управлять временем существования скомпилированных регулярных выражений, используйте методы экземпляра <xref:System.Text.RegularExpressions.Regex.Split%2A>.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса.  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон регулярного выражения используется `[a-z]+` для разбиения входной строки на любой алфавитный символ в верхнем или нижнем регистре. Поскольку строка начинается и заканчивается соответствующими буквами, значение первого и последнего элементов возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются круглые скобки, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%2A> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении.  
  
 Исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> возникает, если время выполнения операции разбиения превышает интервал времени ожидания, заданный для домена приложения, в котором вызывается метод. Если время ожидания не определено в свойствах домена приложения или если значение времени ожидания равно <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Время ожидания этого метода истекает через интервал, равный значению времени ожидания по умолчанию для домена приложения, в котором вызывается метод. Если для домена приложения не определено значение времени ожидания, то используется значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, которое предотвращает истечение времени ожидания для метода. Для разделения текста в шаблоне рекомендуется использовать статический метод, <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет задать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> похожи на метод <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>, за исключением того, что <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разделяет строку по разделителю, определенному регулярным выражением, а не набором символов. Строка разделяется столько раз, сколько возможно. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходной строкой `input`.  
  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах статических <xref:System.Text.RegularExpressions.Regex.Split%2A> методов, кэшируются автоматически. Чтобы самостоятельно управлять временем существования скомпилированных регулярных выражений, используйте методы экземпляра <xref:System.Text.RegularExpressions.Regex.Split%2A>.  
  
 Если несколько совпадений находятся рядом друг с другом, в массив вставляется пустая строка. Например, разбиение строки на один дефис приводит к тому, что возвращаемый массив включает пустую строку в позицию, где обнаружены два смежных дефиса.  
  
 Если совпадение находится в начале или в конце входной строки, то в начале или конце возвращаемого массива включается пустая строка. В следующем примере шаблон регулярного выражения используется `[a-z]+` для разбиения входной строки на любой алфавитный символ в верхнем или нижнем регистре. Поскольку строка начинается и заканчивается соответствующими буквами, значение первого и последнего элементов возвращаемого массива <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Если в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражении используются круглые скобки, любой захваченный текст включается в результирующий массив строк. Например, если разделить строку "Плам-груш" на дефис, помещенный в круглые скобки, возвращаемый массив включает строковый элемент, содержащий дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Однако если шаблон регулярного выражения включает несколько наборов скобок записи, поведение этого метода зависит от версии .NET Framework. В .NET Framework 1,0 и 1,1, если совпадение не найдено в первом наборе скобок записи, записанный текст из дополнительных скобок записи не включается в возвращаемый массив. Начиная с .NET Framework 2,0, весь захваченный текст также добавляется в возвращаемый массив. Например, следующий код использует два набора скобок записи для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи захватывает дефис, а второй набор захватывает косую черту. Если пример кода компилируется и выполняется с .NET Framework 1,0 или 1,1, он исключает символы косой черты. Если он компилируется и запускается в .NET Framework 2,0 или более поздних версиях, он включает их.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может соответствовать пустой строке, <xref:System.Text.RegularExpressions.Regex.Split%2A> разделит строку на массив односимвольных строк, так как разделитель пустых строк можно найти в каждом расположении.  
  
 Параметр `matchTimeout` указывает, как долго метод сопоставления шаблонов должен пытаться найти соответствие до истечения времени ожидания. Установка интервала времени ожидания предотвращает зависание регулярных выражений, которые полагаются на избыточное выполнение поиска с возвратом, при обработке входных данных, содержащих близкие совпадения. Дополнительные сведения см. в разделе рекомендации [по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [поиска с возвратом](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если в течение этого интервала времени совпадения не найдены, метод создает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенное для домена приложения, в котором выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Рекомендуется присвоить параметру <paramref name="matchTimeout" /> соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного более высокую производительность. Однако время ожидания следует отключить только при следующих условиях. 
— Если входные данные, обрабатываемые регулярным выражением, являются производными от известного и надежного источника или состоят из статического текста. Это исключает текст, введенный пользователями динамически.  
  
— При тщательном тестировании шаблона регулярного выражения для обеспечения эффективной обработки совпадений, несоответствий и близких соответствий.  
  
— Если шаблон регулярного выражения не содержит элементов языка, которые вызывают избыточный поиск с возвратом при обработке близкого соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="si">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Этот параметр зарезервирован для использования в будущем.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает шаблон регулярного выражения, который был передан в конструктор <see langword="Regex" />.</summary>
        <returns>Параметр <paramref name="pattern" />, который был передан в конструктор <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `pattern` состоит из элементов языка регулярных выражений, которые символно описывает строку для сопоставления. Дополнительные сведения о регулярных выражениях см. в разделе [.NET Framework регулярные выражения](~/docs/standard/base-types/regular-expressions.md) и [Язык регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданных методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />. Эти скомпилированные регулярные выражения используют реализацию <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> базового класса. При вызове из производного класса метод <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> возвращает строку, которая была передана в параметр <paramref name="pattern" /> конструктора <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> класса, который использовался для определения регулярного выражения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая текст для преобразования.</param>
        <summary>Преобразует все escape-символы во входной строке обратно в символы.</summary>
        <returns>Строка символов с любыми преобразованными символами, приведенными в их непреобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.RegularExpressions.Regex.Unescape%2A> выполняет одно из следующих двух преобразований:  
  
-   Он обращает преобразование, выполняемое методом <xref:System.Text.RegularExpressions.Regex.Escape%2A>, удаляя escape-символ ("\\") из каждого символа, экранированного методом. К ним относятся \\, *, +,?, &#124;, {, [, (,), ^, $,., # и символы пробела. Кроме того, метод <xref:System.Text.RegularExpressions.Regex.Unescape%2A> отменяет escape-символы закрывающей скобки (]) и закрывающих фигурных скобок (}).  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> не может разменять escape-строку идеальной, так как она не может точно определить, какие символы были экранированы,  
  
-   Он заменяет шестнадцатеричные значения в буквальных строковых литералах фактическими печатаемыми символами. Например, он заменяет @"\x07" на "\a" или @"\x0A" с "\n". Он преобразует в поддерживаемые escape-символы, такие как \a, \b, \e, \n, \r, \f, \t, \v и буквенно-цифровые символы.
  
 Если метод <xref:System.Text.RegularExpressions.Regex.Unescape%2A> встречает другие escape-последовательности, которые не могут быть преобразованы, например \w или \s, он выдает исключение <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> включает нераспознанную escape-последовательность.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>Значение <see langword="true" />, если свойство <see cref="P:System.Text.RegularExpressions.Regex.Options" /> содержит параметр <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Время ожидания, которое требуется проверить.</param>
        <summary>Проверяет, попадает ли интервал времени ожидания в допустимый диапазон.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное время ожидания выходит за пределы допустимого диапазона.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
