<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="517657d5c9b0e58ce68b4057b652e59f2b7ef87d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014341" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет постоянное регулярное выражение.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс представляет механизм регулярных выражений платформы .NET Framework. Его можно использовать для быстрого разбора большого текста для поиска определенных шаблонов символов; для извлечения, изменять, заменять или удалять текстовые подстроки, и добавлять извлеченные строки в коллекцию для создания отчета.  
  
> [!NOTE]
>  Если ваш основной интерес для проверки строки, определяя их соответствие определенному шаблону, можно использовать <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> класса.  
  
 Использовать регулярные выражения, можно определить шаблон, который вы хотите определить в текстовый поток, используя синтаксис, задокументированный в [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Затем при необходимости можно создать экземпляр <xref:System.Text.RegularExpressions.Regex> объекта. Наконец можно вызвать метод, который выполняет некоторые операции, такие как замена текста, который соответствует шаблону регулярного выражения или идентификация совпадения с шаблоном.  
  
> [!NOTE]
>  Некоторые распространенные шаблоны регулярных выражений см. в разделе [Примеры регулярных выражений](~/docs/standard/base-types/regular-expression-examples.md). Также имеется несколько библиотек online шаблоны регулярных выражений, как в [Regular Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Дополнительные сведения об использовании <xref:System.Text.RegularExpressions.Regex> класса, в следующих разделах этой статьи:  
  
-   [Vs регулярное выражение. Методы строк](#regex_vs_string)  
  
-   [Статические vs. Методы экземпляра](#static_vs_instance)  
  
-   [Выполнение операций регулярного выражения](#regex_ops)  
  
-   [Определение значения времени ожидания](#define_timeout)  
  
 Дополнительные сведения о языке регулярных выражений см. в [кратком справочнике по элементам языка регулярных выражений](~/docs/standard/base-types/regular-expression-language-quick-reference.md) или в одной из следующих брошюр, который вы можете скачать и распечатать:  
  
 [Краткий справочник в формате Word (DOCX)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx);  
 [Краткий справочник в формате PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf).  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Vs регулярное выражение. Методы строк  
 <xref:System.String?displayProperty=nameWithType> Класс содержит несколько методов поиска и сравнения, которые можно использовать для выполнения сопоставления с текстом шаблона. Например <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, и <xref:System.String.StartsWith%2A?displayProperty=nameWithType> методы определяют, содержит ли экземпляр строки заданной подстроки; и <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, и <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> методы возвращают начальный позиции указанной подстроки в строке. Используйте методы класса <xref:System.String?displayProperty=nameWithType> класса при поиске конкретной строки. Используйте <xref:System.Text.RegularExpressions.Regex> класса при поиске определенного шаблона в строке. Дополнительные сведения и примеры см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [К "Примечания"](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Статические vs. Методы экземпляра  
 Определив шаблон регулярного выражения, его можно было предоставить к обработчику регулярных выражений одним из двух способов:  
  
-   Путем создания экземпляра <xref:System.Text.RegularExpressions.Regex> , представляющий регулярное выражение. Для этого необходимо передать шаблон регулярного выражения для <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> конструктор. Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым; при создании экземпляра <xref:System.Text.RegularExpressions.Regex> объекта с регулярным выражением, что регулярное выражение объекта нельзя изменить.  
  
-   Указав регулярное выражение и текст для поиска для `static` (`Shared` в Visual Basic) <xref:System.Text.RegularExpressions.Regex> метод. Это позволяет использовать регулярное выражение без явного создания <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 Все <xref:System.Text.RegularExpressions.Regex> методы идентификации шаблона включают как статическим и экземпляр перегрузки.  
  
 Обработчик регулярных выражений необходимо скомпилировать определенный шаблон, прежде чем можно будет использовать шаблон. Так как <xref:System.Text.RegularExpressions.Regex> объекты являются неизменяемыми, это одноразовую процедуру, которая возникает, когда <xref:System.Text.RegularExpressions.Regex> вызывается конструктор класса или статический метод. Чтобы избежать необходимости повторно компилировать одним регулярным выражением, обработчик регулярных выражений кэширует скомпилированные регулярные выражения, используемые в вызовах статичных методов. Таким образом методы поиска совпадения с шаблоном регулярного выражения обеспечивают сравнимую производительность для статических методов и методов экземпляра.  
  
> [!IMPORTANT]
>  В версии 1.0 и 1.1, все скомпилированные регулярные выражения .NET Framework используются ли они в экземпляра или статического метода вызывает, были кэшированы. Начиная с .NET Framework 2.0, кэшируются только регулярные выражения, используемые в вызовах статичных методов.  
  
 Тем не менее кэширование может отрицательно сказаться на производительности в следующих двух случаях:  
  
-   При использовании вызовов статических методов с большим числом регулярные выражения. По умолчанию обработчик регулярных выражений кэширует 15 последних использованных статических регулярных выражений. Если приложение использует более чем 15 статических регулярных выражений, некоторые регулярные выражения должны быть перекомпилированы. Чтобы перекомпиляция, вы можете увеличить <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> свойство.  
  
-   При создании экземпляра new <xref:System.Text.RegularExpressions.Regex> объектов с помощью регулярных выражений, которые ранее были скомпилированы. Например следующий код определяет регулярное выражение для поиска повторяющихся слов в текстовый поток. Несмотря на то, что в примере используется одним регулярным выражением, он создает новый экземпляр <xref:System.Text.RegularExpressions.Regex> объекта для обработки каждой строки текста. Это приводит к повторной компиляции регулярного выражения с каждой итерацией цикла.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Чтобы избежать перекомпиляции, следует создавать экземпляр одного <xref:System.Text.RegularExpressions.Regex> объекта, доступного на весь код, которому он требуется, как показано в следующем примере переопределенный.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [К "Примечания"](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Выполнение операций регулярного выражения  
 От вашего решения для создания экземпляра <xref:System.Text.RegularExpressions.Regex> объекта и вызова его методов или вызывают статические методы <xref:System.Text.RegularExpressions.Regex> класс предлагает следующие функциональные возможности поиска совпадения с шаблоном:  
  
-   Проверка соответствия. Вы вызываете <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> метод, чтобы определить, присутствует ли совпадение.  
  
-   Извлечение одного совпадения. Вы вызываете <xref:System.Text.RegularExpressions.Regex.Match%2A> метод для извлечения <xref:System.Text.RegularExpressions.Match> объект, представляющий первое соответствие в строку, или часть строки. Последующие соответствия можно получить, вызвав <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод.  
  
-   Извлечение всех совпадений. Вы вызываете <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод для извлечения <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> , представляющий всеми соответствиями, найденными в строку, или часть строки.  
  
-   Замена совпадающего текста. Вы вызываете <xref:System.Text.RegularExpressions.Regex.Replace%2A> метод для замены совпадающего текста. Текст замены можно также определить регулярным выражением. Кроме того, некоторые из <xref:System.Text.RegularExpressions.Regex.Replace%2A> методы включают в себя <xref:System.Text.RegularExpressions.MatchEvaluator> параметр, который позволяет программно определить текст замены.  
  
-   Создание массива строк, сформированный на основе части во входной строке. Вы вызываете <xref:System.Text.RegularExpressions.Regex.Split%2A> способ разделения входную строку в позициях, определенных регулярным выражением.  
  
 В дополнение к его методов поиска совпадения с шаблоном <xref:System.Text.RegularExpressions.Regex> класс включает несколько специализированных методов:  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> Метод экранирует все символы, которые могут быть интерпретированы как операторы регулярных выражений в регулярное выражение или входной строки.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод удаляет эти escape-символы.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Метод создает сборку, содержащую предварительно определенных регулярных выражений. .NET Framework содержит примеры эти сборки специального назначения в <xref:System.Web.RegularExpressions?displayProperty=nameWithType> пространства имен.  
  
 [К "Примечания"](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Определение значения времени ожидания  
 .NET Framework поддерживает язык полнофункциональный регулярного выражения, предоставляет значительные возможности и гибкость при сопоставлении шаблонов. Тем не менее, возможности и гибкость некоторых затрат: риск снижения производительности. Регулярные выражения, которые плохо представляют удивительно легко создать. В некоторых случаях операции регулярного выражения, которые зависят от избыточный поиск с возвратом может показаться перестать отвечать на запросы при обработке текст, почти соответствующий шаблону регулярного выражения. Дополнительные сведения о обработчик регулярных выражений .NET Framework, см. в разделе [сведения о поведении регулярных выражений](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Дополнительные сведения о избыточный поиск с возвратом см. в разделе [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], вы можете определить интервал времени ожидания для совпадения с регулярными выражениями. Если обработчик регулярных выражений не может определить соответствие, в течение этого интервала времени, создает операцию сопоставления <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. В большинстве случаев это не позволяет обработчику регулярных выражений тратить энергию обработки при попытке сопоставить текст, почти соответствующий шаблону регулярного выражения. Он также может указывать, тем не менее, что интервал времени ожидания было установлено слишком низкое, или что текущей загрузки компьютеров вызвала Общее снижение производительности.  
  
 Как обрабатывать исключение зависит от причины исключения. Если исключение происходит из-за слишком малое значение истечения времени ожидания или из-за чрезмерного машины нагрузки, можно увеличить интервал времени ожидания и повторите операцию сопоставления. Если исключение возникает, так как регулярное выражение использует избыточный поиск с возвратом, можно предположить, что соответствие не существует, и при необходимости можно записывать в журнал сведения, которые помогут вам изменить шаблон регулярного выражения.  
  
 Можно задать интервал времени ожидания путем вызова <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор при создании экземпляра объекта регулярного выражения. Для статических методов, можно задать интервал времени ожидания путем вызова перегрузки метода сопоставления, который имеет `matchTimeout` параметра. Если значение времени ожидания не задано явно, то значение времени ожидания по умолчанию определяется следующим образом:  
  
-   С помощью задания времени ожидания приложения. значение, если он существует. Это может быть любым значением времени ожидания, который применяется в домен приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается экземпляр объекта или вызов статического метода. Можно задать значение времени ожидания для всего приложения, вызвав <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод назначения строковым представлением <xref:System.TimeSpan> значение к свойству «REGEX_DEFAULT_MATCH_TIMEOUT».  
  
-   С помощью значения <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, если значение времени ожидания для всего приложения не было задано.  
  
> [!IMPORTANT]
>  Мы рекомендуем создать значение времени ожидания во всех операциях поиска совпадения с шаблоном регулярного выражения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 [К "Примечания"](#remarks)  
  
   
  
## Examples  
 В следующем примере регулярное выражение для проверки для повторяющихся вхождений слов в строке. Регулярное выражение `\b(?<word>\w+)\s+(\k<word>)\b` может интерпретироваться, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало соответствия на границе слова.|  
|`(?<word>\w+)`|Сопоставляется один или несколько словообразующих символов до границы слова. Имя данной захватываемой группой `word`.|  
|`\s+`|Совпадение один или несколько символов пробела.|  
|`(\k<word>)`|Соответствует группе записи, которая называется `word`.|  
|`\b`|Соответствует границе слова.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Следующий пример иллюстрирует использование регулярного выражения для проверки ли строка представляет значение валюты или имеет правильный формат для представления значения валюты. В этом случае регулярное выражение строится динамически на основе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойства для текущего языка и региональных параметров пользователя. Если текущий язык и региональные параметры en US, полученный регулярное выражение – `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Это регулярное выражение может интерпретироваться, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начать с начала строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`[\+-]?`|Совпадение с нулем или одним вхождением знак плюс или минус.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\$?`|Совпадение с нулем или одним вхождением знак доллара.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`\d*`|Соответствует нулю или нескольким десятичным числам.|  
|`\.?`|Соответствует ноль или один символ десятичной запятой.|  
|`\d{2}?`|Сопоставить две десятичные цифры ноль или один раз.|  
|`(\d*\.?\d{2}?){1}`|Совпадение с шаблоном целой и дробной части, разделенные запятой хотя бы один раз.|  
|`$`|Поиск конца строки.|  
  
 Таким образом, регулярное выражение предполагает, что строка допустимой валюты не содержит символы разделителя группы, и что он имеет дробных разрядов или количество цифр дробной части определяется текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> свойство.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Так как регулярное выражение в этом примере создается динамически, мы не знаем во время разработки ли символ валюты для текущего языка и региональных параметров, десятичного разделителя или положительный и отрицательный знаки могут быть неправильно, обработчик регулярных выражений, как обычный операторы выражений языка. Во избежание любой интерпретации в примере передается каждой динамически создаваемые строки <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод.  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" /> Класс является неизменяемым (только для чтения) и является потокобезопасным. <see cref="T:System.Text.RegularExpressions.Regex" /> объекты могут создаваться в любом потоке и совместно использоваться несколькими потоками. Дополнительные сведения см. в разделе [потокобезопасность](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Регулярные выражения в .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Регулярные выражения — краткий справочник (загрузить в формате Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Регулярные выражения — краткий справочник (загрузить в формате PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание на то, что данный конструктор является защищенным; может вызываться только в классах, производных от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> конструктор эквивалентен вызову <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор со значением <xref:System.Text.RegularExpressions.RegexOptions.None> для `options` аргумент.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для шаблона соответствия, определяется при ее создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 Этот конструктор создает объект регулярного выражения, пытающийся совпадение с учетом регистра любых алфавитных символов, определенных в `pattern`. Для совпадений без учета регистра, используйте <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> конструктор.  
  
   
  
## Examples  
 В следующем примере показано, как этот конструктор используется для создания экземпляра регулярное выражение, которое соответствует любому слову, которое начинается с буквы «a» или «t».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Обратите внимание, что шаблон регулярного выражения не может совпадать слово «» в начале текста, так как при сравнении учитывается регистр, по умолчанию. Пример сравнение без учета регистра, см. в разделе <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию домена приложения, в котором она создается. Если значение времени ожидания не был определен для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <see cref="T:System.Text.RegularExpressions.Regex" /> объект <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, содержащий сериализованный шаблон и <see cref="T:System.Text.RegularExpressions.RegexOptions" /> сведения.</param>
        <param name="context">Целевой объект этой сериализации. (Этот параметр не используется; задайте значение <see langword="null" />.)</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" />, используя сериализованные данные.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Шаблон, <paramref name="info" /> содержит является <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> содержит недопустимое <see cref="T:System.Text.RegularExpressions.RegexOptions" /> флаг.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, изменяющими шаблон.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для параметров соответствия, определяется при ее создании. Однако его можно использовать любое количество раз без повторной компиляции.  
  
   
  
## Examples  
 В следующем примере показано, как этот конструктор используется для создания экземпляра регулярное выражение, которое соответствует любому слову, которое начинается с буквы «a» или «t».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Обратите внимание, что коллекция match включает слово «,» что начинается текст, так как `options` параметр определила сравнения без учета регистра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> содержит недопустимый флаг.</exception>
        <block subset="none" type="usage"><para>Этот конструктор создает <see cref="T:System.Text.RegularExpressions.Regex" /> объект, который использует значение времени ожидания по умолчанию домена приложения, в котором она создается. Если значение времени ожидания не был определен для домена приложения, <see cref="T:System.Text.RegularExpressions.Regex" /> объект использует значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что мешает выполнить операцию по истечении времени ожидания. Рекомендуемые конструктор для создания <see cref="T:System.Text.RegularExpressions.Regex" /> объект <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовое сочетание значений перечисления, изменяющих регулярное выражение.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.RegularExpressions.Regex" /> для указанного регулярного выражения с параметрами, которые изменяют шаблон и значение, указывающее, как долго метод сравнения с шаблоном должен пытаться найти совпадение, до истечения времени ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md) разделы.  
  
 Объект <xref:System.Text.RegularExpressions.Regex> является неизменяемым, это означает, что он может использоваться только для шаблона соответствия, определить, когда вы создаете. Однако его можно использовать любое количество раз без повторной компиляции.  
  
 `matchTimeout` Параметр указывает, сколько соответствий метод следует пытаться найти совпадение, до истечения времени ожидания. Если совпадений не найдено в течение этого интервала времени, метод поиска совпадения с шаблоном вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Методы поиска совпадения с шаблоном экземпляра, которые наблюдают за `matchTimeout` интервал времени ожидания включают следующее:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом скрывается перестает отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Чтобы задать интервал времени ожидания разумным, учитывайте следующие факторы:  
  
-   Длина и сложность шаблон регулярного выражения. Длинные и более сложные регулярные выражения требуется больше времени, чем короче и проще, из них.  
  
-   Загрузки ожидаемый компьютеров. Обработка занимает больше времени, в системах с высокой загрузки ЦП и памяти.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктора для создания <xref:System.Text.RegularExpressions.Regex> объект со значением времени ожидания равным одной секунде. Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом. Если <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> является исключение, в примере увеличивается значение времени ожидания до достижения максимального значения, равного трем секундам. В противном случае он отказывается от попытка соответствует шаблону.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество записей в текущей статической кэш-памяти скомпилированных регулярных выражений.</summary>
        <value>Максимальное количество записей в статической кэш-памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> Класс хранит внутренний кэш скомпилированных регулярных выражений, используемых в вызовах статичных методов. Если значение, указанное в наборе операций меньше, чем текущий размер кэша, записей кэша, удаляются, пока размер кэша равен указанному значению.  
  
 По умолчанию кэш содержит 15 скомпилированных статических регулярных выражений. Обычно приложения для изменения размера кэша не будет. Используйте <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> свойства только в том случае, если вы хотите отключить кэширование или при наличии необычайно большого кэша.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.</exception>
        <block subset="none" type="usage"><para>В .NET Framework до версии [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], использовать регулярные выражения в статической и вызовов методов экземпляра были кэшированы. Начиная с версии [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], только регулярные выражения, используемые в вызовах статичных методов, кэшируются.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий именованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 Пытается преобразовать значение присвоено свойству в операции задания <xref:System.Collections.Hashtable> объекта; Если это преобразование не удается, он вызывает метод <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</summary>
        <value>Словарь, сопоставляющий нумерованные захватываемые группы со значениями их индексов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство защищено; может осуществляться только из класса, производного от <xref:System.Text.RegularExpressions.Regex> класса.  
  
 Пытается преобразовать значение присвоено свойству в операции задания <xref:System.Collections.Hashtable> объекта; Если это преобразование не удается, он вызывает метод <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, присвоенное свойству <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> в операции задания, равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Компилирует регулярные выражения и сохраняет их на диск в единой сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

В .NET Core, вызовы `Regex.CompileToAssembly` throw метод <xref:System.PlatformNotSupportedException>; записи вне сборки не поддерживается.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <summary>Компилирует один или несколько указанных <see cref="T:System.Text.RegularExpressions.Regex" /> объекты в именованную сборку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Метод создает сборку .NET Framework, в какие каждого регулярному выражению, определенному в `regexinfos` массив представляется классом. Как правило <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> метод вызывается из другого приложения, который создает сборку скомпилированных регулярных выражений. Каждый регулярного выражения, включаются в сборку имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей назначается полное доменное имя, которое определяется `fullnamespace` и `name` параметры соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет значение по умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает экземпляр и использует скомпилированное регулярное выражение находится в сборке или приложение, которое отличается от кода, который создает сборку.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем RegexLib.dll. Сборка включает два скомпилированных регулярных выражений. Во-первых, `Utilities.RegularExpressions.DuplicatedString`, сопоставляет два идентичных смежных слова. Второй, `Utilities.RegularExpressions.EmailAddress`, проверяет ли строка имеет правильный формат было адресом электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Регулярное выражение, которое проверяет строку на наличие повторяющихся слов затем создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> свойства является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения из одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, которая имеет [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее доработанных выпусков, установить целевые [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, есть [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] возникло исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
-Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] вместо более поздних версий.  
  
-Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и извлечение скомпилированное регулярное выражение из сборки, используйте статический или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <summary>Компилирует один или несколько указанных <see cref="T:System.Text.RegularExpressions.Regex" /> объекты в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Метод создает сборку .NET Framework, в какие каждого регулярному выражению, определенному в `regexinfos` массив представляется классом. Как правило <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> метод вызывается из другого приложения, который создает сборку скомпилированных регулярных выражений. Каждый регулярного выражения, включаются в сборку имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей назначается полное доменное имя, которое определяется `fullnamespace` и `name` параметры соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет значение по умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает экземпляр и использует скомпилированное регулярное выражение находится в сборке или приложение, которое отличается от кода, который создает сборку.  
  
 Так как <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> метод создает сборку .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса определенного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не поддерживает атрибуты .NET Framework для назначения на сборку с помощью языка разработки стандартный синтаксис атрибутов. `attributes` Параметр предоставляет альтернативный метод определения атрибутов, которые применяются к сборке. Для каждого атрибута, который требуется применить к сборке сделайте следующее:  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который вы хотите вызвать.  
  
2.  Получить <xref:System.Type> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.  
  
3.  Вызовите <xref:System.Type.GetConstructor%2A> метод атрибута <xref:System.Type> извлекаемого объекта <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который вы хотите вызвать. Передайте <xref:System.Type.GetConstructor%2A> метод массива из <xref:System.Type> объектов, представляющих типы параметров конструктора.  
  
4.  Создание <xref:System.Object> массив, который определяет параметры для передачи конструктору атрибута.  
  
5.  Создать экземпляр <xref:System.Reflection.Emit.CustomAttributeBuilder> объект путем передачи его конструктору <xref:System.Reflection.ConstructorInfo> объект, полученный на шаге 3 и <xref:System.Object> массива, созданного на шаге 4.  
  
 Затем можно передать массив этих <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов вместо `attributes` параметр <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере создается сборка с именем RegexLib.dll и применяет <xref:System.Reflection.AssemblyTitleAttribute> к нему атрибут. Сборка включает два скомпилированных регулярных выражений. Во-первых, `Utilities.RegularExpressions.DuplicatedString`, сопоставляет два идентичных смежных слова. Второй, `Utilities.RegularExpressions.EmailAddress`, проверяет ли строка имеет правильный формат было адресом электронной почты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Можно убедиться, что <xref:System.Reflection.AssemblyTitleAttribute> был применен атрибут к сборке, просмотрев его манифест с помощью служебной программы отражения, например ILDasm.  
  
 Регулярное выражение, которое проверяет строку на наличие повторяющихся слов затем создается и используется в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Для успешной компиляции во втором примере требуется ссылка на RegexLib.dll (сборка, созданная в первом примере) для добавления в проект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> свойства является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения из одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, которая имеет [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее доработанных выпусков, установить целевые [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, есть [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] возникло исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
-Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] вместо более поздних версий.  
  
-Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и извлечение скомпилированное регулярное выражение из сборки, используйте статический или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Массив, описывающий регулярные выражения для компилирования.</param>
        <param name="assemblyname">Имя файла сборки.</param>
        <param name="attributes">Массив, определяющий атрибуты, применяемые к сборке.</param>
        <param name="resourceFile">Имя файла ресурсов Win32 для включения в сборку.</param>
        <summary>Компилирует один или несколько указанных <see cref="T:System.Text.RegularExpressions.Regex" /> объекты и указанный файл ресурсов в именованную сборку с заданными атрибутами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method generates a .NET Framework assembly in which each regular expression defined in the `regexinfos` array is represented by a class. Typically, the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method is called from a separate application that generates an assembly of compiled regular expressions. Каждый регулярного выражения, включаются в сборку имеет следующие характеристики:  
  
-   Он является производным от <xref:System.Text.RegularExpressions.Regex> класса.  
  
-   Ей назначается полное доменное имя, которое определяется `fullnamespace` и `name` параметры соответствующего <xref:System.Text.RegularExpressions.RegexCompilationInfo> объекта.  
  
-   Он имеет значение по умолчанию (или без параметров) конструктора.  
  
 Обычно код, который создает экземпляр и использует скомпилированное регулярное выражение находится в сборке или приложение, которое отличается от кода, который создает сборку.  
  
 Так как <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> метод создает сборку .NET Framework из вызова метода, вместо того чтобы использовать ключевое слово определение класса определенного языка (например, `class` в C# или `Class`...`End Class` в Visual Basic) он не поддерживает атрибуты .NET Framework для назначения на сборку с помощью языка разработки стандартный синтаксис атрибутов. `attributes` Параметр предоставляет альтернативный метод определения атрибутов, которые применяются к сборке. Для каждого атрибута, который требуется применить к сборке сделайте следующее:  
  
1.  Создайте массив <xref:System.Type> объектов, представляющих типы параметров конструктора атрибута, который вы хотите вызвать.  
  
2.  Получить <xref:System.Type> объект, представляющий класс атрибута, который вы хотите применить к новой сборке.  
  
3.  Вызовите <xref:System.Type.GetConstructor%2A> метод атрибута <xref:System.Type> извлекаемого объекта <xref:System.Reflection.ConstructorInfo> объект, представляющий конструктор атрибута, который вы хотите вызвать. Передайте <xref:System.Type.GetConstructor%2A> метод массива из <xref:System.Type> объектов, представляющих типы параметров конструктора  
  
4.  Создание <xref:System.Object> массив, который определяет параметры для передачи конструктору атрибута.  
  
5.  Создать экземпляр <xref:System.Reflection.Emit.CustomAttributeBuilder> объект путем передачи его конструктору <xref:System.Reflection.ConstructorInfo> объект, полученный на шаге 3 и <xref:System.Object> массива, созданного на шаге 4.  
  
 You can then pass an array of these <xref:System.Reflection.Emit.CustomAttributeBuilder> objects instead of the `attributes` parameter to the [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="assemblyname" /> параметра <see cref="P:System.Reflection.AssemblyName.Name" /> свойства является пустая или нулевая строка.  
  
-или- 
Шаблон регулярного выражения из одного или нескольких объектов в <paramref name="regexinfos" /> содержит недопустимый синтаксис.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="assemblyname" /> или <paramref name="regexinfos" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> Параметр обозначает недопустимый файл ресурсов Win32.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл, назначенному с помощью <paramref name="resourceFile" /> параметр не найден.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Только в .NET Core: создание сборки скомпилированных регулярных выражений не поддерживается.</exception>
        <block subset="none" type="usage"><para>Если вы разрабатываете в системе, которая имеет [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или ее доработанных выпусков, установить целевые [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], и использовании <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> метод, чтобы создать сборку, содержащую скомпилированные регулярные выражения. Попытка использовать одно из регулярных выражений в этой сборке в системе, есть [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] возникло исключение. Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов: 
-Создать сборку, содержащую скомпилированные регулярные выражения в системе, которая имеет [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] вместо более поздних версий.  
  
-Вместо из вызова метода <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> и извлечение скомпилированное регулярное выражение из сборки, используйте статический или экземпляр <see cref="T:System.Text.RegularExpressions.Regex" /> методы с <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр при создании экземпляра <see cref="T:System.Text.RegularExpressions.Regex" /> объекта или вызвать регулярного выражения методу сопоставления шаблона.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Компиляция и многократное использование</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая преобразуемый текст.</param>
        <summary>Преобразует минимальный набор символов (\\, *, +, ?, |, {, [, (,), ^, $,., # и пробел), заменяя их escape-кодами. При этом обработчику регулярных выражений дается команда интерпретировать эти символы буквально, а не как метасимволы.</summary>
        <returns>Строка символов с метасимволами, приведенными в преобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Преобразует строку, чтобы обработчик регулярных выражений интерпретирует метасимволами, он может содержать как символьные литералы. Например рассмотрим регулярное выражение, предназначенное для извлечения комментарии, заключенные в разделители открывающей и закрывающей квадратных скобок ([и]) из текста. В следующем примере регулярное выражение «[(.*?)]» интерпретируется как класс символов. Вместо сопоставления комментариев внедренных во входном тексте, регулярное выражение соответствует каждой открывающей или закрывающей скобкой, период, звездочка или вопросительный знак.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Тем не менее если открывающей круглой скобкой, экранируется, передав его в <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод, регулярное выражение успешно сопоставления комментариев, которые внедряются во входной строке. Это показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 В регулярном выражении, которое определяется с помощью статического текста, символов, которые должны интерпретироваться буквально, а не как метасимволы можно экранировать, поставив символ обратной косой черты (\\) также путем вызова <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод. В регулярном выражении, которое определяется динамически с помощью символов, которые не известны во время разработки вызвав <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод особенно важно, чтобы убедиться, что обработчик регулярных выражений интерпретирует отдельные символы как литералы вместо чем как метасимволы.  
  
> [!NOTE]
>  Если шаблон регулярного выражения включает символ номера (#) или литеральные символы-разделители, их необходимо экранировать, если входной текст разбирается с <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр включен.  
  
 Хотя <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод экранирует прямой Открытие квадратная скобка ([) и открыв скобки ({}), он не экранирует их соответствующий закрывающий символов (] и}). В большинстве случаев эти экранирование не требуется. Закрывающая скобка или фигурной скобкой не предшествует соответствующего открывающего символа, обработчик регулярных выражений интерпретирует буквально. Если открывающей круглой скобкой или фигурной скобки интерпретируется как метасимвол, обработчик регулярных выражений интерпретирует первый соответствующий закрывающий знак как метасимвол. Если это не требуемое поведение, добавляя перед обратной косой чертой следует экранировать закрывающая скобка или фигурной скобкой (\\) символов. Иллюстрация см. в разделе в подразделе "Пример".  
  
   
  
## Examples  
 Следующий пример извлекает комментарии из текста. Предполагается, что комментарии разделяются символом начала комментария и символом окончания комментария, выбранного пользователем. Так как символы начала комментария должны интерпретироваться буквально, они передаются в <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод, чтобы гарантировать, что они не может быть ошибочно интерпретирована как метасимволы. Кроме того пример явно проверяет, является ли символ окончания комментарий, введенный пользователем закрывающая скобка (]) или фигурной скобкой (}). В противном случае символ обратной косой черты (\\) добавляется в скобки или фигурной скобкой, таким образом, чтобы он интерпретируется буквально. Обратите внимание, что в примере также используется <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> коллекции, чтобы отобразить комментарий, вместо того чтобы комментарий вместе с ее открывающих и закрывающих символов комментария.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Escape-знаки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Этот член переопределяет <see cref="M:System.Object.Finalize" />; по данной теме может быть доступна более полная документация.

Позволяет <see cref="T:System.Object" /> попытаться освободить ресурсы и выполнить другие завершающие операции перед <see cref="T:System.Object" /> сборщиком мусора.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив имен группы записи для регулярного выражения.</summary>
        <returns>Строковый массив имен группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Коллекция имен групп содержит набор строк, используемых для имени захватываемых групп в выражении. Даже если не явно названы захватываемые группы, они автоматически назначаются числовые имена («0», «1», «2», «3» и т. д.). «0» с именем группы представляет весь текст, соответствующие шаблону регулярного выражения. Нумерованные группы перед явно именованные группы в коллекции, а именованные группы отображаются в том порядке, в котором они определены в шаблоне регулярного выражения.  
  
 Можно использовать <xref:System.Array.Length%2A> свойства в массиве, возвращенное этим методом, чтобы определить число групп в регулярном выражении.  
  
   
  
## Examples  
 В следующем примере определяется общего назначения `ShowMatches` метод, который отображает имена групп регулярных выражений и их совпадающего текста.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 В нашем примере шаблон регулярного выражения `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` предназначен для синтаксического анализа простого предложения, а также для определения его первое слово, последнее слово и конечный знак пунктуации. В следующей таблице показаны, как интерпретируется шаблон регулярного выражения:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<FirstWord>\w+)`|Совпадение с одним или несколькими символами слова. Это `FirstWord` с именем группы.|  
|\s?|Совпадение с нулем или одним символом пробела.|  
|(\w+)|Совпадение с одним или несколькими символами слова. Это вторая группа записи.|  
|\s|Соответствует пробелу.|  
|((\w+)\s)*|Сопоставление нуля или более вхождений одного или нескольких словообразующих символов, за которым следует пробел. Это первая группа записи.|  
|(? \<LastWord > \w+)?|Совпадение с нулем или одним вхождением один или несколько словообразующих символов. Это `LastWord` с именем группы.|  
|(? \<Пунктуации > \p{Po})|Соответствует символу Юникода, категория которых является знаком пунктуации, другие. Это `Punctuation` с именем группы.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив номеров групп записи, что соответствует именам групп в массиве.</summary>
        <returns>Целочисленный массив номеров групп.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неименованные и именованные захватываемые группы может осуществляться по номеру. Неименованные группы нумеруются слева направо, начиная с 1. (Группе записи с индексом 0 (ноль) представляет сопоставление в целом).  Именованные группы, затем нумеруются слева направо, начиная с номером, которая на единицу больше, чем число неименованных захватываемых групп.  
  
 Ссылки на группы по номеру, а не по имени строки может обеспечить более быстрый доступ.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, который соответствует предложению. Регулярное выражение содержит три группы захвата: неименованные группы, который фиксирует отдельного слова вместе с символом пробела, который может следовать за ней; Группа с именем `word` , собирающий отдельные слова в операторе; и создается группа с именем `end` , собирающий знаки препинания, завершает предложение. В примере вызывается <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> метод для получения требуемых показателей все записи группы, а затем отображает их захватываемой строки. Кроме того <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод используется для указания того, соответствует ли определенный нумерованной группе именованную группу.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?<word>\w+)`|Сопоставляется один или несколько словообразующих символов и назначить соответствующие строки в группу с именем `word`.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`((?<word>\w+)\s*)`|Назначить `word` захватываемой группы, все записанные символы-разделители для первой захваченной группы.|  
|`((?<word>\w+)\s*)+`|Совпадение с шаблоном один или несколько словообразующих символов, за которым следует любой пробелы один или несколько раз.|  
|`(?<end>[.?!])`|Совпадение с точкой, вопросительным знаком или восклицательным знаком. Назначьте соответствующий символ для `end` захватываемой группой.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группировки в регулярных выражениях</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Номер группы для преобразования в соответствующее имя группы.</param>
        <summary>Получает имя группы, соответствующее указанному номеру группы.</summary>
        <returns>Строка, содержащая имя группы, связанное с указанным номером группы. При отсутствии имени группы, соответствующий <paramref name="i" />, метод возвращает <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные захватываемые группы, которые отображают части выражений в пределах соответствия шаблону. Нумерованные группы разделены с помощью синтаксиса (*subexpression*) и им присваиваются номера, на основе их порядка в регулярном выражении. Именованные группы разделены с помощью синтаксиса (?`<` *имя*`>`*subexpression*) или (? " *имя*"*subexpression*), где *имя* — это имя, по которому будет определяться часть выражения. (Дополнительные сведения см. в разделе [Конструкции группировки](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Определяет метод, именованным группам и нумерованные группы по их порядковому номеру позиции в регулярном выражении. Порядковый номер ноль всегда представляет всему регулярному выражению. Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `i` — это номер именованные группы, метод возвращает имя группы. Если `i` — это номер неименованные группы, метод возвращает строковое представление числа. Например если `i` -1, метод возвращает «1». Если `i` не — номер захватываемой группы, метод возвращает <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Если шаблон найден, значение, возвращаемое этим методом затем используется для получения <xref:System.Text.RegularExpressions.Group> , представляющий захватываемой группы из <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> свойство. <xref:System.Text.RegularExpressions.GroupCollection> Объект, возвращаемый методом <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> свойство.  
  
   
  
## Examples  
 В следующем примере определяется шаблон регулярного выражения, который соответствует строке адреса, содержащая название города США, штат и почтовый индекс. В примере используется <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> метод для извлечения имен захватываемые группы. Затем эти имена используются для извлечь соответствующий захваченные группы совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Совпадение с символом один или несколько букв или пустого пространства. Назначьте этой группе записи, имя `city`.|  
|`,`|Соответствует запятой (,), за которым следует символ пробела.|  
|`(?<state>[A-Za-z]{2})`|Соответствует двух букв. Назначьте этой группе записи, имя `state`. Эта группа должна следовать символ пробела.|  
|`(?<zip>\d{5}(-\d{4})?)`|Соответствует пяти цифр, после которой следует ноль или одно вхождение дефис и еще четыре цифры. Назначьте этой группе записи, имя `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя группы для преобразования в соответствующий номер группы.</param>
        <summary>Возвращает номер группы, соответствующий указанному имени группы.</summary>
        <returns>Номер группы, соответствующий указанному имени группы, или значение -1, если <paramref name="name" /> не является допустимым именем группы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон регулярного выражения может содержать именованные или нумерованные захватываемые группы, которые отображают части выражений в пределах соответствия шаблону. Нумерованные группы разделены с помощью синтаксиса (*subexpression*) и им присваиваются номера, на основе их порядка в регулярном выражении. Именованные группы разделены с помощью синтаксиса (?`<` *имя*`>`*subexpression*) или (? " *имя*"*subexpression*), где *имя* — это имя, по которому будет определяться часть выражения. (Дополнительные сведения см. в разделе [Конструкции группировки](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Определяет метод, именованным группам и нумерованные группы по их порядковому номеру позиции в регулярном выражении. Порядковый номер ноль всегда представляет всему регулярному выражению. Все пронумерованные группы, затем учитываются перед именем группы, независимо от их фактического расположения в шаблоне регулярного выражения.  
  
 Если `name` является строковым представлением номер группы, который присутствует в шаблоне регулярного выражения, возвращает метод, этот номер. Если `name` соответствует именованной захватываемой группе, которая присутствует в шаблоне регулярного выражения, метод возвращает его соответствующий номер. Сравнение `name` с группой его имени учитывается регистр. Если `name` не соответствует имени захватываемой группы, или строковое представление номер захватываемой группы, метод возвращает значение -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Конструкции группирования</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для операции сравнения с шаблоном не используется конечное время ожидания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Класса конструктор и ряд статического сопоставления методов использования <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> константу, чтобы указать, что в процессе поиска соответствия шаблону следует время ожидания не истекает.  
  
> [!WARNING]
>  Установка значения времени ожидания обработчик регулярных выражений в <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> может привести к регулярных выражений, которые зависят от того, избыточный поиск с возвратом к перестает отвечать на запросы при обработке текста, почти соответствующий шаблону регулярного выражения. Если отключить время ожидания, следует убедиться, что регулярное выражение не зависит от избыточный поиск с возвратом и обработки текст, почти соответствующий шаблону регулярного выражения.  
>   
>  Дополнительные сведения об обработке поиск с возвратом см. в разделе [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Константа может быть передано в качестве значение `matchTimeout` аргумент из следующих элементов:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Ссылки уже инициализированы.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Максимальное время, которое может пройти в операции сравнения с шаблоном перед истечением срока ожидания операции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает на то, обнаруживает ли регулярное выражение соответствие во входной строке.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Указывает, является ли регулярному выражению, заданному в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор находит соответствие в указанной входной строке.</summary>
        <returns><see langword="true" /> Если регулярное выражение обнаруживает соответствие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или, чтобы убедиться, что строка соответствует определенному шаблону без получения эту строку для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> метод, чтобы определить, является ли строка допустимым артикул. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, который содержит четыре символа, должен содержать буквы или цифры, за которым следует два числовых символа, следуют буквы или цифры. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифры, следуют буквы или цифры.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Сопоставление двух числовых символов.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно три числовых символов.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и подобрать два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Позиция символа, с которого начинается поиск.</param>
        <summary>Указывает, является ли регулярному выражению, заданному в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор находит соответствие в указанной входной строке, начиная с указанной начальной позиции в строке.</summary>
        <returns><see langword="true" /> Если регулярное выражение обнаруживает соответствие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или, чтобы убедиться, что строка соответствует определенному шаблону без получения эту строку для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> метод, чтобы определить, является ли строка допустимым артикул. Он выполняет поиск номер части, следует двоеточие (:) в строке. <xref:System.String.IndexOf%28System.Char%29> Метод используется для определения положения символа двоеточия, который затем передается <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> метод. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, который содержит четыре символа, должен содержать буквы или цифры, за которым следует два числовых символа, следуют буквы или цифры. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифры, следуют буквы или цифры.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Сопоставление двух числовых символов.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно три числовых символов.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и подобрать два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению.</summary>
        <returns><see langword="true" /> Если регулярное выражение обнаруживает соответствие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или, чтобы убедиться, что строка соответствует определенному шаблону без получения эту строку для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> с шаблоном регулярного выражения, заданные `pattern` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> метод экземпляра. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод, чтобы определить, является ли строка допустимым артикул. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, который содержит четыре символа, должен содержать буквы или цифры, за которым следует два числовых символа, следуют буквы или цифры. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифры, следуют буквы или цифры.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`\d{2}`|Сопоставление двух числовых символов.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно три числовых символов.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и подобрать два вхождения этого шаблона.|  
|`[a-zA-Z0-9]`|Соответствовать один буквенный символ (`a` через `z` или `A` через `Z`) или цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значению времени ожидания по умолчанию домен приложения, в котором вызывается метод. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для проверки соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, используя указанные параметры сопоставления.</summary>
        <returns><see langword="true" /> Если регулярное выражение обнаруживает соответствие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или, чтобы убедиться, что строка соответствует определенному шаблону без получения эту строку для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> с шаблоном регулярного выражения, заданные `pattern` и параметры регулярных выражений, определяемое `options` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> экземпляра метод. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод, чтобы определить, является ли строка допустимым артикул. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, который содержит четыре символа, должен содержать буквы или цифры, за которым следует два числовых символа, следуют буквы или цифры. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифры, следуют буквы или цифры.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`\d{2}`|Сопоставление двух числовых символов.|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно три числовых символов.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и два вхождения этого шаблона...|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод с `options` параметру присвоить <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> эквивалентен определение следующее регулярное выражение:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения, см. в примере <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для проверки соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Указывает, обнаружено ли в указанной входной строке соответствие заданному регулярному выражению, с помощью указанных параметров сопоставления и интервала времени ожидания.</summary>
        <returns><see langword="true" /> Если регулярное выражение обнаруживает соответствие; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Метод обычно используется для проверки строки или, чтобы убедиться, что строка соответствует определенному шаблону без получения эту строку для последующей обработки. Если вы хотите определить ли одну или несколько строк, соответствующих шаблону регулярного выражения и затем извлечение их для последующей обработки, вызов <xref:System.Text.RegularExpressions.Regex.Match%2A> или <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод.  
  
 Статический <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> с шаблоном регулярного выражения, заданные `pattern` и параметры регулярных выражений, определяемое `options` и вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> экземпляра метод. Этот шаблон регулярного выражения кэшируется для быстрого извлечения обработчиком регулярных выражений.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `matchTimeout` Параметр указывает о том, как долго шаблон соответствующий метод следует пытаться найти совпадение, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом скрывается перестает отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадений не найдено в течение этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы определить, является ли строка допустимым артикул. Регулярное выражение предполагает, что номер части имеет определенный формат, состоящий из трех наборов символов, разделенных дефисами. Первый набор, который содержит четыре символа, должен содержать буквы или цифры, за которым следует два числовых символа, следуют буквы или цифры. Второй набор, состоящий из трех символов, должен быть числовым. Третий набор, состоящий из четырех символов, должен иметь три цифры, следуют буквы или цифры. Соответствующие шаблону регулярного выражения необходимо привлечь минимальной поиска по входной строке, поэтому метод задает интервала ожидания 500 миллисекунд.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале строки.|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`\d{2}`|Сопоставление двух числовых символов.|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`-`|Выделение дефиса.|  
|`\d{3}`|Совпадение ровно три числовых символов.|  
|`(-\d{3}){2}`|Найти дефис и еще по три цифры и подобрать два вхождения этого шаблона.|  
|`[A-Z0-9]`|Соответствует любому одиночному символу буквы из `A` через `Z`, или любой цифре.|  
|`$`|Совпадение должно заканчиваться в конце строки.|  
  
 Вызов <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод с `options` параметру присвоить <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> эквивалентен определение следующее регулярное выражение:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Для сравнения, см. в примере <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> не является допустимым значением <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло.</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит во входной строке подстроку, совпадающую с шаблоном регулярного выражения и возвращает первое вхождение в качестве единого <see cref="T:System.Text.RegularExpressions.Match" /> объекта.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке первое вхождение регулярного выражения, указанного в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Все совпадения в одном вызове метода также можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере вычисляется шаблон регулярного выражения сопоставляет строки, а затем список соответствующих групп, записей и позиций записи.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Шаблон регулярного выражения `(\w+)\s+(car)` совпадает с числом вхождений слова «автомобиль», вместе с word, после нее. Он интерпретируется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|`\s+`|Совпадение один или несколько символов пробела.|  
|(car)|Совпадение с литеральной строкой «автомобиль». Это вторая группа записи.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Отсчитываемый от нуля позиция, с которого начинается поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения, начиная с или после `startat` позиции во входной строке знака. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> поиска методов определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторов класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 При необходимости можно указать начальную позицию в строке с помощью `startat` параметра. Когда обработчик регулярных выражений выполняет синтаксический анализ слева направо (по умолчанию), сопоставление и сканирование перемещать правом направлении, начиная с символа, указанного в `startat`. Когда обработчик регулярных выражений выполняет синтаксический анализ справа налево (если создается шаблон регулярного выражения с <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> параметр), сопоставление и просмотр перемещения в обратном направлении и начинаются с символа в `startat` -1. Если вы не укажете начальной позицией, поиск начинается в режиме по умолчанию `startat` позиции. Если регулярное выражение выполняет поиск в направлении слева направо, по умолчанию `startat` расположено в левый конец `input`; если он выполняет поиск справа слева, по умолчанию `startat` расположено в правом конце `input`.  
  
 Если вы хотите ограничить соответствие, таким образом, чтобы он начинается с позиции конкретного символа в строке, и обработчик регулярных выражений не проверяет оставшейся части строки для сопоставления, закрепите регулярное выражение с `\G` (слева для слева направо шаблон, или справа для шаблона справа налево). Это ограничит сопоставление, поэтому оно должно начинаться точно в `startat`.  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в или после `startat` позиция знака в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Все совпадения в одном вызове метода также можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке первое вхождение заданного регулярного выражения.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> объекта с помощью заданного шаблона регулярного выражения и вызов экземпляра <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод. В этом случае обработчик регулярных выражений кэширует шаблон регулярного выражения.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод. Все совпадения в одном вызове метода также можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> метод, чтобы найти первое слово, содержащее хотя бы один `z` символ, а затем вызывает <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> способ поиска дополнительных совпадений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b\w*z+\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w*`|Соответствует ноль, один или несколько словообразующих символов.|  
|`z+`|Сопоставление одного или нескольких вхождений `z` символ.|  
|`\w*`|Соответствует ноль, один или несколько словообразующих символов.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для получения соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="beginning">Отсчитываемая от нуля позиция символа во входной строке, определяющая самую левую позицию диапазона поиска.</param>
        <param name="length">Количество символов в подстроке для включения в поиск.</param>
        <summary>Ищет во входной строке первое вхождение регулярного выражения, начиная с указанной начальной позиции и выполняя поиск только по указанному количеству символов.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения в части во входной строке. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> поиска методов определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторов класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Метод выполняет поиск часть `input` определяется `beginning` и `length` параметры для шаблона регулярного выражения. `beginning` всегда определяет индекс первого символа для включения в поиск, и `length` определяет максимальное количество символов для поиска. Вместе они определяют диапазон поиска. Если поиск выполняется слева направо (по умолчанию), обработчик регулярных выражений выполняет поиск от знак с индексом `beginning` для знак с индексом `beginning`  +  `length` - 1. Если обработчик регулярных выражений был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> так, что поиск выполняется справа, слева, поиск обработчика регулярных выражений из знак с индексом `beginning`  +  `length` - 1 для знак с индексом `beginning`. Этот метод возвращает первое совпадение найденном в течение этого периода. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> метод.  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не устанавливайте значение времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="beginning" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  
  
-или- 
 Параметр <paramref name="length" /> имеет значение меньше нуля или больше длины <paramref name="input" />.  
  
-или- 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> определяет позицию, которая находится вне диапазона <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> со <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> конструктор и вызова экземпляр <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод. Все совпадения в одном вызове метода также можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции поиска совпадения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, которое совпадает со словами, начинающиеся с буквы «». Она использует <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> параметр, чтобы убедиться, что регулярное выражение находит слова, начинающиеся на обоих заглавных букв нижнего регистра «» и «».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Возможные интерпретации шаблона регулярного выражения `\ba\w*\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`a`|Совпадение с символом «».|  
|`\w*`|Соответствует ноль, один или несколько словообразующих символов.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для получения соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет во входной строке первое вхождение заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Объект, содержащий сведения о совпадении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Метод возвращает первую подстроку, соответствующую шаблону регулярного выражения во входной строке. Сведения об элементах языка, используемый для построения шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Статический <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метода эквивалентно созданию <xref:System.Text.RegularExpressions.Regex> со <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> конструктор и вызова экземпляр <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Можно определить, было ли найдено шаблон регулярного выражения во входной строке, проверив значение возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Group.Success%2A> свойство. Если соответствие найдено, возвращенный <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Capture.Value%2A> свойство содержит подстроку из `input` , соответствующий шаблону регулярного выражения. Если совпадений не найдено, его значение равно <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Этот метод возвращает первую подстроку, найденную в `input` , соответствующий шаблону регулярного выражения. Можно получить последующие соответствия, повторно вызывая возвращенного <xref:System.Text.RegularExpressions.Match> объекта <xref:System.Text.RegularExpressions.Match.NextMatch%2A> метод. Все совпадения в одном вызове метода также можно получить, вызвав <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> метод.  
  
 `matchTimeout` Параметр указывает о том, как долго шаблон соответствующий метод следует пытаться найти совпадение, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом скрывается перестает отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадений не найдено в течение этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ищет во входной строке все вхождения регулярного выражения и возвращает все соответствия.</summary>
        <block subset="none" type="usage"><para>При повторном попытки поиска совпадения, вызвав <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> , обработчик регулярных выражений дает пустые соответствия обрабатываются особым образом. Обычно обработчик регулярных выражений начинает поиск следующего соответствия ровно там, где предыдущего совпадения остановились. Однако после пустого соответствия, обработчик регулярных выражений перемещает один символ перед попыткой следующего совпадения. Такое поведение гарантирует, что обработчик регулярных выражений будет протекать строки. В противном случае из-за пустого соответствия не приведет к любой перемещение вперед, следующий поиск начнется в том же месте, что и предыдущий, и процесс зациклится же пустая строка.  
  
В следующем примере шаблон регулярного выражения <c>*</c> ищет ноль или более вхождения буквы «» в строке «abaabb». Как видно в результатах показано в примере, полученный в результате <see cref="T:System.Text.RegularExpressions.MatchCollection" /> объект содержит шесть <see cref="T:System.Text.RegularExpressions.Match" /> объектов. Первая попытка match находит первый «». Второй поиск начинается точно в том случае, где первый соответствовать завершается, прежде чем первый b; он выполняет поиск вхождений «a» и возвращает пустую строку. Третье соответствие не начинается точно где второй объект match закончилось, так как второй объект match вернул пустую строку. Вместо этого он начинает один символ позже, после первой «b». Третье соответствие находит два вхождения «a» и возвращает «aa». Четвертый попытки поиска совпадения начинается, где закончился третий, перед второй «b» и возвращает пустую строку. Пятой попытки поиска совпадения снова перемещает один символ, так что он начинается еще до третьей «b» и возвращает пустую строку. Шестой поиск начинается после последнего «b» и снова возвращает пустую строку.  
  
[!code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [!code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения.</summary>
        <returns>Коллекция <see cref="T:System.Text.RegularExpressions.Match" /> объекты, найденные в ходе поиска. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Метод аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> за тем исключением, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это аналогично следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Коллекция включает только те и заканчивается на первом не соответствует.  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> поиска методов определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторов класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенные вычисления для заполнения возвращенного <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает сбор для заполнения немедленно. Чтобы воспользоваться преимуществами отложенное вычисление, следует осуществить итерацию по коллекции с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенные вычисления вызывая <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Тем не менее, возникает исключение при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объекта, возвращаемого этим методом, если <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> свойство не является <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и соответствующая операция превысит этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> метод выявления слов в предложении, которые заканчиваются на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение с литеральной строкой «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="startat">Позиция символа во входной строке, с которого начинается поиск.</param>
        <summary>Ищет в указанной входной строке все вхождения регулярного выражения, начиная с указанной начальной позиции.</summary>
        <returns>Коллекция <see cref="T:System.Text.RegularExpressions.Match" /> объекты, найденные в ходе поиска. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Метод аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> за тем исключением, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это аналогично следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Шаблон регулярного выражения, для которого <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> поиска методов определяется путем вызова одного из <xref:System.Text.RegularExpressions.Regex> конструкторов класса. Дополнительные сведения об элементах, образующих шаблон регулярного выражения, см. в разделе [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенные вычисления для заполнения возвращенного <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает сбор для заполнения немедленно. Чтобы воспользоваться преимуществами отложенное вычисление, следует осуществить итерацию по коллекции с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенные вычисления вызывая <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Тем не менее, возникает исключение при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объекта, возвращаемого этим методом, если <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> свойство не является <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и соответствующая операция превысит этот интервал времени ожидания. 
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метод для поиска первого слова в предложении, которое заканчивается на «es», а затем вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> метод выявления другие слова, которые заканчиваются на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение с литеральной строкой «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения.</summary>
        <returns>Коллекция <see cref="T:System.Text.RegularExpressions.Match" /> объекты, найденные в ходе поиска. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Метод аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> за тем исключением, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это аналогично следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Статический `Matches` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенные вычисления для заполнения возвращенного <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает сбор для заполнения немедленно. Чтобы воспользоваться преимуществами отложенное вычисление, следует осуществить итерацию по коллекции с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенные вычисления вызывая <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Тем не менее, возникает исключение при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объекта, возвращаемого этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» для текущего домена приложения и операцию сопоставления. превысит этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод выявления любое слово в предложении, которое заканчивается на «es».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение с литеральной строкой «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для извлечения нескольких шаблон соответствует — <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, которые позволяют указать интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления.</summary>
        <returns>Коллекция <see cref="T:System.Text.RegularExpressions.Match" /> объекты, найденные в ходе поиска. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Метод аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> за тем исключением, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это аналогично следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Статический `Matches` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенные вычисления для заполнения возвращенного <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает сбор для заполнения немедленно. Чтобы воспользоваться преимуществами отложенное вычисление, следует осуществить итерацию по коллекции с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенные вычисления вызывая <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Тем не менее, возникает исключение при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объекта, возвращаемого этим методом, если интервал времени ожидания определяется свойством «REGEX_DEFAULT_MATCH_TIMEOUT» для текущего домена приложения и операцию сопоставления. превысит этот интервал времени ожидания.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> метод выявления любых слов в предложении, которое заканчивается на «es», а затем вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой. Как показывает вывод, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение с литеральной строкой «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Рекомендуемые статический метод для извлечения нескольких шаблон соответствует — <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, задающая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Ищет в указанной входной строке все вхождения заданного регулярного выражения, используя указанные параметры сопоставления и интервал времени ожидания.</summary>
        <returns>Коллекция <see cref="T:System.Text.RegularExpressions.Match" /> объекты, найденные в ходе поиска. Если соответствующие объекты не найдены, метод возвращает пустой объект коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Метод аналогичен методу <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> за тем исключением, что он возвращает сведения о всех сопоставлениях найден во входной строке, а не одного совпадения. Это аналогично следующему коду:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Статический `Matches` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Matches`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 <xref:System.Text.RegularExpressions.Regex.Matches%2A> Метод использует отложенные вычисления для заполнения возвращенного <xref:System.Text.RegularExpressions.MatchCollection> объекта. Доступ к членам этой коллекции, такие как <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> вызывает сбор для заполнения немедленно. Чтобы воспользоваться преимуществами отложенное вычисление, следует осуществить итерацию по коллекции с помощью конструкции, такие как `foreach` в C# и `For Each`...`Next` в Visual Basic.  
  
 Из-за его отложенные вычисления вызывая <xref:System.Text.RegularExpressions.Regex.Matches%2A> метод не выдает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. Тем не менее, создается исключение при выполнении операции над <xref:System.Text.RegularExpressions.MatchCollection> объекта, возвращаемого этим методом, если соответствующая операция превысит этот интервал времени ожидания, заданный в параметре`matchTimeout` параметра.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы выполнить сравнение с учетом регистра, который соответствует любому слову, в предложении, которое заканчивается на «es». Затем он вызывает <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод, чтобы выполнить сравнение без учета регистра шаблона со входной строкой. В обоих случаях интервал времени ожидания устанавливается одной секунде. Как показывает вывод, два метода возвращают разные результаты.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Шаблон регулярного выражения `\b\w+es\b` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`es`|Совпадение с литеральной строкой «es».|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает интервал времени ожидания текущего экземпляра.</summary>
        <value>Максимальный интервал времени, которое может пройти в операции поиска совпадения с шаблоном перед <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> возникает исключение, или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> тайм-ауты при отключении.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Свойство определяет приблизительное максимальный интервал времени для <xref:System.Text.RegularExpressions.Regex> экземпляра для выполнения одной операции сопоставления до истечения времени ожидания операции. Обработчик регулярных выражений создает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключения во время его следующей проверки времени, по истечении интервала времени ожидания. Это предотвращает обработки входных строк, которые требуют избыточный поиск с возвратом обработчик регулярных выражений. Дополнительные сведения см. в разделе [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md) и [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md).  
  
 Это свойство доступно только для чтения. Его значение можно задать явным образом для отдельного <xref:System.Text.RegularExpressions.Regex> путем вызова метода <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктора; и вы можете задать его значение для всех <xref:System.Text.RegularExpressions.Regex> совпадающие операции в домене приложения, вызвав <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод и предоставляя <xref:System.TimeSpan> значение для свойства «REGEX_DEFAULT_MATCH_TIMEOUT», как показано в следующем примере.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Если не задано явным образом интервал времени ожидания, значение по умолчанию <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> используется и сопоставление операции не имеют срока действия.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает параметры, которые были переданы в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор.</summary>
        <value>Один или несколько членов <see cref="T:System.Text.RegularExpressions.RegexOptions" /> перечисления, представляющих параметры, которые были переданы <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Text.RegularExpressions.Regex.Options%2A> свойство состоит из одного или нескольких членов из <xref:System.Text.RegularExpressions.RegexOptions> перечисления. Если параметры не были определены в <xref:System.Text.RegularExpressions.Regex> конструктора класса, его значение равно <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Доступные варианты подробно описаны в [параметры регулярных выражений](~/docs/standard/base-types/regular-expression-options.md) раздела.  
  
 Обратите внимание, что <xref:System.Text.RegularExpressions.Regex.Options%2A> свойство не отражает встроенные параметры, определенные в регулярном выражении шаблон сам.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданных <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> метод. Эти скомпилированные регулярные выражения использовать реализацию базового класса <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство. При вызове из производного класса, <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство возвращает параметры, которые были переданы <paramref name="options" /> параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Параметры регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>В указанной входной строке заменяет строки, соответствующие шаблону регулярного выражения с указанной строкой замены.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начинается поиск совпадений в начале `input` строка. Регулярное выражение — это шаблон, определенный в конструкторе для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `replacement` Параметр указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\s+`, который соответствует один или несколько символов пробела. Строка замены "«, заменяются одним пробелом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 В следующем примере определяется регулярное выражение, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`и шаблон замены `$2`, которая удаляет начальный или конечный символ валюты из числового значения.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\p{Sc}`|Соответствует символ валюты. `{Sc}` Обозначает любой символ, который входит в состав Юникода категории символов и валют.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{Sc}\s?)?`|Совпадение с нулем или одним вхождением сочетание символ валюты, за которым следует ноль или один символ пробела. Это первая группа записи.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\.?`|Совпадение с нулем или одним вхождением точки (используется как символ десятичного разделителя).|  
|`((?<=\.)\d+)?`|Если период предыдущего символа, соответствует один или несколько десятичных цифр. Этот шаблон могут быть сопоставлены ноль или один раз.|  
|`(\d+\.?((?<=\.)\d+)?)`|Совпадение с шаблоном один или несколько десятичных цифр, за которым следует необязательная точка и десятичными цифрами. Это вторая группа записи. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> метод заменяет все совпадения со значением данной захватываемой группой.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Если первая захваченная группа существует, сопоставьте пустую строку. В противном случае соответствовать ноль или один символ пробела, за которым следует символ валюты.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной в сопоставленной строке.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> передачей каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 Регулярное выражение — это шаблон, определенный в конструкторе для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере кода отображается исходная строка, сопоставляет каждое слово в исходной строке, преобразует первую букву каждого совпадения в верхний регистр, а затем отображает преобразованную строку.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное количество возможных случаев замены.</param>
        <summary>В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начинается поиск совпадений в начале `input` строка. Регулярное выражение – шаблон, который определен с помощью конструктора для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, заменяются все совпадения.  
  
 `replacement` Параметр указывает строку, которая заключается в замене первый `count` соответствует `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере заменяется первые пять вхождений повторяющихся символов в виде одного символа. Шаблон регулярного выражения `(\w)\1` соответствует последовательных вхождений одного символа и присваивает его первое вхождение первой захватываемой группе. Шаблон замены `$1` заменяет все совпадения с первой захватываемой группы.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Начинается поиск совпадений в начале `input` строка.  
  
 `replacement` Параметр указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере определяется регулярное выражение, `\s+`, который соответствует один или несколько символов пробела. Строка замены "«, заменяются одним пробелом.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод для замены локальные имена машины и диска в пути UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство, чтобы включить имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Чтобы успешно запустить пример, строковый литерал «MyMachine» следует заменить имя вашего локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, с дополнительную обратную косую черту необходимо экранировать каждой обратной косой чертой.|  
|`(?i:" + Environment.MachineName + ")`|Выполните совпадение без учета регистра строки, возвращаемые <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Соответствует периода (`.`) символа, за которой следует один или несколько словообразующих символов. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не захватывается.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`((?i:[" + driveNames + "]))`|Выполните совпадение без учета регистра символов класса, который состоит из отдельных букв диска. Это первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первой захватываемой части выражения. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для замены соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной в сопоставленной строке.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> передачей каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифрует отдельные буквы в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент <xref:System.String> конструктора класса. Эта строка только что созданный то возвращенные `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует один или несколько символов слова; обработчик регулярных выражений будет продолжать добавлять знаки к совпадению, пока встретится несловообразующий символ, такой как символ пробела.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для оценки и заменив соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество случаев замены.</param>
        <summary>В указанной входной строке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> делегировать.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной в сопоставленной строке.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> передачей первый `count` <xref:System.Text.RegularExpressions.Match> объектов в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 Регулярное выражение — это шаблон, определенный в конструкторе для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере регулярное выражение намеренно опечатка половина слов из списка. Она использует регулярное выражение `\w*(ie|ei)\w*` для сопоставления слов, которые содержат символы «ie» или «ei». Он передает первой половины совпадающих слов `ReverseLetter` метод, который, в свою очередь, использует <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> способы восстановления «i» и «e» в совпадающую строку. Остальные слова остаются неизменными.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Определение регулярного выражения `\w*(ie|ei)\w*` показано в таблице ниже.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
|<code>(ie&#124;ei)</code>|Совпадает с «ie» или «ei».|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
  
 Шаблон регулярного выражения `([ie])([ie])` в `ReverseLetter` метод соответствует diphthong «ie» или «ei» первый «i» или «e» и назначает ему букву первой захватываемой группе. Он соответствует второй «i» или «e» и назначает ему букву второй захватываемой группе. Два символа отменяются, вызвав <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> метод с шаблон замены `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="replacement">Строка замены.</param>
        <param name="count">Максимальное возможное количество случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, указанной строкой замены.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запускает поиск соответствий в `input` строка в позиции, заданной параметром `startat` параметр. Регулярное выражение — это шаблон, определенный в конструкторе для текущего <xref:System.Text.RegularExpressions.Regex> объекта. Если `count` является отрицательным, замена продолжается до конца строки. Если `count` превышает количество совпадений, заменяются все совпадения.  
  
 `replacement` Параметр указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 Следующий пример двойные пробелы содержатся все, кроме первой строки в строке. Он определяет шаблон регулярного выражения `^.*$`, выделяющий строку текста, вызовы <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> метода в соответствии первая часть строки, а использует `Match.Index` и `Match.Count` свойства, чтобы определить позицию второго Строка.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Шаблон регулярного выражения `^.*$` определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Соответствует концу строки. (Обратите внимание, что <xref:System.Text.RegularExpressions.Regex> объект был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> параметр; в противном случае этот класс символов будет соответствовать только начало входной строки.)|  
|`.*`|Совпадение с любым символом ноль или более раз.|  
|`$`|Поиск конца строки. (Обратите внимание, что <xref:System.Text.RegularExpressions.Regex> объект был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> параметр; в противном случае этот класс символов будет соответствовать только начало входной строки.)|  
  
 Строка замены (`vbCrLf + "$&"` в Visual Basic, `"\n$&"` в C#) добавляет новую строку перед совпадающую строку. Обратите внимание, что `\n` в C# пример интерпретируется как символ новой строки с помощью компилятора C#; он не представляет escape-знаков регулярных выражений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="replacement" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Если указать <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметр, поиск соответствий начинается в конце входной строки и перемещает слева; в противном, поиск начинается с начала входной строки и сдвиг вправо.  
  
 `replacement` Параметр указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> метод для замены локальные имена машины и диска в пути UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство, чтобы включить имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Все Регулярное выражение сравнения строк без учета регистра. Чтобы успешно запустить пример, строковый литерал «MyMachine» следует заменить имя вашего локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, с дополнительную обратную косую черту необходимо экранировать каждой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадает со строкой, которая возвращается <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Соответствует периода (`.`) символа, за которой следует один или несколько словообразующих символов. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не захватывается.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`([" + driveNames + "])`|Соответствует класс символов, состоящий из отдельных букв диска. Это первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первой захватываемой части выражения. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значение времени ожидания по умолчанию домена приложения, в котором он вызывается. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для замены соответствия шаблону <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения в, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной в сопоставленной строке.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> передачей каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 Если указать <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметр, поиск соответствий начинается в конце входной строки и перемещает слева; в противном, поиск начинается с начала входной строки и сдвиг вправо.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифрует отдельные буквы в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент <xref:System.String> конструктора класса. Эта строка только что созданный то возвращенные `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует один или несколько символов слова; обработчик регулярных выражений будет продолжать добавлять знаки к совпадению, пока встретится несловообразующий символ, такой как символ пробела. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метод включает <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` обрабатывается обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="count">Максимальное количество случаев замены.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>В указанной входной подстроке заменяет указанное максимальное количество строк, соответствующих шаблону регулярного выражения, строкой, возвращенной <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> делегировать.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если в текущем экземпляре нет соответствия шаблону регулярных выражений, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Строка замены получается из некоторой обработки, выполненной в сопоставленной строке.  
  
-   Строка замены получается из условной обработки.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> передачей первый `count` <xref:System.Text.RegularExpressions.Match> объектов в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 Регулярное выражение — это шаблон, определенный в конструкторе для текущего <xref:System.Text.RegularExpressions.Regex> объекта.  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции замены превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="evaluator" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="replacement">Строка замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все строки, соответствующие указанному регулярному выражению, указанной строкой замены. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статический `Replace` методов эквивалентны созданию <xref:System.Text.RegularExpressions.Regex> с заданного шаблона регулярного выражения и вызова метода `Replace`.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Если указать <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметр, поиск соответствий начинается в конце входной строки и перемещает слева; в противном, поиск начинается с начала входной строки и сдвиг вправо.  
  
 `replacement` Параметр указывает строку, которая является для замены каждого соответствия во `input`. `replacement` может содержать любое сочетание текста и [подстановок](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Например, шаблон замены `a*${test}b` вставляет строку «*» следуют подстроке, которая сопоставляется с методом `test` захватываемой группе, в том случае, если таковые имеются, за которым следует строка «b». * Символ не распознается как метасимвол в шаблоне замены.  
  
> [!NOTE]
>  Подстановки — это элементы языка только регулярных выражений, которые распознаются в шаблонах замены. Все другие регулярного выражения элементов языка, включая [символ escape-символы](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), допустимы только шаблоны регулярных выражений и не распознаются в шаблонах замены.  
  
 `matchTimeout` Параметр указывает о том, как долго шаблон соответствующий метод следует пытаться найти совпадение, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом скрывается перестает отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадений не найдено в течение этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> метод для замены локальные имена машины и диска в пути UNC путь к локальному файлу. В регулярном выражении используется <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство, чтобы включить имя локального компьютера и <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> метод, чтобы включить имена логических дисков. Все Регулярное выражение сравнения строк без учета регистра, а время ожидания для любой операции одна операция замены, если совпадение не найдено в 0,5 секунды. Чтобы успешно запустить пример, строковый литерал «MyMachine» следует заменить имя вашего локального компьютера.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Шаблон регулярного выражения определяется следующее выражение:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\\\\`|Соответствует двум обратной косой черты подряд (`\`) символов. Так как символ обратной косой черты интерпретируется как escape-символ, с дополнительную обратную косую черту необходимо экранировать каждой обратной косой чертой.|  
|`+ Environment.MachineName +`|Совпадает со строкой, которая возвращается <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойство.|  
|`(?:\.\w+)*`|Соответствует периода (`.`) символа, за которой следует один или несколько словообразующих символов. Это совпадение может произойти ноль или более раз. Сопоставленная часть выражения не захватывается.|  
|`\\`|Соответствует обратной косой черты (`\`) символов.|  
|`([" + driveNames + "])`|Соответствует класс символов, состоящий из отдельных букв диска. Это первое полученное вложенное выражение.|  
|`\$`|Соответствует знак доллара (`$`) символов.|  
  
 Шаблон замены `$1` заменяет все совпадения с первой захватываемой части выражения. То есть он заменяет UNC-имя компьютера и диск с буквой диска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="replacement" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для поиска соответствия.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="evaluator">Пользовательский метод, анализирующий каждое совпадение и возвращающий либо исходную строку с совпадениями, либо строку замены.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющих параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>В указанной входной строке заменяет все подстроки, соответствующие указанному регулярному выражению, строкой, возвращенной делегатом <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Новая строка, идентичная входной строке, за исключением того что строка замены занимает место каждой соответствующей строки. Если для <paramref name="pattern" /> не найдено соответствия в текущем экземпляре, метод возвращает текущий экземпляр без изменений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Метод полезен для замены совпадения регулярного выражения, если выполняется хотя бы одно из следующих условий:  
  
-   Если строка замены нельзя легко указать замены шаблоном регулярного выражения.  
  
-   Если строка замены полученный в результате некоторые обработки выполняются на совпадающую строку.  
  
-   Если строка замены результатом условную обработку.  
  
 Метод эквивалентно вызову <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> передачей каждого <xref:System.Text.RegularExpressions.Match> объекта в возвращаемом <xref:System.Text.RegularExpressions.MatchCollection> коллекции `evaluator` делегировать.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 `evaluator` Параметр является делегатом для пользовательского метода, который определяется и проверяет каждое соответствие. Пользовательский метод должен иметь следующую сигнатуру в соответствии с <xref:System.Text.RegularExpressions.MatchEvaluator> делегировать.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Пользовательский метод возвращает строку, которая заменяет совпадающую входных данных.  
  
 Если указать <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> для `options` параметр, поиск соответствий начинается в конце входной строки и перемещает слева; в противном, поиск начинается с начала входной строки и сдвиг вправо.  
  
 `matchTimeout` Параметр указывает о том, как долго шаблон соответствующий метод следует пытаться найти совпадение, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом из на «перестать отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадений не найдено в течение этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 Поскольку этот метод возвращает `input` без изменений, если совпадения нет, можно использовать <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод, чтобы определить, ли метод сделать замены к входной строке.  
  
   
  
## Examples  
 Следующий пример использует регулярное выражение для извлечения отдельные слова из строки, а затем использует <xref:System.Text.RegularExpressions.MatchEvaluator> делегат, вызываемый метод с именем `WordScramble` , шифрует отдельные буквы в слове. Чтобы сделать это, `WordScramble` метод создает массив, содержащий символы в соответствие. Он также создает параллельный массив, который он заполняет случайными числами с плавающей запятой. Массивы сортируются путем вызова <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> метод и упорядоченный массив предоставляется как аргумент <xref:System.String> конструктора класса. Эта строка только что созданный то возвращенные `WordScramble` метод. Шаблон регулярного выражения `\w+` соответствует один или несколько символов слова; обработчик регулярных выражений будет продолжать добавлять знаки к совпадению, пока встретится несловообразующий символ, такой как символ пробела. Вызов <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> метод включает <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> параметр, чтобы комментарий в шаблоне регулярного выражения `\w+  # Matches all the characters in a word.` обрабатывается обработчиком регулярных выражений.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="input" />, <paramref name="pattern" /> или <paramref name="evaluator" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Подстановки</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Поиск с возвратом</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Рекомендации по использованию регулярных выражений в .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее на то, выполняется ли регулярным выражением поиск справа налево.</summary>
        <value><see langword="true" /> Если регулярное выражение выполняет поиск справа налево; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> — `true` Если <xref:System.Text.RegularExpressions.Regex> экземпляр был создан с помощью <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> параметр.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных соответствием регулярного выражения.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения, указанным в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется максимально возможное количество раз. Если разделитель не найден, то возвращаемое значение содержит один элемент, значение которого является исходной входной строкой.  
  
 Если рядом друг с другом несколько соответствий, пустая строка вставляется в массив. Например разделение строки дефисом приводит возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Если соответствие найдено в начале или конце входной строки, пустая строка включается в начале или конце возвращаемого массива. В следующем примере используется шаблон регулярного выражения `\d+` для разбиения входной строки для числовых символов. Так как строка начинается и заканчивается сопоставления числовых символов, значение первого и последнего элемента, возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любое записанный текст включается в результирующий массив строк. Например если выполнить разделение строки «слива груша» дефисами находиться внутри круглых скобок, возвращаемый массив включает в себя строковый элемент, который содержит дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора круглых скобок для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, это исключит символы косой черты; Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте. Пример:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции разбиения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. `count` Параметр указывает максимальное количество подстрок, в который `input` можно разделить строку; последняя строка содержит неразделенный остаток строки. Объект `count` нулевое значение обеспечивает разбивки максимально возможное поведение по умолчанию.  
  
 Если несколько соответствий находятся рядом друг с другом или найдено в начале или конце `input`, а число найденных совпадений — по крайней мере два меньше, чем `count`, пустая строка вставляется в массив. То есть пустые строки, которые в результате смежных соответствий или совпадений в начале или в конце входной строки учитываются при определении ли число соответствует equals подстроки `count`. В следующем примере регулярное выражение `/d+` используется для разбиения входной строки, включает в себя более трех подстроки один или несколько десятичных цифр. Так как в начале входной строки соответствует шаблону регулярного выражения, первый элемент массива содержит <xref:System.String.Empty?displayProperty=nameWithType>, второй содержит первый набор буквенные символы во входной строке, а третий содержит остаток строки Третье соответствие ниже.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк. Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении количество совпадений, достиг ли `count`. Например разделение строки «apple яблоко слива груша банан» в максимум четыре результаты подстроки в 7 элементный массив, как следующий код показывает.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 только записанный текст из первого набора круглых скобок, включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст добавляется в возвращаемый массив. Тем не менее, элементы в возвращенном массиве, содержащие записанный текст, не учитываются при определении ли число соответствует equals подстроки `count`. Например в следующем коде, регулярное выражение использует два набора круглых скобок для извлечения элементов даты из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Вызов <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> метод затем задает более двух элементов в возвращаемый массив. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, метод возвращает массив строк двух элементов. Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздних версий, метод возвращает массив строк с тремя элементами.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте. Следующий пример разделяет строку «символы» на столько элементов, у вас есть входная строка. Так как пустая строка соответствует началу входной строки, пустая строка вставляется в начале возвращаемого массива. В результате десятый элемент состоит из двух символов в конце входной строки.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции разбиения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных шаблоном регулярного выражения.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. `input` Строка разделяется максимально возможное. Если `pattern` не найден в `input` строки, возвращаемое значение содержит один элемент, значение которого является исходный `input` строка.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах на статический <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем существования скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если рядом друг с другом несколько соответствий, пустая строка вставляется в массив. Например разделение строки дефисом приводит возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса, как показано в следующем коде.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Если соответствие найдено в начале или конце входной строки, пустая строка включается в начале или конце возвращаемого массива. В следующем примере используется шаблон регулярного выражения `\d+` для разбиения входной строки для числовых символов. Так как строка начинается и заканчивается сопоставления числовых символов, значение первого и последнего элемента, возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любое записанный текст включается в результирующий массив строк. Например если выполнить разделение строки «слива груша» дефисами находиться внутри круглых скобок, возвращаемый массив включает в себя строковый элемент, который содержит дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора круглых скобок для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, это исключит символы косой черты; Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте. Пример:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Обратите внимание, что возвращаемый массив также включает пустую строку в начале и в конец массива.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции разбиения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значению времени ожидания по умолчанию домен приложения, в котором вызывается метод. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для разделения текста на соответствие шаблону <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="count">Максимальное количество возможных случаев разделения.</param>
        <param name="startat">Позиция символа во входной строке, с которой начинается поиск.</param>
        <summary>Разделяет входную строку указанное максимальное количество раз в массив подстрок в позициях, определенных регулярным выражением, указанным в <see cref="T:System.Text.RegularExpressions.Regex" /> конструктор. Поиск шаблона регулярного выражения начинается с указанной позиции элемента во входной строке.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%2A?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. `count` Параметр указывает максимальное количество подстрок, в который `input` разбиения строк; последняя строка содержит неразделенный остаток строки. Объект `count` нулевое значение обеспечивает разбивки максимально возможное поведение по умолчанию. `startat` Параметр определяет точку, с которого начинается поиск первого разделителя (это может использоваться для пропуска начальных пробелов).  
  
 Если соответствий не найдено из `count`+ 1 позицию в строке, то метод возвращает одноэлементный массив, содержащий `input` строка. Если один или несколько совпадений, первый элемент возвращенного массива содержит первую часть строки с первого символа до одного символа до соответствия.  
  
 Если несколько соответствий находятся рядом друг с другом, а число найденных совпадений — по крайней мере два меньше, чем `count`, пустая строка вставляется в массив. Аналогично если он найден в `startat`, который является первым символом в строке, первый элемент возвращенного массива является пустой строкой. То есть пустые строки, являющиеся результатом смежных соответствий учитываются при определении ли число соответствует equals подстроки `count`. В следующем примере регулярное выражение `\d+` используется для поиска начальную позицию первой подстроке числовых символов в строке, а затем для разбиения строки более трех раз, начиная с этой позиции. Так как шаблон регулярного выражения соответствует началу входной строки, возвращаемый массив строк состоит из пустая строка, строка является буквой алфавита пяти символов и остальная часть строки,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Если в регулярном выражении используются скобки записи, любой записанный текст включается в массив разделенных строк. Тем не менее, все элементы массива, содержащие записанный текст, не учитываются при определении количество совпадений, достиг ли `count`. Например, разделение строки "«яблоко-абрикос-слива-груша-гранат-ананас-персик» в максимальном количестве четырех подстроки, начиная с символа" 15 "в строке, дает в 7 элементный массив, как показано в следующем коде.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора круглых скобок для извлечения отдельных слов в строке. Первый набор скобок записи записывает дефис, а второй набор записывает вертикальной чертой. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, исключаются вертикальной строки символов. Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте. Следующий пример разделяется на строку «символы» столько же элементов содержит входную строку, начиная с символа «». Так как пустая строка соответствует концу входной строки, в конце возвращаемый массив вставляется пустая строка.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции разбиения превышает интервал времени ожидания, который задается параметром <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> конструктор. Если вы не установите интервал времени ожидания при вызове конструктора, исключение, если операция длится любое значение времени ожидания, установленным для домена приложения, в котором <xref:System.Text.RegularExpressions.Regex> создается объект. Если время ожидания не определен в <xref:System.Text.RegularExpressions.Regex> вызов конструктора или в свойствах домена приложения, или если значение интервала <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="startat" /> имеет значение меньше нуля или больше длины <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Указанные параметры изменяют операцию сопоставления.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется максимально возможное количество раз. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный `input` строка.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах на статический <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем существования скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если рядом друг с другом несколько соответствий, пустая строка вставляется в массив. Например разделение строки дефисом приводит возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.  
  
 Если соответствие найдено в начале или конце входной строки, пустая строка включается в начале или конце возвращаемого массива. В следующем примере используется шаблон регулярного выражения `[a-z]+` для разбиения входной строки на любой прописные или строчные буквы. Так как строка начинается и заканчивается с совпадающими буквенные символы, значение первого и последнего элемента, возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любое записанный текст включается в результирующий массив строк. Например если выполнить разделение строки «слива груша» дефисами находиться внутри круглых скобок, возвращаемый массив включает в себя строковый элемент, который содержит дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора круглых скобок для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, это исключит символы косой черты; Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Исключение вызывается в том случае, если время выполнения операции разбиения превышает ожидания, указанное для домена приложения, в котором вызывается метод. Если время ожидания не определен в свойствах домена приложения, или в том случае, если значение времени ожидания <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Этот метод время истекает через интервал, равный значению времени ожидания по умолчанию домен приложения, в котором вызывается метод. Если значение времени ожидания не был определен для домена приложения, значение <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, что предотвращает истечения времени ожидания, метод используется. Статические рекомендуется для разделения текста на соответствие шаблону <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, который позволяет установить интервал времени ожидания.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Строка для разделения.</param>
        <param name="pattern">Шаблон регулярного выражения для сопоставления.</param>
        <param name="options">Побитовая комбинация значений перечисления, предоставляющая параметры для сопоставления.</param>
        <param name="matchTimeout">Интервал времени ожидания или <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, чтобы указать, что метод не должен превышать время ожидания.</param>
        <summary>Разделяет входную строку в массив подстрок в позициях, определенных указанным шаблоном регулярного выражения. Дополнительные параметры определяют параметры, которые изменяют соответствующую операцию и интервал времени ожидания, если совпадение не найдено.</summary>
        <returns>Массив строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Методы похожи на <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> метода, за исключением случаев, <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> разбивает строку по разделителям регулярным выражением, вместо набора символов. Строка разделяется максимально возможное количество раз. Если разделитель не найден, возвращаемое значение содержит один элемент, значение которого является исходный `input` строка.  
  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Скомпилированные регулярные выражения, используемые в вызовах на статический <xref:System.Text.RegularExpressions.Regex.Split%2A> методы автоматически сохраняются в кэше. Чтобы самостоятельно управлять временем существования скомпилированные регулярные выражения, используйте экземпляр <xref:System.Text.RegularExpressions.Regex.Split%2A> методы.  
  
 Если рядом друг с другом несколько соответствий, пустая строка вставляется в массив. Например разделение строки дефисом приводит возвращаемый массив для включения пустую строку в позицию, где находятся два смежных дефиса.  
  
 Если соответствие найдено в начале или конце входной строки, пустая строка включается в начале или конце возвращаемого массива. В следующем примере используется шаблон регулярного выражения `[a-z]+` для разбиения входной строки на любой прописные или строчные буквы. Так как строка начинается и заканчивается с совпадающими буквенные символы, значение первого и последнего элемента, возвращаемого массива является <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Если используются скобки записи в <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> выражения, любое записанный текст включается в результирующий массив строк. Например если выполнить разделение строки «слива груша» дефисами находиться внутри круглых скобок, возвращаемый массив включает в себя строковый элемент, который содержит дефис.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Тем не менее если шаблон регулярного выражения содержит несколько наборов круглых скобок, поведение этого метода зависит от версии платформы .NET Framework. В .NET Framework 1.0 и 1.1 Если соответствие не найдено в первый набор круглых скобок, записанный текст из дополнительных скобок записи не включается в возвращенном массиве. Начиная с .NET Framework 2.0, все записанный текст также добавляется в возвращаемый массив. Например следующий код использует два набора круглых скобок для извлечения элементов даты, включая разделители даты, из строки даты. Первый набор скобок записи записывает дефис, а второй набор записывает косую черту. Если код примера компилируется и выполняться с использованием .NET Framework 1.0 или 1.1, это исключит символы косой черты; Если он скомпилирован и выполняются в .NET Framework 2.0 или более поздней версии, то они включаются.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Если регулярное выражение может совпасть с пустой строкой, <xref:System.Text.RegularExpressions.Regex.Split%2A> будет разбить строку на массив односимвольных строк, так как разделитель пустой строки можно найти в любом месте.  
  
 `matchTimeout` Параметр указывает о том, как долго шаблон соответствующий метод следует пытаться найти совпадение, до истечения времени ожидания. Установка интервала времени ожидания предотвращает регулярных выражений, которые зависят от того, избыточный поиск с возвратом скрывается перестает отвечать на запросы при обработке входных данных, содержащий ближайшие совпадения. Дополнительные сведения см. в разделе [рекомендации по использованию регулярных выражений](~/docs/standard/base-types/best-practices.md) и [возвратом в регулярных выражениях](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Если совпадений не найдено в течение этого интервала времени, метод вызывает <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> исключение. `matchTimeout` переопределяет любое значение времени ожидания по умолчанию, определенные для домена приложения, в которой выполняется метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Произошла ошибка анализа регулярного выражения.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="input" /> или <paramref name="pattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="options" /> не является допустимой битовой комбинацией значений <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
-или- 
 Значение параметра <paramref name="matchTimeout" /> отрицательное, равно нулю или больше, чем приблизительно 24 дня.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Время ожидания истекло. Дополнительные сведения о времени ожидания см. в разделе "Примечания".</exception>
        <block subset="none" type="usage"><para>Мы рекомендуем установить <paramref name="matchTimeout" /> параметр соответствующее значение, например две секунды. Если отключить время ожидания, указав <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, обработчик регулярных выражений обеспечивает немного лучшую производительность. Тем не менее следует отключить время ожидания только при следующих условиях: 
— Если входные данные, обрабатываемые регулярное выражение является производным от известного и надежного источника или состоит из статического текста. Это исключает текст, который был динамически входные данные пользователей.  
  
— Если шаблон регулярного выражения был всесторонне протестирован для обеспечения эффективной обработки соответствует, несовпадающие, а ближайшем.  
  
— Если шаблон регулярного выражения содержит не элементов языка, причиной которых могут стать избыточный поиск с возвратом при обработке почти соответствия.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Этот параметр зарезервирован для использования в будущем.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает шаблон регулярного выражения, который был передан в <see langword="Regex" /> конструктор.</summary>
        <returns><paramref name="pattern" /> Параметр, который был передан в <see langword="Regex" /> конструктор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` Параметр состоит из элементов языка регулярных выражений, с помощью описывающих сопоставляемой строки. Дополнительные сведения о регулярных выражениях см. в разделе [регулярные выражения .NET Framework](~/docs/standard/base-types/regular-expressions.md) и [языка регулярных выражений — краткий справочник](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> является базовым классом регулярных выражений, созданных <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> метод. Эти скомпилированные регулярные выражения используйте <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> реализации базового класса. При вызове из производного класса, <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> метод возвращает строку, который был передан <paramref name="pattern" /> параметр <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> конструктора класса, который использовался для определения регулярного выражения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Входная строка, содержащая преобразуемый текст.</param>
        <summary>Преобразует все escape-символы во входной строке обратно в символы.</summary>
        <returns>Строка символов с любыми преобразованными символами, приведенными в их непреобразованную форму.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Метод выполняет одно из следующих двух преобразований:  
  
-   Он обращает преобразование, выполненное с <xref:System.Text.RegularExpressions.Regex.Escape%2A> метод путем удаления escape-символ (»\\«) из каждого символа, с помощью метода в escape-последовательность. К ним относятся \\, *, +,?, &#124;, {, [, (,), ^, $,., # и пробелы. Кроме того <xref:System.Text.RegularExpressions.Regex.Unescape%2A> метод отменяет преобразование преобразованных закрывающая скобка (]) и закрывающей фигурной скобкой (}) символов.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Невозможно обратить строку escape-идеально, так как он не может вывести точно были escape-символов,  
  
-   Он заменяет шестнадцатеричных значений в строковые литералы verbatim фактическое печатных символов. Например, он заменяет @"\x07" с «\a», или @"\x0A" с помощью «\n». Он преобразует в поддерживаемые escape-символы, такие как \a, \b, \e, \n, \r, \f, \t, \v и буквенно-цифровые символы.
  
 Если <xref:System.Text.RegularExpressions.Regex.Unescape%2A> метод встречает других escape-последовательности, преобразование невозможно, например \w или \s, он выдает <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> включает нераспознанную escape-последовательность.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="str" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Элементы языка регулярных выражений — краткий справочник</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns><see langword="true" /> Если <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство содержит <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> параметр; в противном случае <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется объектом <see cref="T:System.Text.RegularExpressions.Regex" />, который создан методом <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns><see langword="true" /> Если <see cref="P:System.Text.RegularExpressions.Regex.Options" /> свойство содержит <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> параметр; в противном случае <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Время ожидания, которое требуется проверить.</param>
        <summary>Проверяет, попадает ли интервал времени ожидания в допустимый диапазон.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное время ожидания находится за пределами допустимого диапазона.</exception>
      </Docs>
    </Member>
  </Members>
</Type>