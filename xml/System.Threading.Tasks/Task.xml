<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="398b44801e870ca6454ac741f9a2c20b26ee3f96" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014259" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет асинхронную операцию.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task> Класса представляет одну операцию, которая не возвращает значение и обычно выполняется асинхронно. <xref:System.Threading.Tasks.Task> объекты являются одним из основных составляющих [асинхронную модель на основе задач](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) впервые появилась в .NET Framework 4. Поскольку работа выполняется по <xref:System.Threading.Tasks.Task> объект обычно выполняется асинхронно в потоке пула потоков, а не синхронно в потоке основного приложения, можно использовать <xref:System.Threading.Tasks.Task.Status%2A> свойства, а также <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, и <xref:System.Threading.Tasks.Task.IsFaulted%2A> свойства, чтобы определить состояние задачи. Чаще всего лямбда-выражение используется для указания ожидаемого задачи для выполнения работы.  
  
 Для операций, возвращающих значения, используйте <xref:System.Threading.Tasks.Task%601> класса.  
  
 Содержание  
  
 [Примеры создания экземпляра задачи](#Instant)   
 [Создание и выполнение задачи](#Creating)   
 [Разделение задач создания и выполнения](#Separating)   
 [Ожидание завершения одного или нескольких задач](#WaitingForOne)   
 [Задачи и языка и региональных параметров](#Culture)   
 [Для разработчиков отладчика](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>При создании экземпляра задачи  
 Следующий пример создает и выполняет четыре задачи. Выполнить три задачи <xref:System.Action%601> делегат с именем `action`, который принимает аргумент типа <xref:System.Object>. Четвертый задача выполняет лямбда-выражения ( <xref:System.Action> делегировать) то есть определенный встроенным в вызове метода создания задачи. Каждая задача создается и выполнения по-разному:  
  
-   Задача `t1` создается путем вызова конструктора класса задачи, но начатую посредством вызова его <xref:System.Threading.Tasks.Task.Start> метод только после задачи `t2` запущена.  
  
-   Задача `t2` создается и запустить в одном вызове метода, вызвав командлет <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> метод.  
  
-   Задача `t3` создается и запустить в одном вызове метода, вызвав командлет <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод.  
  
-   Задача `t4` выполняется синхронно в основном потоке, вызвав <xref:System.Threading.Tasks.Task.RunSynchronously> метод.  
  
 Так как задача `t4` выполняется синхронно, оно выполняется в потоке основного приложения. Остальные задачи обычно асинхронного выполнения в одной или нескольких потоках пула потоков.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Создание и выполнение задачи  
 <xref:System.Threading.Tasks.Task> экземпляры могут создаваться разными способами. Наиболее распространенным подходом, который доступен, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], заключается в вызове статического <xref:System.Threading.Tasks.Task.Run%2A> метод. <xref:System.Threading.Tasks.Task.Run%2A> Метод предоставляет простой способ запуска задачи, используя значения по умолчанию и не требует дополнительных параметров. В следующем примере используется <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод, чтобы запустить задачу, которая выполняет цикл, а затем отображает количество итераций цикла:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Альтернативы и наиболее распространенный метод для запуска задачи в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], является статическим <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод. <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Возвращает <xref:System.Threading.Tasks.TaskFactory> объекта. Перегруженные версии <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод позволяет задавать параметры для передачи параметры создания задач и планировщик задач. В следующем примере используется <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод для запуска задачи. Это функционально эквивалентно кода в предыдущем примере.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Более полные примеры см. в разделе [Task-based асинхронное программирование](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Разделение задач создания и выполнения  
 <xref:System.Threading.Tasks.Task> Класс также предоставляет конструкторы, которые инициализируют задачу, но не запланировать его выполнение. Для повышения производительности <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод — предпочтительный механизм для создания и планирования вычислительных задач, но для сценариев, где должны быть разделены Создание и планирование, можно использовать конструкторы и затем вызвать <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> метод для планирования задачи для выполнения в дальнейшем.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Ожидание завершения одного или нескольких задач  
 Поскольку задачи обычно выполняются асинхронно в потоке пула потоков, потока, который создает и запускает задачу продолжает выполнение сразу же после создания экземпляра задачи. В некоторых случаях, когда вызывающий поток является потоком основного приложения, приложение может завершиться перед любым задачи фактически начинает выполнение. В других случаях логику приложения может потребоваться, что вызывающему потоку продолжить выполнение только в том случае, если один или несколько задач было выполнено. Вы можете синхронизировать выполнение вызывающего потока и асинхронной задачи он запускает путем вызова `Wait` метод для ожидания завершения одной или нескольких задач.  
  
 Чтобы дождаться завершения выполнения одной задачи, можно вызвать его <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод. Вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод блокирует вызывающий поток до завершения выполнения экземпляра одного класса.  
  
 В следующем примере вызывается без параметров <xref:System.Threading.Tasks.Task.Wait> метод безусловно ожидания до завершения задачи. Задача имитирует работы путем вызова <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод в спящий режим на две секунды.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Условно также можно дождаться завершения задачи. <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> И <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> методы блокирует вызывающий поток до завершения задачи или истечет время ожидания, какое событие произойдет первым. Так, как следующий пример запускает задачу, которая определяет значение времени ожидания одну секунду, а вызывающий поток блокируется, пока не истечет время ожидания, но бездействует в течение двух секунд и до завершения выполнения задачи.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Также можно использовать токен отмены, путем вызова <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> и <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> методы. Если токен <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> свойство `true` или становится `true` хотя <xref:System.Threading.Tasks.Task.Wait%2A> выполняется метод, этот метод вызывает <xref:System.OperationCanceledException>.  
  
 В некоторых случаях может потребоваться подождать для первого ряда выполнение задач для завершения, но не является осторожностью, что задачи.  Для этой цели, вы можете вызвать один из перегруженных версий <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> метод.  В следующем примере создается три задачи, каждая из которых находится в спящем режиме, для определяют интервал с генератором случайных чисел. <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Метод ожидает завершения первой задачи. Затем пример отображает сведения о состоянии всех трех задач.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Также можно отложить для каждого ряда задач, которые необходимо завершить путем вызова <xref:System.Threading.Tasks.Task.WaitAll%2A> метод. Следующий пример создает десять задач, ожидает в течение всех десяти для завершения, а затем отображает их состояние.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Обратите внимание, что при ожидании завершения одного или нескольких задач, все исключения, возникшие в выполняющихся задач распространяются на поток, вызывающий `Wait` метода, как показано в следующем примере. Она запускает 12 задачи, три из которых нормально завершен и три из которых выдал исключение. Из оставшихся шести задач три являются отменена до того, как они начинаются три отменяются, пока они выполняются. Исключения, возникшие в <xref:System.Threading.Tasks.Task.WaitAll%2A> вызов метода на них обрабатываются `try` / `catch` блока.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Дополнительные сведения об обработке исключений в асинхронных операций на основе задач, см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Задачи и языка и региональных параметров  
 Начиная с настольных приложений, предназначенных [!INCLUDE[net_v46](~/includes/net-v46-md.md)], язык и региональные параметры потока, который создает и вызывает задачу становится частью контекст потока. Независимо от текущего потока, на котором выполняется задача, текущий язык и региональные параметры задачи является язык и региональные параметры вызывающего потока. Для приложений, предназначенных для версий платформы .NET Framework до версии [!INCLUDE[net_v46](~/includes/net-v46-md.md)], язык и региональные параметры задачи — это язык и региональные параметры потока, на котором выполняется задача. Дополнительные сведения см. в разделе «Язык и региональные параметры и асинхронные операции на основе задач» в <xref:System.Globalization.CultureInfo> разделе.  
  
> [!NOTE]
>  Приложения Store придерживаются среды выполнения Windows в установку и получение культуры по умолчанию.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Для разработчиков отладчика  
 Для разработчиков, реализации пользовательских отладчиков несколько членов с внутренним и закрытым задачи можно использовать (они могут изменяться от выпуска к выпуску). `m_taskId` Поле выступает в качестве резервного хранилища для <xref:System.Threading.Tasks.Task.Id%2A> свойства, однако доступ к это поле прямо из отладчика может быть более эффективным, чем к доступу и то же значение с помощью метода чтения данного свойства ( `s_taskIdCounter` счетчик используется для извлечения следующий доступный идентификатор задачи). Аналогичным образом `m_stateFlags` поле хранятся сведения о текущем этапе жизненного цикла задачи, сведения также доступны через <xref:System.Threading.Tasks.Task.Status%2A> свойство. `m_action` Поле хранит ссылку на делегат задачи и `m_stateObject` поле хранит состояние асинхронной, переданных в задачу разработчиком. Наконец, чтобы отладчики, выполняющие синтаксический анализ кадров стека `InternalWait` метод служит потенциальным для при вводит операции ожидания задачи.   
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены <see cref="T:System.Threading.Tasks.Task" />, за исключением <see cref="M:System.Threading.Tasks.Task.Dispose" />, являются потокобезопасными и могут быть использованы из нескольких потоков одновременно.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Асинхронное программирование на основе задач</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Примеры параллельного программирования в .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый объект <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданным действием.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор следует использовать только в сложных сценариях, когда он необходим отделяется создания и запуска задачи.  
  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> метод.  
  
 Если задача, не выполняя никаких действий для ситуация каким-то await, необходима только для потребителей API <xref:System.Threading.Tasks.TaskCompletionSource%601> следует использовать.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> конструктор для создания задачи, которые получают имена файлов в указанных каталогах. Все задачи записи имен файлов к одному <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта. Затем в примере вызывается <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> метод, чтобы гарантировать, что все задачи завершены, а затем отображает количество общее количество имен файлов, записываемый <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Следующий пример идентичен, за исключением того, чтобы его использовать <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод для создания экземпляра и запуска задачи в рамках одной операции. Этот метод возвращает <xref:System.Threading.Tasks.Task> объект, представляющий задачу.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="cancellationToken">Маркер <see cref="T:System.Threading.CancellationToken" />, который будет контролироваться новой задачей.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданным действием и токеном <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> и <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> методы. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 Дополнительные сведения см. в разделе [параллелизм задач (библиотека параллельных задач)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [Отмена в управляемых потоках](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> конструктор, чтобы создать задачу, которая выполняет итерацию файлы в каталог C:\Windows\System32. Лямбда-выражение вызывает <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> метод, чтобы добавить информацию о каждом файле, чтобы <xref:System.Collections.Generic.List%601> объекта. Каждый отсоединенной вложенной задачей, вызываемых <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> цикл проверяет состояние токена отмены и если запрос на отмену вызывает <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Вызывает метод <xref:System.OperationCanceledException> исключение, которое обрабатывается в `catch` заблокировать, если вызывающий поток вызывает <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод.  <xref:System.Threading.Tasks.Task.Start%2A> Затем вызывается метод для запуска задачи.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="creationOptions">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и параметрами создания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="state">Объект, который представляет данные, используемые действием.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданным действием и состоянием.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
   
  
## Examples  
 В следующем примере определяется массив слов 6 букв. Каждое слово затем передается в качестве аргумента для <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> конструктор, которого <xref:System.Action%601> делегат кодирует символы в слове, а затем отображает исходного слова и ее скремблированных версии.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</param>
        <param name="creationOptions">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и параметрами создания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 Дополнительные сведения см. в разделе [параллелизм задач (библиотека параллельных задач)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [Отмена задач](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Создания <paramref name="cancellationToken" /> уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="state">Объект, который представляет данные, используемые действием.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Создания <paramref name="cancellationToken" /> уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="state">Объект, который представляет данные, используемые действием.</param>
        <param name="creationOptions">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Делегат, который представляет код, выполняемый в рамках задачи.</param>
        <param name="state">Объект, который представляет данные, используемые действием.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</param>
        <param name="creationOptions">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</param>
        <summary>Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> метод. Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Создания <paramref name="cancellationToken" /> уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="action" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект состояния, предоставленный при создании задачи <see cref="T:System.Threading.Tasks.Task" />, или значение null, если объект не предоставлен.</summary>
        <value>Объект <see cref="T:System.Object" />, представляющий данные о состоянии, переданные задаче на этапе создания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приведите объект обратно к исходному типу для извлечения данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает задачу, которая уже завершилась успешно.</summary>
        <value>Успешно завершенная задача.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство Возвращает задачу, <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Чтобы создать задачу, которая возвращает значение и выполняется до завершения, вызовите <xref:System.Threading.Tasks.Task.FromResult%2A> метод.  
  
 Повторные попытки получить значение этого свойства может не всегда возвращать тот же экземпляр.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">Значение <see langword="true" />, чтобы попытаться выполнить маршалинг продолжения обратно в исходный захваченный контекст; в противном случае — значение <see langword="false" />.</param>
        <summary>Настраивает объект типа awaiter, используемый для данного объекта <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Объект, используемый для ожидания данной задачи.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
   
  
## Examples  
 В следующем примере определяется задача, которая заполняет массив, содержащий 100 случайных значений даты и времени. Она использует <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> метод для выбора самой ранней и последние значения даты, когда массив заполняется полностью.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Так как консольное приложение может завершиться до задача продолжения выполняется, <xref:System.Threading.Tasks.Task.Wait> вызывается метод, чтобы убедиться, что продолжение завершается выполнение до окончания этого примера.  
  
 Дополнительный пример см. в разделе [создание цепочки задач с помощью задач продолжения](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения задачи. При запуске делегату передается в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые действием продолжения.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Новая задача продолжения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или выход из раньше, из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <summary>Создает продолжение, которое получает маркер отмены и которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Создавший маркер объект уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие для запуска в соответствии с заданными параметрами <paramref name="continuationOptions" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Создает продолжение, которое выполняется после завершения целевой задачи в соответствии с заданными параметрами <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи. Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Threading.Tasks.TaskContinuationOptions> для указания, что задача продолжения должна выполняться синхронно при завершении предыдущей задачи. (Если указанная задача уже завершена, когда <xref:System.Threading.Tasks.Task.ContinueWith%2A> вызове синхронных продолжение будет выполняться в потоке вызывающего <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="scheduler" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые действием продолжения.</param>
        <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и маркер отмены и которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые действием продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение выполняется на основе набора указанных условий.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи. Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.  При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые действием продолжения.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие для запуска в соответствии с заданными параметрами <paramref name="continuationOptions" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется после завершения целевой задачи в соответствии с заданными параметрами <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. Продолжение получает маркер отмены и использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи. Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
   
  
## Examples  
 Ниже приведен пример использования ContinueWith для выполнения работы в фоновом режиме и пользователем, потоки интерфейса.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Создавший маркер объект уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationAction" /> имеет значение NULL.  
  
-или- 
Аргумент <paramref name="scheduler" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые действием продолжения.</param>
        <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который связывается с задачей продолжения для ее запуска.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и маркер отмены и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение выполняется на основе набора указанных условий и использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи. Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task`1" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task`1" /> и которое возвращает значение.</summary>
        <returns>Новая задача продолжения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
   
  
## Examples  
 Приведенный ниже показано, как использовать метод ContinueWith на значениях:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые функцией продолжения.</param>
        <summary>Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии, выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение. Продолжение получает маркер отмены.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.  
  
-или- 
<see cref="T:System.Threading.CancellationTokenSource" /> Создавший маркер объект уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция для запуска в соответствии с условием, заданным в <paramref name="continuationOptions" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Создает продолжение, которое выполняется в соответствии с заданными параметрами и которое возвращает значение.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи. Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение. Продолжение использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.  
  
-или- 
Аргумент <paramref name="scheduler" /> имеет значение NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые функцией продолжения.</param>
        <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение. Продолжение получает предоставленные вызывающей стороной сведения и маркер отмены.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые функцией продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Создает продолжение, которое выполняется на основе указанных параметров продолжения задачи после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение получает предоставленные вызывающей стороной сведения.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи. Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.  При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые функцией продолжения.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />. Продолжение получает предоставленные вызывающей стороной сведения и использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция для запуска в соответствии с заданными параметрами <c>continuationOptions</c>. При запуске делегата завершенная задача будет передана ему в качестве аргумента.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется в соответствии с заданными параметрами и которое возвращает значение. Продолжение получает маркер отмены и использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи. Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
   
  
## Examples  
 Приведенный ниже показано, как использовать метод ContinueWith с параметры продолжения:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.  
  
-или- 
<see cref="T:System.Threading.CancellationTokenSource" /> Создавший маркер объект уже был удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.  
  
-или- 
Аргумент <paramref name="scheduler" /> имеет значение NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, созданного продолжением.</typeparam>
        <param name="continuationFunction">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />. При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</param>
        <param name="state">Объект, который представляет данные, используемые функцией продолжения.</param>
        <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</param>
        <param name="continuationOptions">Параметры, определяющие запланированное время продолжения и его поведение. Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который связывается с задачей продолжения для ее запуска.</param>
        <summary>Создает продолжение, которое выполняется на основе указанных параметров продолжения задачи после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и которое возвращает значение. Продолжение получает предоставленные вызывающей стороной сведения и маркер отмены, а также использует указанный планировщик.</summary>
        <returns>Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи. Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, используемый для создания данной задачи.</summary>
        <value>Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, используемый для создания данной задачи.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает идентификатор выполняющейся в настоящее время задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Целое число, присвоенное системой выполняемой в настоящее время задаче.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> — `static` (`Shared` в Visual Basic) свойство, которое позволяет получить идентификатор текущей выполняемой задачи из кода, который выполняется задача. Он отличается от <xref:System.Threading.Tasks.Task.Id%2A> свойство, которое возвращает идентификатор конкретного <xref:System.Threading.Tasks.Task> экземпляра. При попытке получить <xref:System.Threading.Tasks.Task.CurrentId%2A> свойство возвращает значение из вне кода, выполняющего задачу `null`.  
  
 Обратите внимание, что несмотря на то, что конфликты очень редки, задача не гарантируется, что идентификаторы должны быть уникальными.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает задачу, которая будет выполнена после некоторой временной задержки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Время в миллисекундах, в течение которого ожидается завершение возвращаемой задачи, или -1 для неограниченного времени ожидания.</param>
        <summary>Создает задачу, которая завершается через заданное количество миллисекунд.</summary>
        <returns>Задача, представляющая временную задержку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A> Метод обычно используется для задержка операции всех или части задачи на указанный интервал времени. Чаще всего вводится время задержки:  
  
-   AT показано начало задачи, как в примере ниже.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Некоторое время, пока выполняется задача. В этом случае вызов <xref:System.Threading.Tasks.Task.Delay%2A> метод выполняется как дочерняя задача в задаче, как показано в следующем примере. Обратите внимание, что с момента задачи, который вызывает <xref:System.Threading.Tasks.Task.Delay%2A> метод выполняется асинхронно, в родительскую задачу, дождитесь ее завершения с помощью `await` ключевое слово.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 После указанного времени задержки, задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.  
  
 Этот метод зависит от системных часов. Это означает, что время задержки будет примерно равны разрешение системных часов Если `millisecondsDelay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.  
  
   
  
## Examples  
 В следующем примере показано простое использование <xref:System.Threading.Tasks.Task.Delay%2A> метод.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="millisecondsDelay" /> меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">Время, в течение которого ожидается завершение возвращаемой задачи, или <see langword="TimeSpan.FromMilliseconds(-1)" /> для неограниченного времени ожидания.</param>
        <summary>Создает задачу, которая завершается через заданное время.</summary>
        <returns>Задача, представляющая временную задержку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После указанного времени задержки, задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.  
  
 Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.  
  
 Этот метод зависит от системных часов. Это означает, что время задержки будет примерно равны разрешение системных часов Если `delay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.  
  
   
  
## Examples  
 В следующем примере показано простое использование <xref:System.Threading.Tasks.Task.Delay%2A> метод.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> представляет отрицательный интервал времени, отличный от <see langword="TimeSpan.FromMilliseconds(-1)" />.  
  
-или- 
Свойство <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="delay" /> больше, чем <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Время в миллисекундах, в течение которого ожидается завершение возвращаемой задачи, или -1 для неограниченного времени ожидания.</param>
        <param name="cancellationToken">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Создает отменяемую задачу, которая завершается через заданное количество миллисекунд.</summary>
        <returns>Задача, представляющая временную задержку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если токен отмены получает сигнал до указанного времени задержки, <xref:System.Threading.Tasks.TaskCanceledException> результаты исключения, а задача завершается в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние.  В противном случае задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние после истечения указанного времени задержки.  
  
 Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.  
  
 Этот метод зависит от системных часов. Это означает, что время задержки будет примерно равны разрешение системных часов Если `millisecondsDelay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.  
  
   
  
## Examples  
 Следующий пример запускает задачу, которая включает вызов <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> метод с одной секунда. До истечения интервала задержки, токена отмены. Выходные данные примера показано, что, в результате, <xref:System.Threading.Tasks.TaskCanceledException> возникает исключение и задач <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент <paramref name="millisecondsDelay" /> меньше –1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <paramref name="cancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">Время, в течение которого ожидается завершение возвращаемой задачи, или <see langword="TimeSpan.FromMilliseconds(-1)" /> для неограниченного времени ожидания.</param>
        <param name="cancellationToken">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Создает отменяемую задачу, которая завершается через заданное время.</summary>
        <returns>Задача, представляющая временную задержку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если токен отмены получает сигнал до указанного времени задержки, <xref:System.Threading.Tasks.TaskCanceledException> результаты исключения, а задача завершается в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние.  В противном случае задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние после истечения указанного времени задержки.  
  
 Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.  
  
 Этот метод зависит от системных часов. Это означает, что время задержки будет примерно равны разрешение системных часов Если `delay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.  
  
   
  
## Examples  
 Следующий пример запускает задачу, которая включает вызов <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод с 1,5 секунда. До истечения интервала задержки, токена отмены. Выходные данные примера показано, что, в результате, <xref:System.Threading.Tasks.TaskCanceledException> возникает исключение и задач <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Обратите внимание, что в этом примере включает потенциальный конфликт: она зависит от задачи асинхронно выполнение задержки, когда токен отменяется. Несмотря на то, что задержка 1,5 секунды из вызова <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод допущения, скорее всего, тем не менее возможно, вызов <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод может вернуть значение до токена отмены. В этом случае пример выводит следующие результаты:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> представляет отрицательный интервал времени, отличный от <see langword="TimeSpan.FromMilliseconds(-1)" />.  
  
-или- 
Свойство <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="delay" /> больше, чем <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Предоставленный объект <paramref name="cancellationToken" /> уже удален.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Класс реализует <xref:System.IDisposable> интерфейс, так как внутренне он использует ресурсы, которые также реализуют <xref:System.IDisposable>. Тем не менее особенно в том случае, если ваше приложение предназначено [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или более поздней версии, нет необходимости вызывать <xref:System.Threading.Tasks.Task.Dispose%2A> Если производительность или масштабируемость тестирование показывает, что, на основе использования шаблонов, удалив задач будет улучшена производительность приложения. Дополнительные сведения см. в разделе [нужно избавиться от задач?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) в параллельному программированию в блоге .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Задача не находится в одном из окончательных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing">Логическое значение, указывающее, вызывается ли данный метод из-за вызова задачи <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Удаляет задачу<see cref="T:System.Threading.Tasks.Task" />, освобождая все используемые ею неуправляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Класс реализует <xref:System.IDisposable> интерфейс, так как внутренне он использует ресурсы, которые также реализуют <xref:System.IDisposable>. Тем не менее особенно в том случае, если ваше приложение предназначено [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или более поздней версии, нет необходимости вызывать <xref:System.Threading.Tasks.Task.Dispose%2A> Если производительность или масштабируемость тестирование показывает, что, на основе использования шаблонов, удалив задач будет улучшена производительность приложения. Дополнительные сведения см. в разделе [нужно избавиться от задач?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) в параллельному программированию в блоге .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Задача не находится в одном из окончательных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>В отличие от большинства элементов <see cref="T:System.Threading.Tasks.Task" /> класса, этот метод не является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.AggregateException" />, который привел к преждевременному завершению задачи <see cref="T:System.Threading.Tasks.Task" />. Если задача <see cref="T:System.Threading.Tasks.Task" /> завершилась успешно или еще не создала ни одного исключения, возвращает значение <see langword="null" />.</summary>
        <value>Объект <see cref="T:System.AggregateException" />, который привел к преждевременному завершению задачи <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задачи, которые вызывает необработанные исключения хранения результирующее исключение и передать их в оболочку <xref:System.AggregateException> в вызовах <xref:System.Threading.Tasks.Task.Wait%2A> или в доступе к <xref:System.Threading.Tasks.Task.Exception%2A> свойство. Любые исключения, не наблюдается, когда экземпляр задачи удаляется сборщиком мусора распространяется на поток метода завершения. Дополнительные сведения и пример см. в разделе [обработка исключений (библиотека параллельных задач)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет доступ к фабричным методам для создания и настройки экземпляров <see cref="T:System.Threading.Tasks.Task" /> и <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Объект фабрики, который может создавать разнообразные объекты <see cref="T:System.Threading.Tasks.Task" /> и <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает экземпляр по умолчанию <xref:System.Threading.Tasks.TaskFactory> класс, созданный при вызове без параметров идентичный <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> конструктор. Он имеет следующие значения свойств:  
  
|Свойство|Значение|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, или <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Чаще всего это свойство используется для создания и запуска новой задачи в рамках одного вызова <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> метод предоставляет самый простой способ создать <xref:System.Threading.Tasks.Task> объекта значения конфигурации по умолчанию.  
  
 В следующем примере используется статический <xref:System.Threading.Tasks.Task.Factory%2A> свойства два вызова <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод. Первый заполняет массив, содержащий имена файлов в каталоге Мои документы пользователя, пока второй заполняет массив имен подкаталогов каталога Мои документы пользователя. Затем он вызывает <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> метод, который отображает сведения о количестве файлов и каталогов в двух массивах, после выполнения первых двух задачах.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Маркер отмены, с которым завершается задача.</param>
        <summary>Создает задачу <see cref="T:System.Threading.Tasks.Task" />, которая завершилась из-за отмены с помощью указанного маркера отмены.</summary>
        <returns>Отменяемая задача.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Не запрошена отмена для параметра <paramref name="cancellationToken" />; его свойство <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, возвращенного задачей.</typeparam>
        <param name="cancellationToken">Маркер отмены, с которым завершается задача.</param>
        <summary>Создает задачу <see cref="T:System.Threading.Tasks.Task`1" />, которая завершилась из-за отмены с помощью указанного маркера отмены.</summary>
        <returns>Отменяемая задача.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Не запрошена отмена для параметра <paramref name="cancellationToken" />; его свойство <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> имеет значение <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception">Исключение, с которым завершается задача.</param>
        <summary>Создает задачу <see cref="T:System.Threading.Tasks.Task" />, которая завершилась с указанным исключением.</summary>
        <returns>Задача, завершившаяся сбоем.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает <xref:System.Threading.Tasks.Task> которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.Faulted> и которого <xref:System.Threading.Tasks.Task.Exception%2A> свойство содержит `exception`. Метод обычно используется, когда вы немедленно узнаете, что работы, выполняемой задачей будет выдано исключение перед выполнением более длинный путь кода. Например, см. в разделе <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> перегрузки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, возвращенного задачей.</typeparam>
        <param name="exception">Исключение, с которым завершается задача.</param>
        <summary>Создает задачу <see cref="T:System.Threading.Tasks.Task`1" />, которая завершилась с указанным исключением.</summary>
        <returns>Задача, завершившаяся сбоем.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает <xref:System.Threading.Tasks.Task%601> которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.Faulted> и которого <xref:System.Threading.Tasks.Task.Exception%2A> свойство содержит `exception`. Метод обычно используется, когда вы немедленно узнаете, что работы, выполняемой задачей будет выдано исключение перед выполнением более длинный путь кода. Иллюстрация приведена в примере.  
  
   
  
## Examples  
 Следующий пример — программа командной строки, которая вычисляет число байтов в файлах в каждом каталоге, имя которого передано в качестве аргумента командной строки. Вместо того, чтобы выполнение более длинный путь кода, который создает экземпляры <xref:System.IO.FileInfo> объекта и возвращает значение его <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> свойство для каждого файла в каталоге, в примере просто вызывается <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> метод для создания задачи, если определенный вложенный каталог не существует.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, возвращенного задачей.</typeparam>
        <param name="result">Результат, сохраняемый в завершенную задачу.</param>
        <summary>Создает задачу <see cref="T:System.Threading.Tasks.Task`1" />, которая завершается удачно с указанным результатом.</summary>
        <returns>Успешно завершенная задача.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает <xref:System.Threading.Tasks.Task%601> которого <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство `result` и которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Метод обычно используется, если возвращаемое значение задачи сразу же известно, выполняя более длинный путь кода. Иллюстрация приведена в примере.  
  
 Чтобы создать объект задачи, которая не возвращает значение, получить объект задачи из <xref:System.Threading.Tasks.Task.CompletedTask%2A> свойство.  
  
   
  
## Examples  
 Следующий пример — программа командной строки, которая вычисляет число байтов в файлах в каждом каталоге, имя которого передано в качестве аргумента командной строки. Вместо того, чтобы выполнение более длинный путь кода, который создает экземпляры <xref:System.IO.FileStream> объекта и возвращает значение его <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> свойство для каждого файла в каталоге, в примере просто вызывается <xref:System.Threading.Tasks.Task.FromResult%2A> метод для создания задачи которого <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство равно нулю (0), если каталог не содержит файлов.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект типа awaiter, используемый для данного объекта <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Экземпляр объекта типа awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для внутреннего использования компиляторами, а не для использования в прикладном коде.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает идентификатор указанного экземпляра <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Идентификатор, присвоенный системой данному экземпляру <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы задач назначаются по запросу и не обязательно представляют порядок, в какую задачу создаются экземпляры. Обратите внимание, что несмотря на то, что конфликты очень редки, задача не гарантируется, что идентификаторы должны быть уникальными.  
  
 Чтобы получить идентификатор задачи текущей выполняемой задачи из кода эта задача выполняется, используйте <xref:System.Threading.Tasks.Task.CurrentId%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершилось ли выполнение данного экземпляра <see cref="T:System.Threading.Tasks.Task" /> из-за отмены.</summary>
        <value>Значение <see langword="true" />, если задача была завершена из-за отмены; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Threading.Tasks.Task> завершится в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния выполняется любое из следующих условий:  
  
-   Его <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> был помечен для отмены до начала выполнения, задачи  
  
-   Задача приняла запрос на отмену на уже сигнальное <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> , выдав <xref:System.OperationCanceledException> предпоследнюю же <xref:System.Threading.CancellationToken>.  
  
-   Задача приняла запрос на отмену на уже сигнальное <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> путем вызова <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> метод <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Получение значения <xref:System.Threading.Tasks.Task.IsCanceled%2A> свойство не блокирует вызывающий поток до завершения задачи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, завершена ли задача.</summary>
        <value><see langword="true" /> Если задача была завершена (то есть задача находится в одном из трех конечных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> Получение значения <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, завершилась ли задача <see cref="T:System.Threading.Tasks.Task" /> из-за необработанного исключения.</summary>
        <value>Значение <see langword="true" />, если задача создала необрабатываемое исключение; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Threading.Tasks.Task.IsFaulted%2A> — `true`, задачи <xref:System.Threading.Tasks.Task.Status%2A> равен <xref:System.Threading.Tasks.TaskStatus.Faulted>и его <xref:System.Threading.Tasks.Task.Exception%2A> свойство будет иметь значение null.  
  
> [!IMPORTANT]
>  Получение значения <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ставит в очередь заданную работу для запуска в ThreadPool и возвращает задачу или дескриптор <see cref="T:System.Threading.Tasks.Task`1" /> для этой работы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Метод предоставляет набор перегрузки, которые позволяют легко запустить задачу со значениями по умолчанию. Это упрощенная альтернатива <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> перегрузки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Работа для асинхронного выполнения</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task" />, представляющий эту работу.</summary>
        <returns>Задача, которая представляет работу в очереди на выполнение в ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Метод позволяет создавать и выполнять задачи в одном методе и является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> метод. Он создает задачу, со следующими значениями по умолчанию:  
  
-   Ее токен отмены <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Она использует планировщик задач по умолчанию.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 В следующем примере определяется `ShowThreadInfo` метод, отображающий <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> текущего потока. Он вызывается напрямую из потока приложения и вызывается из <xref:System.Action> делегат, переданный <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Следующий пример аналогичен предыдущему, за исключением того, что лямбда-выражения используются для определения кода, которая будет выполнена задача.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 В примерах показано, что асинхронная задача выполняется в потоке, отличном от основного потока приложения.  
  
 Вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что задача завершается и отображение его выходных данных до окончания работы приложения. В противном случае возможна ситуация, `Main` метод будет выполнена до завершения задачи.  
  
 В следующем примере показано <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод. Он определяет массив имен каталогов и запускает отдельную задачу, чтобы получить имена файлов в каждом каталоге. Все задачи записи имен файлов к одному <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта. Затем в примере вызывается <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> метод, чтобы гарантировать, что все задачи завершены, а затем отображает количество общее количество имен файлов, записываемый <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="action" /> имел значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">Работа для асинхронного выполнения</param>
        <summary>Ставит в очередь указанную работу для запуска в пуле потоков и возвращает прокси для задачи, возвращаемой функцией <paramref name="function" />.</summary>
        <returns>Задача, которая представляет прокси для задачи, возвращаемой <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имел значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Работа для асинхронного выполнения</param>
        <param name="cancellationToken">Маркер отмены, который может использоваться для отмены работы.</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task" />, представляющий эту работу. Маркер отмены позволяет отменить работу.</summary>
        <returns>Задача, которая представляет работу в очереди на выполнение в пуле потоков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если Отмена запрашивается до ее начала выполнения, задача не выполняется. Вместо этого он становится равным <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние и выдает исключение <xref:System.Threading.Tasks.TaskCanceledException> исключение.  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> метод. Он создает задачу, со следующими значениями по умолчанию:  
  
-   Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Она использует планировщик задач по умолчанию.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> метод, чтобы создать задачу, которая выполняет итерацию файлы в каталог C:\Windows\System32. Лямбда-выражение вызывает <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> метод, чтобы добавить информацию о каждом файле, чтобы <xref:System.Collections.Generic.List%601> объекта. Каждый отсоединенной вложенной задачей, вызываемых <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> цикл проверяет состояние токена отмены и если запрос на отмену вызывает <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Вызывает метод <xref:System.OperationCanceledException> исключение, которое обрабатывается в `catch` заблокировать, если вызывающий поток вызывает <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="action" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">Работа для асинхронного выполнения.</param>
        <param name="cancellationToken">Маркер отмены, который должен использоваться для отмены работы.</param>
        <summary>Ставит в очередь указанную работу для запуска в пуле потоков и возвращает прокси для задачи, возвращаемой функцией <paramref name="function" />.</summary>
        <returns>Задача, которая представляет прокси для задачи, возвращаемой <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Отмена задач</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, возвращенного задачей прокси-сервера.</typeparam>
        <param name="function">Работа для асинхронного выполнения</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает прокси для задачи <see langword="Task(TResult)" />, возвращаемой <paramref name="function" />.</summary>
        <returns>Объект <see langword="Task(TResult)" />, представляющий прокси для объекта <see langword="Task(TResult)" />, возвращаемого <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имел значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип возвращаемого значения задачи.</typeparam>
        <param name="function">Работа для асинхронного выполнения.</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task`1" />, представляющий эту работу.</summary>
        <returns>Объект задачи, представляющий работу в очереди на выполнение в пуле потоков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> метод. Он создает задачу, со следующими значениями по умолчанию:  
  
-   Ее токен отмены <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Она использует планировщик задач по умолчанию.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается приблизительное количество слов в текстовых файлах, которые представляют опубликованных бюллетеней. Каждая задача отвечает за открытие файла, асинхронного чтения все его содержимое и подсчет слов с помощью регулярного выражения. <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Вызывается метод, чтобы убедиться, что все задачи завершены перед отображением подсчета слов каждую книгу в консоль.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Регулярное выражение `\p{P}*\s+` заменяет ноль, один или несколько знаков пунктуации, за которыми следует один или несколько символов пробела. Предполагается, что общее количество совпадений равна приблизительно Статистика.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата, возвращенного задачей прокси-сервера.</typeparam>
        <param name="function">Работа для асинхронного выполнения</param>
        <param name="cancellationToken">Токен отмены, который должен использоваться для отмены работы</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает прокси для задачи <see langword="Task(TResult)" />, возвращаемой <paramref name="function" />.</summary>
        <returns>Объект <see langword="Task(TResult)" />, представляющий прокси для объекта <see langword="Task(TResult)" />, возвращаемого <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Отмена задач</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип результата задачи.</typeparam>
        <param name="function">Работа для асинхронного выполнения</param>
        <param name="cancellationToken">Токен отмены, который должен использоваться для отмены работы</param>
        <summary>Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see langword="Task(TResult)" />, представляющий эту работу. Маркер отмены позволяет отменить работу.</summary>
        <returns>Задача <see langword="Task(TResult)" />, которая представляет работу в очереди на выполнение в пуле потоков.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если Отмена запрашивается до ее начала выполнения, задача не выполняется. Вместо этого он становится равным <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние и выдает исключение <xref:System.Threading.Tasks.TaskCanceledException> исключение.  
  
 <xref:System.Threading.Tasks.Task.Run%2A> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> метод. Он создает задачу, со следующими значениями по умолчанию:  
  
-   Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Она использует планировщик задач по умолчанию.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 В следующем примере создается 20 задачи, которые будут цикл, пока значение счетчика увеличивается значение 2 млн. По достижении 2 миллиона первые 10 задач токен отмены отменяется и будут отменены все задачи, в которых счетчики не достигли 2 млн. В примере возможного выхода.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Вместо использования <xref:System.AggregateException.InnerExceptions%2A> свойство для проверки исключений, приведенный пример проходит все задачи, чтобы определить, который успешно выполнены и которого были отменены. Для тех, которые были завершены отображается значение, возвращенного задачей.  
  
 Так как Отмена выполняется совместно, каждой задачи можно решить, как реагировать на отмену. Следующий пример аналогичен первой, за исключением того, что после токена отмены задач возвращают число итераций, они завершили работу, а не к возникновению исключения.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Пример по-прежнему должны обрабатывать <xref:System.AggregateException> исключение, так как все задачи, которые еще не начали при запросе отмены по-прежнему исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="function" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Задача была отменена.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Отмена задач</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно задачи выполняются асинхронно в потоке пула потоков и не блокируют вызывающий поток. Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously> метод связаны с текущим <xref:System.Threading.Tasks.TaskScheduler> и выполняются в вызывающем потоке. Если целевой планировщик не поддерживает выполнение этой задачи в вызывающем потоке, задача будет планироваться выполнение в планировщике, и вызывающий поток будет заблокирован до завершения выполнения задачи. Несмотря на то, что задача выполняется синхронно, вызывающий поток по-прежнему должны вызывать <xref:System.Threading.Tasks.Task.Wait%2A> для обработки исключений, которые могут создавать задачи.  Дополнительные сведения об обработке исключений см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод создаются путем вызова <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> конструктора класса. Задание для синхронного выполнения должно быть в <xref:System.Threading.Tasks.TaskStatus.Created> состояние. Задача может запускаются и выполняются только один раз. Любые попытки запланировать задачу, второй раз приведет к исключению.  
  
   
  
## Examples  
 В следующем примере сравниваются задачи выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод с одним-выражение выполняется асинхронно. В обоих случаях выполняться задачи одинаковыми лямбда-выражениями, которые отображают идентификатор задачи и идентификатор потока, на котором запущена задача. Задача вычисляет сумму целые числа от 1 до 1 000 000. Как видно из примера, задача выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод выполняется в потоке приложения, а асинхронная задача — нет.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.InvalidOperationException">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска. Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Планировщик, в котором следует попытаться выполнить задачу.</param>
        <summary>Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в предоставленном планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод создаются путем вызова <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> конструктора класса. Задание для синхронного выполнения должно быть в <xref:System.Threading.Tasks.TaskStatus.Created> состояние. Задача может запускаются и выполняются только один раз. Любые попытки запланировать задачу, второй раз приведет к исключению.  
  
 Если целевой планировщик не поддерживает выполнение этой задачи в текущем потоке, задача будет планироваться выполнение в планировщике, а текущий поток будет заблокирован до завершения выполнения задачи. По этой причине вызывающий поток не нужно вызывать метод, например <xref:System.Threading.Tasks.Task.Wait%2A> чтобы убедиться, что задача завершила выполнение. Дополнительные сведения о обработчика исключений для операции задачи, см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска. Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает задачу <see cref="T:System.Threading.Tasks.Task" />, планируя ее выполнение в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задача может запускаются и выполняются только один раз. Любые попытки запланировать задачу во второй раз приведет к исключение.  
  
 <xref:System.Threading.Tasks.Task.Start%2A> Позволяет выполнять задачу, которая будет создана путем вызова одного из <xref:System.Threading.Tasks.Task> конструкторы. Как правило это делается, если вам нужно отделить Создание задачи от ее выполнения, например когда позволяет выполнять задачи, которые вы создали. Для более распространенный случай, в котором не требуется разделения задач при создании экземпляра выполнения, рекомендуется вызывать перегрузку <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> конструктор для создания нового <xref:System.Threading.Tasks.Task> объект, который отображает свою задачу, идентификатор и идентификатор управляемого потока, а затем выполняет цикл. Затем он вызывает <xref:System.Threading.Tasks.Task.Start%2A> метод для выполнения задачи.  Так как это консольное приложение, вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод необходим запретить приложению завершение работы до завершения выполнения задачи.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.InvalidOperationException">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска. Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, с которым нужно связать и в котором нужно выполнить данную задачу.</param>
        <summary>Запускает задачу <see cref="T:System.Threading.Tasks.Task" />, планируя ее выполнение в заданном планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задача может только запускаются и выполняются только один раз. Любые попытки запланировать задачу во второй раз приведет к исключение.  
  
 Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска. Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</exception>
        <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Планировщику не удалось поставить эту задачу в очередь.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Обработка исключений (библиотека параллельных задач)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает состояние <see cref="T:System.Threading.Tasks.TaskStatus" /> данной задачи.</summary>
        <value>Текущее состояние <see cref="T:System.Threading.Tasks.TaskStatus" /> данного экземпляра задачи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.  
  
 Дополнительные сведения и пример см. в разделе [создание цепочки задач с помощью задач продолжения](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) и [как: Отмена задачи и ее дочерних элементов](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 В следующем примере создается 20 задачи, которые будут цикл, пока значение счетчика увеличивается значение 2 млн. По достижении 2 миллиона первые 10 задач токен отмены отменяется и будут отменены все задачи, в которых счетчики не достигли 2 млн. Пример затем просматривает <xref:System.Threading.Tasks.Task.Status%2A> свойства каждой задачи, чтобы указать ли она завершилась успешно, или была отменена. Для тех, которые выполнены отображается значение, возвращенного задачей.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания завершения задачи.</summary>
        <value>Дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания завершения задачи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью ожидания функциональных возможностях, предоставляемых <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> предпочтительнее использования <xref:System.IAsyncResult.AsyncWaitHandle%2A> аналогичными функциональными возможностями. Дополнительные сведения см. в разделе «Ожидание на задачи» в [Task-based асинхронное программирование](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [с помощью библиотеки параллельных задач с другие асинхронные шаблоны](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, синхронно ли выполнена операция.</summary>
        <value>Значение <see langword="true" />, если операция завершилась синхронно, в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> — Это метод синхронизации, который вызывающий поток до завершения текущей задачи. Если текущая задача еще не началось выполнение, метода Wait пытается удалить задание из планировщика и выполните его, встроенные в текущем потоке. Если не удается это сделать, или если выполнения текущей задачи уже начался, он блокирует вызывающий поток до завершения выполнения задачи. Дополнительные сведения см. в разделе [Task.Wait и «Встраивание»](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) в параллельному программированию в блоге .NET.   
  
## Examples  
 В следующем примере запускается задача, которая создает один миллион случайных целых чисел от 0 до 100 и вычисляет их среднее значение. В примере используется <xref:System.Threading.Tasks.Task.Wait%2A> метод, чтобы гарантировать, что задача будет завершена, прежде чем приложение завершит работу. В противном случае — так как это консольное приложение, пример завершает работу до задачи можно вычислить и отобразить среднее значение.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.AggregateException">Задача отменена. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
-или- 
Во время выполнения задачи возникло исключение. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/">Task.Wait и «Встраивания»</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Ожидает завершения задачи <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:  
  
-   Задача завершается успешно.  
  
-   Сама задача отменяется или создает исключение. В этом случае вы обрабатываете <xref:System.AggregateException> исключение. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.  
  
-   Интервал, заданный `millisecondsTimeout` пройдет указанное время. В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.  
  
   
  
## Examples  
 В следующем примере запускается задача, которая создает пять миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее значение. В примере используется <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> метод для ожидания в миллисекундах 150 приложения. Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, он сформирован. Если истек интервал времени ожидания, выводится сообщение перед завершением.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.AggregateException">Задача отменена. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
-или- 
Во время выполнения задачи возникло исключение. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />. Ожидание завершается, если токен отмены отменяется до завершения задачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Метод создает отменяемого ожидания, то есть вызывает текущий поток может ожидать, пока не произойдет одно из следующих событий:  
  
-   Задача будет завершена.  
  
-   Токен отмены отменяется. В этом случае вызов <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> вызывает метод <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Отмена `cancellationToken` токен отмены никак не влияет на выполняемая задача, если он также был передан токен отмены и подготовиться к обработке отмены. Передача `cancellationToken` в этот метод позволяет просто ожидания отменяется.  
  
   
  
## Examples  
 В следующем примере использует токен отмены для отмены ожидания завершения задачи. Задача запускается, вызывает <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> метод отменить любую из токенов отмены Источник токена, а затем задержки в течение пяти секунд. Обратите внимание, что сама задача не был передан токен отмены и не может быть отменен. Поток приложения вызывает задачи <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод для ожидания завершения задачи, но время ожидания отменяется после отмены токена отмены и <xref:System.OperationCanceledException> возникает исключение. Обработчик исключений сообщает исключение и затем бездействует в течение шести секунд. Как видно из примера, что задержка позволяет задаче для выполнения в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException">Задача была удалена.</exception>
        <exception cref="T:System.AggregateException">Задача отменена. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
-или- 
Во время выполнения задачи возникло исключение. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Ожидает завершения выполнения задач <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного периода.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:  
  
-   Задача завершается успешно.  
  
-   Сама задача отменяется или создает исключение. В этом случае вы обрабатываете <xref:System.AggregateException> исключение. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.  
  
-   Интервал, заданный `timeout` пройдет указанное время. В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.  
  
   
  
## Examples  
 В следующем примере запускается задача, которая создает пять миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее значение. В примере используется <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> метод для ожидания в миллисекундах 150 приложения. Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, он сформирован. Если истек интервал времени ожидания, выводится сообщение перед завершением.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания. 
-или- 
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Задача отменена. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
-или- 
Во время выполнения задачи возникло исключение. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="cancellationToken">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />. Ожидание завершается, если время ожидания истекает или токен отмены отменяется до завершения задачи.</summary>
        <returns>Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:  
  
-   Задача завершается успешно.  
  
-   Сама задача отменяется или создает исключение. В этом случае вы обрабатываете <xref:System.AggregateException> исключение. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.  
  
-   `cancellationToken` Токен отмены отменяется. В этом случае вызов <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> вызывает метод <xref:System.OperationCanceledException>.  
  
-   Интервал, заданный `millisecondsTimeout` пройдет указанное время. В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.  
  
> [!NOTE]
>  Отмена `cancellationToken` токен отмены никак не влияет на выполняемая задача, если он также был передан токен отмены и подготовиться к обработке отмены. Передача `cancellationToken` в этот метод просто позволяет отменить ожидание от некоторых условий.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> метод, чтобы предоставить значение времени ожидания и отмену токен, который можно завершить ожидания завершения задачи. Новый поток запущен и выполняет `CancelToken` метод, который приостанавливает и затем вызывает <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> метод отменить токенов отмены. Задача запуска затем откладывается на 5 секунд. <xref:System.Threading.Tasks.Task.Wait%2A> Метод вызывается для ожидания завершения задачи и предоставляется краткое ожидания и токен отмены.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Обратите внимание на то, что точное выходные данные примера зависит ли ожидание было отменено из-за токен отмены, или из-за истечения времени ожидания истекло.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.AggregateException">Задача отменена. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
-или- 
Во время выполнения задачи возникло исключение. Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается 10 задач, каждая из которых передается индекс как объект состояния. Задачи с индексом от двух до пяти вызывать исключения. Вызов <xref:System.Threading.Tasks.Task.WaitAll%2A> метод создает оболочку для всех исключений в <xref:System.AggregateException> объект и передает его в вызывающий поток.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.  
  
-или- 
Аргумент <paramref name="tasks" /> — пустой массив.</exception>
        <exception cref="T:System.AggregateException">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален. Если задача была отменена, <see cref="T:System.AggregateException" /> содержит исключение <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.  
  
-или- 
Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</summary>
        <returns><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален. Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.  
  
-или- 
Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.  
  
-или- 
Аргумент <paramref name="tasks" /> — пустой массив.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задач.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />, пока ожидание не будет отменено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Аргумент используется для отмены операции ожидания. — Это отдельная операция отмены задач и путем <xref:System.AggregateException> как указано выше.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален. Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.  
  
-или- 
Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.  
  
-или- 
Аргумент <paramref name="tasks" /> — пустой массив.</exception>
        <exception cref="T:System.ObjectDisposedException">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Ожидает завершения выполнения всех указанных отменяемых объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного интервала.</summary>
        <returns><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален. Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.  
  
-или- 
Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания. 
-или- 
 Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.  
  
-или- 
Аргумент <paramref name="tasks" /> — пустой массив.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задач.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд или до отмены ожидания.</summary>
        <returns><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Аргумент используется для отмены операции ожидания. — Это отдельная операция отмены задач и путем <xref:System.AggregateException> указано выше.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален. Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.  
  
-или- 
Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.  
  
-или- 
Аргумент <paramref name="tasks" /> — пустой массив.</exception>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <summary>Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Индекс завершенного объекта <see cref="T:System.Threading.Tasks.Task" /> в массиве <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример запускает пять задач, каждая из которых бездействует в течение как минимум 50 миллисекунд или более 1,050 миллисекунд. <xref:System.Threading.Tasks.Task.WaitAny%2A> Метод затем ожидает либо завершения задач. В примере отображается идентификатор задачи завершения ожидания задачи, а также текущее состояние всех задач.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <summary>Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</summary>
        <returns>Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />, пока ожидание не будет отменено.</summary>
        <returns>Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.</exception>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="timeout">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
        <summary>Ожидает завершения выполнения любого из указанных отменяемых объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного интервала.</summary>
        <returns>Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="timeout" /> является отрицательным числом, отличающимся от -1, которое представляет неограниченное время ожидания. 
-или- 
Свойство <paramref name="timeout" /> аргумента <see cref="P:System.TimeSpan.TotalMilliseconds" /> больше чем <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</param>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
        <param name="cancellationToken">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задачи.</param>
        <summary>Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд или до отмены токена отмены.</summary>
        <returns>Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <exception cref="T:System.ArgumentException">Аргумент <paramref name="tasks" /> содержит элемент NULL.</exception>
        <exception cref="T:System.OperationCanceledException">Объект <paramref name="cancellationToken" /> отменен.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает задачу, которая будет выполнена после выполнения всех предоставленных задач.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена, когда все объекты <see cref="T:System.Threading.Tasks.Task" /> в перечисляемой коллекции будут завершены.</summary>
        <returns>Задача, представляющая завершение всех предоставленных задач.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Threading.Tasks.Task.WhenAll%2A> метода, который возвращает <xref:System.Threading.Tasks.Task> объект обычно вызываются, если вы заинтересованы в состояние набора задач или исключения, создаваемые набор задач.  
  
> [!NOTE]
>  Вызов <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод не блокирует вызывающий поток.  
  
 Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.  
  
 Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.  
  
 Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.  
  
 Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.  
  
   
  
## Examples  
 В следующем примере создается набор задач, проверьте связь с URL-адреса в массиве. Задачи будут храниться в `List<Task>` коллекции, который передается <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод. После вызова <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что все потоки завершены, пример просматривает <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойства, чтобы определить, ли все задачи в состоянии faulted.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Коллекция <paramref name="tasks" />содержала задачу <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена, когда все <see cref="T:System.Threading.Tasks.Task" /> объекты в массиве будут завершены.</summary>
        <returns>Задача, представляющая завершение всех предоставленных задач.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перегрузки <xref:System.Threading.Tasks.Task.WhenAll%2A> метода, который возвращает <xref:System.Threading.Tasks.Task> объект обычно вызываются, если вы заинтересованы в состояние набора задач или исключения, создаваемые набор задач.  
  
> [!NOTE]
>  Вызов <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> метод не блокирует вызывающий поток.  
  
 Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.  
  
 Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.  
  
 Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.  
  
 Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.  
  
   
  
## Examples  
 В следующем примере создается набор задач, проверьте связь с URL-адреса в массиве. Задачи будут храниться в `List<Task>` коллекцию, которая преобразуется в массив и передается <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод. После вызова <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что все потоки завершены, пример просматривает <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойства, чтобы определить, ли все задачи в состоянии faulted.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="tasks" /> содержал задачу <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип завершенной задачи.</typeparam>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена, когда все объекты <see cref="T:System.Threading.Tasks.Task`1" /> в перечисляемой коллекции будут завершены.</summary>
        <returns>Задача, представляющая завершение всех предоставленных задач.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> метод не блокирует вызывающий поток. Тем не менее вызов к возвращенному <xref:System.Threading.Tasks.Task%601.Result%2A> свойство блокирует вызывающий поток.  
  
 Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.  
  
 Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.  
  
 Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Возвращаемой задачи будет установлено в массив, содержащий все результаты из предоставленных задач в том же порядке, так как они были предоставлены (например, если входные данные задачи массива t1, t2, t3, выходные данные задачи <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство возвратит `TResult[]` где `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Если `tasks` аргумент содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне. Возвращенный `TResult[]` будет состоять из 0 элементов.  
  
   
  
## Examples  
 В следующем примере создается десять задач, каждая из которых создает экземпляр генератора случайных чисел, который создает 1000 случайных чисел от 1 до 1000 и вычисляет их среднее значение. <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Метод используется для задержки при создании экземпляра генераторов случайных чисел, таким образом, они не создаются с использованием идентичных начальных значений. Вызов <xref:System.Threading.Tasks.Task.WhenAll%2A> метод затем возвращает <xref:System.Int64> массив, содержащий среднего значения, вычисленные поиском решения для каждой задачи. Затем они используются для вычисления общей среднее значение.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 В этом случае десяти отдельных задач хранятся в <xref:System.Collections.Generic.List%601> объекта. Класс <xref:System.Collections.Generic.List%601> реализует интерфейс списка <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Коллекция <paramref name="tasks" />содержала задачу <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип завершенной задачи.</typeparam>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена, когда все <see cref="T:System.Threading.Tasks.Task`1" /> объекты в массиве будут завершены.</summary>
        <returns>Задача, представляющая завершение всех предоставленных задач.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> метод не блокирует вызывающий поток. Тем не менее вызов к возвращенному <xref:System.Threading.Tasks.Task%601.Result%2A> свойство блокирует вызывающий поток.  
  
 Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.  
  
 Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.  
  
 Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.  <xref:System.Threading.Tasks.Task%601.Result%2A> Возвращаемой задачи устанавливается в массив, содержащий все результаты из предоставленных задач в том же порядке, так как они были предоставлены (например, если входные данные задачи массива t1, t2, t3, выходные данные задачи <xref:System.Threading.Tasks.Task%601.Result%2A> вернет `TResult[]` где `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.  Возвращенный `TResult[]` будет состоять из 0 элементов.  
  
   
  
## Examples  
 В следующем примере создается десять задач, каждая из которых создает экземпляр генератора случайных чисел, который создает 1000 случайных чисел от 1 до 1000 и вычисляет их среднее значение. В этом случае десяти отдельных задач хранятся в `Task<Int64>` массива.  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Метод используется для задержки при создании экземпляра генераторов случайных чисел, таким образом, они не создаются с использованием идентичных начальных значений. Вызов <xref:System.Threading.Tasks.Task.WhenAll%2A> метод затем возвращает <xref:System.Int64> массив, содержащий среднего значения, вычисленные поиском решения для каждой задачи. Затем они используются для вычисления общей среднее значение.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="tasks" /> содержал задачу <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</summary>
        <returns>Задача, представляющая завершение одной из предоставленных задач.  Результат возвращенной задачи — задача, которая была завершена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.  Возвращаемая задача всегда будет заканчиваться `RanToCompletion` состояния с помощью результирующего набора к первой задаче для завершения.  Это справедливо, даже если завершился завершения первой задачи `Canceled` или `Faulted` состояния.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Массива содержал задачу со значением null или пуст.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</summary>
        <returns>Задача, представляющая завершение одной из предоставленных задач.  Результат возвращенной задачи — задача, которая была завершена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.  Возвращаемая задача всегда будет заканчиваться `RanToCompletion` состояния с его `Result` присвоено первой задачи для завершения.  Это справедливо, даже если завершился завершения первой задачи `Canceled` или `Faulted` состояния.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Аргумент имел значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Массива содержал задачу со значением null или пуст.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип завершенной задачи.</typeparam>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</summary>
        <returns>Задача, представляющая завершение одной из предоставленных задач.  Результат возвращенной задачи — задача, которая была завершена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.  Возвращаемая задача всегда будет заканчиваться в состоянии RanToCompletion результирующего набора к первой задаче для завершения. Это справедливо, даже если завершения выполнения первой задачи в состояние Canceled или Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Массива содержал задачу со значением null или пуст.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип завершенной задачи.</typeparam>
        <param name="tasks">Задачи, завершение которых требуется подождать.</param>
        <summary>Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</summary>
        <returns>Задача, представляющая завершение одной из предоставленных задач.  Результат возвращенной задачи — задача, которая была завершена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.  Возвращаемая задача всегда будет заканчиваться в состоянии RanToCompletion результирующего набора к первой задаче для завершения. Это справедливо, даже если завершения выполнения первой задачи в состояние Canceled или Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Аргумент имел значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Массива содержал задачу со значением null или пуст.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает поддерживающий ожидание объект задачи, который асинхронным образом выдает возврат текущему контексту, когда его ожидают.</summary>
        <returns>Контекст, который при ожидании будет асинхронно переходить назад в текущий контекст во время ожидания. Если текущий <see cref="T:System.Threading.SynchronizationContext" /> отличен от null, он также обрабатывается как текущий контекст. В противном случае планировщик задач, связанный с задачей, выполняющейся в данный момент, рассматривается как текущий контекст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать `await Task.Yield();` в асинхронном методе для принудительного завершения асинхронного метода. Если текущий контекст синхронизации (<xref:System.Threading.SynchronizationContext> объекта), этот поток будет публиковать в конце выполнения метода к этого контекста. Тем не менее контекст будет решить, как назначать приоритет этой работы по отношению к другим операциям, может быть отложена. Контекст синхронизации, которая присутствует в потоке пользовательского интерфейса в большинстве сред пользовательского интерфейса будет часто определения приоритета работы, отправляется выше, чем входных данных и подготовки к просмотру рабочего контекста. По этой причине не следует полагаться на `await Task.Yield();` для сохранения отклика пользовательского интерфейса.  Дополнительные сведения см. в записи [полезные абстракции снабженный ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) в параллельному программированию в блоге .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>