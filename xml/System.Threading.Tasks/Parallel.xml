<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9969ebfed1c4d5ee33c68817c29ef43bc01f7aa4" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70628556" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет поддержку параллельных циклов и областей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> Класс обеспечивает параллельные замены данных на основе библиотеки для таких распространенных операций, как циклы for, для каждого цикла и выполнения набора инструкций.  
  
   
  
## Examples  
 В этом примере демонстрируется несколько подходов к реализации параллельного цикла с использованием нескольких языковых конструкций.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Все открытые и защищенные члены <see cref="T:System.Threading.Tasks.Parallel" /> являются потокобезопасными и могут использоваться одновременно из нескольких потоков.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Параллелизм данных (библиотека параллельных задач)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Примеры параллельного программирования с .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет цикл <see langword="for" />, в котором итерации могут выполняться параллельно.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется с двумя аргументами:  
  
-   <xref:System.Int32> Значение, представляющее число итераций.  
  
-   <xref:System.Threading.Tasks.ParallelLoopState> Экземпляр, который можно использовать для преждевременного разбиения цикла. <xref:System.Threading.Tasks.ParallelLoopState> Объект создается компилятором; экземпляр не может быть создан в пользовательском коде.  
  
 Вызов метода информирует `for` операцию, которая выполняет итерацию после текущего, не нужно выполнять. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Однако все итерации, предшествующие текущему, будут по-прежнему выполняться, если они еще не были выполнены.  
  
 Таким образом, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> вызов аналогичен использованию операции break в обычном `for` цикле на языке C#, например, но не является идеальным вариантом: например, нет никакой гарантии, что итерации после текущего будут определенно не выполняется.  
  
 Если выполнение всех итераций до текущего не требуется, используйте <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод вместо использования. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Вызов <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> информирует `for`  цикл о том, что он может отказаться от всех оставшихся итераций, независимо от того, были ли они выполнены до или после текущей итерации, так как вся необходимая работа уже будет завершена. Однако, как и <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>в, нет никаких гарантий относительно того, какие другие итерации не будут выполняться.  
  
 Если цикл завершается преждевременно, <xref:System.Threading.Tasks.ParallelLoopResult> Возвращаемая структура будет содержать актуальные сведения о завершении цикла.  
  
 Если `fromInclusive` значение параметра больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере выполняется параллельное выполнение до 100 итераций цикла. Каждая итерация приостанавливается на случайный интервал от 1 до 1 000 миллисекунд. Генерируемое случайным образом значение определяет, на какой итерации <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> цикла вызывается метод. Как видно из выходных данных в примере, нет итераций, индекс которых больше <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> значения свойства Start после вызова <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> метода.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Поскольку итерации цикла по-прежнему могут выполняться при <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> вызове метода, каждая итерация <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> вызывает свойство, чтобы проверить, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> вызвала ли метод другую итерацию. Если значение свойства равно `true`, итерация проверяет значение <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> свойства и, если оно больше, чем значение индекса текущей итерации, возвращает немедленно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" />, в котором итерации могут выполняться параллельно.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется с числом итераций (<xref:System.Int32>) в качестве параметра.  
  
 Если `fromInclusive` значение параметра больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.Tasks.Parallel.For%2A> метод для вызовов 100 делегата, который создает случайные байтовые значения и вычисляет их сумму.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура <see cref="T:System.Threading.Tasks.ParallelLoopResult" />, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> и экземпляр, который может использоваться для преждевременного разбиения цикла.  
  
 Вызов метода информирует `for` операцию, которая выполняет итерацию после текущего, не нужно выполнять все итерации, предшествующие текущему. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>  
  
 Таким образом, вызов Break аналогичен использованию операции break в обычном `for` цикле на языке C#, например, но это не является идеальным вариантом: например, нет никакой гарантии, что итерации после текущего не будут работать.  
  
 Если выполнение всех итераций до текущего не требуется, используйте <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> метод вместо использования. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Вызов <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> информирует `for`  цикл о том, что он может отказаться от всех оставшихся итераций, независимо от того, были ли они выполнены до или после текущей итерации, так как вся необходимая работа уже будет завершена. Однако, как и <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>в, нет никаких гарантий относительно того, какие другие итерации не будут выполняться.  
  
 Если цикл завершается преждевременно, <xref:System.Threading.Tasks.ParallelLoopResult> Возвращаемая структура будет содержать актуальные сведения о завершении цикла.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами, в котором итерации могут выполняться параллельно.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется с числом итераций (<xref:System.Int64>) в качестве параметра.  
  
 Если `fromInclusive` значение параметра больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> и экземпляр, который может использоваться для преждевременного разбиения цикла.  
  
 Если `fromInclusive` значение параметра больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" />, обеспечивая возможность параллельного выполнения итераций и настройки параметров цикла.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется с числом итераций (<xref:System.Int32>) в качестве параметра.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере показано, как отменить параллельный цикл:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> и экземпляр, который может использоваться для преждевременного разбиения цикла.  
  
 Если `fromInclusive` значение параметра больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере показано, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> как использовать метод <xref:System.Threading.Tasks.ParallelOptions> с объектом:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами, обеспечивая возможность параллельного выполнения итераций и настройки параметров цикла.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поддерживает 64-разрядные индексы. Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется с числом итераций (<xref:System.Int64>) в качестве параметра.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.Tasks.ParallelOptions> для задания настраиваемого планировщика задач.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет цикл <see langword="for" /> с локальными данными потока, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в одном потоке.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 Пример, в котором используется этот метод, см. в разделе [как написать параллельный цикл for с локальными переменными потока](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами и локальными данными потока, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в той же задаче.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 Пример, в котором используется этот метод, см. в разделе [как написать параллельный цикл for с локальными переменными потока](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет цикл <see langword="for" /> с локальными данными потока, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в той же задаче.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно для нескольких потоков. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
   
  
## Examples  
 В следующем примере локальные переменные потока используются для вычисления суммы результатов многих длительных операций. В этом примере степень параллелизма ограничивается четырьмя.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="fromInclusive">Начальный индекс (включительно).</param>
        <param name="toExclusive">Конечный индекс, не включительно.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждого потока.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждого потока.</param>
        <summary>Выполняет цикл <see langword="for" /> с 64-разрядными индексами и локальными данными потока, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого значения в диапазоне итерации (`fromInclusive`, `toExclusive`). `body` Он предоставляется со следующими параметрами: число итераций (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в одном потоке.  
  
 `localInit` Делегат вызывается один раз для каждого потока, участвующего в выполнении цикла, и возвращает начальное локальное состояние для каждого из этих потоков. Эти начальные состояния передаются в `body` первый вызов в каждом потоке. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждом потоке возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждого потока, чтобы выполнить завершающее действие в локальном состоянии каждого потока. Этот делегат может быть вызван одновременно для нескольких потоков. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 Если `fromInclusive` значение больше или `toExclusive`равно, метод возвращает значение немедленно, не выполняя никаких итераций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each " /> в Visual Basic), в которой итерации могут выполняться параллельно.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Упорядочиваемый разделитель, содержащий исходный источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в упорядочиваемом разделителе <paramref name="source" /> возвращает значение <see langword="false" />.  
  
- или - 
Свойство <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> в упорядочиваемом разделителе источника возвращает значение <see langword="false" />.  
  
- или - 
Все методы в упорядочиваемом модуле разделения источника возвращают <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, порождаемое одним из указанных делегатов.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /> возвращает <see langword="false" />.  
  
- или - 
Метод в разделителе <paramref name="source" /> возвращает <see langword="null" />.  
  
- или - 
Метод <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> в разделителе <paramref name="source" /> не возвращает правильное число разделов.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
        <exception cref="T:System.AggregateException">Исключение, которое содержит исключение, созданное одним из указанных делегатов.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 В следующем примере показано, как реализовать разделитель диапазонов для использования с <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /> возвращает <see langword="false" />.  
  
-или- 
Исключение, которое возникает, когда какие-либо методы в разделителе <paramref name="source" /> возвращают значение <see langword="null" />.  
  
-или- 
Метод <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> в разделителе <paramref name="source" /> не возвращает правильное число разделов.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
        <exception cref="T:System.AggregateException">Исключение, которое содержит исключение, созданное одним из указанных делегатов.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с 64-разрядными индексами для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, и индекс текущего элемента (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент и <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется с текущим элементом в качестве параметра.  
  
   
  
## Examples  
 В следующем примере <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> метод используется для подсчета числа гласных и непустых символов в текстовом файле. В этом случае <xref:System.Threading.Tasks.ParallelLoopResult> значение, возвращаемое методом, игнорируется. Обратите внимание, что, поскольку операции могут выполняться параллельно, необходимо убедиться в том, что увеличение переменных счетчика является атомарной операцией, и что несколько потоков не пытаются одновременно получить доступ к переменным счетчика. Для этой цели в примере используется `lock` оператор (в C#) и `SyncLock` оператор (в Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Упорядочиваемый разделитель, содержащий исходный источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в упорядочиваемом разделителе <paramref name="source" /> возвращает значение <see langword="false" />.  
  
- или - 
Свойство <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> в упорядочиваемом разделителе <paramref name="source" /> возвращает значение <see langword="false" />.  
  
-или- 
Исключение, которое возникает, когда методы в упорядочиваемом разделителе <paramref name="source" /> возвращают значение <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
        <exception cref="T:System.AggregateException">Исключение, которое содержит исключение, созданное одним из указанных делегатов.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /> возвращает <see langword="false" />.  
  
- или - 
Исключение, которое возникает, когда какие-либо методы в разделителе <paramref name="source" /> возвращают значение <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
        <exception cref="T:System.AggregateException">Исключение, которое содержит исключение, созданное одним из указанных делегатов.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций и настройки параметров цикла.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /> возвращает <see langword="false" />.  
  
- или - 
Исключение, которое возникает, когда какие-либо методы в разделителе <paramref name="source" /> возвращают значение <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
        <exception cref="T:System.AggregateException">Исключение, которое содержит исключение, созданное одним из указанных делегатов.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с 64-разрядными индексами для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, и индекс текущего элемента (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент и <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций и настройки параметров цикла.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется с текущим элементом в качестве параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Упорядочиваемый разделитель, содержащий исходный источник данных.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для объекта <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> возвращает значение <see langword="false" /> или разделитель возвращает части со значением <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для объекта <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Делегат вызывается один раз для каждого потока, участвующего в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> возвращает значение <see langword="false" /> или разделитель возвращает части со значением <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, индекс текущего элемента (<xref:System.Int64>) и некоторое локальное состояние, которые могут совместно использоваться итерациями, выполняющими в том же потоке.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в одном потоке.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждого потока для выполнения последнего действия с локальным состоянием каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.Tasks.Parallel.ForEach%2A> метод с локальным состоянием.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Упорядочиваемый разделитель, содержащий исходный источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с 64-разрядными индексами и локальными данными потока для объекта <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждом потоке возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> или аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> возвращает значение <see langword="false" /> или разделитель возвращает части со значением <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов в объекте <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Разделитель, содержащий исходный источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для класса <see cref="T:System.Collections.Concurrent.Partitioner" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка предоставляется для сценариев, в которых необходимо переопределить схему секционирования по умолчанию. Например, небольшие фрагменты цикла могут выиграть от секционирования диапазона. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Метод должен поддерживать Динамическое секционирование для пользовательских секционирований. Эта перегрузка предоставляется для сценариев с небольшими частями цикла, которые могут выиграть от статического секционирования диапазона. Модули секционирования должны поддерживать динамические секции.  Дополнительные сведения см. в разделах [пользовательские разделители для PLINQ и TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) и [инструкции: Реализация динамических секций](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждой задачи, чтобы выполнить Последнее действие в локальном состоянии каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> в разделителе <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> возвращает значение <see langword="false" /> или разделитель возвращает части со значением <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с 64-разрядными индексами и локальными данными потока для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, индекс текущего элемента (<xref:System.Int64>) и некоторое локальное состояние, которые могут совместно использоваться итерациями, выполняющими в том же потоке.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждого потока для выполнения последнего действия с локальным состоянием каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип данных в источнике.</typeparam>
        <typeparam name="TLocal">Тип данных, локальных для потока.</typeparam>
        <param name="source">Перечислимый источник данных.</param>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="localInit">Делегат функции, который возвращает начальное состояние локальных данных для каждой задачи.</param>
        <param name="body">Делегат, который вызывается один раз за итерацию.</param>
        <param name="localFinally">Делегат, который выполняет финальное действие с локальным состоянием каждой задачи.</param>
        <summary>Выполняет операцию <see langword="foreach" /> (<see langword="For Each" /> в Visual Basic) с локальными данными потока для объекта <see cref="T:System.Collections.IEnumerable" />, обеспечивая возможность параллельного выполнения итераций, настройки параметров цикла, а также контроля состояния цикла и управления этим состоянием.</summary>
        <returns>Структура, в которой содержатся сведения о выполненной части цикла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается один раз для каждого элемента `source` в перечислимом элементе. `body` Он предоставляется со следующими параметрами: текущий элемент, <xref:System.Threading.Tasks.ParallelLoopState> экземпляр, который может использоваться для преждевременного разрыва цикла, и некоторое локальное состояние, которое может совместно использоваться итерациями, выполняемыми в одном потоке.  
  
 `localInit` Делегат вызывается один раз для каждой задачи, участвующей в выполнении цикла, и возвращает начальное локальное состояние для каждой из этих задач. Эти начальные состояния передаются в `body` первый вызов каждой задачи. Затем при каждом последующем вызове тела возвращается потенциально измененное значение состояния, которое передается следующему вызову тела. Наконец, последний вызов тела в каждой задаче возвращает значение состояния, которое передается `localFinally` делегату. `localFinally` Делегат вызывается один раз для каждого потока для выполнения последнего действия с локальным состоянием каждой задачи. Этот делегат может быть вызван одновременно несколькими задачами. Поэтому необходимо синхронизировать доступ к любым общим переменным.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Метод может использовать больше задач, чем потоков, в течение времени существования его выполнения, так как существующие задачи завершены и заменены новыми задачами. Это дает базовому <xref:System.Threading.Tasks.TaskScheduler> объекту возможность добавлять, изменять или удалять потоки, обслуживающие цикл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="source" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.  
  
- или - 
Аргумент <paramref name="body" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localInit" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="localFinally" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">Токен <see cref="T:System.Threading.CancellationToken" /> в аргументе <paramref name="parallelOptions" /> отменен.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое содержит все отдельные исключения, создаваемые во всех потоках.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Параллельные циклы</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет все предоставленные действия, в том числе параллельно.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Массив действий <see cref="T:System.Action" /> для выполнения.</param>
        <summary>Выполняет все предоставленные действия, в том числе параллельно.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для выполнения набора операций, которые могут выполняться параллельно.  
  
 Нет никаких гарантий относительно порядка, в котором операции выполняются или выполняются параллельно. Этот метод не возвращает значение до тех пор, пока не завершится каждая из указанных операций, независимо от того, происходит ли завершение из-за обычного или исключительного завершения.  
  
 Дополнительные сведения см. в разделе [Практическое руководство. Использование метода Parallel.Invoke для выполнения простых параллельных задач](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 В этом примере показано, как использовать <xref:System.Threading.Tasks.Parallel.Invoke%2A> метод с другими методами, анонимными делегатами и лямбда-выражениями.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="actions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое возникает, когда любое действие в массиве <paramref name="actions" /> создает исключение.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="actions" /> содержит элемент <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Объект, используемый для настройки поведения этой операции.</param>
        <param name="actions">Массив действий для выполнения.</param>
        <summary>Выполняет каждое из указанных действий по возможности в параллельном режиме, если операция не отменена пользователем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для выполнения набора операций, которые могут выполняться параллельно. Токен отмены, переданный с помощью <xref:System.Threading.Tasks.ParallelOptions> структуры, позволяет вызывающему объекту отменить всю операцию. См. дополнительные сведения об [отмене в управляемых потоках](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Нет никаких гарантий относительно порядка, в котором операции выполняются или выполняются параллельно. Этот метод не возвращает значение до тех пор, пока не завершится каждая из указанных операций, независимо от того, происходит ли завершение из-за обычного или исключительного завершения.  
  
 Дополнительные сведения см. в разделе [Практическое руководство. Использование метода Parallel.Invoke для выполнения простых параллельных задач](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" /> задан.</exception>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="actions" /> имеет значение <see langword="null" />.  
  
-или- 
Аргумент <paramref name="parallelOptions" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Исключение, которое возникает, когда любое действие в массиве <paramref name="actions" /> создает исключение.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="actions" /> содержит элемент <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" />, связанный с <see cref="T:System.Threading.CancellationToken" /> в <paramref name="parallelOptions" />, удален.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
