<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="59e88bc9b363c87e030660b4cdc70d3f74162419" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158976" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, обрабатывающий низкоуровневую постановку задач в очередь на потоки.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр класса <xref:System.Threading.Tasks.TaskScheduler> представляет планировщик задач. Планировщик задач гарантирует, что работа над задачей в итоге будет выполнена.  
  
 Планировщик заданий по умолчанию основан на пуле потоков .NET Framework 4, который обеспечивает перехват работы для балансировки нагрузки, вставку/удаление потока для максимальной пропускной способности и общее повышение производительности. Его должно быть достаточно для большинства сценариев.  
  
 Класс <xref:System.Threading.Tasks.TaskScheduler> также служит точкой расширения для всей настраиваемой логики планирования.  Сюда входят такие механизмы, как планирование выполнения задачи и выполнение запланированных задач для отладчиков. Если требуются специальные функции, можно создать пользовательский планировщик и включить его для определенных задач или запросов.  
  
 В этом разделе.  
[Планировщик задач по умолчанию и пул потоков](#Default)  
 [Глобальная очередь и локальные очереди](#Queues)  
 [Перенос нагрузки](#Stealing)  
 [Длительные задачи](#LongRunning)  
 [Встраивание задач](#Inlining)  
[Указание контекста синхронизации](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Планировщик задач по умолчанию и пул потоков  
 Планировщик по умолчанию для библиотеки параллельных задач и PLINQ использует пул потоков .NET Framework, который представлен классом <xref:System.Threading.ThreadPool>, для постановки в очередь и выполнения работы. Пул потоков использует сведения, предоставляемые типом <xref:System.Threading.Tasks.Task>, для эффективной поддержки точного параллелизма (единиц работы с кратковременным временем существования), которые часто представляют параллельные задачи и запросы.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Глобальная очередь и локальные очереди  
 Пул потоков поддерживает глобальную очередь FIFO (по принципу "первым поступил — первым обслужен") для потоков в каждом домене приложения. Всякий раз, когда программа вызывает метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (или <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>), работа помещается в эту общую очередь и в конечном итоге удаляется из очереди в следующий поток, который становится доступным. Начиная с .NET Framework 4, эта очередь была улучшена для использования алгоритма без блокировки, который напоминает класс <xref:System.Collections.Concurrent.ConcurrentQueue%601>. Используя эту реализацию без блокировки, пул потоков тратит меньше времени, когда он помещает рабочие элементы в очередь и освобождает их. Это преимущество производительности доступно для всех программ, использующих пул потоков.  
  
 Задачи верхнего уровня, которые являются задачами, не созданными в контексте других задач, помещаются в глобальную очередь так же, как и другие рабочие элементы. Однако вложенные или дочерние задачи, создаваемые в контексте других задач, обрабатываются по-другому. Дочерняя или вложенная задача помещается в локальную очередь, относящуюся к потоку, в котором выполняется родительская задача. Родительская задача может быть задачей верхнего уровня или дочерней задачей другой задачи. Когда этот поток готов для дополнительной работы, сначала он выполняет поиск в локальной очереди. Если в ней существует ожидающие рабочие элементы, к ним возможен быстрый доступ. Доступ к локальным очередям осуществляется по принципу "последним порядку выхода" (ЛИФО), чтобы сохранить локальность кэша и уменьшить состязание. Дополнительные сведения о дочерних задачах и вложенных задачах см. в разделе [присоединенные и отсоединенные дочерние задачи](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Использование локальных очередей не только сокращает нагрузку на глобальную очередь, но и использует преимущества локального использования данных. Рабочие элементы в локальной очереди часто ссылаются на структуры данных, которые физически находятся рядом друг с другом в памяти. В этих случаях данные уже находятся в кэше после выполнения первой задачи и могут быть быстро доступны. Как [параллельный LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) , так и класс <xref:System.Threading.Tasks.Parallel> используют вложенные задачи и дочерние задачи широко и обеспечивают значительное ускорение с помощью локальных рабочих очередей.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Перенос нагрузки  
 Начиная с .NET Framework 4, пул потоков также применяет алгоритм переноса нагрузки, позволяющий убедиться, что потоки не находятся в состоянии простоя, а другие еще работают в своих очередях. Когда поток из пула потоков готов для дополнительной работы, сначала он выполняет поиск в своей локальной очереди, далее в глобальной очереди, а затем в локальных очередях других потоков. При обнаружении рабочего элемента в локальной очереди другого потока он сначала применяет эвристику, чтобы убедиться, что он может эффективно выполнить эту работу. Если это возможно, он удаляет рабочий элемент из конца в очередь (в порядке FIFO). Это уменьшает конкуренцию внутри каждой из локальных очередей и сохраняет локальность данных. Эта архитектура позволяет повысить эффективность балансировки нагрузки пула потоков по сравнению с предыдущими версиями.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Длительные задачи  
 Может потребоваться явно запретить помещение задачи в локальную очередь. Например, вы знаете, что определенный рабочий элемент будет выполняться довольно долго и может заблокировать другие рабочие элементы в локальной очереди. В таком случае можно указать параметр <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, который подсказывает планировщику, что для задачи может потребоваться дополнительный поток, чтобы она не блокировала дальнейший ход работы других потоков или рабочих элементов в локальной очереди. С помощью этого параметра можно полностью избежать пула потоков, включая глобальные и локальные очереди.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Встраивание задач  
 В некоторых случаях, когда ожидается <xref:System.Threading.Tasks.Task>, он может выполняться синхронно в потоке, который выполняет операцию ожидания. Это повышает производительность, предотвращая необходимость в дополнительном потоке и вместо этого использует существующий поток, который в противном случае был бы заблокирован. Чтобы предотвратить возникновение ошибок из-за повторного входа, встраивание задачи происходит только в том случае, если целевой объект ожидания находится в локальной очереди соответствующего потока.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Указание контекста синхронизации  
 С помощью метода <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> можно указать, что задачу необходимо планировать для запуска в определенном потоке. Это полезно на платформах, например Windows Forms и Windows Presentation Foundation, где доступ к объектам пользовательского интерфейса часто ограничен кодом, выполняемым в том же потоке, в котором был создан этот объект пользовательского интерфейса.  
  
 В следующем примере используется метод <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> в приложении Windows Presentation Foundation (WPF) для планирования задачи в том же потоке, в котором был создан элемент управления пользовательского интерфейса.   В примере создается мозаика из изображений, которые выбираются случайным образом из указанного каталога. Объекты WPF используются для загрузки и изменения размера изображений. Необработанные пиксели затем передаются в задачу, которая использует цикл <xref:System.Threading.Tasks.Parallel.For%2A> для записи пиксельных данных в большой однобайтовый массив. Синхронизация не требуется, поскольку две плитки не занимают одни и те же элементы массива. Плитки также можно записать в любом порядке, так как их расположение вычисляется независимо от любой другой плитки. После этого большой массив передается задаче, выполняемой в потоке пользовательского интерфейса, в котором данные пикселей загружаются в элемент управления Image.  
  
 В примере данные перемещаются из потока пользовательского интерфейса, изменяются с помощью параллельных циклов и <xref:System.Threading.Tasks.Task> объектов, а затем передаются обратно в задачу, выполняемую в потоке пользовательского интерфейса. Этот подход удобен, когда необходимо использовать библиотеку параллельных задач для выполнения операций, которые либо не поддерживаются API WPF, либо не выполняются достаточно быстро. Другим способом создания мозаики изображений в WPF является использование элемента управления <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> и добавление в него изображений. <xref:System.Windows.Controls.WrapPanel> обрабатывает работу по размещению плиток. Однако эту работу можно выполнить только в потоке пользовательского интерфейса.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Чтобы создать пример, создайте проект приложения WPF в Visual Studio и назовите его WPF_CS1 (для проекта C# WPF) или WPF_VB1 (для Visual Basic проекта WPF). Затем выполните следующие действия.  
  
1. В режиме конструктора перетащите элемент управления <xref:System.Windows.Controls.Image> из области **элементов** в левый верхний угол области конструктора. В текстовом поле **имя** окна **свойства** назовите элемент управления "Image".    
  
2. Перетащите элемент управления <xref:System.Windows.Controls.Button> из **области элементов** в нижнюю левую часть окна приложения. В представлении XAML укажите <xref:System.Windows.Controls.ContentControl.Content%2A> свойство кнопки как "создать мозаику" и укажите для свойства <xref:System.Windows.FrameworkElement.Width> значение "100". Соедините событие <xref:System.Windows.Controls.Primitives.ButtonBase.Click> с обработчиком событий `button_Click`, определенным в коде примера, добавив `Click="button_Click"` к элементу `<Button>`. В текстовом поле **имя** окна **свойства** назовите элемент управления "Кнопка".  
  
3. Замените все содержимое файла MainWindow.xaml.cs или MainWindow. XAML. vb кодом из этого примера. Для проекта C# WPF убедитесь, что имя рабочей области совпадает с именем проекта. 
  
4. Пример считывает изображения JPEG из каталога с именем К:\усерс\публик\пиктурес\сампле pictures\\. Либо создайте каталог и поместите в него некоторые образы, либо измените путь, чтобы он ссылался на другой каталог, содержащий образы. 
  
Этот пример имеет некоторые ограничения. Например, поддерживаются только изображения размером 32 бит на пиксель; изображения в других форматах повреждаются объектом <xref:System.Windows.Media.Imaging.BitmapImage> во время операции изменения размера. Кроме того, исходные изображения должны быть больше, чем размер плитки. В качестве дальнейшего упражнения можно добавить функциональные возможности для обработки нескольких форматов пикселей и размеров файлов.  
  
## Examples  
 Следующий пример взят из [примеров для параллельного программирования с .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) на веб-сайте коллекции кода MSDN.  Он создает настраиваемый планировщик задач, ограничивающий количество потоков, используемых приложением. Затем он запускает два набора задач и отображает сведения о задаче и потоке, в котором выполняются задачи.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Кроме того, в галерее кода доступны несколько планировщиков заданий: [примеры для параллельного программирования с помощью .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены абстрактного типа <see cref="T:System.Threading.Tasks.TaskScheduler" /> являются потокобезопасными и могут использоваться из нескольких потоков одновременно.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует объект <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</summary>
        <value>Возвращает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в задаче не вызывается, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> вернет планировщик <xref:System.Threading.Tasks.TaskScheduler.Default%2A>.  
  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию, предоставляемый платформой .NET Framework.</summary>
        <value>Возвращает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с данным планировщиком.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />, как определено в <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все экземпляры <xref:System.Threading.Tasks.Task>, помещенные в очередь на возвращенный планировщик, будут выполняться посредством вызова метода <xref:System.Threading.SynchronizationContext.Post%2A> в этом контексте.  
  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий SynchronizationContext нельзя использовать как TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает перечисляемый объект экземпляров <see cref="T:System.Threading.Tasks.Task" />, которые в настоящее время находятся в очереди планировщика, ожидая выполнения (только для поддержки отладки).</summary>
        <returns>Перечисляемый объект, позволяющий отладчику перемещаться по задачам, которые находятся в очереди данного планировщика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler>, реализует этот метод для поддержки интеграции с отладчиками. Этот метод будет вызываться только .NET Framework, когда отладчик запрашивает доступ к данным. Возвращаемые перечислимые значения будут обойтися с помощью служебных программ отладки для доступа к задачам, находящихся в очереди данного планировщика, что позволяет отладчику предоставить представление этих сведений в пользовательском интерфейсе.  
  
 Важно отметить, что при вызове этого метода все остальные потоки в процессе будут заморожены. Поэтому важно избегать синхронизации с другими потоками, которые могут привести к блокировке. Если требуется синхронизация и вы не можете получить блокировку в этом методе, следует создать исключение, чтобы отладчик не блокировал его. В следующем примере показан один из возможных подходов в C#:
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Кроме того, этот метод и возвращаемое перечислимое значение не должны изменять глобально видимое состояние.  
  
 Возвращаемое перечислимое значение никогда не должно быть равно null. Если в настоящее время нет задач, поставленных в очередь, вместо нее должно возвращаться пустое перечислимое значение.  
  
 Разработчики, реализующие пользовательские отладчики, не должны вызывать этот метод напрямую, но вместо этого следует использовать внутренний метод-оболочка `GetScheduledTasksForDebugger`: `internal Task[] GetScheduledTasksForDebugger()`. Этот метод-оболочка возвращает массив задач вместо перечислимого. Чтобы получить список активных планировщиков, используйте внутренний метод `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Этот статический метод возвращает массив всех активных экземпляров <xref:System.Threading.Tasks.TaskScheduler>. Затем можно использовать `GetScheduledTasksForDebugger` для каждого экземпляра планировщика, чтобы получить список запланированных задач.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этому планировщику не удается создать список находящихся в данный момент в очереди задач.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Возвращает уникальный идентификатор для данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает максимальный уровень параллелизма, который может поддерживаться данным планировщиком <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Возвращает целое число, представляющее максимальный уровень параллелизма. Планировщик по умолчанию возвращает значение свойства <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Помещаемый в очередь объект <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Ставит объект <see cref="T:System.Threading.Tasks.Task" /> в очередь планировщика.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler>, реализует этот метод для принятия задач, запланированных в планировщике.  
  
 Типичная реализация сохранит задачу во внутренней структуре данных, которая будет обслуживаться потоками, которые будут выполнять эти задачи в будущем.  
  
 Этот метод предназначен только для вызова .NET Framework и не должен вызываться непосредственно производным классом. Это необходимо для поддержания согласованности системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Объект <see cref="T:System.Threading.Tasks.Task" /> для удаления из очереди.</param>
        <summary>Пытается удалить из очереди задачу <see cref="T:System.Threading.Tasks.Task" />, ранее поставленную в очередь данного планировщика.</summary>
        <returns>Логическое значение, указывающее, был ли аргумент <paramref name="task" /> успешно удален из очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Этот метод может выполняться в блоке finally; Поэтому он должен возвращать как можно быстрее, чтобы все ресурсы, такие как <xref:System.Threading.CancellationTokenRegistration> объекты, можно было своевременно удалять.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Выполняемая задача <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Пытается выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом планировщике.</summary>
        <returns>Логическое значение true, если задача <paramref name="task" /> успешно выполнена; в противном случае — значение false. Общая причина ошибки выполнения состоит в том, что задача выполнялась ранее или выполняется другим потоком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации планировщика предоставляются с <xref:System.Threading.Tasks.Task> экземплярами, которые выполняются с помощью метода <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> или метода <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>. Когда планировщик считает, что он подходит для выполнения предоставленной задачи, для этого следует использовать <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>. Трексекутетаск обрабатывает все аспекты выполнения задачи, включая вызов действия, обработку исключений, управление состоянием и управление жизненным циклом.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> должны использоваться только для задач, предоставленных этому планировщику .NET Framework инфраструктурой. Его не следует использовать для выполнения произвольных задач, полученных с помощью пользовательских механизмов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> не связана с данным планировщиком.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Выполняемый объект <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="taskWasPreviouslyQueued">Логическое значение, указывающее, была ли задача ранее поставлена в очередь. Если этот параметр имеет значение True, задача могла ранее быть в очереди; если он имеет значение False, задача не была поставлена в очередь, а данный вызов совершается для выполнения задачи на месте без постановки в очередь.</param>
        <summary>Определяет, можно ли выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом вызове синхронно, и если возможно, выполняет ее.</summary>
        <returns>Логическое значение, определяющее, была ли задача выполнена на месте.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс, производный от <xref:System.Threading.Tasks.TaskScheduler>, реализует эту функцию для поддержки встроенного выполнения задачи в потоке, которая инициирует ожидание этого объекта задачи. Встроенное выполнение является необязательным, и запрос может быть отклонен путем возвращения значения false. Тем не менее, чем больше задач может быть встроено, тем лучше масштабируется планировщик. Фактически, планировщик, слишком маленький, может быть подвержен взаимоблокировкам. Правильная реализация должна обеспечивать возможность успешного выполнения запроса, который выполняется в соответствии с политиками, гарантированными планировщиком. Например, если планировщик использует выделенный поток для выполнения задач, все запросы на встраивание из этого потока должны быть выполнены.  
  
 Если планировщик решает выполнить встроенное выполнение, он должен сделать это, вызвав метод <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> базового TaskScheduler с предоставленным объектом Task, выполнив распространение возвращаемого значения. Кроме того, планировщик может подойти к удалению встроенной задачи из ее внутренних структур данных, если он решит обработать запрос встраивания. Однако обратите внимание, что в некоторых обстоятельствах планировщику может быть предложено выполнить встраивание задачи, которая ранее не была предоставлена с помощью метода <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>.  
  
 Производный планировщик отвечает за обеспечение того, что вызывающий поток подходит для выполнения данной задачи до тех пор, пока применяются собственные политики планирования и выполнения.  
  
 Для получения дополнительной информации см. <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Аргумент <paramref name="task" /> имеет значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> уже выполнена.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создается при активации политики эскалации исключений из-за непредвиденного исключения задачи, завершившейся сбоем. По умолчанию из-за этой политики процесс будет прерван.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие уровня домена приложения предоставляет механизм для предотвращения срабатывания политики эскалации исключений (которая по умолчанию завершает процесс).  
  
 Чтобы разработчикам было проще писать асинхронный код на основе задач, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] изменяет поведение исключения по умолчанию для незамеченных исключений. Хотя незамеченные исключения по-прежнему вызывают исключение <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>, процесс по умолчанию не завершается. Вместо этого исключение обрабатывается средой выполнения после возникновения события, независимо от того, наблюдает ли обработчик событий с исключением. Это поведение можно настроить. Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)]можно использовать элемент конфигурации [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) , чтобы вернуться к поведению [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] и завершить процесс:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Библиотека параллельных задач (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;Сровунобсерведтаскексцептионс&gt; элемент</related>
      </Docs>
    </Member>
  </Members>
</Type>
