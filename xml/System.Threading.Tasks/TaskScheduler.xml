<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6eccab7743830eb390cf2966272244bf716e11b3" /><Meta Name="ms.sourcegitcommit" Value="75eca440f8f4d595506405f48961f38649e160d7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/01/2019" /><Meta Name="ms.locfileid" Value="66457968" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a8cf9-101">Представляет объект, обрабатывающий низкоуровневую постановку задач в очередь на потоки.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-102">Экземпляр <xref:System.Threading.Tasks.TaskScheduler> класс представляет планировщика задач.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="a8cf9-103">Планировщик задач гарантирует, что работа над задачей в итоге будет выполнена.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="a8cf9-104">Планировщик заданий по умолчанию основан на пуле потоков .NET Framework 4, который обеспечивает перехват работы для балансировки нагрузки, вставку/удаление потока для максимальной пропускной способности и общее повышение производительности.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="a8cf9-105">Его должно быть достаточно для большинства сценариев.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="a8cf9-106"><xref:System.Threading.Tasks.TaskScheduler> Класс также служит точкой расширения для всех настраиваемых логики планирования.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="a8cf9-107">Сюда входят механизмы, такие как планирование задач для выполнения и как запланированные задачи должны предоставляться к отладчикам.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="a8cf9-108">Если требуются специальные функциональные возможности, можно создать пользовательский планировщик и включить его для определенных задач или запросов.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="a8cf9-109">В этом разделе.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-109">In this topic:</span></span>  
[<span data-ttu-id="a8cf9-110">Планировщик задач по умолчанию и пула потоков</span><span class="sxs-lookup"><span data-stu-id="a8cf9-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="a8cf9-111">Глобальную очередь и локальные очереди</span><span class="sxs-lookup"><span data-stu-id="a8cf9-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="a8cf9-112">Перехват работы</span><span class="sxs-lookup"><span data-stu-id="a8cf9-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="a8cf9-113">Длительно выполняемые задачи</span><span class="sxs-lookup"><span data-stu-id="a8cf9-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="a8cf9-114">Встраивание задачи</span><span class="sxs-lookup"><span data-stu-id="a8cf9-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="a8cf9-115">Указание контекста синхронизации</span><span class="sxs-lookup"><span data-stu-id="a8cf9-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="a8cf9-116">Планировщик задач по умолчанию и пула потоков</span><span class="sxs-lookup"><span data-stu-id="a8cf9-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="a8cf9-117">Планировщик по умолчанию для библиотеки параллельных задач и PLINQ использует пул потоков .NET Framework, которое представляется <xref:System.Threading.ThreadPool> класса очередь и выполнения работы.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="a8cf9-118">Пул потоков использует сведения, предоставляемые <xref:System.Threading.Tasks.Task> тип для эффективной поддержки точного параллелизма (кратковременных единиц работы), параллельные задачи и запросы часто представляют.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="a8cf9-119">Глобальную очередь и локальные очереди</span><span class="sxs-lookup"><span data-stu-id="a8cf9-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="a8cf9-120">Пул потоков обслуживает очередь глобального FIFO (первым пришел, первым обслужен) для потоков в каждом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="a8cf9-121">Каждый раз, когда программа вызывает <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (или <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) метод, работа, сохраняются в этой общей очереди и в конечном счете, выведенных из очереди в следующий поток, который становится доступным.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="a8cf9-122">Начиная с .NET Framework 4, эта очередь было улучшено использовать свободную от блокировок алгоритм, который напоминает <xref:System.Collections.Concurrent.ConcurrentQueue%601> класса.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="a8cf9-123">Используя эту свободную от блокировок реализацию, пул потоков тратит меньше времени, когда он помещает в очередь и исключении из очереди рабочих элементов.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="a8cf9-124">Такое преимущество в производительности доступно для всех программ, использующих пул потоков.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="a8cf9-125">Задачи верхнего уровня, которые являются задачами, не созданными в контексте других задач, помещаются в глобальную очередь так же, как и другие рабочие элементы.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="a8cf9-126">Однако вложенные или дочерние задачи, создаваемые в контексте других задач, обрабатываются по-другому.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="a8cf9-127">Дочерняя или вложенная задача помещается в локальную очередь, относящуюся к потоку, в котором выполняется родительская задача.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="a8cf9-128">Родительская задача может быть задачей верхнего уровня или дочерней задачей другой задачи.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="a8cf9-129">Когда этот поток готов для дополнительной работы, сначала он выполняет поиск в локальной очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="a8cf9-130">Если в ней существует ожидающие рабочие элементы, к ним возможен быстрый доступ.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="a8cf9-131">Доступ к локальным очередям осуществляется порядку последним поступил — первым обслужен (LIFO) для сохранения локальности кэша и уменьшения количества конфликтов.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="a8cf9-132">Дополнительные сведения о дочерних и вложенных задачах см. в разделе [присоединенные и отсоединенные дочерние задачи](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="a8cf9-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="a8cf9-133">Использование локальных очередей не только снижает нагрузку на глобальную очередь, но также использует преимущества локальности данных.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="a8cf9-134">Рабочие элементы в локальной очереди часто ссылаются на структуры данных, которые физически находятся рядом друг с другом в памяти.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="a8cf9-135">В этих случаях данные уже находятся в кэше после выполнения первой задачи и возможен быстрый.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="a8cf9-136">Оба [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) и <xref:System.Threading.Tasks.Parallel> класса широко используют вложенные и дочерние задачи и получают значительное увеличение скорости с помощью локальных рабочих очередей.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="a8cf9-137">Перехват работы</span><span class="sxs-lookup"><span data-stu-id="a8cf9-137">Work stealing</span></span>  
 <span data-ttu-id="a8cf9-138">Начиная с .NET Framework 4, пул потоков также содержит алгоритм переноса нагрузки, чтобы убедиться, что сидите нет потоков простоя хотя другие работают в свои очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="a8cf9-139">Когда поток из пула потоков готов для дополнительной работы, сначала он выполняет поиск в своей локальной очереди, далее в глобальной очереди, а затем в локальных очередях других потоков.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="a8cf9-140">При обнаружении рабочего элемента в локальной очереди другого потока он сначала применяет эвристику, чтобы убедиться, что он может эффективно выполнить эту работу.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="a8cf9-141">Если это возможно, он выводит из очереди рабочий элемент из заключительного (в порядке FIFO).</span><span class="sxs-lookup"><span data-stu-id="a8cf9-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="a8cf9-142">Это уменьшает конкуренцию внутри каждой из локальных очередей и сохраняет локальность данных.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="a8cf9-143">Эта архитектура позволяет потоков пула Балансировка нагрузки работает более эффективно, чем в предыдущих версиях.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="a8cf9-144">Длительно выполняемые задачи</span><span class="sxs-lookup"><span data-stu-id="a8cf9-144">Long-running tasks</span></span>  
 <span data-ttu-id="a8cf9-145">Может потребоваться явно запретить помещение задачи в локальную очередь.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="a8cf9-146">Например, вы знаете, что определенный рабочий элемент будет выполняться довольно долго и может заблокировать другие рабочие элементы в локальной очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="a8cf9-147">В таком случае можно указать параметр <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, который подсказывает планировщику, что для задачи может потребоваться дополнительный поток, чтобы она не блокировала дальнейший ход работы других потоков или рабочих элементов в локальной очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="a8cf9-148">С помощью этого параметра можно избежать в пул потоков полностью, включая глобальные и локальные очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="a8cf9-149">Встраивание задачи</span><span class="sxs-lookup"><span data-stu-id="a8cf9-149">Task inlining</span></span>  
 <span data-ttu-id="a8cf9-150">В некоторых случаях, когда <xref:System.Threading.Tasks.Task> ожидает, она может быть выполнена синхронно в потоке, который выполняет операцию ожидания.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="a8cf9-151">Это увеличивает производительность благодаря избегнув дополнительный поток, а вместо этого использовать существующий поток, который может быть заблокирован в противном случае.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="a8cf9-152">Во избежание ошибок из-за повторного входа Встраивание задачи происходит только при обнаружении цели ожидания в локальной очереди соответствующего потока.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-152">To prevent errors due to reentrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="a8cf9-153">Указание контекста синхронизации</span><span class="sxs-lookup"><span data-stu-id="a8cf9-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="a8cf9-154">С помощью метода <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> можно указать, что задачу необходимо планировать для запуска в определенном потоке.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="a8cf9-155">Это полезно на платформах, например Windows Forms и Windows Presentation Foundation, где доступ к объектам пользовательского интерфейса часто ограничен кодом, выполняемым в том же потоке, в котором был создан этот объект пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="a8cf9-156">В следующем примере используется <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> метод в приложении Windows Presentation Foundation (WPF) для планирования задач в одном потоке, для элемента управления пользовательского интерфейса (UI) был создан.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="a8cf9-157">В примере создается mosaic образов, которые выбираются в случайном порядке из указанного каталога.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="a8cf9-158">Объекты WPF используются для загрузки и изменения размеров изображения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="a8cf9-159">Необработанные пиксели передаются задаче, которая использует <xref:System.Threading.Tasks.Parallel.For%2A> цикле для записи в большой массив однобайтовых данные о пикселях.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="a8cf9-160">Синхронизация не является обязательным, поскольку не две плитки занимают те же элементы массива.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="a8cf9-161">Плитки также могут записываться в любом порядке, так как их расположение рассчитывается независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="a8cf9-162">Большой массив передается в задачу, которая выполняется в потоке пользовательского интерфейса, где данные о пикселях загружается в элемент управления Image.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="a8cf9-163">Пример перемещает данные вне потока пользовательского интерфейса, его изменение с помощью параллельных циклов и <xref:System.Threading.Tasks.Task> объектов, а затем передает его обратно в задачу, которая выполняется в потоке пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="a8cf9-164">Этот подход полезен в тех случаях, когда необходимо использовать для выполнения операций, которые не поддерживаются WPF API, или работают недостаточно быстро библиотека параллельных задач.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="a8cf9-165">Другой способ создания мозаики из изображения в WPF является использование <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> управления и добавление изображений к нему.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="a8cf9-166"><xref:System.Windows.Controls.WrapPanel> Выполняет работу по расположению элементов мозаики.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="a8cf9-167">Тем не менее эта работа может выполняться только в потоке пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="a8cf9-168">Для создания примера, создайте проект приложения WPF в Visual Studio и назовите его WPF_CS1 (для C# проект WPF) или WPF_VB1 (для проекта WPF Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a8cf9-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="a8cf9-169">Затем сделайте следующее:</span><span class="sxs-lookup"><span data-stu-id="a8cf9-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="a8cf9-170">В режиме конструктора перетащите <xref:System.Windows.Controls.Image> управления из **элементов** в верхнем левом углу области конструктора.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="a8cf9-171">В **имя** текстовое поле **свойства** окна, имя элемента управления «изображение».</span><span class="sxs-lookup"><span data-stu-id="a8cf9-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="a8cf9-172">Перетащите <xref:System.Windows.Controls.Button> управления из **элементов** в левой нижней части окна приложения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="a8cf9-173">В представлении XAML, укажите <xref:System.Windows.Controls.ContentControl.Content%2A> свойства кнопки, как «Make мозаики» и укажите его <xref:System.Windows.FrameworkElement.Width> свойство как «100».</span><span class="sxs-lookup"><span data-stu-id="a8cf9-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="a8cf9-174">Подключение <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие с `button_Click` обработчик событий, определенных в коде этого примера, добавив `Click="button_Click"` для `<Button>` элемент.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="a8cf9-175">В **имя** текстовое поле **свойства** окна, имя элемента управления «кнопка».</span><span class="sxs-lookup"><span data-stu-id="a8cf9-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="a8cf9-176">Замените все содержимое в файл MainWindow.xaml.cs или MainWindow.xaml.vb код из этого примера.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="a8cf9-177">Для C# WPF проекта, убедитесь, что имя рабочей области, совпадает с именем проекта.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="a8cf9-178">В примере считываются JPEG-изображения из каталога с именем изображения C:\Users\Public\Pictures\Sample\\.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="a8cf9-179">Создайте каталог и поместите в него некоторые образы или изменить путь для ссылки на другой каталог, который содержит изображения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="a8cf9-180">В этом примере имеет некоторые ограничения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-180">This example has some limitations.</span></span> <span data-ttu-id="a8cf9-181">Например поддерживаются только 32-битами на пиксель образов; образы в других форматах, повреждены <xref:System.Windows.Media.Imaging.BitmapImage> объекта во время операции по изменению размера.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="a8cf9-182">Кроме того исходные изображения должны все быть больше, чем размер мозаики.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="a8cf9-183">В качестве дополнительного упражнения можно добавить функциональные возможности для обработки различных форматов пикселей и размер файла.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="a8cf9-184">Следующий пример взят из [примеры параллельного программирования в .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) на код коллекции веб-сайте MSDN.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="a8cf9-185">Он создает пользовательский планировщик задач ограничивает количество потоков, используемых приложением.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="a8cf9-186">Затем он запускает два набора задач и отображает сведения о задаче и поток, на котором выполняется задача.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="a8cf9-187">Кроме того некоторые планировщики задач образец доступны в коллекции кода: [Примеры параллельного программирования в .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="a8cf9-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="a8cf9-188">Все члены абстрактного <see cref="T:System.Threading.Tasks.TaskScheduler" /> типа являются потокобезопасными и могут быть использованы из нескольких потоков одновременно.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-189">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8cf9-190">Инициализирует объект <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-191">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8cf9-192">Получает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="a8cf9-193">Возвращает объект <see cref="T:System.Threading.Tasks.TaskScheduler" />, связанный с выполняемой в настоящий момент задачей.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-194">Если не вызвать из задачи, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> вернет <xref:System.Threading.Tasks.TaskScheduler.Default%2A> планировщика.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="a8cf9-195">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-196">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8cf9-197">Получает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию, предоставляемый платформой .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="a8cf9-198">Возвращает экземпляр <see cref="T:System.Threading.Tasks.TaskScheduler" /> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-199">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-200">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8cf9-201">Освобождает все ресурсы, связанные с данным планировщиком.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8cf9-202">Создает <see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="a8cf9-203"><see cref="T:System.Threading.Tasks.TaskScheduler" /> для связывания с текущим элементом <see cref="T:System.Threading.SynchronizationContext" />, как определено в <see cref="P:System.Threading.SynchronizationContext.Current" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-204">Все <xref:System.Threading.Tasks.Task> экземпляров, к возвращенному поставлены в очередь планировщика выполняется посредством вызова <xref:System.Threading.SynchronizationContext.Post%2A> метод в этом контексте.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="a8cf9-205">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8cf9-206">Текущий SynchronizationContext нельзя использовать как TaskScheduler.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-207">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a8cf9-208">Создает перечисляемый объект экземпляров <see cref="T:System.Threading.Tasks.Task" />, которые в настоящее время находятся в очереди планировщика, ожидая выполнения (только для поддержки отладки).</span><span class="sxs-lookup"><span data-stu-id="a8cf9-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="a8cf9-209">Перечисляемый объект, позволяющий отладчику перемещаться по задачам, которые находятся в очереди данного планировщика.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-210">Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует этот метод для поддержки интеграции с отладчики.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="a8cf9-211">Этот метод будет вызван только платформой .NET Framework, когда отладчик запрашивает доступ к данным.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="a8cf9-212">Возвращенное перечислимое значение будет обращаться по отладке служебных программ для доступа к задачам в настоящее время в очереди данного планировщика, что позволит отладчику для представления этих сведений в пользовательском интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="a8cf9-213">Важно отметить, что при вызове этого метода все потоки в процессе, будут зафиксированы.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="a8cf9-214">Таким образом важно избегать синхронизации с другими потоками, которые могут привести к блокировке.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="a8cf9-215">Если синхронизация необходима, и вы не сможете получить блокировку в этом методе, должен создавать исключение, чтобы отладчик не приводит к блокировке.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not block.</span></span> <span data-ttu-id="a8cf9-216">В примере показан один из возможных способов в C#:</span><span class="sxs-lookup"><span data-stu-id="a8cf9-216">The following example shows one possible approach in C#:</span></span>
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="a8cf9-217">Кроме того этот метод и возвращаемое перечислимое значение не следует изменять любое состояние видимый глобально.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="a8cf9-218">Возвращаемый перечисляемый никогда не должен иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="a8cf9-219">Если в настоящий момент нет задач в очереди, должны возвращаться пустое перечисление.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="a8cf9-220">Разработчики, при реализации пользовательских отладчиков не следует вызывать этот метод напрямую, но следует использовать метод внутренней программы-оболочки `GetScheduledTasksForDebugger` вместо: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="a8cf9-221">Этот метод оболочки возвращает массив задач вместо перечислимый объект.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="a8cf9-222">Чтобы получить список активным планировщикам, используйте внутренний метод `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="a8cf9-223">Этот статический метод возвращает массив всех активных <xref:System.Threading.Tasks.TaskScheduler> экземпляров.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="a8cf9-224">Затем можно использовать `GetScheduledTasksForDebugger` на каждый экземпляр планировщика, чтобы получить его список запланированных заданий.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a8cf9-225">Этому планировщику не удается создать список находящихся в данный момент в очереди задач.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-226">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8cf9-227">Получает уникальный идентификатор данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="a8cf9-228">Возвращает уникальный идентификатор для данного объекта <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-229">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-230">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8cf9-231">Указывает максимальный уровень параллелизма, который может поддерживаться данным планировщиком <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="a8cf9-232">Возвращает целое число, представляющее максимальный уровень параллелизма.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="a8cf9-233">Планировщик по умолчанию возвращает значение свойства <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-234">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-235">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="a8cf9-236">Помещаемый в очередь объект <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="a8cf9-237">Ставит объект <see cref="T:System.Threading.Tasks.Task" /> в очередь планировщика.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-238">Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует этот метод для принятия задачи, выполнение которого запланировано на планировщик.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="a8cf9-239">Типичная реализация должна сохранить задачу в внутреннюю структуру данных, который будет обслуживаться потоков, которые будут выполнять эти задачи в некоторый момент в будущем.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="a8cf9-240">Этот метод предназначен только для вызывается платформой .NET Framework и не должен вызываться непосредственно производным классом.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="a8cf9-241">Это необходимо для поддержания целостности системы.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8cf9-242">Аргумент <paramref name="task" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-243">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="a8cf9-244">Объект <see cref="T:System.Threading.Tasks.Task" /> для удаления из очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="a8cf9-245">Пытается удалить из очереди задачу <see cref="T:System.Threading.Tasks.Task" />, ранее поставленную в очередь данного планировщика.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="a8cf9-246">Логическое значение, указывающее, был ли аргумент <paramref name="task" /> успешно удален из очереди.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-247">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="a8cf9-248">Этот метод может выполняться в блоке finally; Поэтому он должен вернуть как можно быстрее таким образом, любые ресурсы, такие как <xref:System.Threading.CancellationTokenRegistration> объекты могут быть уничтожены своевременно.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8cf9-249">Аргумент <paramref name="task" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-250">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="a8cf9-251">Выполняемая задача <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="a8cf9-252">Пытается выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом планировщике.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="a8cf9-253">Логическое значение true, если задача <paramref name="task" /> успешно выполнена; в противном случае — значение false.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="a8cf9-254">Общая причина ошибки выполнения состоит в том, что задача выполнялась ранее или выполняется другим потоком.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-255">Входящие в состав реализаций планировщика <xref:System.Threading.Tasks.Task> экземпляров для выполнения с помощью либо <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> метод или <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="a8cf9-256">Когда планировщик считает, что он имеет смысл запустить предоставленной задачи <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> следует использовать для этого.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="a8cf9-257">TryExecuteTask обрабатывает все аспекты выполнения задач, включая вызов действия, обработку исключений, управление состоянием и управления жизненным циклом.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="a8cf9-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> должен использоваться только для задачи, используя платформу .NET Framework данного планировщика.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="a8cf9-259">Он не должен использоваться для выполнения произвольных задач, полученных через пользовательские механизмы.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8cf9-260"><paramref name="task" /> не связана с данным планировщиком.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-261">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="a8cf9-262">Выполняемый объект <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="a8cf9-263">Логическое значение, указывающее, была ли задача ранее поставлена в очередь.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="a8cf9-264">Если этот параметр имеет значение True, задача могла ранее быть в очереди; если он имеет значение False, задача не была поставлена в очередь, а данный вызов совершается для выполнения задачи на месте без постановки в очередь.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="a8cf9-265">Определяет, можно ли выполнить предоставленную задачу <see cref="T:System.Threading.Tasks.Task" /> в этом вызове синхронно, и если возможно, выполняет ее.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="a8cf9-266">Логическое значение, определяющее, была ли задача выполнена на месте.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-267">Класс, производный от <xref:System.Threading.Tasks.TaskScheduler> реализует эту функцию для поддержки встроенного выполнения задачи в потоке, который инициирует ожидания для этого объекта задачи.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="a8cf9-268">Встроенного выполнения является необязательным, и запрос может быть отклонен, вернув значение false.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="a8cf9-269">Тем не менее, дополнительные задачи, можно выполнять как встроенный, тем лучше планировщик.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="a8cf9-270">На самом деле планировщик, встраивает слишком мало может быть вероятность возникновения взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="a8cf9-271">Правильная реализация следует убедиться, что запроса, выполняющегося в политиках, обеспечиваемых планировщик может успешно встроенный.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="a8cf9-272">Например если планировщик использует выделенный поток для выполнения задач, любые запросы встраивания из этого потока должны завершиться успешно.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="a8cf9-273">Если для выполнения встроенной решает планировщика, это следует сделать, вызвав метод базового TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> метод объект предоставленной задачи, передавать трафик транзитом через возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="a8cf9-274">Также возможно для планировщика отменить задачу как встроенный свои структуры внутренних данных, если она решает удовлетворять этот запрос встраивания.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="a8cf9-275">Обратите внимание, что в некоторых случаях планировщик может появиться запрос на встроенный задачу, которая ранее не был предоставлен к нему с помощью <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="a8cf9-276">Производный Планировщик отвечает за убедившись, что вызывающий поток подходит для выполнения данной задачи собственное расписание и точки зрения политики выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="a8cf9-277">Дополнительные сведения см. в разделе <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a8cf9-278">Аргумент <paramref name="task" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a8cf9-279"><paramref name="task" /> уже выполнена.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-280">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a8cf9-281">Создается при активации политики эскалации исключений из-за непредвиденного исключения задачи, завершившейся сбоем. По умолчанию из-за этой политики процесс будет прерван.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a8cf9-282">Это событие уровня домена приложения предоставляет механизм для предотвращения политику эскалации исключений (которая по умолчанию прерывает процесс) из активируемых.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="a8cf9-283">Чтобы облегчить разработчикам писать асинхронный код, основанный на задачах, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] изменяет поведение по умолчанию исключения для исключений без наблюдения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="a8cf9-284">Несмотря на то, что незамеченные исключения по-прежнему вызывать <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> исключение, процесс не завершает работу по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="a8cf9-285">Вместо этого исключение после события, независимо от того, обнаруживает ли обработчик событий, исключение обрабатывается средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="a8cf9-286">Это поведение можно настроить.</span><span class="sxs-lookup"><span data-stu-id="a8cf9-286">This behavior can be configured.</span></span> <span data-ttu-id="a8cf9-287">Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], можно использовать [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) элемент конфигурации, чтобы вернуться к поведению [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] и завершить процесс:</span><span class="sxs-lookup"><span data-stu-id="a8cf9-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="a8cf9-288">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="a8cf9-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md"><span data-ttu-id="a8cf9-289">&lt;ThrowUnobservedTaskExceptions&gt; элемент</span><span class="sxs-lookup"><span data-stu-id="a8cf9-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>