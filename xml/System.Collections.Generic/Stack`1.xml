<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="472148ca2dba95c20c7a22169fb84ecb2843df8f" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75151488" /></Metadata><TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Задает тип элементов в стеке.</typeparam>
    <summary>Представляет коллекцию переменного размера экземпляров одинакового заданного типа, обслуживаемую по принципу "последним пришел - первым вышел" (LIFO).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> реализуется как массив.  
  
 Стеки и очереди полезны, если для получения сведений требуется временное хранилище. то есть, когда может потребоваться отменить элемент после получения его значения. Используйте <xref:System.Collections.Generic.Queue%601>, если необходимо получить доступ к данным в том же порядке, в котором они хранятся в коллекции. Используйте <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>, если необходимо получить доступ к данным в обратных последовательностях.  
  
 Используйте типы <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> и <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>, если требуется одновременный доступ к коллекции из нескольких потоков.  
  
 Чаще всего <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> используется для сохранения состояния переменных во время вызовов других процедур.  
  
 В <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> и его элементах можно выполнять три основные операции:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> вставляет элемент в верхнюю часть <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> удаляет элемент из верхней части <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Возвращает элемент, расположенный в верхней части <xref:System.Collections.Generic.Stack%601> но не удаляет его из <xref:System.Collections.Generic.Stack%601>.  
  
 Емкость <xref:System.Collections.Generic.Stack%601> — число элементов, которые может содержать <xref:System.Collections.Generic.Stack%601>. При добавлении элементов в <xref:System.Collections.Generic.Stack%601>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива. Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Если <xref:System.Collections.Generic.Stack%601.Count%2A> меньше емкости стека, <xref:System.Collections.Generic.Stack%601.Push%2A> является операцией O (1). Если емкость необходимо увеличить для размещения нового элемента, <xref:System.Collections.Generic.Stack%601.Push%2A> становится операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> является операцией O (1).  
  
 <xref:System.Collections.Generic.Stack%601> принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>. В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
<see cref="T:System.Collections.Generic.Stack`1" /> может поддерживать одновременно несколько модулей чтения, если коллекция не изменяется.  Даже поэтому перечисление по коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Итераторы (C# и Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.Stack`1" />, который является пустым и имеет начальную емкость по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.Stack%601> — это количество элементов, которые может содержать <xref:System.Collections.Generic.Stack%601>. При добавлении элементов в <xref:System.Collections.Generic.Stack%601>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов в <xref:System.Collections.Generic.Stack%601>.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Этот конструктор является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется этот конструктор и несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Коллекция, из которой требуется скопировать элементы.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Collections.Generic.Stack`1" />, который содержит элементы, скопированные из указанной коллекции, и имеет емкость, достаточную для размещения всех скопированных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.Stack%601> — это количество элементов, которые может содержать <xref:System.Collections.Generic.Stack%601>. При добавлении элементов в <xref:System.Collections.Generic.Stack%601>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов в <xref:System.Collections.Generic.Stack%601>.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Элементы копируются на <xref:System.Collections.Generic.Stack%601> в том же порядке, в котором они считываются <xref:System.Collections.Generic.IEnumerator%601> коллекции.  
  
 Этот конструктор является операцией O (`n`), где `n` — число элементов в `collection`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется этот конструктор и несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Начальное количество элементов, которое может содержать коллекция <see cref="T:System.Collections.Generic.Stack`1" />.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Collections.Generic.Stack`1" />, который является пустым и обладает указанной начальной емкостью или емкостью по умолчанию, в зависимости от того, какое значение больше.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.Stack%601> — это количество элементов, которые может содержать <xref:System.Collections.Generic.Stack%601>. При добавлении элементов в <xref:System.Collections.Generic.Stack%601>емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов в <xref:System.Collections.Generic.Stack%601>.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Этот конструктор является операцией O (`n`), где `n` `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все объекты из <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> имеет значение 0, а ссылки на другие объекты из элементов коллекции также освобождаются.  
  
 Емкость остается неизменной. Чтобы сбросить емкость <xref:System.Collections.Generic.Stack%601>, вызовите <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Удаление пустой <xref:System.Collections.Generic.Stack%601> задает емкость объекта <xref:System.Collections.Generic.Stack%601> емкость по умолчанию.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.Clear%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.Stack`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.Generic.Stack`1" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство, используя <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> компаратора проверки на равенство по умолчанию для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.Contains%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.Stack`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <summary>Копирует элементы класса <see cref="T:System.Collections.Generic.Stack`1" /> в существующий одномерный массив класса <see cref="T:System.Array" />, начиная с указанного индекса массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются в массив в порядке «последним поверх-первым обслужен» (ЛИФО), аналогично порядку элементов, возвращенных при последующей попытке вызова <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Число элементов в исходной коллекции <see cref="T:System.Collections.Generic.Stack`1" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.Stack%601> — количество элементов, которые может хранить <xref:System.Collections.Generic.Stack%601>. <xref:System.Collections.Generic.Stack%601.Count%2A> — количество элементов, которые фактически находятся в <xref:System.Collections.Generic.Stack%601>.  
  
 Емкость всегда больше или равна <xref:System.Collections.Generic.Stack%601.Count%2A>. Если <xref:System.Collections.Generic.Stack%601.Count%2A> превышает емкость при добавлении элементов, емкость увеличивается путем автоматического перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано несколько свойств и методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая свойство <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель для коллекции <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Интерфейс <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> для <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор `foreach` C# языка (`for each` в C++`For Each` в Visual Basic) скрывает сложность перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции значение свойства <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> задает <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> передает конец коллекции, перечислитель размещается после последнего элемента в коллекции и <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> также возвращают `false`. Если последний вызов <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> вернул `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> не определено. Значение свойства <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> или <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Реализации по умолчанию коллекций в <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано, что <xref:System.Collections.Generic.Stack%601> универсальный класс является перечислимым. Для перечисления очереди используется инструкция `foreach` (`For Each` в Visual Basic C++, `for each` в).  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект, находящийся в начале <see cref="T:System.Collections.Generic.Stack`1" />, без его удаления.</summary>
        <returns>Объект, находящийся в начале <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод аналогичен методу <xref:System.Collections.Generic.Stack%601.Pop%2A>, однако метод <xref:System.Collections.Generic.Stack%601.Peek%2A> не вносит изменения в очередь <xref:System.Collections.Generic.Stack%601>.  
  
 Если тип `T` является ссылочным типом, `null` может быть помещен в <xref:System.Collections.Generic.Stack%601> в качестве заполнителя, если это необходимо.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.Peek%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь <see cref="T:System.Collections.Generic.Stack`1" /> является пустой.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет и возвращает объект, находящийся в начале <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Объект, удаляемый из начала <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод аналогичен методу <xref:System.Collections.Generic.Stack%601.Peek%2A>, однако метод <xref:System.Collections.Generic.Stack%601.Peek%2A> не вносит изменения в очередь <xref:System.Collections.Generic.Stack%601>.  
  
 Если тип `T` является ссылочным типом, `null` может быть помещен в <xref:System.Collections.Generic.Stack%601> в качестве заполнителя, если это необходимо.  
  
 <xref:System.Collections.Generic.Stack%601> реализуется как массив. Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь <see cref="T:System.Collections.Generic.Stack`1" /> является пустой.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.Stack`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Вставляет объект как верхний элемент стека <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> реализуется как массив.  
  
 Если <xref:System.Collections.Generic.Stack%601.Count%2A> уже равен емкости, емкость <xref:System.Collections.Generic.Stack%601> увеличивается путем автоматического перераспределения внутреннего массива, а существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 Если тип `T` является ссылочным типом, `null` может быть помещен в <xref:System.Collections.Generic.Stack%601> в качестве заполнителя, если это необходимо. Он занимает ячейку в стеке и обрабатывается как любой объект.  
  
 Если <xref:System.Collections.Generic.Stack%601.Count%2A> меньше емкости стека, <xref:System.Collections.Generic.Stack%601.Push%2A> является операцией O (1). Если емкость необходимо увеличить для размещения нового элемента, <xref:System.Collections.Generic.Stack%601.Push%2A> становится операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.Push%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.Generic.IEnumerator`1" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор `foreach` C# языка (`for each` в C++`For Each` в Visual Basic) скрывает сложность перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции значение свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.Generic.IEnumerator%601.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель размещается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают `false`. Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> вернул `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не определено. Значение свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Реализации по умолчанию коллекций в <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.ICollection" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <summary>Копирует элементы коллекции <see cref="T:System.Collections.ICollection" /> в массив <see cref="T:System.Array" />, начиная с указанного индекса массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если тип источника <xref:System.Collections.ICollection> не может быть автоматически приведен к типу `array`назначения, неуниверсальные реализации <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> вызывают <xref:System.InvalidCastException>, тогда как универсальные реализации создают <xref:System.ArgumentException>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
-или- 
 В массиве <paramref name="array" /> не используется индексация, начинающаяся с нуля.  
  
-или- 
Число элементов в исходном массиве <see cref="T:System.Collections.ICollection" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.  
  
-или- 
Тип исходного массива <see cref="T:System.Collections.ICollection" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Collections.ICollection" /> синхронизированным (потокобезопасным).</summary>
        <value><see langword="true" />, если доступ к классу <see cref="T:System.Collections.ICollection" /> является синхронизированным (потокобезопасным); в противном случае — <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.Stack`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации по умолчанию коллекций в <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  В редких случаях, когда перечисления конкурируют за доступ на запись, необходимо заблокировать коллекцию во время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> возвращает объект, который можно использовать для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация вступает в силу только в том случае, если все потоки блокируют этот объект перед доступом к коллекции.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Collections.ICollection" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.Stack`1" /> это свойство всегда возвращает текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации по умолчанию коллекций в <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> возвращает объект, который можно использовать для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация вступает в силу только в том случае, если все потоки блокируют этот объект перед доступом к коллекции. В следующем коде показано использование свойства <xref:System.Collections.ICollection.SyncRoot%2A> для C#, C++и Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, который осуществляет итерацию по коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор `foreach` C# языка (`for each` в C++`For Each` в Visual Basic) скрывает сложность перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции значение свойства <xref:System.Collections.IEnumerator.Current%2A> не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A>, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> возвращает тот же объект, пока не будет вызван метод <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель размещается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают `false`. Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> вернул `false`, <xref:System.Collections.IEnumerator.Current%2A> не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, например добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Реализации по умолчанию коллекций в <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует <see cref="T:System.Collections.Generic.Stack`1" /> в новый массив.</summary>
        <returns>Новый массив, содержащий копии элементов <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются в массив в порядке «последним поверх-первым обслужен» (ЛИФО), аналогично порядку элементов, возвращенных при последующей попытке вызова <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано несколько методов универсального класса <xref:System.Collections.Generic.Stack%601>, включая метод <xref:System.Collections.Generic.Stack%601.ToArray%2A>.  
  
 В примере кода создается стек строк с емкостью по умолчанию и используется метод <xref:System.Collections.Generic.Stack%601.Push%2A> для отправки пяти строк в стек. Элементы стека перечисляются, что не приводит к изменению состояния стека. Метод <xref:System.Collections.Generic.Stack%601.Pop%2A> используется для POP первой строки из стека. Метод <xref:System.Collections.Generic.Stack%601.Peek%2A> используется для просмотра следующего элемента в стеке, а затем для его открытия используется метод <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Метод <xref:System.Collections.Generic.Stack%601.ToArray%2A> используется для создания массива и копирования в него элементов стека, а затем массив передается конструктору <xref:System.Collections.Generic.Stack%601.%23ctor%2A>, который принимает <xref:System.Collections.Generic.IEnumerable%601>, создавая копию стека с порядком элементов в обратную. Отобразятся элементы копии.  
  
 Массив в два раза создается размер стека, а метод <xref:System.Collections.Generic.Stack%601.CopyTo%2A> используется для копирования элементов массива, начиная с середины массива. Конструктор <xref:System.Collections.Generic.Stack%601.%23ctor%2A> снова используется для создания копии стека с порядком элементов в обратном порядке. Поэтому три элемента null находятся в конце.  
  
 Метод <xref:System.Collections.Generic.Stack%601.Contains%2A> позволяет показать, что строка «четыре» находится в первой копии стека, после чего метод <xref:System.Collections.Generic.Stack%601.Clear%2A> очищает копию, а свойство <xref:System.Collections.Generic.Stack%601.Count%2A> показывает, что стек пуст.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает емкость равной фактическому количеству элементов в <see cref="T:System.Collections.Generic.Stack`1" />, если это количество составляет менее 90 процентов текущей емкости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для снижения нагрузки на память коллекции, если в коллекцию не добавляются новые элементы. Однако стоимость повторного выделения и копирования больших <xref:System.Collections.Generic.Stack%601> может быть значительной, поэтому метод <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> не выполняет никаких действий, если список имеет более 90 процентов емкости. Это позволяет избежать больших затрат на повторное распределение для относительно небольшого выигрыша.  
  
 Этот метод является операцией O (`n`), где `n` <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Чтобы сбросить <xref:System.Collections.Generic.Stack%601> до начального состояния, вызовите метод <xref:System.Collections.Generic.Stack%601.Clear%2A> перед вызовом метода <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Удаление пустой <xref:System.Collections.Generic.Stack%601> задает емкость объекта <xref:System.Collections.Generic.Stack%601> емкость по умолчанию.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek : 'T -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop : 'T -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
