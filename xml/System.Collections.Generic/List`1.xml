<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a7f0f273a278f342094cd7219e6187d9518950fb" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68901948" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Тип элементов в списке.</typeparam>
    <summary>Представляет строго типизированный список объектов, доступных по индексу. Поддерживает методы для поиска по списку, выполнения сортировки и других операций со списками.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс является универсальным эквивалентом <xref:System.Collections.ArrayList>класса. <xref:System.Collections.Generic.List%601> Он реализует <xref:System.Collections.Generic.IList%601> универсальный интерфейс с помощью массива, размер которого динамически увеличивается по мере необходимости.  
  
 Элементы можно добавлять в <xref:System.Collections.Generic.List%601> с <xref:System.Collections.Generic.List%601.Add%2A> помощью методов или <xref:System.Collections.Generic.List%601.AddRange%2A> .  
  
 <xref:System.Collections.Generic.List%601> Класс использует и компаратор равенства, и компаратор упорядочения.  
  
-   Такие методы, <xref:System.Collections.Generic.List%601.Contains%2A>как <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, и <xref:System.Collections.Generic.Dictionary%602.Remove%2A> , используют компаратор проверки на равенство для элементов списка. Компаратор проверки на равенство по умолчанию для типа `T` определяется следующим образом. Если тип `T` <xref:System.IEquatable%601.Equals%28%600%29> реализует универсальный интерфейс, компаратор проверки на равенство является методом этого интерфейса; в противном случае компаратор по умолчанию имеет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>значение. <xref:System.IEquatable%601>  
  
-   Методы, такие <xref:System.Collections.Generic.List%601.BinarySearch%2A> как <xref:System.Collections.Generic.List%601.Sort%2A> и, используют компаратор упорядочения для элементов списка. Компаратор по умолчанию для типа `T` определяется следующим образом.  Если тип `T` <xref:System.IComparable%601.CompareTo%28%600%29> `T` <xref:System.IComparable> реализует универсальный интерфейс, то компаратором по умолчанию является метод этого интерфейса; в противном случае, если тип реализует неуниверсальный интерфейс, по умолчанию используется <xref:System.IComparable%601> компаратор — это <xref:System.IComparable.CompareTo%28System.Object%29> метод этого интерфейса. Если тип `T` не реализует ни интерфейс, то компаратор по умолчанию отсутствует, а компаратор или делегат сравнения необходимо предоставить явным образом.  
  
 Сортировка <xref:System.Collections.Generic.List%601> не гарантируется.  Необходимо отсортировать <xref:System.Collections.Generic.List%601> перед выполнением операций ( <xref:System.Collections.Generic.List%601.BinarySearch%2A>например,), <xref:System.Collections.Generic.List%601> для которых требуется сортировка.  
  
 Доступ к элементам в этой коллекции можно получить с помощью целочисленного индекса.  Индексы в этой коллекции отсчитываются от нуля.  
  
 **Только .NET Framework:** Для очень больших <xref:System.Collections.Generic.List%601> объектов можно увеличить максимальную емкость до 2 000 000 000 элементов в 64-разрядной системе, `enabled` задав атрибут [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) элемента `true` конфигурации в среде выполнения.  
  
 <xref:System.Collections.Generic.List%601>принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
 Сведения о неизменяемой версии <xref:System.Collections.Generic.List%601> класса см. в разделе. <xref:System.Collections.Immutable.ImmutableList%601>  
  
## <a name="performance-considerations"></a>Особенности производительности  
 При принятии решения о том, следует <xref:System.Collections.Generic.List%601> ли <xref:System.Collections.ArrayList> использовать класс или, оба из которых имеют похожие <xref:System.Collections.Generic.List%601> функции, помните, что класс работает лучше в большинстве случаев и является типобезопасным. Если для типа `T` <xref:System.Collections.Generic.List%601> класса используется ссылочный тип, поведение двух классов идентично. Однако если для типа `T`используется тип значения, необходимо рассмотреть проблемы с реализацией и упаковкой.  
  
 Если для типа `T`используется тип значения, компилятор создает реализацию <xref:System.Collections.Generic.List%601> класса специально для этого типа значения. Это означает, что элемент <xref:System.Collections.Generic.List%601> списка объекта не обязательно должен быть упакован перед тем, как можно будет использовать элемент, и 500 после создания элементов списка, сохраненных в памяти, не превышающих размер памяти, используемой для создания реализации класса.  
  
 Убедитесь, что тип значения, используемый для `T` типа, <xref:System.IEquatable%601> реализует универсальный интерфейс. В противном случае методы, <xref:System.Collections.Generic.List%601.Contains%2A> такие как, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> должны вызывать метод, который является затронутым элементом списка. Если <xref:System.IComparable> тип значения реализует интерфейс и вы владеете исходным кодом, также <xref:System.IComparable%601> реализуйте <xref:System.Collections.Generic.List%601.BinarySearch%2A> универсальный интерфейс, чтобы предотвратить методы и <xref:System.Collections.Generic.List%601.Sort%2A> из элементов списка упаковки. Если вы не владеете исходным кодом, передайте <xref:System.Collections.Generic.IComparer%601> объект <xref:System.Collections.Generic.List%601.BinarySearch%2A> методам и <xref:System.Collections.Generic.List%601.Sort%2A>  
  
 Для этого лучше использовать реализацию <xref:System.Collections.Generic.List%601> класса, зависящую от типа, а не <xref:System.Collections.ArrayList> использовать класс или писать строго типизированную коллекцию оболочек самостоятельно. Причина в том, что ваша реализация должна сделать то, что .NET Framework делает, а общеязыковая среда выполнения может совместно использовать код промежуточного языка Майкрософт и метаданные, которые ваша реализация не может.  
  
## <a name="f-considerations"></a>F#Следует  
 Класс часто используется в F# коде. <xref:System.Collections.Generic.List%601> Вместо этого, как правило, предпочтительно использовать [списки](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), которые являются неизменяемыми однонаправленными списками. F# Список содержит упорядоченную, неизменяемую последовательность значений и поддерживается для использования в функциональной разработке. При использовании из F# <xref:System.Collections.Generic.List%601> класс, как правило, называется сокращением типа [ресизеаррай\<>](https://msdn.microsoft.com/library/ee353447.aspx) , чтобы избежать конфликтов имен с F# списками  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как добавить, удалить и вставить простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере демонстрируется несколько свойств и методов <xref:System.Collections.Generic.List%601> универсального класса типа String. (Пример <xref:System.Collections.Generic.List%601> составного типа см. в <xref:System.Collections.Generic.List%601.Contains%2A> описании метода.)  
  
 Конструктор без параметров используется для создания списка строк с емкостью по умолчанию. Свойство отображается, а <xref:System.Collections.Generic.List%601.Add%2A> затем метод используется для добавления нескольких элементов. <xref:System.Collections.Generic.List%601.Capacity%2A> Элементы перечисляются, и <xref:System.Collections.Generic.List%601.Capacity%2A> свойство отображается снова вместе <xref:System.Collections.Generic.List%601.Count%2A> со свойством, чтобы показать, что емкость увеличилась по мере необходимости.  
  
 Метод используется для проверки наличия элемента в списке <xref:System.Collections.Generic.List%601.Insert%2A> , метод используется для вставки нового элемента в середину списка, и содержимое списка снова выводится. <xref:System.Collections.Generic.List%601.Contains%2A>  
  
 Свойство по <xref:System.Collections.Generic.List%601.Item%2A> умолчанию (индексатор в C#) используется для получения элемента, <xref:System.Collections.Generic.List%601.Remove%2A> метод используется для удаления первого экземпляра повторяющегося элемента, добавленного ранее, и содержимое отображается снова. <xref:System.Collections.Generic.List%601.Remove%2A> Метод всегда удаляет первый обнаруженный экземпляр.  
  
 Метод используется для уменьшения емкости в соответствии с количеством, <xref:System.Collections.Generic.List%601.Capacity%2A> и отображаются свойства и <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.TrimExcess%2A> Если неиспользуемая емкость была меньше 10% от общей емкости, размер списка не изменится.  
  
 Наконец, <xref:System.Collections.Generic.List%601.Clear%2A> метод используется для удаления всех элементов из списка, <xref:System.Collections.Generic.List%601.Capacity%2A> и отображаются свойства и <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
В можно выполнять несколько операций <see cref="T:System.Collections.Generic.List`1" />чтения, но при изменении коллекции во время ее чтения могут возникать проблемы. Чтобы обеспечить безопасность потоков, заблокируйте коллекцию во время операции чтения или записи. Чтобы обеспечить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию. Сведения о коллекциях со встроенной синхронизацией см. в разделе <see cref="N:System.Collections.Concurrent" /> классы в пространстве имен. Дополнительные сведения о поточно-ориентированной альтернативе см <see cref="T:System.Collections.Immutable.ImmutableList`1" /> . в разделе класс.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Итераторы (C# и Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.List`1" />, который является пустым и имеет начальную емкость по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.List%601> — это количество элементов, которые может содержать объект <xref:System.Collections.Generic.List%601> . Когда элементы добавляются в <xref:System.Collections.Generic.List%601>, емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, использование <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> конструктора и указание начальной емкости избавляет от необходимости выполнять ряд операций изменения размера при добавлении элементов <xref:System.Collections.Generic.List%601>в.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод или явно <xref:System.Collections.Generic.List%601.Capacity%2A> задав свойство. Уменьшение емкости приводит к повторному распределению памяти и копированию всех элементов в <xref:System.Collections.Generic.List%601>.  
  
 Этот конструктор является операцией O (1).  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показан конструктор <xref:System.Collections.Generic.List%601> без параметров универсального класса. Конструктор без параметров создает список с емкостью по умолчанию, как показано при отображении <xref:System.Collections.Generic.List%601.Capacity%2A> свойства.  
  
 В этом примере добавляются, вставляются и удаляются элементы, показывающие, как изменяется емкость при использовании этих методов.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Коллекция, элементы которой копируются в новый список.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Collections.Generic.List`1" />, который содержит элементы, скопированные из указанной коллекции, и имеет емкость, достаточную для размещения всех скопированных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются <xref:System.Collections.Generic.List%601> в в в том же порядке, в котором они считываются перечислителем коллекции.  
  
 Этот конструктор является операцией O (*n*), где *n* — число элементов в `collection`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.%23ctor%2A> конструктор и различные методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. Массив строк создается и передается в конструктор, заполняя список элементами массива. Затем <xref:System.Collections.Generic.List%601.Capacity%2A> отображается свойство, чтобы показать, что начальная емкость — именно то, что требуется для хранения входных элементов.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Число элементов, которые может изначально вместить новый список.</param>
        <summary>Инициализирует новый пустой экземпляр класса <see cref="T:System.Collections.Generic.List`1" /> с указанной начальной емкостью.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.List%601> — это количество элементов, которые может содержать объект <xref:System.Collections.Generic.List%601> . Когда элементы добавляются в <xref:System.Collections.Generic.List%601>, емкость автоматически увеличивается по мере необходимости путем перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, указание начальной емкости избавляет от необходимости выполнять несколько операций изменения размера при добавлении элементов <xref:System.Collections.Generic.List%601>в.  
  
 Емкость можно уменьшить, вызвав <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод или явно <xref:System.Collections.Generic.List%601.Capacity%2A> задав свойство. Уменьшение емкости приводит к повторному распределению памяти и копированию всех элементов в <xref:System.Collections.Generic.List%601>.  
  
 Этот конструктор является операцией O (*n*), где *n* — `capacity`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> конструктор. <xref:System.Collections.Generic.List%601> Создается строка с емкостью 4, так как максимальный размер списка должен быть ровно 4. Список заполняется четырьмя строками, а копия, доступная только для чтения, создается с помощью <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метода.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект, добавляемый в конец коллекции <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Добавляет объект в конец очереди <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
 Если <xref:System.Collections.Generic.List%601.Count%2A> значение уже <xref:System.Collections.Generic.List%601.Capacity%2A> равно<xref:System.Collections.Generic.List%601> , емкость увеличивается путем автоматического перераспределения внутреннего массива, а существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 <xref:System.Collections.Generic.List%601.Count%2A> Если<xref:System.Collections.Generic.List%601.Capacity%2A>меньше, этот метод является операцией O (1). Если емкость необходимо увеличить для размещения нового элемента, этот метод становится операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как добавить, удалить и вставить простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере показано несколько свойств и методов <xref:System.Collections.Generic.List%601> универсального класса, <xref:System.Collections.Generic.List%601.Add%2A> включая метод. Конструктор без параметров используется для создания списка строк с емкостью 0. Свойство отображается, а <xref:System.Collections.Generic.List%601.Add%2A> затем метод используется для добавления нескольких элементов. <xref:System.Collections.Generic.List%601.Capacity%2A> Элементы перечисляются, и <xref:System.Collections.Generic.List%601.Capacity%2A> свойство отображается снова вместе <xref:System.Collections.Generic.List%601.Count%2A> со свойством, чтобы показать, что емкость увеличилась по мере необходимости.  
  
 Другие свойства и методы используются для поиска, вставки и удаления элементов из списка и, наконец, для очистки списка.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Коллекция, элементы которой добавляются в конец списка <see cref="T:System.Collections.Generic.List`1" />. Коллекция не может быть задана значением <see langword="null" />, но может содержать элементы <see langword="null" />, если тип <paramref name="T" /> является ссылочным типом.</param>
        <summary>Добавляет элементы указанной коллекции в конец списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок элементов в коллекции сохраняется в <xref:System.Collections.Generic.List%601>.  
  
 Если новый <xref:System.Collections.Generic.List%601.Count%2A> (текущий <xref:System.Collections.Generic.List%601.Count%2A> плюс размер коллекции <xref:System.Collections.Generic.List%601.Capacity%2A>) будет больше, емкость <xref:System.Collections.Generic.List%601> увеличивается путем автоматического перераспределения внутреннего массива для размещения новых элементов, а элемент существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если объект <xref:System.Collections.Generic.List%601> может разместить новые элементы <xref:System.Collections.Generic.List%601.Capacity%2A>без увеличения, этот метод является операцией O (*n*), где *n* — число добавляемых элементов. Если емкость необходимо увеличить для размещения новых элементов, этот метод становится операцией O (*n* + *m*), где *n* — число добавляемых элементов, а *m* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.AddRange%2A> метод и различные методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. Массив строк создается и передается в конструктор, заполняя список элементами массива. <xref:System.Collections.Generic.List%601.AddRange%2A> Метод вызывается со списком в качестве аргумента. В результате текущие элементы списка добавляются в конец списка, что приводит к дублированию всех элементов.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает для текущей коллекции оболочку <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, доступную только для чтения.</summary>
        <returns>Объект, который служит оболочкой, обеспечивающей доступность текущего списка <see cref="T:System.Collections.Generic.List`1" /> только для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить внесение изменений в <xref:System.Collections.Generic.List%601> объект, предоставляйте его только через эту оболочку. <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> Объект не предоставляет методы, изменяющие коллекцию. Однако при внесении изменений в базовый <xref:System.Collections.Generic.List%601> объект коллекция, доступная только для чтения, отражает эти изменения.  
  
 Этот метод является операцией O (1).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метод. <xref:System.Collections.Generic.List%601> Создается строка с емкостью 4, так как максимальный размер списка должен быть ровно 4. Список заполняется четырьмя строками, а <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метод используется для получения реализации универсального интерфейса только <xref:System.Collections.Generic.IList%601> для чтения, которая упаковывает исходный список.  
  
 Элементу исходного списка присваивается значение "коелофисис" с помощью <xref:System.Collections.Generic.List%601.Item%2A> свойства (индексатор в C#), и содержимое списка только для чтения отображается снова, чтобы продемонстрировать, что это просто оболочка для исходного списка.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Использует алгоритм двоичного поиска для нахождения определенного элемента в отсортированном списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.Generic.List`1" />, используя компаратор по умолчанию, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует компаратор <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> по умолчанию для типа `T` , чтобы определить порядок элементов списка. Свойство проверяет, реализует `T` <xref:System.IComparable%601> ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов, <xref:System.InvalidOperationException> <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> создает исключение.  
  
 <xref:System.Collections.Generic.List%601> Должен быть уже отсортирован в соответствии с реализацией компаратора; в противном случае результат неверен.  
  
 Сравнение `null` с любым ссылочным типом разрешено и не создает исключение при <xref:System.IComparable%601> использовании универсального интерфейса. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.Generic.List%601> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.Generic.List%601>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O (log *n*), где *n* — число элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> и перегрузка метода. <xref:System.Collections.Generic.List%601> Строки создаются и заполняются четырьмя строками без определенного порядка. Список отображается, сортируется и отображается снова.  
  
 Затем перегрузка <xref:System.Collections.Generic.List%601.Insert%2A> метода используется для поиска двух строк, которых нет в списке, и для их вставки используется метод. <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Возвращаемое значение <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> метода в каждом случае отрицательно, поскольку строки отсутствуют в списке. При получении побитового дополнения (оператор ~ C# в и C++Visual `Xor` ,-1 в Visual Basic) этого отрицательного числа создается индекс первого элемента в списке, который больше, чем строка поиска, и вставляется в это место. сохраняет порядок сортировки. Вторая строка поиска больше, чем любой элемент в списке, поэтому позиция вставки находится в конце списка.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  
  
- или - 
 <see langword="null" />, если требуется использовать компаратор по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.Generic.List`1" />, используя указанный компаратор, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр в качестве компаратора для выполнения поиска строки без учета регистра.  
  
 Если `comparer` указано, элементы <xref:System.Collections.Generic.List%601> объекта сравниваются с указанным значением с использованием указанной <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` имеет `null`значение `T` ,компараторпо<xref:System.IComparable%601> умолчанию проверяет, реализует ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов <xref:System.InvalidOperationException>, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает исключение.  
  
 <xref:System.Collections.Generic.List%601> Должен быть уже отсортирован в соответствии с реализацией компаратора; в противном случае результат неверен.  
  
 Сравнение `null` с любым ссылочным типом разрешено и не создает исключение при <xref:System.IComparable%601> использовании универсального интерфейса. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.Generic.List%601> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.Generic.List%601>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O (log *n*), где *n* — число элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и перегрузка метода.  
  
 В примере определяется альтернативный компаратор для `IComparer<string>` строк с именем динокомпаре, который реализует универсальный интерфейс (`IComparer(Of String)` в Visual Basic `IComparer<String^>` , в C++Visual). Средство сравнения работает следующим образом: Во-первых, сравниваемые проверяются на `null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 <xref:System.Collections.Generic.List%601> Строки создаются и заполняются четырьмя строками без определенного порядка. Список отображается, сортируется с помощью альтернативного компаратора и снова отображается.  
  
 Затем <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода используется для поиска нескольких строк, которые отсутствуют в списке, с применением альтернативного компаратора. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки строк. Эти два метода находятся `SearchAndInsert`в функции с именем, а также с кодом для получения побитового дополнения (оператор ~ в C# и Visual C++, `Xor` -1 в Visual Basic) отрицательного числа, возвращаемого методом <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> , и его использования в качестве индекс для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, а функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона поиска.</param>
        <param name="count">Длина диапазона поиска.</param>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Выполняет поиск элемента в диапазоне элементов отсортированного списка <see cref="T:System.Collections.Generic.List`1" />, используя указанную функцию сравнения, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения позволяет настроить сравнение элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр в качестве компаратора для выполнения поиска строки без учета регистра.  
  
 Если `comparer` указано, элементы <xref:System.Collections.Generic.List%601> объекта сравниваются с указанным значением с использованием указанной <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` имеет `null`значение `T` ,компараторпо<xref:System.IComparable%601> умолчанию проверяет, реализует ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов <xref:System.InvalidOperationException>, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает исключение.  
  
 <xref:System.Collections.Generic.List%601> Должен быть уже отсортирован в соответствии с реализацией компаратора; в противном случае результат неверен.  
  
 Сравнение `null` с любым ссылочным типом разрешено и не создает исключение при <xref:System.IComparable%601> использовании универсального интерфейса. При сортировке `null` считается меньше, чем любой другой объект.  
  
 Если объект <xref:System.Collections.Generic.List%601> содержит более одного элемента с одинаковым значением, метод возвращает только одно из вхождений и может возвращать одно из вхождений, необязательное в первую очередь.  
  
 Если параметр <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Операцию побитового дополнения (~) можно применить к этому отрицательному целому числу, чтобы получить индекс первого элемента, превышающего искомое значение. При вставке значения в объект <xref:System.Collections.Generic.List%601>этот индекс следует использовать в качестве точки вставки для сохранения порядка сортировки.  
  
 Этот метод является операцией O (log *n*), где *n* — число элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и перегрузка метода.  
  
 В примере определяется альтернативный компаратор для `IComparer<string>` строк с именем динокомпаре, который реализует универсальный интерфейс (`IComparer(Of String)` в Visual Basic `IComparer<String^>` , в C++Visual). Средство сравнения работает следующим образом: Во-первых, сравниваемые проверяются на `null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 <xref:System.Collections.Generic.List%601> Строки создаются и заполняются именами из пяти динозавров хербивораус и трех динозавров карнивораус. В каждой из этих двух групп имена не имеют определенного порядка сортировки. Отобразится список, диапазон хербиворес будет отсортирован с помощью альтернативного компаратора, а список снова отобразится.  
  
 Затем <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода используется для поиска только диапазона хербиворес для "брачиосаурус". C# Строка не найдена и побитовое дополнение (оператор ~ в и Visual C++, `Xor` -1 в Visual Basic) отрицательного числа, возвращенного <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> методом, используется в качестве индекса для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> имеет значение <see langword="null" />, а функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает общее число элементов, которые может вместить внутренняя структура данных без изменения размера.</summary>
        <value>Число элементов, которые может вместить коллекция <see cref="T:System.Collections.Generic.List`1" />, прежде чем потребуется изменить ее размер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>число элементов, которое <xref:System.Collections.Generic.List%601> может храниться до изменения размера, в <xref:System.Collections.Generic.List%601.Count%2A> то время как — это количество элементов <xref:System.Collections.Generic.List%601>, которые фактически находятся в.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>всегда больше или равно <xref:System.Collections.Generic.List%601.Count%2A>. Если <xref:System.Collections.Generic.List%601.Count%2A> превышено <xref:System.Collections.Generic.List%601.Capacity%2A> время добавления элементов, емкость увеличивается путем автоматического перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Если емкость значительно больше <xref:System.Collections.Generic.List%601>, чем число, и необходимо уменьшить объем памяти, используемой объектом, можно уменьшить емкость, <xref:System.Collections.Generic.List%601.TrimExcess%2A> вызвав <xref:System.Collections.Generic.List%601.Capacity%2A> метод или явно задав для свойства более низкое значение. Если значение <xref:System.Collections.Generic.List%601.Capacity%2A> задано явно, внутренний массив также перераспределяется в соответствии с заданной емкостью, и все элементы копируются.  
  
 Получение значения этого свойства является операцией O (1); Задание свойства является операцией O (*n*), где *n* — это новая емкость.  
  
   
   
## Examples  
 
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как проверить емкость и количество элементов <xref:System.Collections.Generic.List%601> , содержащих простой бизнес-объект, и продемонстрировать <xref:System.Collections.Generic.List%601.TrimExcess%2A> использование метода для удаления дополнительной емкости.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере показано <xref:System.Collections.Generic.List%601.Capacity%2A> свойство в нескольких точках жизненного цикла списка. Конструктор без параметров используется для создания списка строк с емкостью 0, а <xref:System.Collections.Generic.List%601.Capacity%2A> свойство показывает это. После того, как <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> метод использовался для добавления нескольких элементов, элементы перечисляются, а затем свойство отображается снова вместе со свойством, чтобы показать, что емкость увеличилась по мере необходимости. <xref:System.Collections.Generic.List%601.Add%2A>  
  
 Свойство отображается снова <xref:System.Collections.Generic.List%601.TrimExcess%2A> после использования метода для уменьшения емкости, соответствующей количеству. <xref:System.Collections.Generic.List%601.Capacity%2A> Наконец, <xref:System.Collections.Generic.List%601.Clear%2A> метод используется для удаления всех элементов из списка, <xref:System.Collections.Generic.List%601.Capacity%2A> а свойства и <xref:System.Collections.Generic.List%601.Count%2A> снова отображаются.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для <see cref="P:System.Collections.Generic.List`1.Capacity" /> установлено значение, которое меньше <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно свободной памяти в системе.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.Generic.List`1" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A>имеет значение 0, а ссылки на другие объекты из элементов коллекции также освобождаются.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>не изменяется. Чтобы сбросить емкость <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.List%601.TrimExcess%2A> вызовите метод или задайте <xref:System.Collections.Generic.List%601.Capacity%2A> свойство напрямую. Уменьшение емкости приводит к повторному распределению памяти и копированию всех элементов в <xref:System.Collections.Generic.List%601>. Удаление пустой <xref:System.Collections.Generic.List%601> задает емкость объекта <xref:System.Collections.Generic.List%601> емкость по умолчанию.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Clear%2A> метод и различные другие свойства и методы <xref:System.Collections.Generic.List%601> универсального класса. Метод используется в конце программы для удаления всех элементов из списка, <xref:System.Collections.Generic.List%601.Capacity%2A> а затем отображаются свойства и <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.Clear%2A>  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.Generic.List`1" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство с помощью компаратора проверки на равенство по умолчанию, как определено реализацией <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> объекта метода для `T` (тип значений в списке).  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере демонстрируются <xref:System.Collections.Generic.List%601.Contains%2A> методы <xref:System.Collections.Generic.List%601.Exists%2A> и для <xref:System.Collections.Generic.List%601> , которые содержат простой бизнес-объект, реализующий <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 В следующем примере содержится список сложных объектов типа `Cube`. `Cube` Класс<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> реализует метод, чтобы два куба считались равными, если их измерения одинаковы. В этом примере <xref:System.Collections.Generic.List%601.Contains%2A> метод возвращает `true`, так как куб с указанными измерениями уже находится в коллекции.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Тип элементов массива назначения.</typeparam>
        <param name="converter">Делегат <see cref="T:System.Converter`2" />, преобразующий каждый элемент из одного типа в другой.</param>
        <summary>Преобразует элементы текущего списка <see cref="T:System.Collections.Generic.List`1" /> в другой тип и возвращает список преобразованных элементов.</summary>
        <returns>Список <see cref="T:System.Collections.Generic.List`1" /> с элементами конечного типа, преобразованными из текущего списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> — Это делегат метода, который преобразует объект в целевой тип.  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Converter%602> в делегат по отдельности, а преобразованные элементы сохраняются в новом <xref:System.Collections.Generic.List%601>.  
  
 Текущий <xref:System.Collections.Generic.List%601> объект остается без изменений.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере определяется метод с именем `PointFToPoint` , который <xref:System.Drawing.PointF> преобразует структуру в <xref:System.Drawing.Point> структуру. Затем в <xref:System.Collections.Generic.List%601> примере создается <xref:System.Drawing.PointF> структура, создается `Converter\<PointF, Point>` `Converter(Of PointF, Point)` делегат(<xref:System.Collections.Generic.List%601.ConvertAll%2A> в Visual Basic), который представляет метод,ипередаетделегатвметод.`PointFToPoint` Метод передает каждый элемент входного списка `PointFToPoint` в метод и помещает преобразованные элементы <xref:System.Drawing.Point> в новый список структур. <xref:System.Collections.Generic.List%601.ConvertAll%2A> Отобразятся оба списка.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует список <see cref="T:System.Collections.Generic.List`1" /> или его часть в массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <summary>Копирует весь список <see cref="T:System.Collections.Generic.List`1" /> в совместимый одномерный массив, начиная с первого элемента целевого массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.Generic.List%601>по.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метода. <xref:System.Collections.Generic.List%601> Строка создается и заполняется 5 строками. Создается пустой массив строк из 15 элементов, а <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив, начиная с первого элемента массива. Перегрузка <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (при этом индекс 5 пуст). Наконец, <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования 3 элементов из списка, начиная с индекса 2, в массив, начиная с индекса Array 12 (при этом индекс 11 пуст). Затем отображается содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число элементов в исходном массиве <see cref="T:System.Collections.Generic.List`1" /> больше числа элементов, которые может содержать массив назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <summary>Копирует <see cref="T:System.Collections.Generic.List`1" /> целиком в совместимый одномерный массив, начиная с указанного индекса конечного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.Generic.List%601>по.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метода. <xref:System.Collections.Generic.List%601> Строка создается и заполняется 5 строками. Создается пустой массив строк из 15 элементов, а <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив, начиная с первого элемента массива. Перегрузка <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (при этом индекс 5 пуст). Наконец, <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования 3 элементов из списка, начиная с индекса 2, в массив, начиная с индекса Array 12 (при этом индекс 11 пуст). Затем отображается содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Число элементов в исходной коллекции <see cref="T:System.Collections.Generic.List`1" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс исходного списка <see cref="T:System.Collections.Generic.List`1" />, с которого начинается копирование.</param>
        <param name="array">Одномерный массив <see cref="T:System.Array" /> , в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <param name="count">Число элементов для копирования.</param>
        <summary>Копирует диапазон элементов из списка <see cref="T:System.Collections.Generic.List`1" /> в совместимый одномерный массив, начиная с указанного индекса конечного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> для копирования элементов.  
  
 Элементы копируются <xref:System.Array> в в том же порядке, в котором перечислитель выполняет итерацию <xref:System.Collections.Generic.List%601>по.  
  
 Этот метод является операцией O (*n*), где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метода. <xref:System.Collections.Generic.List%601> Строка создается и заполняется 5 строками. Создается пустой массив строк из 15 элементов, а <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив, начиная с первого элемента массива. Перегрузка <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (при этом индекс 5 пуст). Наконец, <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования 3 элементов из списка, начиная с индекса 2, в массив, начиная с индекса Array 12 (при этом индекс 11 пуст). Затем отображается содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="arrayIndex" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="index" /> больше или равно значению <see cref="P:System.Collections.Generic.List`1.Count" /> исходного списка <see cref="T:System.Collections.Generic.List`1" />.  
  
- или - 
Число элементов от <paramref name="index" /> до конца исходного списка <see cref="T:System.Collections.Generic.List`1" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>число элементов, которое <xref:System.Collections.Generic.List%601> может храниться, прежде чем потребуется изменить размер. <xref:System.Collections.Generic.List%601.Count%2A>число элементов, которые фактически находятся в <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>всегда больше или равно <xref:System.Collections.Generic.List%601.Count%2A>. Если <xref:System.Collections.Generic.List%601.Count%2A> превышено <xref:System.Collections.Generic.List%601.Capacity%2A> время добавления элементов, емкость увеличивается путем автоматического перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как проверить емкость и количество элементов <xref:System.Collections.Generic.List%601> , содержащих простой бизнес-объект, и продемонстрировать <xref:System.Collections.Generic.List%601.TrimExcess%2A> использование метода для удаления дополнительной емкости.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере показано значение <xref:System.Collections.Generic.List%601.Count%2A> свойства в различных точках жизненного цикла списка. После создания и заполнения списка и отображения <xref:System.Collections.Generic.List%601.Capacity%2A> его элементов отображаются свойства и. <xref:System.Collections.Generic.List%601.Count%2A> Эти свойства отображаются снова после <xref:System.Collections.Generic.List%601.TrimExcess%2A> вызова метода и снова после очистки содержимого списка.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Определяет, содержит ли <see cref="T:System.Collections.Generic.List`1" /> элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns><see langword="true" />, если <see cref="T:System.Collections.Generic.List`1" /> содержит один или несколько элементов, удовлетворяющих условиям указанного предиката, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Predicate%601> в делегат по отдельности, а обработка останавливается при обнаружении совпадения.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере демонстрируются <xref:System.Collections.Generic.List%601.Contains%2A> методы <xref:System.Collections.Generic.List%601.Exists%2A> и для <xref:System.Collections.Generic.List%601> , которые содержат простой бизнес-объект, реализующий <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Exists%2A> метод и несколько других методов, <xref:System.Predicate%601> использующих универсальный делегат.  
  
 <xref:System.Collections.Generic.List%601> Создается строка, содержащая 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере также определяется метод предиката поиска с `EndsWithSaurus`именем, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Методы <xref:System.Collections.Generic.List%601.Find%2A> <xref:System.Collections.Generic.List%601.RemoveAll%2A> , <xref:System.Collections.Generic.List%601.FindLast%2A>и используются для поиска в списке с помощью метода предиката Search, а затем метод используется для удаления всех записей, оканчивающихся на "саурус". <xref:System.Collections.Generic.List%601.FindAll%2A>  
  
 Наконец, <xref:System.Collections.Generic.List%601.Exists%2A> вызывается метод. Он проходит по списку с начала, передавая каждый элемент в свою очередь `EndsWithSaurus` на метод. Поиск останавливается, и метод возвращает `true` значение, `EndsWithSaurus` если метод возвращает `true` значение для любого элемента. Метод <xref:System.Collections.Generic.List%601.Exists%2A> возвращает`false` , так как все такие элементы были удалены.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать `Predicate<string>` делегат (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает первое найденное вхождение в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Первый элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Predicate%601> в делегат <xref:System.Collections.Generic.List%601>, перемещаясь вперед в, начиная с первого элемента и заканчивая последним элементом.  Обработка останавливается при обнаружении соответствия.  
  
> [!IMPORTANT]
>  При поиске в списке типов значений убедитесь, что значение по умолчанию для типа не соответствует предикату поиска. В противном случае невозможно отличить значение по умолчанию, указывающее, что совпадений не найдено, и элемент списка, который имеет значение по умолчанию для типа. Если значение по умолчанию удовлетворяет предикату поиска, используйте <xref:System.Collections.Generic.List%601.FindIndex%2A> вместо него метод.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показан <xref:System.Collections.Generic.List%601.Find%2A> метод <xref:System.Collections.Generic.List%601> для, который содержит простой сложный объект.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 В следующем примере показаны методы Find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класса содержит `book` объекты класса `Book`, используя данные из [примера XML-файла: Книги (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Метод в примере использует [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для анализа значений из XML в значения `book` свойств объектов. `FillList`  
  
 В следующей таблице описаны примеры, приведенные для методов Find.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу по идентификатору с помощью `IDToFind` делегата предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, свойство `Genre` которых имеет значение "Computer", `FindComputer` с помощью делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Извлекает все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Список <see cref="T:System.Collections.Generic.List`1" />, содержащий все элементы, удовлетворяющие условиям указанного предиката, если такие элементы найдены; в противном случае — пустой список <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Predicate%601> в делегат по отдельности, а элементы, соответствующие условиям, сохраняются в возвращаемом <xref:System.Collections.Generic.List%601>значении.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показаны методы Find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класса содержит `book` объекты класса `Book`, используя данные из [примера XML-файла: Книги (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Метод в примере использует [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для анализа значений из XML в значения `book` свойств объектов. `FillList`  
  
 В следующей таблице описаны примеры, приведенные для методов Find.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу по идентификатору с помощью `IDToFind` делегата предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, свойство `Genre` которых имеет значение "Computer", `FindComputer` с помощью делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" /> или его части. Этот метод возвращает значение -1, если соответствующий условию элемент не найден.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> выполняется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класс с двумя полями: `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним `StartsWith`методом, который указывает, начинается ли `Employee.Name` поле с `EmployeeSearch` указанной подстроки, которая предоставляется конструктору класса. Обратите внимание на сигнатуру этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан <xref:System.Collections.Generic.List%601.FindIndex%2A> в метод. `List<Employee>` В примере создается экземпляр объекта, добавляется к нему `Employee` несколько объектов <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> , а затем метод вызывается дважды для поиска по всей коллекции в первый раз для первого `Employee` объекта, чье `Name` поле начинается со значением "J" и вторым временем для первого `Employee` объекта, поле которого `Name` начинается с "жу".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с заданного индекса и заканчивая последним элементом.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск выполняется в прямом направлении `startIndex` и заканчивается на последнем элементе. <xref:System.Collections.Generic.List%601>  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), где *n* — число элементов от `startIndex` до конца. <xref:System.Collections.Generic.List%601>  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класс с двумя полями: `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним `StartsWith`методом, который указывает, начинается ли `Employee.Name` поле с `EmployeeSearch` указанной подстроки, которая предоставляется конструктору класса. Обратите внимание на сигнатуру этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан <xref:System.Collections.Generic.List%601.FindIndex%2A> в метод. В примере создается `List<Employee>` объект, добавляется к нему `Employee` несколько объектов <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> , а затем метод вызывается дважды для поиска в коллекции, начиная с пятого элемента (то есть элемента в индексе 4). В первый раз он ищет `Employee` первый объект, поле которого `Name` начинается с "J"; второй раз он ищет первый `Employee` объект, поле которого `Name` начинается с "жу".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, отвечающего условиям предиката <paramref name="match" />, если такой элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` `count` `count` Поиск выполняется в прямом направлении `startIndex` и заканчивается в плюс минус 1, если больше 0. <xref:System.Collections.Generic.List%601>  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n `count`—.  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класс с двумя полями: `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним `StartsWith`методом, который указывает, начинается ли `Employee.Name` поле с `EmployeeSearch` указанной подстроки, которая предоставляется конструктору класса. Обратите внимание на сигнатуру этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан <xref:System.Collections.Generic.List%601.FindIndex%2A> в метод. В `List<Employee>` примере создается экземпляр объекта, добавляется к нему `Employee` несколько объектов <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> , а затем метод вызывается дважды для поиска по всей коллекции (то есть элементам от индекса 0 до индекса <xref:System.Collections.Generic.List%601.Count%2A> -1). В первый раз он ищет `Employee` первый объект, поле которого `Name` начинается с "J"; второй раз он ищет первый `Employee` объект, поле которого `Name` начинается с "жу".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.  
  
- или - 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает последнее найденное вхождение в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Последний элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта по отдельности передаются <xref:System.Predicate%601> в делегат <xref:System.Collections.Generic.List%601>, перемещаясь назад в, начиная с последнего элемента и заканчивая первым.  Обработка останавливается при обнаружении соответствия.  
  
> [!IMPORTANT]
>  При поиске в списке типов значений убедитесь, что значение по умолчанию для типа не соответствует предикату поиска. В противном случае невозможно отличить значение по умолчанию, указывающее, что совпадений не найдено, и элемент списка, который имеет значение по умолчанию для типа. Если значение по умолчанию удовлетворяет предикату поиска, используйте <xref:System.Collections.Generic.List%601.FindLastIndex%2A> вместо него метод.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показаны методы Find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класса содержит `book` объекты класса `Book`, используя данные из [примера XML-файла: Книги (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Метод в примере использует [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для анализа значений из XML в значения `book` свойств объектов. `FillList`  
  
 В следующей таблице описаны примеры, приведенные для методов Find.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу по идентификатору с помощью `IDToFind` делегата предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, свойство `Genre` которых имеет значение "Computer", `FindComputer` с помощью делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> выполняется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показаны методы Find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класса содержит `book` объекты класса `Book`, используя данные из [примера XML-файла: Книги (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Метод в примере использует [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для анализа значений из XML в значения `book` свойств объектов. `FillList`  
  
 В следующей таблице описаны примеры, приведенные для методов Find.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу по идентификатору с помощью `IDToFind` делегата предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, свойство `Genre` которых имеет значение "Computer", `FindComputer` с помощью делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> в обратном направлении начинается `startIndex` с и заканчивается на первом элементе.  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), где *n* — число элементов от <xref:System.Collections.Generic.List%601> начала до. `startIndex`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, содержащем указанное число элементов и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> в обратном направлении начинается `startIndex` с и заканчивается `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Predicate%601> отдельности.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n `count`—.  
  
   
  
## Examples  
 В следующем примере показаны методы Find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класса содержит `book` объекты класса `Book`, используя данные из [примера XML-файла: Книги (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Метод в примере использует [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для анализа значений из XML в значения `book` свойств объектов. `FillList`  
  
 В следующей таблице описаны примеры, приведенные для методов Find.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу по идентификатору с помощью `IDToFind` делегата предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, свойство `Genre` которых имеет значение "Computer", `FindComputer` с помощью делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> C#в примере используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции с помощью `FindComputer` делегата предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.  
  
- или - 
 <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Делегат <see cref="T:System.Action`1" />, выполняемый для каждого элемента списка <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Выполняет указанное действие с каждым элементом списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> — Это делегат метода, который выполняет действие с объектом, переданным ему.  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются в делегат по <xref:System.Action%601> отдельности.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Изменение базовой коллекции в теле <xref:System.Action%601> делегата не поддерживается и приводит к неопределенному поведению.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Action%601> делегата для вывода содержимого <xref:System.Collections.Generic.List%601> объекта. В этом примере `Print` метод используется для вывода содержимого списка на консоль.  
  
> [!NOTE]
>  Кроме отображения содержимого с помощью `Print` метода, в C# примере демонстрируется использование анонимных [методов](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) для отображения результатов на консоли.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="action" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Элемент в коллекции изменен.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, осуществляющий перебор элементов списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Новый объект <see cref="T:System.Collections.Generic.List`1.Enumerator" /> для <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Оператор C# языка(`for each` C++в VisualBasic)скрываетсложностьперечислителей.`For Each` Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> свойство не определено. Поэтому необходимо вызвать <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции перед считыванием <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>значения.  
  
 Свойство возвращает тот же объект до <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> вызова метода. <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> задает <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> передает конец коллекции, перечислитель располагается после последнего элемента в коллекции и <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> также возвращают. `false` Если последний вызов <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> возвращен `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> значение не определено. Значение свойства <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, такие как добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> или <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> вызывает <xref:System.InvalidOperationException>исключение.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс списка <see cref="T:System.Collections.Generic.List`1" />, с которого начинается диапазон.</param>
        <param name="count">Число элементов в диапазоне.</param>
        <summary>Создает неполную копию диапазона элементов исходного списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Неполная копия диапазона элементов исходного списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неполная копия коллекции ссылочных типов или подмножества этой коллекции содержит только ссылки на элементы коллекции. Сами объекты не копируются. Ссылки в новом списке указывают на те же объекты, что и ссылки в исходном списке.  
  
 Неполная копия коллекции типов значений или подмножества этой коллекции содержит элементы коллекции. Однако если элементы коллекции содержат ссылки на другие объекты, эти объекты не копируются. Ссылки в элементах новой коллекции указывают на те же объекты, что и ссылки в элементах исходной коллекции.  
  
 В отличие от этого, глубокая копия коллекции копирует элементы и все, на которые прямо или косвенно ссылаются элементы.  
  
 Этот метод является операцией O (*n*), где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.GetRange%2A> метод и другие методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. В конце примера <xref:System.Collections.Generic.List%601.GetRange%2A> метод используется для получения трех элементов из списка, начиная с позиции индекса 2. Метод вызывается в результате <xref:System.Collections.Generic.List%601>создания массива из трех элементов. <xref:System.Collections.Generic.List%601.ToArray%2A> Отображаются элементы массива.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс первого вхождения значения в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс первого вхождения, найденного в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Индекс (с нуля) первого вхождения параметра <paramref name="item" />, если оно найдено в коллекции <see cref="T:System.Collections.Generic.List`1" />; в противном случае -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> выполняется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> метода выполняет поиск в списке с начала и находит первое вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке, начиная с позиции индекса 3, и продолжается до конца списка и находит второе вхождение строки. Наконец, <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска в диапазоне двух записей, начиная с позиции индекса два; она возвращает значение-1, так как в этом диапазоне нет экземпляров строки поиска.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с заданного индекса и до последнего элемента.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с позиции <paramref name="index" /> и до конца списка, если элемент найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск выполняется в прямом направлении `index` и заканчивается на последнем элементе. <xref:System.Collections.Generic.List%601>  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), где *n* — число элементов от `index` до конца. <xref:System.Collections.Generic.List%601>  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> метода выполняет поиск в списке с начала и находит первое вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке, начиная с позиции индекса 3, и продолжается до конца списка и находит второе вхождение строки. Наконец, <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска в диапазоне двух записей, начиная с позиции индекса два; она возвращает значение-1, так как в этом диапазоне нет экземпляров строки поиска.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает отсчитываемый от нуля индекс его первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, который начинается с позиции <paramref name="index" /> и содержит <paramref name="count" /> элементов, если искомый объект найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` `count` `count` Поиск выполняется в прямом направлении `index` и заканчивается в плюс минус 1, если больше 0. <xref:System.Collections.Generic.List%601>  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n `count`—.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> метода выполняет поиск в списке с начала и находит первое вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке, начиная с позиции индекса 3, и продолжается до конца списка и находит второе вхождение строки. Наконец, <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска в диапазоне двух записей, начиная с позиции индекса два; она возвращает значение-1, так как в этом диапазоне нет экземпляров строки поиска.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше 0.  
  
-или- 
 <paramref name="index" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить элемент <paramref name="item" />.</param>
        <param name="item">Вставляемый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.Generic.List`1" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
 Если <xref:System.Collections.Generic.List%601.Count%2A> значение уже <xref:System.Collections.Generic.List%601.Capacity%2A> равно<xref:System.Collections.Generic.List%601> , емкость увеличивается путем автоматического перераспределения внутреннего массива, а существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 Если `index` параметр <xref:System.Collections.Generic.List%601>равен, то`item` добавляется в конец. <xref:System.Collections.Generic.List%601.Count%2A>  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как добавить, удалить и вставить простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Insert%2A> метод, а также различные другие свойства и методы <xref:System.Collections.Generic.List%601> универсального класса. После создания списка добавляются элементы. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки элемента в середину списка. Вставленный элемент является дубликатом, который позже удаляется с помощью <xref:System.Collections.Generic.List%601.Remove%2A> метода.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс места вставки новых элементов.</param>
        <param name="collection">Коллекция, элементы которой следует вставить в список <see cref="T:System.Collections.Generic.List`1" />. Коллекция не может быть задана значением <see langword="null" />, но может содержать элементы <see langword="null" />, если тип <paramref name="T" /> является ссылочным типом.</param>
        <summary>Вставляет элементы коллекции в список <see cref="T:System.Collections.Generic.List`1" /> в позиции с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
 Если новый <xref:System.Collections.Generic.List%601.Count%2A> (текущий <xref:System.Collections.Generic.List%601.Count%2A> плюс размер коллекции <xref:System.Collections.Generic.List%601.Capacity%2A>) будет больше, емкость <xref:System.Collections.Generic.List%601> увеличивается путем автоматического перераспределения внутреннего массива для размещения новых элементов, а элемент существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если `index` равен<xref:System.Collections.Generic.List%601.Count%2A>, элементы<xref:System.Collections.Generic.List%601>добавляются в конец.  
  
 Порядок элементов в коллекции сохраняется в <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n* * *m*), где *n* — число добавляемых элементов, а *m* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.InsertRange%2A> метод и различные методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. После создания списка и заполнения его именами из нескольких динозавров <xref:System.Collections.Generic.List%601.InsertRange%2A> мирным растения-съесть метод используется для вставки в список массива из трех фероЦиаусов мясо-съесть, начиная с индекса Location 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс элемента, который требуется возвратить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>принимает `null` как допустимое значение для ссылочных типов и допускает дублирование элементов.  
  
 Это свойство предоставляет доступ к указанному элементу коллекции при использовании следующего синтаксиса: `myCollection[index]`.  
  
 Получение значения этого свойства является операцией O (1); Задание свойства также является операцией O (1).  
  
   
  
## Examples  
 Пример в этом разделе демонстрирует <xref:System.Collections.Generic.List%601.Item%2A> свойство (индексатор в C#) и различные другие свойства <xref:System.Collections.Generic.List%601> и методы универсального класса. После того как список создан и заполнен с помощью <xref:System.Collections.Generic.List%601.Add%2A> метода, элемент извлекается и отображается <xref:System.Collections.Generic.List%601.Item%2A> с помощью свойства. (Пример, использующий <xref:System.Collections.Generic.List%601.Item%2A> свойство для задания значения элемента списка, см. в разделе <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C#и C++ имеют синтаксис <xref:System.Collections.Generic.List%601.Item%2A> для доступа к свойству без использования его имени. Вместо этого переменная, содержащая <xref:System.Collections.Generic.List%601> , используется как массив.  
  
 C# Язык использует [`this`](~/docs/csharp/language-reference/keywords/this.md) ключевое слово для определения индексаторов <xref:System.Collections.Generic.List%601.Item%2A> вместо реализации свойства. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.Generic.List%601.Item%2A>, предоставляющее те же возможности индексирования.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс последнего вхождения значения в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения, найденного в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="item" /> в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />, если элемент найден; в противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> выполняется в обратном направлении, начиная с последнего элемента и заканчивая первым элементом.  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> метода выполняет поиск по всему списку в конце и находит второе вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке в обратном порядке, начинающемся с позиции индекса 3, и перехода к началу списка, чтобы найти первое вхождение строки в списке. Наконец, <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска диапазона из четырех записей, начиная с позиции индекса 4 и расширяя обратно (т. е. он ищет элементы в расположениях 4, 3, 2 и 1); этот поиск возвращает значение-1, так как нет экземпляров поиска. строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и до позиции с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и до позиции <paramref name="index" />, если элемент найден; в противном случае значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> в обратном направлении начинается `index` с и заканчивается на первом элементе.  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), где *n* — число элементов от <xref:System.Collections.Generic.List%601> начала до. `index`  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> метода выполняет поиск по всему списку в конце и находит второе вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке в обратном порядке, начинающемся с позиции индекса 3, и перехода к началу списка, чтобы найти первое вхождение строки в списке. Наконец, <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска диапазона из четырех записей, начиная с позиции индекса 4 и расширяя обратно (т. е. он ищет элементы в расположениях 4, 3, 2 и 1); этот поиск возвращает значение-1, так как нет экземпляров поиска. строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, содержащем указанное число элементов и заканчивающемся в позиции с указанным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, состоящем из <paramref name="count" /> элементов и заканчивающемся в позиции <paramref name="index" />, если элемент найден. В противном случае значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск <xref:System.Collections.Generic.List%601> в обратном направлении начинается `index` с и заканчивается `index` минус `count` плюс 1, если `count` больше 0.  
  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n `count`—.  
  
   
  
## Examples  
 В следующем примере показаны все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метода. <xref:System.Collections.Generic.List%601> Создается строка с одной записью, которая появляется дважды в позиции индекса 0 и позиции индекса 5. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> метода выполняет поиск по всему списку в конце и находит второе вхождение строки. Перегрузка <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> метода используется для поиска в списке в обратном порядке, начинающемся с позиции индекса 3, и перехода к началу списка, чтобы найти первое вхождение строки в списке. Наконец, <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для поиска диапазона из 4 записей, начиная с позиции индекса 4 и расширяя обратно (т. е. выполняет поиск элементов в расположениях 4, 3, 2 и 1); этот поиск возвращает значение-1, так как отсутствуют экземпляры поиска. строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> находится вне диапазона допустимых индексов для <see cref="T:System.Collections.Generic.List`1" />.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.  
  
- или - 
 <paramref name="index" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Значение <see langword="true" />, если элемент <paramref name="item" /> успешно удален, в противном случае — значение <see langword="false" />.  Этот метод также возвращает <see langword="false" />, если элемент <paramref name="item" /> не найден в коллекции <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип `T` <xref:System.IEquatable%601.Equals%2A> реализует универсальный интерфейс, компаратор проверки на равенство является методом этого интерфейса; в противном случае компаратор по умолчанию имеет <xref:System.Object.Equals%2A?displayProperty=nameWithType>значение. <xref:System.IEquatable%601>  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как добавить, удалить и вставить простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Remove%2A> метод. Для добавления, вставки и поиска <xref:System.Collections.Generic.List%601> в списке используются несколько свойств и методов универсального класса. После выполнения этих операций список будет содержать дубликат. <xref:System.Collections.Generic.List%601.Remove%2A> Метод используется для удаления первого экземпляра повторяющегося элемента и отображения содержимого. <xref:System.Collections.Generic.List%601.Remove%2A> Метод всегда удаляет первый обнаруженный экземпляр.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия удаления элемента.</param>
        <summary>Удаляет все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Число элементов, удаляемых из списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Predicate%601> в делегат по отдельности, а элементы, соответствующие <xref:System.Collections.Generic.List%601>условиям, удаляются из.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.RemoveAll%2A> метод и несколько других методов, <xref:System.Predicate%601> использующих универсальный делегат.  
  
 <xref:System.Collections.Generic.List%601> Создается строка, содержащая 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере также определяется метод предиката поиска с `EndsWithSaurus`именем, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Методы <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A> и<xref:System.Collections.Generic.List%601.FindAll%2A> используются для поиска в списке с помощью метода предиката Search.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> Метод используется для удаления всех записей, оканчивающихся на "саурус". Он проходит по списку с начала, передавая каждый элемент в свою очередь `EndsWithSaurus` на метод. Элемент удаляется, если метод `EndsWithSaurus` возвращает `true`значение.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать `Predicate<string>` делегат (`Predicate(Of String)` в Visual Basic). Эти языки выводят нужный делегат из контекста и создают его автоматически.  
  
 Наконец, <xref:System.Collections.Generic.List%601.Exists%2A> метод проверяет, что в списке нет строк, заканчивающихся на "саурус".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) элемента, который требуется удалить.</param>
        <summary>Удаляет элемент по указанному индексу из коллекции <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Collections.Generic.List%601.RemoveAt%2A> для удаления элемента оставшиеся элементы в списке нумеруются повторно, чтобы заменить удаленный элемент. Например, если удалить элемент с индексом 3, элемент с индексом 4 будет перемещен в 3 позицию. Кроме того, число элементов в списке (представленное <xref:System.Collections.Generic.List%601.Count%2A> свойством) уменьшается на 1.  
  
 Этот метод является операцией O (*n*), где *n* — (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 В следующем примере показано, как добавить, удалить и вставить простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона элементов, которые требуется удалить.</param>
        <param name="count">Число удаляемых элементов.</param>
        <summary>Удаляет диапазон элементов из списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы удаляются, а все элементы, следующие за ними в <xref:System.Collections.Generic.List%601> , их индексы `count`уменьшаются.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.RemoveRange%2A> метод и различные методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. После создания и изменения <xref:System.Collections.Generic.List%601.RemoveRange%2A> списка метод используется для удаления двух элементов из списка, начиная с позиции индекса 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет порядок элементов в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части на обратный.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Изменяет порядок элементов во всем списке <see cref="T:System.Collections.Generic.List`1" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> , чтобы изменить порядок элементов на обратный.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируются обе перегрузки <xref:System.Collections.Generic.List%601.Reverse%2A> метода. В примере создается <xref:System.Collections.Generic.List%601> строка из строк и добавляется шесть строк. Перегрузка метода используется для обращения к списку, а <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> затем перегрузка метода используется для обращения к середине списка, начиная с элемента 1 и охватывающего четыре элемента. <xref:System.Collections.Generic.List%601.Reverse>  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона, порядок элементов которого требуется изменить.</param>
        <param name="count">Число элементов в диапазоне, порядок сортировки в котором требуется изменить.</param>
        <summary>Изменяет порядок элементов в указанном диапазоне.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> , чтобы изменить порядок элементов на обратный.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируются обе перегрузки <xref:System.Collections.Generic.List%601.Reverse%2A> метода. В примере создается <xref:System.Collections.Generic.List%601> строка из строк и добавляется шесть строк. Перегрузка метода используется для обращения к списку, а <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> затем перегрузка метода используется для обращения к середине списка, начиная с элемента 1 и охватывающего четыре элемента. <xref:System.Collections.Generic.List%601.Reverse>  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон элементов в списке <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сортирует элементы или части элементов в списке <see cref="T:System.Collections.Generic.List`1" /> с использованием заданного значения или значения по умолчанию <see cref="T:System.Collections.Generic.IComparer`1" /> реализации или предоставленного делегата <see cref="T:System.Comparison`1" /> для сравнения элементов списка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с помощью компаратора по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует компаратор <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> по умолчанию для типа `T` , чтобы определить порядок элементов списка. Свойство проверяет, реализует `T` <xref:System.IComparable%601> ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов, <xref:System.InvalidOperationException> <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> создает исключение.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType> метод, который применяет сортировку гибридности следующим образом:  
  
-   Если размер секции меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 log *n*, где *n* — диапазон входного массива, используется алгоритм хеапсорт.  
  
-   В противном случае используется алгоритм QuickSort.  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 В среднем этот метод является операцией o (*n* log *n*), где *n* имеет значение <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае это операция o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 В следующем примере добавляются некоторые имена в `List<String>` объект, отображается список в несортированном порядке, <xref:System.Collections.Generic.List%601.Sort%2A> вызывается метод, а затем отображается отсортированный список.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 В следующем коде показаны <xref:System.Collections.Generic.List%601.Sort> перегрузки методов и <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> для простого бизнес-объекта. Вызов метода приводит к использованию компаратора по умолчанию для типа Part, <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> а метод реализуется с помощью анонимного метода. <xref:System.Collections.Generic.List%601.Sort>  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> и перегрузка метода. <xref:System.Collections.Generic.List%601> Строки создаются и заполняются четырьмя строками без определенного порядка. Список отображается, сортируется и отображается снова.  
  
 Затем перегрузка <xref:System.Collections.Generic.List%601.Insert%2A> метода используется для поиска двух строк, которых нет в списке, и для их вставки используется метод. <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Возвращаемое значение <xref:System.Collections.Generic.List%601.BinarySearch%2A> метода в каждом случае отрицательно, поскольку строки отсутствуют в списке. При получении побитового дополнения (оператор ~ C# в и C++Visual `Xor` ,-1 в Visual Basic) этого отрицательного числа создается индекс первого элемента в списке, который больше, чем строка поиска, и вставляется в это место. сохраняет порядок сортировки. Вторая строка поиска больше, чем любой элемент в списке, поэтому позиция вставки находится в конце списка.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` указан, элементы <xref:System.Collections.Generic.List%601> объекта сортируются с помощью указанной <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` имеет `null`значение `T` ,компараторпо<xref:System.IComparable%601> умолчанию проверяет, реализует ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов, <xref:System.InvalidOperationException> <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> создает исключение.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType> метод, который применяет сортировку гибридности следующим образом:  
  
-   Если размер секции меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 log *n*, где *n* — диапазон входного массива, используется алгоритм хеапсорт.  
  
-   В противном случае используется алгоритм QuickSort.  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 В среднем этот метод является операцией o (*n* log *n*), где *n* имеет значение <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае это операция o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и перегрузка метода.  
  
 В примере определяется альтернативный компаратор для `IComparer<string>` строк с именем динокомпаре, который реализует универсальный интерфейс (`IComparer(Of String)` в Visual Basic `IComparer<String^>` , в C++Visual). Средство сравнения работает следующим образом: Во-первых, сравниваемые проверяются на `null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 <xref:System.Collections.Generic.List%601> Строки создаются и заполняются четырьмя строками без определенного порядка. Список отображается, сортируется с помощью альтернативного компаратора и снова отображается.  
  
 Затем <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода используется для поиска нескольких строк, которые отсутствуют в списке, с применением альтернативного компаратора. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки строк. Эти два метода находятся `SearchAndInsert`в функции с именем, а также с кодом для получения побитового дополнения (оператор ~ в C# и Visual C++, `Xor` -1 в Visual Basic) отрицательного числа, возвращаемого методом <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> , и его использования в качестве индекс для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> является <see langword="null" />, и функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison"><see cref="T:System.Comparison`1" />, используемый при сравнении элементов.</param>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с использованием указанного <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparison` указано, элементы <xref:System.Collections.Generic.List%601> объекта сортируются с помощью метода, представленного делегатом.  
  
 Если `comparison` имеет `null`значение ,<xref:System.ArgumentNullException> создается исключение.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType>, который применяет сортировку гибридности следующим образом:  
  
-   Если размер секции меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 log *n*, где *n* — диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм QuickSort.  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 В среднем этот метод является операцией o (*n* log *n*), где *n* имеет значение <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае это операция o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 В следующем коде показаны <xref:System.Collections.Generic.List%601.Sort%2A> перегрузки методов и <xref:System.Collections.Generic.List%601.Sort%2A> для простого бизнес-объекта. Вызов метода приводит к использованию компаратора по умолчанию для типа Part, <xref:System.Collections.Generic.List%601.Sort%2A> а метод реализуется с помощью анонимного метода. <xref:System.Collections.Generic.List%601.Sort%2A>  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 В следующем примере показана <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> перегрузка метода.  
  
 В примере определяется альтернативный метод сравнения для строк с именем `CompareDinosByLength`. Этот метод работает следующим образом: Во-первых, сравниваемые проверяются на `null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 <xref:System.Collections.Generic.List%601> Строки создаются и заполняются четырьмя строками без определенного порядка. Список также содержит пустую строку и пустую ссылку. Список отображается, сортируется с помощью <xref:System.Comparison%601> универсального делегата, `CompareDinosByLength` представляющего метод, и снова отображается.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="comparison" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparison" /> вызвала ошибку во время сортировки. Например, <paramref name="comparison" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) начала диапазона, который требуется отсортировать.</param>
        <param name="count">Длина диапазона сортировки.</param>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Сортирует элементы в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` указан, элементы <xref:System.Collections.Generic.List%601> объекта сортируются с помощью указанной <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` имеет `null`значение `T` ,компараторпо<xref:System.IComparable%601> умолчанию проверяет, реализует ли тип универсальный интерфейс, и использует эту реализацию, если она доступна. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Если нет, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, реализует `T` <xref:System.IComparable> ли тип интерфейс.  Если тип `T` не реализует ни один из интерфейсов, <xref:System.InvalidOperationException> <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> создает исключение.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType>, который применяет сортировку гибридности следующим образом:  
  
-   Если размер секции меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 log *n*, где *n* — диапазон входного массива, используется алгоритм [хеапсорт](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   В противном случае используется алгоритм QuickSort.  
  
 Эта реализация выполняет нестабильную сортировку; то есть, если два элемента равны, их порядок может не сохраняться. В отличие от этого, стабильная сортировка сохраняет порядок элементов, равных.  
  
 В среднем этот метод является операцией o (*n* log *n*), где *n* имеет значение <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае это операция o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и перегрузка метода.  
  
 В примере определяется альтернативный компаратор для `IComparer<string>` строк с именем динокомпаре, который реализует универсальный интерфейс (`IComparer(Of String)` в Visual Basic `IComparer<String^>` , в C++Visual). Средство сравнения работает следующим образом: Во-первых, сравниваемые проверяются на `null`, а пустая ссылка считается меньше, чем значение, отличное от NULL. Во-вторых, длины строк сравниваются, а более длинная строка считается большей. В-третьих, если длины равны, используется обычное сравнение строк.  
  
 <xref:System.Collections.Generic.List%601> Строки создаются и заполняются именами из пяти динозавров хербивораус и трех динозавров карнивораус. В каждой из этих двух групп имена не имеют определенного порядка сортировки. Отобразится список, диапазон хербиворес будет отсортирован с помощью альтернативного компаратора, а список снова отобразится.  
  
 Затем <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода используется для поиска только диапазона хербиворес для "брачиосаурус". C# Строка не найдена и побитовое дополнение (оператор ~ в и Visual C++, `Xor` -1 в Visual Basic) отрицательного числа, возвращенного <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> методом, используется в качестве индекса для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.Generic.List`1" />.  
  
- или - 
Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> является <see langword="null" />, и функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Выполнение в коллекциях строковых операций, не зависящих от языка и региональных параметров</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Collections.Generic.ICollection`1" /> доступным только для чтения.</summary>
        <value>Значение <see langword="true" />, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1" /> доступен только для чтения; в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания коллекции, доступной только для чтения, не разрешается добавление элементов в коллекцию, их изменение или удаление.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Таким образом, если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, который осуществляет итерацию по коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.Generic.IEnumerator`1" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Оператор C# языка(`for each` C++в VisualBasic)скрываетсложностьперечислителей.`For Each` Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции <xref:System.Collections.Generic.IEnumerator%601.Current%2A> свойство не определено. Поэтому необходимо вызвать <xref:System.Collections.IEnumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции перед считыванием <xref:System.Collections.Generic.IEnumerator%601.Current%2A>значения.  
  
 Свойство возвращает тот же объект до <xref:System.Collections.IEnumerator.MoveNext%2A> вызова метода. <xref:System.Collections.Generic.IEnumerator%601.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.Generic.IEnumerator%601.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель располагается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают. `false` Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> возвращен `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> значение не определено. Значение свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, такие как добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает <xref:System.InvalidOperationException>исключение.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.ICollection" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в массиве <paramref name="array" />, указывающий начало копирования.</param>
        <summary>Копирует элементы коллекции <see cref="T:System.Collections.ICollection" /> в массив <see cref="T:System.Array" />, начиная с указанного индекса массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если тип <xref:System.Collections.ICollection> источника не может быть автоматически приведен к типу назначения <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> `array`, неуниверсальные реализации вызываются <xref:System.InvalidCastException>, в то время как универсальные реализации создают исключение <xref:System.ArgumentException>.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  
  
- или - 
 В массиве <paramref name="array" /> не используется индексация, начинающаяся с нуля.  
  
-или- 
Число элементов в исходном массиве <see cref="T:System.Collections.ICollection" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.  
  
- или - 
Тип исходного массива <see cref="T:System.Collections.ICollection" /> не может быть автоматически приведен к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Collections.ICollection" /> синхронизированным (потокобезопасным).</summary>
        <value><see langword="true" />, если доступ к классу <see cref="T:System.Collections.ICollection" /> является синхронизированным (потокобезопасным); в противном случае — <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  В редких случаях, когда перечисление планируется с доступом на запись, можно заблокировать коллекцию во время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Возвращает объект, который можно использовать для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация вступает в силу только в том случае, если все потоки блокируют этот объект перед доступом к коллекции.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Collections.ICollection" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Возвращает объект, который можно использовать для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация вступает в силу только в том случае, если все потоки блокируют этот объект перед доступом к коллекции. В следующем коде показано использование <xref:System.Collections.ICollection.SyncRoot%2A> свойства для C#, C++и Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, который осуществляет итерацию по коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Оператор C# языка(`for each` C++в VisualBasic)скрываетсложностьперечислителей.`For Each` Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции <xref:System.Collections.IEnumerator.Current%2A> свойство не определено. Поэтому необходимо вызвать <xref:System.Collections.IEnumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции перед считыванием <xref:System.Collections.IEnumerator.Current%2A>значения.  
  
 Свойство возвращает один и тот же объект <xref:System.Collections.IEnumerator.MoveNext%2A> до тех пор, пока не будет вызван метод или. <xref:System.Collections.IEnumerator.Reset%2A> <xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> передает конец коллекции, перечислитель располагается после последнего элемента в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают. `false` Если последний вызов <xref:System.Collections.IEnumerator.MoveNext%2A> возвращен `false`, <xref:System.Collections.IEnumerator.Current%2A> значение не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если в коллекцию вносятся изменения, такие как добавление, изменение или удаление элементов, перечислитель становится необратимо недействительным, а следующий вызов <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает <xref:System.InvalidOperationException>исключение.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Object" />, добавляемый в список <see cref="T:System.Collections.IList" />.</param>
        <summary>Добавляет элемент в коллекцию <see cref="T:System.Collections.IList" />.</summary>
        <returns>Позиция, на которую вставлен новый элемент.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> Если<xref:System.Collections.Generic.List%601.Capacity%2A>меньше, этот метод является операцией O (1). Если емкость необходимо увеличить для размещения нового элемента, этот метод становится операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Определяет, содержит ли коллекция <see cref="T:System.Collections.IList" /> указанное значение.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.IList" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.IList" />.</param>
        <summary>Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.IList" />.</summary>
        <returns>Индекс <paramref name="item" />, если он найден в списке; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить элемент <paramref name="item" />.</param>
        <param name="item">Объект, вставляемый в список <see cref="T:System.Collections.IList" />.</param>
        <summary>Вставляет элемент в список <see cref="T:System.Collections.IList" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение параметра `index` равно количеству элементов в списке <xref:System.Collections.IList>, элемент `item` добавляется в конец списка.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли список <see cref="T:System.Collections.IList" /> фиксированный размер.</summary>
        <value>Значение <see langword="true" />, если список <see cref="T:System.Collections.IList" /> имеет фиксированный размер, в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В созданной коллекции фиксированного размера запрещается добавлять или удалять элементы, но разрешается изменять существующие элементы.  
  
 Коллекция с фиксированным размером — это просто коллекция с оболочкой, которая предотвращает добавление и удаление элементов. Таким образом, если в базовую коллекцию вносятся изменения, включая добавление или удаление элементов, Коллекция фиксированного размера отражает эти изменения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Collections.IList" /> доступным только для чтения.</summary>
        <value>Значение <see langword="true" />, если интерфейс <see cref="T:System.Collections.IList" /> доступен только для чтения; в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания коллекции, доступной только для чтения, не разрешается добавление элементов в коллекцию, их изменение или удаление.  
  
 Коллекция, доступная только для чтения, — это просто коллекция с оболочкой, которая предотвращает изменение коллекции. Таким образом, если в базовую коллекцию вносятся изменения, то эти изменения отражаются в коллекции только для чтения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс элемента, который требуется возвратить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Язык использует ключевое слово [this](~/docs/csharp/language-reference/keywords/this.md) для определения индексаторов вместо реализации <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> свойства. C# В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>, предоставляющее те же возможности индексирования.  
  
 Получение значения этого свойства является операцией O (1); Задание свойства также является операцией O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство задано, и тип параметра <paramref name="value" /> не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство с помощью компаратора <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> проверки на равенство по умолчанию для `T`типа значений в списке.  
  
 Этот метод выполняет линейный поиск. Таким образом, этот метод является операцией O (*n*), ** где n <xref:System.Collections.Generic.List%601.Count%2A>—.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует элементы списка <see cref="T:System.Collections.Generic.List`1" /> в новый массив.</summary>
        <returns>Массив, содержащий копии элементов списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются с помощью <xref:System.Array.Copy%2A?displayProperty=nameWithType>, что является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.ToArray%2A> метод и другие методы <xref:System.Collections.Generic.List%601> класса, действующие для диапазонов. В конце примера <xref:System.Collections.Generic.List%601.GetRange%2A> метод используется для получения трех элементов из списка, начиная с позиции индекса 2. Метод вызывается в результате <xref:System.Collections.Generic.List%601>создания массива из трех элементов. <xref:System.Collections.Generic.List%601.ToArray%2A> Отображаются элементы массива.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает емкость, равную фактическому числу элементов в списке <see cref="T:System.Collections.Generic.List`1" />, если это число меньше порогового значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для снижения нагрузки на память коллекции, если в коллекцию не добавляются новые элементы. Однако стоимость повторного выделения и копирования большого размера <xref:System.Collections.Generic.List%601> может быть значительной, <xref:System.Collections.Generic.List%601.TrimExcess%2A> поэтому метод не выполняет никаких действий, если список имеет более 90 процентов емкости. Это позволяет избежать больших затрат на повторное распределение для относительно небольшого выигрыша.  
  
> [!NOTE]
>  Текущее пороговое значение, равное 90%, может измениться в будущих выпусках.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Чтобы сбросить значение <xref:System.Collections.Generic.List%601> до исходного состояния, <xref:System.Collections.Generic.List%601.Clear%2A> вызовите метод перед вызовом <xref:System.Collections.Generic.List%601.TrimExcess%2A> метода. Удаление пустой <xref:System.Collections.Generic.List%601> задает емкость объекта <xref:System.Collections.Generic.List%601> емкость по умолчанию.  
  
 Емкость также можно задать с помощью <xref:System.Collections.Generic.List%601.Capacity%2A> свойства.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 В следующем примере показано, как проверить емкость и количество элементов <xref:System.Collections.Generic.List%601> , содержащих простой бизнес-объект, и продемонстрировать <xref:System.Collections.Generic.List%601.TrimExcess%2A> использование метода для удаления дополнительной емкости.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод. Для добавления, вставки и удаления <xref:System.Collections.Generic.List%601> элементов из списка строк используются несколько свойств и методов класса. Затем метод используется для уменьшения емкости, соответствующей количеству, <xref:System.Collections.Generic.List%601.Capacity%2A> и отображаются свойства и <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.TrimExcess%2A> Если неиспользуемая емкость была меньше 10% от общей емкости, размер списка не изменится. Наконец, содержимое списка удаляется.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия, проверяемые для элементов.</param>
        <summary>Определяет, все ли элементы списка <see cref="T:System.Collections.Generic.List`1" /> удовлетворяют условиям указанного предиката.</summary>
        <returns><see langword="true" />, если каждый элемент списка <see cref="T:System.Collections.Generic.List`1" /> удовлетворяет условиям заданного предиката, в противном случае — <see langword="false" />. Если в списке нет элементов, возвращается <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это делегат метода, который возвращает `true` значение, если переданный ему объект соответствует условиям, определенным в делегате. <xref:System.Predicate%601>  Элементы текущего <xref:System.Collections.Generic.List%601> объекта передаются <xref:System.Predicate%601> в делегат по отдельности, а обработка останавливается, когда делегат возвращает `false` для любого элемента. Элементы обрабатываются по порядку, а все вызовы выполняются в одном потоке.  
  
 Этот метод является операцией O (*n*), где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.TrueForAll%2A> метод и несколько других методов, использующих <xref:System.Predicate%601> универсальный делегат.  
  
 <xref:System.Collections.Generic.List%601> Создается строка, содержащая 8 названий динозавров, два из которых (в позициях 1 и 5) заканчиваются на "саурус". В примере также определяется метод предиката поиска с `EndsWithSaurus`именем, который принимает строковый параметр и возвращает логическое значение, указывающее, заканчивается ли входная строка в "саурус".  
  
 Метод проходит по списку с начала, передавая каждый элемент в свою очередь `EndsWithSaurus` на метод. <xref:System.Collections.Generic.List%601.TrueForAll%2A> Поиск останавливается, когда метод `EndsWithSaurus` возвращает `false`значение.  
  
> [!NOTE]
>  В C# и Visual Basic нет необходимости явно создавать `Predicate<string>` делегат (`Predicate(Of String)` в Visual Basic). Эти языки выводят правильный делегат из контекста и создают его автоматически.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
